import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-X5MHFPH7.js";

// node_modules/reflect-metadata/Reflect.js
var require_Reflect = __commonJS({
  "node_modules/reflect-metadata/Reflect.js"() {
    var Reflect2;
    (function(Reflect3) {
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
        var exporter = makeExporter(Reflect3);
        if (typeof root.Reflect === "undefined") {
          root.Reflect = Reflect3;
        } else {
          exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
          return function(key, value) {
            if (typeof target[key] !== "function") {
              Object.defineProperty(target, key, { configurable: true, writable: true, value });
            }
            if (previous)
              previous(key, value);
          };
        }
      })(function(exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function";
        var supportsProto = { __proto__: [] } instanceof Array;
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
          // create an object in dictionary mode (a.k.a. "slow" mode in v8)
          create: supportsCreate ? function() {
            return MakeDictionary(/* @__PURE__ */ Object.create(null));
          } : supportsProto ? function() {
            return MakeDictionary({ __proto__: null });
          } : function() {
            return MakeDictionary({});
          },
          has: downLevel ? function(map, key) {
            return hasOwn.call(map, key);
          } : function(map, key) {
            return key in map;
          },
          get: downLevel ? function(map, key) {
            return hasOwn.call(map, key) ? map[key] : void 0;
          } : function(map, key) {
            return map[key];
          }
        };
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        var Metadata3 = new _WeakMap();
        function decorate(decorators, target, propertyKey, attributes) {
          if (!IsUndefined(propertyKey)) {
            if (!IsArray2(decorators))
              throw new TypeError();
            if (!IsObject2(target))
              throw new TypeError();
            if (!IsObject2(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
              throw new TypeError();
            if (IsNull(attributes))
              attributes = void 0;
            propertyKey = ToPropertyKey(propertyKey);
            return DecorateProperty(decorators, target, propertyKey, attributes);
          } else {
            if (!IsArray2(decorators))
              throw new TypeError();
            if (!IsConstructor(target))
              throw new TypeError();
            return DecorateConstructor(decorators, target);
          }
        }
        exporter("decorate", decorate);
        function metadata(metadataKey, metadataValue) {
          function decorator(target, propertyKey) {
            if (!IsObject2(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
              throw new TypeError();
            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
          }
          return decorator;
        }
        exporter("metadata", metadata);
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
          if (!IsObject2(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        function hasMetadata(metadataKey, target, propertyKey) {
          if (!IsObject2(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        function hasOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject2(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        function getMetadata(metadataKey, target, propertyKey) {
          if (!IsObject2(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        function getOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject2(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        function getMetadataKeys(target, propertyKey) {
          if (!IsObject2(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        function getOwnMetadataKeys(target, propertyKey) {
          if (!IsObject2(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        function deleteMetadata(metadataKey, target, propertyKey) {
          if (!IsObject2(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          var metadataMap = GetOrCreateMetadataMap(
            target,
            propertyKey,
            /*Create*/
            false
          );
          if (IsUndefined(metadataMap))
            return false;
          if (!metadataMap.delete(metadataKey))
            return false;
          if (metadataMap.size > 0)
            return true;
          var targetMetadata = Metadata3.get(target);
          targetMetadata.delete(propertyKey);
          if (targetMetadata.size > 0)
            return true;
          Metadata3.delete(target);
          return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
          for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsConstructor(decorated))
                throw new TypeError();
              target = decorated;
            }
          }
          return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
          for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target, propertyKey, descriptor);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsObject2(decorated))
                throw new TypeError();
              descriptor = decorated;
            }
          }
          return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
          var targetMetadata = Metadata3.get(O);
          if (IsUndefined(targetMetadata)) {
            if (!Create)
              return void 0;
            targetMetadata = new _Map();
            Metadata3.set(O, targetMetadata);
          }
          var metadataMap = targetMetadata.get(P);
          if (IsUndefined(metadataMap)) {
            if (!Create)
              return void 0;
            metadataMap = new _Map();
            targetMetadata.set(P, metadataMap);
          }
          return metadataMap;
        }
        function OrdinaryHasMetadata(MetadataKey, O, P) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
          if (hasOwn2)
            return true;
          var parent = OrdinaryGetPrototypeOf(O);
          if (!IsNull(parent))
            return OrdinaryHasMetadata(MetadataKey, parent, P);
          return false;
        }
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(metadataMap))
            return false;
          return ToBoolean(metadataMap.has(MetadataKey));
        }
        function OrdinaryGetMetadata(MetadataKey, O, P) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
          if (hasOwn2)
            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
          var parent = OrdinaryGetPrototypeOf(O);
          if (!IsNull(parent))
            return OrdinaryGetMetadata(MetadataKey, parent, P);
          return void 0;
        }
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(metadataMap))
            return void 0;
          return metadataMap.get(MetadataKey);
        }
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
          var metadataMap = GetOrCreateMetadataMap(
            O,
            P,
            /*Create*/
            true
          );
          metadataMap.set(MetadataKey, MetadataValue);
        }
        function OrdinaryMetadataKeys(O, P) {
          var ownKeys6 = OrdinaryOwnMetadataKeys(O, P);
          var parent = OrdinaryGetPrototypeOf(O);
          if (parent === null)
            return ownKeys6;
          var parentKeys = OrdinaryMetadataKeys(parent, P);
          if (parentKeys.length <= 0)
            return ownKeys6;
          if (ownKeys6.length <= 0)
            return parentKeys;
          var set = new _Set();
          var keys = [];
          for (var _i = 0, ownKeys_1 = ownKeys6; _i < ownKeys_1.length; _i++) {
            var key = ownKeys_1[_i];
            var hasKey = set.has(key);
            if (!hasKey) {
              set.add(key);
              keys.push(key);
            }
          }
          for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
            var key = parentKeys_1[_a];
            var hasKey = set.has(key);
            if (!hasKey) {
              set.add(key);
              keys.push(key);
            }
          }
          return keys;
        }
        function OrdinaryOwnMetadataKeys(O, P) {
          var keys = [];
          var metadataMap = GetOrCreateMetadataMap(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(metadataMap))
            return keys;
          var keysObj = metadataMap.keys();
          var iterator = GetIterator(keysObj);
          var k = 0;
          while (true) {
            var next = IteratorStep(iterator);
            if (!next) {
              keys.length = k;
              return keys;
            }
            var nextValue = IteratorValue(next);
            try {
              keys[k] = nextValue;
            } catch (e) {
              try {
                IteratorClose(iterator);
              } finally {
                throw e;
              }
            }
            k++;
          }
        }
        function Type3(x) {
          if (x === null)
            return 1;
          switch (typeof x) {
            case "undefined":
              return 0;
            case "boolean":
              return 2;
            case "string":
              return 3;
            case "symbol":
              return 4;
            case "number":
              return 5;
            case "object":
              return x === null ? 1 : 6;
            default:
              return 6;
          }
        }
        function IsUndefined(x) {
          return x === void 0;
        }
        function IsNull(x) {
          return x === null;
        }
        function IsSymbol(x) {
          return typeof x === "symbol";
        }
        function IsObject2(x) {
          return typeof x === "object" ? x !== null : typeof x === "function";
        }
        function ToPrimitive(input, PreferredType) {
          switch (Type3(input)) {
            case 0:
              return input;
            case 1:
              return input;
            case 2:
              return input;
            case 3:
              return input;
            case 4:
              return input;
            case 5:
              return input;
          }
          var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
          var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
          if (exoticToPrim !== void 0) {
            var result2 = exoticToPrim.call(input, hint);
            if (IsObject2(result2))
              throw new TypeError();
            return result2;
          }
          return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        function OrdinaryToPrimitive(O, hint) {
          if (hint === "string") {
            var toString_1 = O.toString;
            if (IsCallable(toString_1)) {
              var result2 = toString_1.call(O);
              if (!IsObject2(result2))
                return result2;
            }
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              var result2 = valueOf.call(O);
              if (!IsObject2(result2))
                return result2;
            }
          } else {
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              var result2 = valueOf.call(O);
              if (!IsObject2(result2))
                return result2;
            }
            var toString_2 = O.toString;
            if (IsCallable(toString_2)) {
              var result2 = toString_2.call(O);
              if (!IsObject2(result2))
                return result2;
            }
          }
          throw new TypeError();
        }
        function ToBoolean(argument) {
          return !!argument;
        }
        function ToString(argument) {
          return "" + argument;
        }
        function ToPropertyKey(argument) {
          var key = ToPrimitive(
            argument,
            3
            /* String */
          );
          if (IsSymbol(key))
            return key;
          return ToString(key);
        }
        function IsArray2(argument) {
          return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
        }
        function IsCallable(argument) {
          return typeof argument === "function";
        }
        function IsConstructor(argument) {
          return typeof argument === "function";
        }
        function IsPropertyKey(argument) {
          switch (Type3(argument)) {
            case 3:
              return true;
            case 4:
              return true;
            default:
              return false;
          }
        }
        function GetMethod(V, P) {
          var func = V[P];
          if (func === void 0 || func === null)
            return void 0;
          if (!IsCallable(func))
            throw new TypeError();
          return func;
        }
        function GetIterator(obj) {
          var method = GetMethod(obj, iteratorSymbol);
          if (!IsCallable(method))
            throw new TypeError();
          var iterator = method.call(obj);
          if (!IsObject2(iterator))
            throw new TypeError();
          return iterator;
        }
        function IteratorValue(iterResult) {
          return iterResult.value;
        }
        function IteratorStep(iterator) {
          var result2 = iterator.next();
          return result2.done ? false : result2;
        }
        function IteratorClose(iterator) {
          var f2 = iterator["return"];
          if (f2)
            f2.call(iterator);
        }
        function OrdinaryGetPrototypeOf(O) {
          var proto = Object.getPrototypeOf(O);
          if (typeof O !== "function" || O === functionPrototype)
            return proto;
          if (proto !== functionPrototype)
            return proto;
          var prototype = O.prototype;
          var prototypeProto = prototype && Object.getPrototypeOf(prototype);
          if (prototypeProto == null || prototypeProto === Object.prototype)
            return proto;
          var constructor = prototypeProto.constructor;
          if (typeof constructor !== "function")
            return proto;
          if (constructor === O)
            return proto;
          return constructor;
        }
        function CreateMapPolyfill() {
          var cacheSentinel = {};
          var arraySentinel = [];
          var MapIterator = (
            /** @class */
            function() {
              function MapIterator2(keys, values, selector) {
                this._index = 0;
                this._keys = keys;
                this._values = values;
                this._selector = selector;
              }
              MapIterator2.prototype["@@iterator"] = function() {
                return this;
              };
              MapIterator2.prototype[iteratorSymbol] = function() {
                return this;
              };
              MapIterator2.prototype.next = function() {
                var index = this._index;
                if (index >= 0 && index < this._keys.length) {
                  var result2 = this._selector(this._keys[index], this._values[index]);
                  if (index + 1 >= this._keys.length) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  } else {
                    this._index++;
                  }
                  return { value: result2, done: false };
                }
                return { value: void 0, done: true };
              };
              MapIterator2.prototype.throw = function(error) {
                if (this._index >= 0) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                }
                throw error;
              };
              MapIterator2.prototype.return = function(value) {
                if (this._index >= 0) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                }
                return { value, done: true };
              };
              return MapIterator2;
            }()
          );
          return (
            /** @class */
            function() {
              function Map2() {
                this._keys = [];
                this._values = [];
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              Object.defineProperty(Map2.prototype, "size", {
                get: function() {
                  return this._keys.length;
                },
                enumerable: true,
                configurable: true
              });
              Map2.prototype.has = function(key) {
                return this._find(
                  key,
                  /*insert*/
                  false
                ) >= 0;
              };
              Map2.prototype.get = function(key) {
                var index = this._find(
                  key,
                  /*insert*/
                  false
                );
                return index >= 0 ? this._values[index] : void 0;
              };
              Map2.prototype.set = function(key, value) {
                var index = this._find(
                  key,
                  /*insert*/
                  true
                );
                this._values[index] = value;
                return this;
              };
              Map2.prototype.delete = function(key) {
                var index = this._find(
                  key,
                  /*insert*/
                  false
                );
                if (index >= 0) {
                  var size = this._keys.length;
                  for (var i = index + 1; i < size; i++) {
                    this._keys[i - 1] = this._keys[i];
                    this._values[i - 1] = this._values[i];
                  }
                  this._keys.length--;
                  this._values.length--;
                  if (key === this._cacheKey) {
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                  }
                  return true;
                }
                return false;
              };
              Map2.prototype.clear = function() {
                this._keys.length = 0;
                this._values.length = 0;
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              };
              Map2.prototype.keys = function() {
                return new MapIterator(this._keys, this._values, getKey);
              };
              Map2.prototype.values = function() {
                return new MapIterator(this._keys, this._values, getValue);
              };
              Map2.prototype.entries = function() {
                return new MapIterator(this._keys, this._values, getEntry);
              };
              Map2.prototype["@@iterator"] = function() {
                return this.entries();
              };
              Map2.prototype[iteratorSymbol] = function() {
                return this.entries();
              };
              Map2.prototype._find = function(key, insert) {
                if (this._cacheKey !== key) {
                  this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                }
                if (this._cacheIndex < 0 && insert) {
                  this._cacheIndex = this._keys.length;
                  this._keys.push(key);
                  this._values.push(void 0);
                }
                return this._cacheIndex;
              };
              return Map2;
            }()
          );
          function getKey(key, _) {
            return key;
          }
          function getValue(_, value) {
            return value;
          }
          function getEntry(key, value) {
            return [key, value];
          }
        }
        function CreateSetPolyfill() {
          return (
            /** @class */
            function() {
              function Set2() {
                this._map = new _Map();
              }
              Object.defineProperty(Set2.prototype, "size", {
                get: function() {
                  return this._map.size;
                },
                enumerable: true,
                configurable: true
              });
              Set2.prototype.has = function(value) {
                return this._map.has(value);
              };
              Set2.prototype.add = function(value) {
                return this._map.set(value, value), this;
              };
              Set2.prototype.delete = function(value) {
                return this._map.delete(value);
              };
              Set2.prototype.clear = function() {
                this._map.clear();
              };
              Set2.prototype.keys = function() {
                return this._map.keys();
              };
              Set2.prototype.values = function() {
                return this._map.values();
              };
              Set2.prototype.entries = function() {
                return this._map.entries();
              };
              Set2.prototype["@@iterator"] = function() {
                return this.keys();
              };
              Set2.prototype[iteratorSymbol] = function() {
                return this.keys();
              };
              return Set2;
            }()
          );
        }
        function CreateWeakMapPolyfill() {
          var UUID_SIZE = 16;
          var keys = HashMap.create();
          var rootKey = CreateUniqueKey();
          return (
            /** @class */
            function() {
              function WeakMap2() {
                this._key = CreateUniqueKey();
              }
              WeakMap2.prototype.has = function(target) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table !== void 0 ? HashMap.has(table, this._key) : false;
              };
              WeakMap2.prototype.get = function(target) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table !== void 0 ? HashMap.get(table, this._key) : void 0;
              };
              WeakMap2.prototype.set = function(target, value) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  true
                );
                table[this._key] = value;
                return this;
              };
              WeakMap2.prototype.delete = function(target) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table !== void 0 ? delete table[this._key] : false;
              };
              WeakMap2.prototype.clear = function() {
                this._key = CreateUniqueKey();
              };
              return WeakMap2;
            }()
          );
          function CreateUniqueKey() {
            var key;
            do
              key = "@@WeakMap@@" + CreateUUID();
            while (HashMap.has(keys, key));
            keys[key] = true;
            return key;
          }
          function GetOrCreateWeakMapTable(target, create) {
            if (!hasOwn.call(target, rootKey)) {
              if (!create)
                return void 0;
              Object.defineProperty(target, rootKey, { value: HashMap.create() });
            }
            return target[rootKey];
          }
          function FillRandomBytes(buffer, size) {
            for (var i = 0; i < size; ++i)
              buffer[i] = Math.random() * 255 | 0;
            return buffer;
          }
          function GenRandomBytes(size) {
            if (typeof Uint8Array === "function") {
              if (typeof crypto !== "undefined")
                return crypto.getRandomValues(new Uint8Array(size));
              if (typeof msCrypto !== "undefined")
                return msCrypto.getRandomValues(new Uint8Array(size));
              return FillRandomBytes(new Uint8Array(size), size);
            }
            return FillRandomBytes(new Array(size), size);
          }
          function CreateUUID() {
            var data = GenRandomBytes(UUID_SIZE);
            data[6] = data[6] & 79 | 64;
            data[8] = data[8] & 191 | 128;
            var result2 = "";
            for (var offset = 0; offset < UUID_SIZE; ++offset) {
              var byte = data[offset];
              if (offset === 4 || offset === 6 || offset === 8)
                result2 += "-";
              if (byte < 16)
                result2 += "0";
              result2 += byte.toString(16).toLowerCase();
            }
            return result2;
          }
        }
        function MakeDictionary(obj) {
          obj.__ = void 0;
          delete obj.__;
          return obj;
        }
      });
    })(Reflect2 || (Reflect2 = {}));
  }
});

// node_modules/@aries-framework/core/build/constants.js
var require_constants = __commonJS({
  "node_modules/@aries-framework/core/build/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DID_COMM_TRANSPORT_QUEUE = exports.InjectionSymbols = void 0;
    exports.InjectionSymbols = {
      MessageRepository: Symbol("MessageRepository"),
      StorageService: Symbol("StorageService"),
      Logger: Symbol("Logger"),
      AgentContextProvider: Symbol("AgentContextProvider"),
      AgentDependencies: Symbol("AgentDependencies"),
      Stop$: Symbol("Stop$"),
      FileSystem: Symbol("FileSystem"),
      Wallet: Symbol("Wallet")
    };
    exports.DID_COMM_TRANSPORT_QUEUE = "didcomm:transport/queue";
  }
});

// node_modules/make-error/index.js
var require_make_error = __commonJS({
  "node_modules/make-error/index.js"(exports, module) {
    "use strict";
    var construct = typeof Reflect !== "undefined" ? Reflect.construct : void 0;
    var defineProperty = Object.defineProperty;
    var captureStackTrace = Error.captureStackTrace;
    if (captureStackTrace === void 0) {
      captureStackTrace = function captureStackTrace2(error) {
        var container = new Error();
        defineProperty(error, "stack", {
          configurable: true,
          get: function getStack() {
            var stack = container.stack;
            defineProperty(this, "stack", {
              configurable: true,
              value: stack,
              writable: true
            });
            return stack;
          },
          set: function setStack(stack) {
            defineProperty(error, "stack", {
              configurable: true,
              value: stack,
              writable: true
            });
          }
        });
      };
    }
    function BaseError(message) {
      if (message !== void 0) {
        defineProperty(this, "message", {
          configurable: true,
          value: message,
          writable: true
        });
      }
      var cname = this.constructor.name;
      if (cname !== void 0 && cname !== this.name) {
        defineProperty(this, "name", {
          configurable: true,
          value: cname,
          writable: true
        });
      }
      captureStackTrace(this, this.constructor);
    }
    BaseError.prototype = Object.create(Error.prototype, {
      // See: https://github.com/JsCommunity/make-error/issues/4
      constructor: {
        configurable: true,
        value: BaseError,
        writable: true
      }
    });
    var setFunctionName = function() {
      function setFunctionName2(fn, name) {
        return defineProperty(fn, "name", {
          configurable: true,
          value: name
        });
      }
      try {
        var f2 = function() {
        };
        setFunctionName2(f2, "foo");
        if (f2.name === "foo") {
          return setFunctionName2;
        }
      } catch (_) {
      }
    }();
    function makeError(constructor, super_) {
      if (super_ == null || super_ === Error) {
        super_ = BaseError;
      } else if (typeof super_ !== "function") {
        throw new TypeError("super_ should be a function");
      }
      var name;
      if (typeof constructor === "string") {
        name = constructor;
        constructor = construct !== void 0 ? function() {
          return construct(super_, arguments, this.constructor);
        } : function() {
          super_.apply(this, arguments);
        };
        if (setFunctionName !== void 0) {
          setFunctionName(constructor, name);
          name = void 0;
        }
      } else if (typeof constructor !== "function") {
        throw new TypeError("constructor should be either a string or a function");
      }
      constructor.super_ = constructor["super"] = super_;
      var properties = {
        constructor: {
          configurable: true,
          value: constructor,
          writable: true
        }
      };
      if (name !== void 0) {
        properties.name = {
          configurable: true,
          value: name,
          writable: true
        };
      }
      constructor.prototype = Object.create(super_.prototype, properties);
      return constructor;
    }
    exports = module.exports = makeError;
    exports.BaseError = BaseError;
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports, module) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray2(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray2(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber2(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean2(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString2(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (!isDate2(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray2(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate2(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString2(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber2(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean2(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f2) {
      if (f2.name) {
        return f2.name;
      }
      var m = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray2(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/@aries-framework/core/build/error/BaseError.js
var require_BaseError = __commonJS({
  "node_modules/@aries-framework/core/build/error/BaseError.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fullStack = exports.BaseError = exports.SEPARATOR_TEXT = void 0;
    var make_error_1 = __importDefault(require_make_error());
    var object_inspect_1 = __importDefault(require_object_inspect());
    exports.SEPARATOR_TEXT = `

The following exception was the direct cause of the above exception:

`;
    var BaseError = class extends make_error_1.default.BaseError {
      constructor(message, cause) {
        super(message);
        this.cause = cause;
        Object.defineProperty(this, "cause", {
          value: cause,
          writable: false,
          enumerable: false,
          configurable: false
        });
      }
      inspect() {
        return fullStack(this);
      }
    };
    exports.BaseError = BaseError;
    function fullStack(error) {
      const chain = [];
      let cause = error;
      while (cause) {
        chain.push(cause);
        cause = cause.cause;
      }
      return chain.map((err) => (0, object_inspect_1.default)(err, { customInspect: false })).join(exports.SEPARATOR_TEXT);
    }
    exports.fullStack = fullStack;
  }
});

// node_modules/@aries-framework/core/build/error/AriesFrameworkError.js
var require_AriesFrameworkError = __commonJS({
  "node_modules/@aries-framework/core/build/error/AriesFrameworkError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AriesFrameworkError = void 0;
    var BaseError_1 = require_BaseError();
    var AriesFrameworkError = class extends BaseError_1.BaseError {
      /**
       * Create base AriesFrameworkError.
       * @param message the error message
       * @param cause the error that caused this error to be created
       */
      constructor(message, { cause } = {}) {
        super(message, cause);
      }
    };
    exports.AriesFrameworkError = AriesFrameworkError;
  }
});

// node_modules/@aries-framework/core/build/error/RecordNotFoundError.js
var require_RecordNotFoundError = __commonJS({
  "node_modules/@aries-framework/core/build/error/RecordNotFoundError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RecordNotFoundError = void 0;
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var RecordNotFoundError = class extends AriesFrameworkError_1.AriesFrameworkError {
      constructor(message, { recordType, cause }) {
        super(`${recordType}: ${message}`, { cause });
      }
    };
    exports.RecordNotFoundError = RecordNotFoundError;
  }
});

// node_modules/@aries-framework/core/build/error/RecordDuplicateError.js
var require_RecordDuplicateError = __commonJS({
  "node_modules/@aries-framework/core/build/error/RecordDuplicateError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RecordDuplicateError = void 0;
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var RecordDuplicateError = class extends AriesFrameworkError_1.AriesFrameworkError {
      constructor(message, { recordType, cause }) {
        super(`${recordType}: ${message}`, { cause });
      }
    };
    exports.RecordDuplicateError = RecordDuplicateError;
  }
});

// node_modules/@aries-framework/core/build/error/IndySdkError.js
var require_IndySdkError = __commonJS({
  "node_modules/@aries-framework/core/build/error/IndySdkError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndySdkError = void 0;
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var IndySdkError = class extends AriesFrameworkError_1.AriesFrameworkError {
      constructor(indyError, message) {
        const base = `${indyError.name}(${indyError.indyName}): ${indyError.message}`;
        super(message ? `${message}: ${base}` : base, { cause: indyError });
      }
    };
    exports.IndySdkError = IndySdkError;
  }
});

// node_modules/@aries-framework/core/build/error/ClassValidationError.js
var require_ClassValidationError = __commonJS({
  "node_modules/@aries-framework/core/build/error/ClassValidationError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassValidationError = void 0;
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var ClassValidationError = class extends AriesFrameworkError_1.AriesFrameworkError {
      validationErrorsToString() {
        var _a, _b;
        return (_b = (_a = this.validationErrors) === null || _a === void 0 ? void 0 : _a.map((error) => error.toString(true)).join("\n")) !== null && _b !== void 0 ? _b : "";
      }
      constructor(message, { classType, cause, validationErrors }) {
        const validationErrorsStringified = validationErrors === null || validationErrors === void 0 ? void 0 : validationErrors.map((error) => error.toString()).join("\n");
        super(`${classType}: ${message}
${validationErrorsStringified}`, { cause });
        this.validationErrors = validationErrors !== null && validationErrors !== void 0 ? validationErrors : [];
      }
    };
    exports.ClassValidationError = ClassValidationError;
  }
});

// node_modules/@aries-framework/core/build/error/MessageSendingError.js
var require_MessageSendingError = __commonJS({
  "node_modules/@aries-framework/core/build/error/MessageSendingError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageSendingError = void 0;
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var MessageSendingError = class extends AriesFrameworkError_1.AriesFrameworkError {
      constructor(message, { outboundMessageContext, cause }) {
        super(message, { cause });
        this.outboundMessageContext = outboundMessageContext;
      }
    };
    exports.MessageSendingError = MessageSendingError;
  }
});

// node_modules/@aries-framework/core/build/error/index.js
var require_error = __commonJS({
  "node_modules/@aries-framework/core/build/error/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_AriesFrameworkError(), exports);
    __exportStar(require_RecordNotFoundError(), exports);
    __exportStar(require_RecordDuplicateError(), exports);
    __exportStar(require_IndySdkError(), exports);
    __exportStar(require_ClassValidationError(), exports);
    __exportStar(require_MessageSendingError(), exports);
  }
});

// node_modules/class-transformer/esm5/enums/transformation-type.enum.js
var TransformationType;
var init_transformation_type_enum = __esm({
  "node_modules/class-transformer/esm5/enums/transformation-type.enum.js"() {
    (function(TransformationType2) {
      TransformationType2[TransformationType2["PLAIN_TO_CLASS"] = 0] = "PLAIN_TO_CLASS";
      TransformationType2[TransformationType2["CLASS_TO_PLAIN"] = 1] = "CLASS_TO_PLAIN";
      TransformationType2[TransformationType2["CLASS_TO_CLASS"] = 2] = "CLASS_TO_CLASS";
    })(TransformationType || (TransformationType = {}));
  }
});

// node_modules/class-transformer/esm5/enums/index.js
var init_enums = __esm({
  "node_modules/class-transformer/esm5/enums/index.js"() {
    init_transformation_type_enum();
  }
});

// node_modules/class-transformer/esm5/MetadataStorage.js
var MetadataStorage;
var init_MetadataStorage = __esm({
  "node_modules/class-transformer/esm5/MetadataStorage.js"() {
    init_enums();
    MetadataStorage = /** @class */
    function() {
      function MetadataStorage3() {
        this._typeMetadatas = /* @__PURE__ */ new Map();
        this._transformMetadatas = /* @__PURE__ */ new Map();
        this._exposeMetadatas = /* @__PURE__ */ new Map();
        this._excludeMetadatas = /* @__PURE__ */ new Map();
        this._ancestorsMap = /* @__PURE__ */ new Map();
      }
      MetadataStorage3.prototype.addTypeMetadata = function(metadata) {
        if (!this._typeMetadatas.has(metadata.target)) {
          this._typeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
      };
      MetadataStorage3.prototype.addTransformMetadata = function(metadata) {
        if (!this._transformMetadatas.has(metadata.target)) {
          this._transformMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {
          this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);
        }
        this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);
      };
      MetadataStorage3.prototype.addExposeMetadata = function(metadata) {
        if (!this._exposeMetadatas.has(metadata.target)) {
          this._exposeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
      };
      MetadataStorage3.prototype.addExcludeMetadata = function(metadata) {
        if (!this._excludeMetadatas.has(metadata.target)) {
          this._excludeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
      };
      MetadataStorage3.prototype.findTransformMetadatas = function(target, propertyName, transformationType) {
        return this.findMetadatas(this._transformMetadatas, target, propertyName).filter(function(metadata) {
          if (!metadata.options)
            return true;
          if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
            return true;
          if (metadata.options.toClassOnly === true) {
            return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;
          }
          if (metadata.options.toPlainOnly === true) {
            return transformationType === TransformationType.CLASS_TO_PLAIN;
          }
          return true;
        });
      };
      MetadataStorage3.prototype.findExcludeMetadata = function(target, propertyName) {
        return this.findMetadata(this._excludeMetadatas, target, propertyName);
      };
      MetadataStorage3.prototype.findExposeMetadata = function(target, propertyName) {
        return this.findMetadata(this._exposeMetadatas, target, propertyName);
      };
      MetadataStorage3.prototype.findExposeMetadataByCustomName = function(target, name) {
        return this.getExposedMetadatas(target).find(function(metadata) {
          return metadata.options && metadata.options.name === name;
        });
      };
      MetadataStorage3.prototype.findTypeMetadata = function(target, propertyName) {
        return this.findMetadata(this._typeMetadatas, target, propertyName);
      };
      MetadataStorage3.prototype.getStrategy = function(target) {
        var excludeMap = this._excludeMetadatas.get(target);
        var exclude = excludeMap && excludeMap.get(void 0);
        var exposeMap = this._exposeMetadatas.get(target);
        var expose = exposeMap && exposeMap.get(void 0);
        if (exclude && expose || !exclude && !expose)
          return "none";
        return exclude ? "excludeAll" : "exposeAll";
      };
      MetadataStorage3.prototype.getExposedMetadatas = function(target) {
        return this.getMetadata(this._exposeMetadatas, target);
      };
      MetadataStorage3.prototype.getExcludedMetadatas = function(target) {
        return this.getMetadata(this._excludeMetadatas, target);
      };
      MetadataStorage3.prototype.getExposedProperties = function(target, transformationType) {
        return this.getExposedMetadatas(target).filter(function(metadata) {
          if (!metadata.options)
            return true;
          if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
            return true;
          if (metadata.options.toClassOnly === true) {
            return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;
          }
          if (metadata.options.toPlainOnly === true) {
            return transformationType === TransformationType.CLASS_TO_PLAIN;
          }
          return true;
        }).map(function(metadata) {
          return metadata.propertyName;
        });
      };
      MetadataStorage3.prototype.getExcludedProperties = function(target, transformationType) {
        return this.getExcludedMetadatas(target).filter(function(metadata) {
          if (!metadata.options)
            return true;
          if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
            return true;
          if (metadata.options.toClassOnly === true) {
            return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;
          }
          if (metadata.options.toPlainOnly === true) {
            return transformationType === TransformationType.CLASS_TO_PLAIN;
          }
          return true;
        }).map(function(metadata) {
          return metadata.propertyName;
        });
      };
      MetadataStorage3.prototype.clear = function() {
        this._typeMetadatas.clear();
        this._exposeMetadatas.clear();
        this._excludeMetadatas.clear();
        this._ancestorsMap.clear();
      };
      MetadataStorage3.prototype.getMetadata = function(metadatas, target) {
        var metadataFromTargetMap = metadatas.get(target);
        var metadataFromTarget;
        if (metadataFromTargetMap) {
          metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(function(meta) {
            return meta.propertyName !== void 0;
          });
        }
        var metadataFromAncestors = [];
        for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {
          var ancestor = _a[_i];
          var ancestorMetadataMap = metadatas.get(ancestor);
          if (ancestorMetadataMap) {
            var metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(function(meta) {
              return meta.propertyName !== void 0;
            });
            metadataFromAncestors.push.apply(metadataFromAncestors, metadataFromAncestor);
          }
        }
        return metadataFromAncestors.concat(metadataFromTarget || []);
      };
      MetadataStorage3.prototype.findMetadata = function(metadatas, target, propertyName) {
        var metadataFromTargetMap = metadatas.get(target);
        if (metadataFromTargetMap) {
          var metadataFromTarget = metadataFromTargetMap.get(propertyName);
          if (metadataFromTarget) {
            return metadataFromTarget;
          }
        }
        for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {
          var ancestor = _a[_i];
          var ancestorMetadataMap = metadatas.get(ancestor);
          if (ancestorMetadataMap) {
            var ancestorResult = ancestorMetadataMap.get(propertyName);
            if (ancestorResult) {
              return ancestorResult;
            }
          }
        }
        return void 0;
      };
      MetadataStorage3.prototype.findMetadatas = function(metadatas, target, propertyName) {
        var metadataFromTargetMap = metadatas.get(target);
        var metadataFromTarget;
        if (metadataFromTargetMap) {
          metadataFromTarget = metadataFromTargetMap.get(propertyName);
        }
        var metadataFromAncestorsTarget = [];
        for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {
          var ancestor = _a[_i];
          var ancestorMetadataMap = metadatas.get(ancestor);
          if (ancestorMetadataMap) {
            if (ancestorMetadataMap.has(propertyName)) {
              metadataFromAncestorsTarget.push.apply(metadataFromAncestorsTarget, ancestorMetadataMap.get(propertyName));
            }
          }
        }
        return metadataFromAncestorsTarget.slice().reverse().concat((metadataFromTarget || []).slice().reverse());
      };
      MetadataStorage3.prototype.getAncestors = function(target) {
        if (!target)
          return [];
        if (!this._ancestorsMap.has(target)) {
          var ancestors = [];
          for (var baseClass = Object.getPrototypeOf(target.prototype.constructor); typeof baseClass.prototype !== "undefined"; baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {
            ancestors.push(baseClass);
          }
          this._ancestorsMap.set(target, ancestors);
        }
        return this._ancestorsMap.get(target);
      };
      return MetadataStorage3;
    }();
  }
});

// node_modules/class-transformer/esm5/storage.js
var defaultMetadataStorage;
var init_storage = __esm({
  "node_modules/class-transformer/esm5/storage.js"() {
    init_MetadataStorage();
    defaultMetadataStorage = new MetadataStorage();
  }
});

// node_modules/class-transformer/esm5/utils/get-global.util.js
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof self !== "undefined") {
    return self;
  }
}
var init_get_global_util = __esm({
  "node_modules/class-transformer/esm5/utils/get-global.util.js"() {
  }
});

// node_modules/class-transformer/esm5/utils/is-promise.util.js
function isPromise(p) {
  return p !== null && typeof p === "object" && typeof p.then === "function";
}
var init_is_promise_util = __esm({
  "node_modules/class-transformer/esm5/utils/is-promise.util.js"() {
  }
});

// node_modules/class-transformer/esm5/utils/index.js
var init_utils = __esm({
  "node_modules/class-transformer/esm5/utils/index.js"() {
    init_get_global_util();
    init_is_promise_util();
  }
});

// node_modules/class-transformer/esm5/TransformOperationExecutor.js
function instantiateArrayType(arrayType) {
  var array = new arrayType();
  if (!(array instanceof Set) && !("push" in array)) {
    return [];
  }
  return array;
}
var __spreadArray, TransformOperationExecutor;
var init_TransformOperationExecutor = __esm({
  "node_modules/class-transformer/esm5/TransformOperationExecutor.js"() {
    init_storage();
    init_enums();
    init_utils();
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    TransformOperationExecutor = /** @class */
    function() {
      function TransformOperationExecutor2(transformationType, options) {
        this.transformationType = transformationType;
        this.options = options;
        this.recursionStack = /* @__PURE__ */ new Set();
      }
      TransformOperationExecutor2.prototype.transform = function(source, value, targetType, arrayType, isMap, level) {
        var _this = this;
        if (level === void 0) {
          level = 0;
        }
        if (Array.isArray(value) || value instanceof Set) {
          var newValue_1 = arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS ? instantiateArrayType(arrayType) : [];
          value.forEach(function(subValue, index) {
            var subSource = source ? source[index] : void 0;
            if (!_this.options.enableCircularCheck || !_this.isCircular(subValue)) {
              var realTargetType = void 0;
              if (typeof targetType !== "function" && targetType && targetType.options && targetType.options.discriminator && targetType.options.discriminator.property && targetType.options.discriminator.subTypes) {
                if (_this.transformationType === TransformationType.PLAIN_TO_CLASS) {
                  realTargetType = targetType.options.discriminator.subTypes.find(function(subType) {
                    return subType.name === subValue[targetType.options.discriminator.property];
                  });
                  var options = { newObject: newValue_1, object: subValue, property: void 0 };
                  var newType = targetType.typeFunction(options);
                  realTargetType === void 0 ? realTargetType = newType : realTargetType = realTargetType.value;
                  if (!targetType.options.keepDiscriminatorProperty)
                    delete subValue[targetType.options.discriminator.property];
                }
                if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {
                  realTargetType = subValue.constructor;
                }
                if (_this.transformationType === TransformationType.CLASS_TO_PLAIN) {
                  subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find(function(subType) {
                    return subType.value === subValue.constructor;
                  }).name;
                }
              } else {
                realTargetType = targetType;
              }
              var value_1 = _this.transform(subSource, subValue, realTargetType, void 0, subValue instanceof Map, level + 1);
              if (newValue_1 instanceof Set) {
                newValue_1.add(value_1);
              } else {
                newValue_1.push(value_1);
              }
            } else if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {
              if (newValue_1 instanceof Set) {
                newValue_1.add(subValue);
              } else {
                newValue_1.push(subValue);
              }
            }
          });
          return newValue_1;
        } else if (targetType === String && !isMap) {
          if (value === null || value === void 0)
            return value;
          return String(value);
        } else if (targetType === Number && !isMap) {
          if (value === null || value === void 0)
            return value;
          return Number(value);
        } else if (targetType === Boolean && !isMap) {
          if (value === null || value === void 0)
            return value;
          return Boolean(value);
        } else if ((targetType === Date || value instanceof Date) && !isMap) {
          if (value instanceof Date) {
            return new Date(value.valueOf());
          }
          if (value === null || value === void 0)
            return value;
          return new Date(value);
        } else if (!!getGlobal().Buffer && (targetType === Buffer || value instanceof Buffer) && !isMap) {
          if (value === null || value === void 0)
            return value;
          return Buffer.from(value);
        } else if (isPromise(value) && !isMap) {
          return new Promise(function(resolve, reject) {
            value.then(function(data) {
              return resolve(_this.transform(void 0, data, targetType, void 0, void 0, level + 1));
            }, reject);
          });
        } else if (!isMap && value !== null && typeof value === "object" && typeof value.then === "function") {
          return value;
        } else if (typeof value === "object" && value !== null) {
          if (!targetType && value.constructor !== Object)
            if (!Array.isArray(value) && value.constructor === Array) {
            } else {
              targetType = value.constructor;
            }
          if (!targetType && source)
            targetType = source.constructor;
          if (this.options.enableCircularCheck) {
            this.recursionStack.add(value);
          }
          var keys = this.getKeys(targetType, value, isMap);
          var newValue = source ? source : {};
          if (!source && (this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)) {
            if (isMap) {
              newValue = /* @__PURE__ */ new Map();
            } else if (targetType) {
              newValue = new targetType();
            } else {
              newValue = {};
            }
          }
          var _loop_1 = function(key2) {
            if (key2 === "__proto__" || key2 === "constructor") {
              return "continue";
            }
            var valueKey = key2;
            var newValueKey = key2, propertyName = key2;
            if (!this_1.options.ignoreDecorators && targetType) {
              if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
                var exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName(targetType, key2);
                if (exposeMetadata) {
                  propertyName = exposeMetadata.propertyName;
                  newValueKey = exposeMetadata.propertyName;
                }
              } else if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN || this_1.transformationType === TransformationType.CLASS_TO_CLASS) {
                var exposeMetadata = defaultMetadataStorage.findExposeMetadata(targetType, key2);
                if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
                  newValueKey = exposeMetadata.options.name;
                }
              }
            }
            var subValue = void 0;
            if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
              subValue = value[valueKey];
            } else {
              if (value instanceof Map) {
                subValue = value.get(valueKey);
              } else if (value[valueKey] instanceof Function) {
                subValue = value[valueKey]();
              } else {
                subValue = value[valueKey];
              }
            }
            var type = void 0, isSubValueMap = subValue instanceof Map;
            if (targetType && isMap) {
              type = targetType;
            } else if (targetType) {
              var metadata_1 = defaultMetadataStorage.findTypeMetadata(targetType, propertyName);
              if (metadata_1) {
                var options = { newObject: newValue, object: value, property: propertyName };
                var newType = metadata_1.typeFunction ? metadata_1.typeFunction(options) : metadata_1.reflectedType;
                if (metadata_1.options && metadata_1.options.discriminator && metadata_1.options.discriminator.property && metadata_1.options.discriminator.subTypes) {
                  if (!(value[valueKey] instanceof Array)) {
                    if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
                      type = metadata_1.options.discriminator.subTypes.find(function(subType) {
                        if (subValue && subValue instanceof Object && metadata_1.options.discriminator.property in subValue) {
                          return subType.name === subValue[metadata_1.options.discriminator.property];
                        }
                      });
                      type === void 0 ? type = newType : type = type.value;
                      if (!metadata_1.options.keepDiscriminatorProperty) {
                        if (subValue && subValue instanceof Object && metadata_1.options.discriminator.property in subValue) {
                          delete subValue[metadata_1.options.discriminator.property];
                        }
                      }
                    }
                    if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {
                      type = subValue.constructor;
                    }
                    if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {
                      if (subValue) {
                        subValue[metadata_1.options.discriminator.property] = metadata_1.options.discriminator.subTypes.find(function(subType) {
                          return subType.value === subValue.constructor;
                        }).name;
                      }
                    }
                  } else {
                    type = metadata_1;
                  }
                } else {
                  type = newType;
                }
                isSubValueMap = isSubValueMap || metadata_1.reflectedType === Map;
              } else if (this_1.options.targetMaps) {
                this_1.options.targetMaps.filter(function(map) {
                  return map.target === targetType && !!map.properties[propertyName];
                }).forEach(function(map) {
                  return type = map.properties[propertyName];
                });
              } else if (this_1.options.enableImplicitConversion && this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
                var reflectedType = Reflect.getMetadata("design:type", targetType.prototype, propertyName);
                if (reflectedType) {
                  type = reflectedType;
                }
              }
            }
            var arrayType_1 = Array.isArray(value[valueKey]) ? this_1.getReflectedType(targetType, propertyName) : void 0;
            var subSource = source ? source[valueKey] : void 0;
            if (newValue.constructor.prototype) {
              var descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);
              if ((this_1.transformationType === TransformationType.PLAIN_TO_CLASS || this_1.transformationType === TransformationType.CLASS_TO_CLASS) && // eslint-disable-next-line @typescript-eslint/unbound-method
              (descriptor && !descriptor.set || newValue[newValueKey] instanceof Function))
                return "continue";
            }
            if (!this_1.options.enableCircularCheck || !this_1.isCircular(subValue)) {
              var transformKey = this_1.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key2;
              var finalValue = void 0;
              if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {
                finalValue = value[transformKey];
                finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType);
                finalValue = value[transformKey] === finalValue ? subValue : finalValue;
                finalValue = this_1.transform(subSource, finalValue, type, arrayType_1, isSubValueMap, level + 1);
              } else {
                if (subValue === void 0 && this_1.options.exposeDefaultValues) {
                  finalValue = newValue[newValueKey];
                } else {
                  finalValue = this_1.transform(subSource, subValue, type, arrayType_1, isSubValueMap, level + 1);
                  finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType);
                }
              }
              if (finalValue !== void 0 || this_1.options.exposeUnsetFields) {
                if (newValue instanceof Map) {
                  newValue.set(newValueKey, finalValue);
                } else {
                  newValue[newValueKey] = finalValue;
                }
              }
            } else if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {
              var finalValue = subValue;
              finalValue = this_1.applyCustomTransformations(finalValue, targetType, key2, value, this_1.transformationType);
              if (finalValue !== void 0 || this_1.options.exposeUnsetFields) {
                if (newValue instanceof Map) {
                  newValue.set(newValueKey, finalValue);
                } else {
                  newValue[newValueKey] = finalValue;
                }
              }
            }
          };
          var this_1 = this;
          for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            _loop_1(key);
          }
          if (this.options.enableCircularCheck) {
            this.recursionStack.delete(value);
          }
          return newValue;
        } else {
          return value;
        }
      };
      TransformOperationExecutor2.prototype.applyCustomTransformations = function(value, target, key, obj, transformationType) {
        var _this = this;
        var metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);
        if (this.options.version !== void 0) {
          metadatas = metadatas.filter(function(metadata) {
            if (!metadata.options)
              return true;
            return _this.checkVersion(metadata.options.since, metadata.options.until);
          });
        }
        if (this.options.groups && this.options.groups.length) {
          metadatas = metadatas.filter(function(metadata) {
            if (!metadata.options)
              return true;
            return _this.checkGroups(metadata.options.groups);
          });
        } else {
          metadatas = metadatas.filter(function(metadata) {
            return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;
          });
        }
        metadatas.forEach(function(metadata) {
          value = metadata.transformFn({ value, key, obj, type: transformationType, options: _this.options });
        });
        return value;
      };
      TransformOperationExecutor2.prototype.isCircular = function(object) {
        return this.recursionStack.has(object);
      };
      TransformOperationExecutor2.prototype.getReflectedType = function(target, propertyName) {
        if (!target)
          return void 0;
        var meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);
        return meta ? meta.reflectedType : void 0;
      };
      TransformOperationExecutor2.prototype.getKeys = function(target, object, isMap) {
        var _this = this;
        var strategy = defaultMetadataStorage.getStrategy(target);
        if (strategy === "none")
          strategy = this.options.strategy || "exposeAll";
        var keys = [];
        if (strategy === "exposeAll" || isMap) {
          if (object instanceof Map) {
            keys = Array.from(object.keys());
          } else {
            keys = Object.keys(object);
          }
        }
        if (isMap) {
          return keys;
        }
        if (this.options.ignoreDecorators && this.options.excludeExtraneousValues && target) {
          var exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);
          var excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);
          keys = __spreadArray(__spreadArray([], exposedProperties, true), excludedProperties, true);
        }
        if (!this.options.ignoreDecorators && target) {
          var exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);
          if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
            exposedProperties = exposedProperties.map(function(key) {
              var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
              if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
                return exposeMetadata.options.name;
              }
              return key;
            });
          }
          if (this.options.excludeExtraneousValues) {
            keys = exposedProperties;
          } else {
            keys = keys.concat(exposedProperties);
          }
          var excludedProperties_1 = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);
          if (excludedProperties_1.length > 0) {
            keys = keys.filter(function(key) {
              return !excludedProperties_1.includes(key);
            });
          }
          if (this.options.version !== void 0) {
            keys = keys.filter(function(key) {
              var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
              if (!exposeMetadata || !exposeMetadata.options)
                return true;
              return _this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);
            });
          }
          if (this.options.groups && this.options.groups.length) {
            keys = keys.filter(function(key) {
              var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
              if (!exposeMetadata || !exposeMetadata.options)
                return true;
              return _this.checkGroups(exposeMetadata.options.groups);
            });
          } else {
            keys = keys.filter(function(key) {
              var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
              return !exposeMetadata || !exposeMetadata.options || !exposeMetadata.options.groups || !exposeMetadata.options.groups.length;
            });
          }
        }
        if (this.options.excludePrefixes && this.options.excludePrefixes.length) {
          keys = keys.filter(function(key) {
            return _this.options.excludePrefixes.every(function(prefix) {
              return key.substr(0, prefix.length) !== prefix;
            });
          });
        }
        keys = keys.filter(function(key, index, self2) {
          return self2.indexOf(key) === index;
        });
        return keys;
      };
      TransformOperationExecutor2.prototype.checkVersion = function(since, until) {
        var decision = true;
        if (decision && since)
          decision = this.options.version >= since;
        if (decision && until)
          decision = this.options.version < until;
        return decision;
      };
      TransformOperationExecutor2.prototype.checkGroups = function(groups) {
        if (!groups)
          return true;
        return this.options.groups.some(function(optionGroup) {
          return groups.includes(optionGroup);
        });
      };
      return TransformOperationExecutor2;
    }();
  }
});

// node_modules/class-transformer/esm5/constants/default-options.constant.js
var defaultOptions;
var init_default_options_constant = __esm({
  "node_modules/class-transformer/esm5/constants/default-options.constant.js"() {
    defaultOptions = {
      enableCircularCheck: false,
      enableImplicitConversion: false,
      excludeExtraneousValues: false,
      excludePrefixes: void 0,
      exposeDefaultValues: false,
      exposeUnsetFields: true,
      groups: void 0,
      ignoreDecorators: false,
      strategy: void 0,
      targetMaps: void 0,
      version: void 0
    };
  }
});

// node_modules/class-transformer/esm5/ClassTransformer.js
var __assign, ClassTransformer;
var init_ClassTransformer = __esm({
  "node_modules/class-transformer/esm5/ClassTransformer.js"() {
    init_TransformOperationExecutor();
    init_enums();
    init_default_options_constant();
    __assign = function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    ClassTransformer = /** @class */
    function() {
      function ClassTransformer2() {
      }
      ClassTransformer2.prototype.instanceToPlain = function(object, options) {
        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, __assign(__assign({}, defaultOptions), options));
        return executor.transform(void 0, object, void 0, void 0, void 0, void 0);
      };
      ClassTransformer2.prototype.classToPlainFromExist = function(object, plainObject, options) {
        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, __assign(__assign({}, defaultOptions), options));
        return executor.transform(plainObject, object, void 0, void 0, void 0, void 0);
      };
      ClassTransformer2.prototype.plainToInstance = function(cls, plain, options) {
        var executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, __assign(__assign({}, defaultOptions), options));
        return executor.transform(void 0, plain, cls, void 0, void 0, void 0);
      };
      ClassTransformer2.prototype.plainToClassFromExist = function(clsObject, plain, options) {
        var executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, __assign(__assign({}, defaultOptions), options));
        return executor.transform(clsObject, plain, void 0, void 0, void 0, void 0);
      };
      ClassTransformer2.prototype.instanceToInstance = function(object, options) {
        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, __assign(__assign({}, defaultOptions), options));
        return executor.transform(void 0, object, void 0, void 0, void 0, void 0);
      };
      ClassTransformer2.prototype.classToClassFromExist = function(object, fromObject, options) {
        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, __assign(__assign({}, defaultOptions), options));
        return executor.transform(fromObject, object, void 0, void 0, void 0, void 0);
      };
      ClassTransformer2.prototype.serialize = function(object, options) {
        return JSON.stringify(this.instanceToPlain(object, options));
      };
      ClassTransformer2.prototype.deserialize = function(cls, json, options) {
        var jsonObject = JSON.parse(json);
        return this.plainToInstance(cls, jsonObject, options);
      };
      ClassTransformer2.prototype.deserializeArray = function(cls, json, options) {
        var jsonObject = JSON.parse(json);
        return this.plainToInstance(cls, jsonObject, options);
      };
      return ClassTransformer2;
    }();
  }
});

// node_modules/class-transformer/esm5/decorators/exclude.decorator.js
function Exclude(options) {
  if (options === void 0) {
    options = {};
  }
  return function(object, propertyName) {
    defaultMetadataStorage.addExcludeMetadata({
      target: object instanceof Function ? object : object.constructor,
      propertyName,
      options
    });
  };
}
var init_exclude_decorator = __esm({
  "node_modules/class-transformer/esm5/decorators/exclude.decorator.js"() {
    init_storage();
  }
});

// node_modules/class-transformer/esm5/decorators/expose.decorator.js
function Expose(options) {
  if (options === void 0) {
    options = {};
  }
  return function(object, propertyName) {
    defaultMetadataStorage.addExposeMetadata({
      target: object instanceof Function ? object : object.constructor,
      propertyName,
      options
    });
  };
}
var init_expose_decorator = __esm({
  "node_modules/class-transformer/esm5/decorators/expose.decorator.js"() {
    init_storage();
  }
});

// node_modules/class-transformer/esm5/decorators/transform-instance-to-instance.decorator.js
function TransformInstanceToInstance(params) {
  return function(target, propertyKey, descriptor) {
    var classTransformer2 = new ClassTransformer();
    var originalMethod = descriptor.value;
    descriptor.value = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var result2 = originalMethod.apply(this, args);
      var isPromise3 = !!result2 && (typeof result2 === "object" || typeof result2 === "function") && typeof result2.then === "function";
      return isPromise3 ? result2.then(function(data) {
        return classTransformer2.instanceToInstance(data, params);
      }) : classTransformer2.instanceToInstance(result2, params);
    };
  };
}
var init_transform_instance_to_instance_decorator = __esm({
  "node_modules/class-transformer/esm5/decorators/transform-instance-to-instance.decorator.js"() {
    init_ClassTransformer();
  }
});

// node_modules/class-transformer/esm5/decorators/transform-instance-to-plain.decorator.js
function TransformInstanceToPlain(params) {
  return function(target, propertyKey, descriptor) {
    var classTransformer2 = new ClassTransformer();
    var originalMethod = descriptor.value;
    descriptor.value = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var result2 = originalMethod.apply(this, args);
      var isPromise3 = !!result2 && (typeof result2 === "object" || typeof result2 === "function") && typeof result2.then === "function";
      return isPromise3 ? result2.then(function(data) {
        return classTransformer2.instanceToPlain(data, params);
      }) : classTransformer2.instanceToPlain(result2, params);
    };
  };
}
var init_transform_instance_to_plain_decorator = __esm({
  "node_modules/class-transformer/esm5/decorators/transform-instance-to-plain.decorator.js"() {
    init_ClassTransformer();
  }
});

// node_modules/class-transformer/esm5/decorators/transform-plain-to-instance.decorator.js
function TransformPlainToInstance(classType, params) {
  return function(target, propertyKey, descriptor) {
    var classTransformer2 = new ClassTransformer();
    var originalMethod = descriptor.value;
    descriptor.value = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var result2 = originalMethod.apply(this, args);
      var isPromise3 = !!result2 && (typeof result2 === "object" || typeof result2 === "function") && typeof result2.then === "function";
      return isPromise3 ? result2.then(function(data) {
        return classTransformer2.plainToInstance(classType, data, params);
      }) : classTransformer2.plainToInstance(classType, result2, params);
    };
  };
}
var init_transform_plain_to_instance_decorator = __esm({
  "node_modules/class-transformer/esm5/decorators/transform-plain-to-instance.decorator.js"() {
    init_ClassTransformer();
  }
});

// node_modules/class-transformer/esm5/decorators/transform.decorator.js
function Transform(transformFn, options) {
  if (options === void 0) {
    options = {};
  }
  return function(target, propertyName) {
    defaultMetadataStorage.addTransformMetadata({
      target: target.constructor,
      propertyName,
      transformFn,
      options
    });
  };
}
var init_transform_decorator = __esm({
  "node_modules/class-transformer/esm5/decorators/transform.decorator.js"() {
    init_storage();
  }
});

// node_modules/class-transformer/esm5/decorators/type.decorator.js
function Type(typeFunction, options) {
  if (options === void 0) {
    options = {};
  }
  return function(target, propertyName) {
    var reflectedType = Reflect.getMetadata("design:type", target, propertyName);
    defaultMetadataStorage.addTypeMetadata({
      target: target.constructor,
      propertyName,
      reflectedType,
      typeFunction,
      options
    });
  };
}
var init_type_decorator = __esm({
  "node_modules/class-transformer/esm5/decorators/type.decorator.js"() {
    init_storage();
  }
});

// node_modules/class-transformer/esm5/decorators/index.js
var init_decorators = __esm({
  "node_modules/class-transformer/esm5/decorators/index.js"() {
    init_exclude_decorator();
    init_expose_decorator();
    init_transform_instance_to_instance_decorator();
    init_transform_instance_to_plain_decorator();
    init_transform_plain_to_instance_decorator();
    init_transform_decorator();
    init_type_decorator();
  }
});

// node_modules/class-transformer/esm5/interfaces/decorator-options/expose-options.interface.js
var init_expose_options_interface = __esm({
  "node_modules/class-transformer/esm5/interfaces/decorator-options/expose-options.interface.js"() {
  }
});

// node_modules/class-transformer/esm5/interfaces/decorator-options/exclude-options.interface.js
var init_exclude_options_interface = __esm({
  "node_modules/class-transformer/esm5/interfaces/decorator-options/exclude-options.interface.js"() {
  }
});

// node_modules/class-transformer/esm5/interfaces/decorator-options/transform-options.interface.js
var init_transform_options_interface = __esm({
  "node_modules/class-transformer/esm5/interfaces/decorator-options/transform-options.interface.js"() {
  }
});

// node_modules/class-transformer/esm5/interfaces/decorator-options/type-discriminator-descriptor.interface.js
var init_type_discriminator_descriptor_interface = __esm({
  "node_modules/class-transformer/esm5/interfaces/decorator-options/type-discriminator-descriptor.interface.js"() {
  }
});

// node_modules/class-transformer/esm5/interfaces/decorator-options/type-options.interface.js
var init_type_options_interface = __esm({
  "node_modules/class-transformer/esm5/interfaces/decorator-options/type-options.interface.js"() {
  }
});

// node_modules/class-transformer/esm5/interfaces/metadata/exclude-metadata.interface.js
var init_exclude_metadata_interface = __esm({
  "node_modules/class-transformer/esm5/interfaces/metadata/exclude-metadata.interface.js"() {
  }
});

// node_modules/class-transformer/esm5/interfaces/metadata/expose-metadata.interface.js
var init_expose_metadata_interface = __esm({
  "node_modules/class-transformer/esm5/interfaces/metadata/expose-metadata.interface.js"() {
  }
});

// node_modules/class-transformer/esm5/interfaces/metadata/transform-metadata.interface.js
var init_transform_metadata_interface = __esm({
  "node_modules/class-transformer/esm5/interfaces/metadata/transform-metadata.interface.js"() {
  }
});

// node_modules/class-transformer/esm5/interfaces/metadata/transform-fn-params.interface.js
var init_transform_fn_params_interface = __esm({
  "node_modules/class-transformer/esm5/interfaces/metadata/transform-fn-params.interface.js"() {
  }
});

// node_modules/class-transformer/esm5/interfaces/metadata/type-metadata.interface.js
var init_type_metadata_interface = __esm({
  "node_modules/class-transformer/esm5/interfaces/metadata/type-metadata.interface.js"() {
  }
});

// node_modules/class-transformer/esm5/interfaces/class-constructor.type.js
var init_class_constructor_type = __esm({
  "node_modules/class-transformer/esm5/interfaces/class-constructor.type.js"() {
  }
});

// node_modules/class-transformer/esm5/interfaces/class-transformer-options.interface.js
var init_class_transformer_options_interface = __esm({
  "node_modules/class-transformer/esm5/interfaces/class-transformer-options.interface.js"() {
  }
});

// node_modules/class-transformer/esm5/interfaces/target-map.interface.js
var init_target_map_interface = __esm({
  "node_modules/class-transformer/esm5/interfaces/target-map.interface.js"() {
  }
});

// node_modules/class-transformer/esm5/interfaces/type-help-options.interface.js
var init_type_help_options_interface = __esm({
  "node_modules/class-transformer/esm5/interfaces/type-help-options.interface.js"() {
  }
});

// node_modules/class-transformer/esm5/interfaces/index.js
var init_interfaces = __esm({
  "node_modules/class-transformer/esm5/interfaces/index.js"() {
    init_expose_options_interface();
    init_exclude_options_interface();
    init_transform_options_interface();
    init_type_discriminator_descriptor_interface();
    init_type_options_interface();
    init_exclude_metadata_interface();
    init_expose_metadata_interface();
    init_transform_metadata_interface();
    init_transform_fn_params_interface();
    init_type_metadata_interface();
    init_class_constructor_type();
    init_class_transformer_options_interface();
    init_target_map_interface();
    init_type_help_options_interface();
  }
});

// node_modules/class-transformer/esm5/index.js
var esm5_exports = {};
__export(esm5_exports, {
  ClassTransformer: () => ClassTransformer,
  Exclude: () => Exclude,
  Expose: () => Expose,
  Transform: () => Transform,
  TransformInstanceToInstance: () => TransformInstanceToInstance,
  TransformInstanceToPlain: () => TransformInstanceToPlain,
  TransformPlainToInstance: () => TransformPlainToInstance,
  TransformationType: () => TransformationType,
  Type: () => Type,
  classToClassFromExist: () => classToClassFromExist,
  classToPlain: () => classToPlain,
  classToPlainFromExist: () => classToPlainFromExist,
  deserialize: () => deserialize,
  deserializeArray: () => deserializeArray,
  instanceToInstance: () => instanceToInstance,
  instanceToPlain: () => instanceToPlain,
  plainToClass: () => plainToClass,
  plainToClassFromExist: () => plainToClassFromExist,
  plainToInstance: () => plainToInstance,
  serialize: () => serialize
});
function classToPlain(object, options) {
  return classTransformer.instanceToPlain(object, options);
}
function instanceToPlain(object, options) {
  return classTransformer.instanceToPlain(object, options);
}
function classToPlainFromExist(object, plainObject, options) {
  return classTransformer.classToPlainFromExist(object, plainObject, options);
}
function plainToClass(cls, plain, options) {
  return classTransformer.plainToInstance(cls, plain, options);
}
function plainToInstance(cls, plain, options) {
  return classTransformer.plainToInstance(cls, plain, options);
}
function plainToClassFromExist(clsObject, plain, options) {
  return classTransformer.plainToClassFromExist(clsObject, plain, options);
}
function instanceToInstance(object, options) {
  return classTransformer.instanceToInstance(object, options);
}
function classToClassFromExist(object, fromObject, options) {
  return classTransformer.classToClassFromExist(object, fromObject, options);
}
function serialize(object, options) {
  return classTransformer.serialize(object, options);
}
function deserialize(cls, json, options) {
  return classTransformer.deserialize(cls, json, options);
}
function deserializeArray(cls, json, options) {
  return classTransformer.deserializeArray(cls, json, options);
}
var classTransformer;
var init_esm5 = __esm({
  "node_modules/class-transformer/esm5/index.js"() {
    init_ClassTransformer();
    init_ClassTransformer();
    init_decorators();
    init_interfaces();
    init_enums();
    classTransformer = new ClassTransformer();
  }
});

// node_modules/class-validator/esm5/metadata/ValidationMetadata.js
var ValidationMetadata;
var init_ValidationMetadata = __esm({
  "node_modules/class-validator/esm5/metadata/ValidationMetadata.js"() {
    ValidationMetadata = /** @class */
    function() {
      function ValidationMetadata2(args) {
        this.groups = [];
        this.each = false;
        this.context = void 0;
        this.type = args.type;
        this.target = args.target;
        this.propertyName = args.propertyName;
        this.constraints = args.constraints;
        this.constraintCls = args.constraintCls;
        this.validationTypeOptions = args.validationTypeOptions;
        if (args.validationOptions) {
          this.message = args.validationOptions.message;
          this.groups = args.validationOptions.groups;
          this.always = args.validationOptions.always;
          this.each = args.validationOptions.each;
          this.context = args.validationOptions.context;
        }
      }
      return ValidationMetadata2;
    }();
  }
});

// node_modules/class-validator/esm5/validation-schema/ValidationSchemaToMetadataTransformer.js
var ValidationSchemaToMetadataTransformer;
var init_ValidationSchemaToMetadataTransformer = __esm({
  "node_modules/class-validator/esm5/validation-schema/ValidationSchemaToMetadataTransformer.js"() {
    init_ValidationMetadata();
    ValidationSchemaToMetadataTransformer = /** @class */
    function() {
      function ValidationSchemaToMetadataTransformer2() {
      }
      ValidationSchemaToMetadataTransformer2.prototype.transform = function(schema) {
        var metadatas = [];
        Object.keys(schema.properties).forEach(function(property) {
          schema.properties[property].forEach(function(validation) {
            var validationOptions = {
              message: validation.message,
              groups: validation.groups,
              always: validation.always,
              each: validation.each
            };
            var args = {
              type: validation.type,
              target: schema.name,
              propertyName: property,
              constraints: validation.constraints,
              validationTypeOptions: validation.options,
              validationOptions
            };
            metadatas.push(new ValidationMetadata(args));
          });
        });
        return metadatas;
      };
      return ValidationSchemaToMetadataTransformer2;
    }();
  }
});

// node_modules/class-validator/esm5/utils/convert-to-array.util.js
function convertToArray(val) {
  if (val instanceof Map) {
    return Array.from(val.values());
  }
  return Array.isArray(val) ? val : Array.from(val);
}
var init_convert_to_array_util = __esm({
  "node_modules/class-validator/esm5/utils/convert-to-array.util.js"() {
  }
});

// node_modules/class-validator/esm5/utils/get-global.util.js
function getGlobal2() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof self !== "undefined") {
    return self;
  }
}
var init_get_global_util2 = __esm({
  "node_modules/class-validator/esm5/utils/get-global.util.js"() {
  }
});

// node_modules/class-validator/esm5/utils/is-promise.util.js
function isPromise2(p) {
  return p !== null && typeof p === "object" && typeof p.then === "function";
}
var init_is_promise_util2 = __esm({
  "node_modules/class-validator/esm5/utils/is-promise.util.js"() {
  }
});

// node_modules/class-validator/esm5/utils/index.js
var init_utils2 = __esm({
  "node_modules/class-validator/esm5/utils/index.js"() {
    init_convert_to_array_util();
    init_get_global_util2();
    init_is_promise_util2();
  }
});

// node_modules/class-validator/esm5/metadata/MetadataStorage.js
function getMetadataStorage() {
  var global2 = getGlobal2();
  if (!global2.classValidatorMetadataStorage) {
    global2.classValidatorMetadataStorage = new MetadataStorage2();
  }
  return global2.classValidatorMetadataStorage;
}
var MetadataStorage2;
var init_MetadataStorage2 = __esm({
  "node_modules/class-validator/esm5/metadata/MetadataStorage.js"() {
    init_ValidationSchemaToMetadataTransformer();
    init_utils2();
    MetadataStorage2 = /** @class */
    function() {
      function MetadataStorage3() {
        this.validationMetadatas = [];
        this.constraintMetadatas = [];
      }
      Object.defineProperty(MetadataStorage3.prototype, "hasValidationMetaData", {
        get: function() {
          return !!this.validationMetadatas.length;
        },
        enumerable: false,
        configurable: true
      });
      MetadataStorage3.prototype.addValidationSchema = function(schema) {
        var _this = this;
        var validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);
        validationMetadatas.forEach(function(validationMetadata) {
          return _this.addValidationMetadata(validationMetadata);
        });
      };
      MetadataStorage3.prototype.addValidationMetadata = function(metadata) {
        this.validationMetadatas.push(metadata);
      };
      MetadataStorage3.prototype.addConstraintMetadata = function(metadata) {
        this.constraintMetadatas.push(metadata);
      };
      MetadataStorage3.prototype.groupByPropertyName = function(metadata) {
        var grouped = {};
        metadata.forEach(function(metadata2) {
          if (!grouped[metadata2.propertyName])
            grouped[metadata2.propertyName] = [];
          grouped[metadata2.propertyName].push(metadata2);
        });
        return grouped;
      };
      MetadataStorage3.prototype.getTargetValidationMetadatas = function(targetConstructor, targetSchema, always, strictGroups, groups) {
        var includeMetadataBecauseOfAlwaysOption = function(metadata) {
          if (typeof metadata.always !== "undefined")
            return metadata.always;
          if (metadata.groups && metadata.groups.length)
            return false;
          return always;
        };
        var excludeMetadataBecauseOfStrictGroupsOption = function(metadata) {
          if (strictGroups) {
            if (!groups || !groups.length) {
              if (metadata.groups && metadata.groups.length)
                return true;
            }
          }
          return false;
        };
        var originalMetadatas = this.validationMetadatas.filter(function(metadata) {
          if (metadata.target !== targetConstructor && metadata.target !== targetSchema)
            return false;
          if (includeMetadataBecauseOfAlwaysOption(metadata))
            return true;
          if (excludeMetadataBecauseOfStrictGroupsOption(metadata))
            return false;
          if (groups && groups.length > 0)
            return metadata.groups && !!metadata.groups.find(function(group) {
              return groups.indexOf(group) !== -1;
            });
          return true;
        });
        var inheritedMetadatas = this.validationMetadatas.filter(function(metadata) {
          if (typeof metadata.target === "string")
            return false;
          if (metadata.target === targetConstructor)
            return false;
          if (metadata.target instanceof Function && !(targetConstructor.prototype instanceof metadata.target))
            return false;
          if (includeMetadataBecauseOfAlwaysOption(metadata))
            return true;
          if (excludeMetadataBecauseOfStrictGroupsOption(metadata))
            return false;
          if (groups && groups.length > 0)
            return metadata.groups && !!metadata.groups.find(function(group) {
              return groups.indexOf(group) !== -1;
            });
          return true;
        });
        var uniqueInheritedMetadatas = inheritedMetadatas.filter(function(inheritedMetadata) {
          return !originalMetadatas.find(function(originalMetadata) {
            return originalMetadata.propertyName === inheritedMetadata.propertyName && originalMetadata.type === inheritedMetadata.type;
          });
        });
        return originalMetadatas.concat(uniqueInheritedMetadatas);
      };
      MetadataStorage3.prototype.getTargetValidatorConstraints = function(target) {
        return this.constraintMetadatas.filter(function(metadata) {
          return metadata.target === target;
        });
      };
      return MetadataStorage3;
    }();
  }
});

// node_modules/class-validator/esm5/validation/ValidationError.js
var ValidationError;
var init_ValidationError = __esm({
  "node_modules/class-validator/esm5/validation/ValidationError.js"() {
    ValidationError = /** @class */
    function() {
      function ValidationError2() {
      }
      ValidationError2.prototype.toString = function(shouldDecorate, hasParent, parentPath) {
        var _this = this;
        if (shouldDecorate === void 0) {
          shouldDecorate = false;
        }
        if (hasParent === void 0) {
          hasParent = false;
        }
        if (parentPath === void 0) {
          parentPath = "";
        }
        var boldStart = shouldDecorate ? "\x1B[1m" : "";
        var boldEnd = shouldDecorate ? "\x1B[22m" : "";
        var propConstraintFailed = function(propertyName) {
          return " - property " + boldStart + parentPath + propertyName + boldEnd + " has failed the following constraints: " + boldStart + Object.keys(_this.constraints).join(", ") + boldEnd + " \n";
        };
        if (!hasParent) {
          return "An instance of " + boldStart + (this.target ? this.target.constructor.name : "an object") + boldEnd + " has failed the validation:\n" + (this.constraints ? propConstraintFailed(this.property) : "") + (this.children ? this.children.map(function(childError) {
            return childError.toString(shouldDecorate, true, _this.property);
          }).join("") : "");
        } else {
          var formattedProperty_1 = Number.isInteger(+this.property) ? "[" + this.property + "]" : (parentPath ? "." : "") + this.property;
          if (this.constraints) {
            return propConstraintFailed(formattedProperty_1);
          } else {
            return this.children ? this.children.map(function(childError) {
              return childError.toString(shouldDecorate, true, "" + parentPath + formattedProperty_1);
            }).join("") : "";
          }
        }
      };
      return ValidationError2;
    }();
  }
});

// node_modules/class-validator/esm5/validation/ValidationTypes.js
var ValidationTypes;
var init_ValidationTypes = __esm({
  "node_modules/class-validator/esm5/validation/ValidationTypes.js"() {
    ValidationTypes = /** @class */
    function() {
      function ValidationTypes2() {
      }
      ValidationTypes2.isValid = function(type) {
        var _this = this;
        return type !== "isValid" && type !== "getMessage" && Object.keys(this).map(function(key) {
          return _this[key];
        }).indexOf(type) !== -1;
      };
      ValidationTypes2.CUSTOM_VALIDATION = "customValidation";
      ValidationTypes2.NESTED_VALIDATION = "nestedValidation";
      ValidationTypes2.PROMISE_VALIDATION = "promiseValidation";
      ValidationTypes2.CONDITIONAL_VALIDATION = "conditionalValidation";
      ValidationTypes2.WHITELIST = "whitelistValidation";
      ValidationTypes2.IS_DEFINED = "isDefined";
      return ValidationTypes2;
    }();
  }
});

// node_modules/class-validator/esm5/validation/ValidationUtils.js
function constraintToString(constraint) {
  if (Array.isArray(constraint)) {
    return constraint.join(", ");
  }
  return "" + constraint;
}
var ValidationUtils;
var init_ValidationUtils = __esm({
  "node_modules/class-validator/esm5/validation/ValidationUtils.js"() {
    ValidationUtils = /** @class */
    function() {
      function ValidationUtils2() {
      }
      ValidationUtils2.replaceMessageSpecialTokens = function(message, validationArguments) {
        var messageString;
        if (message instanceof Function) {
          messageString = message(validationArguments);
        } else if (typeof message === "string") {
          messageString = message;
        }
        if (messageString && validationArguments.constraints instanceof Array) {
          validationArguments.constraints.forEach(function(constraint, index) {
            messageString = messageString.replace(new RegExp("\\$constraint" + (index + 1), "g"), constraintToString(constraint));
          });
        }
        if (messageString && validationArguments.value !== void 0 && validationArguments.value !== null && typeof validationArguments.value === "string")
          messageString = messageString.replace(/\$value/g, validationArguments.value);
        if (messageString)
          messageString = messageString.replace(/\$property/g, validationArguments.property);
        if (messageString)
          messageString = messageString.replace(/\$target/g, validationArguments.targetName);
        return messageString;
      };
      return ValidationUtils2;
    }();
  }
});

// node_modules/class-validator/esm5/validation/ValidationExecutor.js
var ValidationExecutor;
var init_ValidationExecutor = __esm({
  "node_modules/class-validator/esm5/validation/ValidationExecutor.js"() {
    init_ValidationError();
    init_ValidationTypes();
    init_ValidationUtils();
    init_utils2();
    init_MetadataStorage2();
    ValidationExecutor = /** @class */
    function() {
      function ValidationExecutor2(validator, validatorOptions) {
        this.validator = validator;
        this.validatorOptions = validatorOptions;
        this.awaitingPromises = [];
        this.ignoreAsyncValidations = false;
        this.metadataStorage = getMetadataStorage();
      }
      ValidationExecutor2.prototype.execute = function(object, targetSchema, validationErrors) {
        var _this = this;
        var _a;
        if (!this.metadataStorage.hasValidationMetaData && ((_a = this.validatorOptions) === null || _a === void 0 ? void 0 : _a.enableDebugMessages) === true) {
          console.warn("No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.");
        }
        var groups = this.validatorOptions ? this.validatorOptions.groups : void 0;
        var strictGroups = this.validatorOptions && this.validatorOptions.strictGroups || false;
        var always = this.validatorOptions && this.validatorOptions.always || false;
        var targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, always, strictGroups, groups);
        var groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);
        if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {
          var validationError = new ValidationError();
          if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === void 0 || this.validatorOptions.validationError.target === true)
            validationError.target = object;
          validationError.value = void 0;
          validationError.property = void 0;
          validationError.children = [];
          validationError.constraints = { unknownValue: "an unknown value was passed to the validate function" };
          validationErrors.push(validationError);
          return;
        }
        if (this.validatorOptions && this.validatorOptions.whitelist)
          this.whitelist(object, groupedMetadatas, validationErrors);
        Object.keys(groupedMetadatas).forEach(function(propertyName) {
          var value = object[propertyName];
          var definedMetadatas = groupedMetadatas[propertyName].filter(function(metadata) {
            return metadata.type === ValidationTypes.IS_DEFINED;
          });
          var metadatas = groupedMetadatas[propertyName].filter(function(metadata) {
            return metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST;
          });
          if (value instanceof Promise && metadatas.find(function(metadata) {
            return metadata.type === ValidationTypes.PROMISE_VALIDATION;
          })) {
            _this.awaitingPromises.push(value.then(function(resolvedValue) {
              _this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);
            }));
          } else {
            _this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);
          }
        });
      };
      ValidationExecutor2.prototype.whitelist = function(object, groupedMetadatas, validationErrors) {
        var _this = this;
        var notAllowedProperties = [];
        Object.keys(object).forEach(function(propertyName) {
          if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)
            notAllowedProperties.push(propertyName);
        });
        if (notAllowedProperties.length > 0) {
          if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {
            notAllowedProperties.forEach(function(property) {
              var _a;
              var validationError = _this.generateValidationError(object, object[property], property);
              validationError.constraints = (_a = {}, _a[ValidationTypes.WHITELIST] = "property " + property + " should not exist", _a);
              validationError.children = void 0;
              validationErrors.push(validationError);
            });
          } else {
            notAllowedProperties.forEach(function(property) {
              return delete object[property];
            });
          }
        }
      };
      ValidationExecutor2.prototype.stripEmptyErrors = function(errors) {
        var _this = this;
        return errors.filter(function(error) {
          if (error.children) {
            error.children = _this.stripEmptyErrors(error.children);
          }
          if (Object.keys(error.constraints).length === 0) {
            if (error.children.length === 0) {
              return false;
            } else {
              delete error.constraints;
            }
          }
          return true;
        });
      };
      ValidationExecutor2.prototype.performValidations = function(object, value, propertyName, definedMetadatas, metadatas, validationErrors) {
        var customValidationMetadatas = metadatas.filter(function(metadata) {
          return metadata.type === ValidationTypes.CUSTOM_VALIDATION;
        });
        var nestedValidationMetadatas = metadatas.filter(function(metadata) {
          return metadata.type === ValidationTypes.NESTED_VALIDATION;
        });
        var conditionalValidationMetadatas = metadatas.filter(function(metadata) {
          return metadata.type === ValidationTypes.CONDITIONAL_VALIDATION;
        });
        var validationError = this.generateValidationError(object, value, propertyName);
        validationErrors.push(validationError);
        var canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);
        if (!canValidate) {
          return;
        }
        this.customValidations(object, value, definedMetadatas, validationError);
        this.mapContexts(object, value, definedMetadatas, validationError);
        if (value === void 0 && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {
          return;
        }
        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {
          return;
        }
        if ((value === null || value === void 0) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {
          return;
        }
        this.customValidations(object, value, customValidationMetadatas, validationError);
        this.nestedValidations(value, nestedValidationMetadatas, validationError.children);
        this.mapContexts(object, value, metadatas, validationError);
        this.mapContexts(object, value, customValidationMetadatas, validationError);
      };
      ValidationExecutor2.prototype.generateValidationError = function(object, value, propertyName) {
        var validationError = new ValidationError();
        if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === void 0 || this.validatorOptions.validationError.target === true)
          validationError.target = object;
        if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.value === void 0 || this.validatorOptions.validationError.value === true)
          validationError.value = value;
        validationError.property = propertyName;
        validationError.children = [];
        validationError.constraints = {};
        return validationError;
      };
      ValidationExecutor2.prototype.conditionalValidations = function(object, value, metadatas) {
        return metadatas.map(function(metadata) {
          return metadata.constraints[0](object, value);
        }).reduce(function(resultA, resultB) {
          return resultA && resultB;
        }, true);
      };
      ValidationExecutor2.prototype.customValidations = function(object, value, metadatas, error) {
        var _this = this;
        metadatas.forEach(function(metadata) {
          _this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls).forEach(function(customConstraintMetadata) {
            if (customConstraintMetadata.async && _this.ignoreAsyncValidations)
              return;
            if (_this.validatorOptions && _this.validatorOptions.stopAtFirstError && Object.keys(error.constraints || {}).length > 0)
              return;
            var validationArguments = {
              targetName: object.constructor ? object.constructor.name : void 0,
              property: metadata.propertyName,
              object,
              value,
              constraints: metadata.constraints
            };
            if (!metadata.each || !(value instanceof Array || value instanceof Set || value instanceof Map)) {
              var validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);
              if (isPromise2(validatedValue)) {
                var promise = validatedValue.then(function(isValid) {
                  if (!isValid) {
                    var _a2 = _this.createValidationError(object, value, metadata, customConstraintMetadata), type2 = _a2[0], message2 = _a2[1];
                    error.constraints[type2] = message2;
                    if (metadata.context) {
                      if (!error.contexts) {
                        error.contexts = {};
                      }
                      error.contexts[type2] = Object.assign(error.contexts[type2] || {}, metadata.context);
                    }
                  }
                });
                _this.awaitingPromises.push(promise);
              } else {
                if (!validatedValue) {
                  var _a = _this.createValidationError(object, value, metadata, customConstraintMetadata), type = _a[0], message = _a[1];
                  error.constraints[type] = message;
                }
              }
              return;
            }
            var arrayValue = convertToArray(value);
            var validatedSubValues = arrayValue.map(function(subValue) {
              return customConstraintMetadata.instance.validate(subValue, validationArguments);
            });
            var validationIsAsync = validatedSubValues.some(function(validatedSubValue) {
              return isPromise2(validatedSubValue);
            });
            if (validationIsAsync) {
              var asyncValidatedSubValues = validatedSubValues.map(function(validatedSubValue) {
                return isPromise2(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue);
              });
              var asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues).then(function(flatValidatedValues) {
                var validationResult2 = flatValidatedValues.every(function(isValid) {
                  return isValid;
                });
                if (!validationResult2) {
                  var _a2 = _this.createValidationError(object, value, metadata, customConstraintMetadata), type2 = _a2[0], message2 = _a2[1];
                  error.constraints[type2] = message2;
                  if (metadata.context) {
                    if (!error.contexts) {
                      error.contexts = {};
                    }
                    error.contexts[type2] = Object.assign(error.contexts[type2] || {}, metadata.context);
                  }
                }
              });
              _this.awaitingPromises.push(asyncValidationIsFinishedPromise);
              return;
            }
            var validationResult = validatedSubValues.every(function(isValid) {
              return isValid;
            });
            if (!validationResult) {
              var _b = _this.createValidationError(object, value, metadata, customConstraintMetadata), type = _b[0], message = _b[1];
              error.constraints[type] = message;
            }
          });
        });
      };
      ValidationExecutor2.prototype.nestedValidations = function(value, metadatas, errors) {
        var _this = this;
        if (value === void 0) {
          return;
        }
        metadatas.forEach(function(metadata) {
          var _a;
          if (metadata.type !== ValidationTypes.NESTED_VALIDATION && metadata.type !== ValidationTypes.PROMISE_VALIDATION) {
            return;
          }
          if (value instanceof Array || value instanceof Set || value instanceof Map) {
            var arrayLikeValue = value instanceof Set ? Array.from(value) : value;
            arrayLikeValue.forEach(function(subValue, index) {
              _this.performValidations(value, subValue, index.toString(), [], metadatas, errors);
            });
          } else if (value instanceof Object) {
            var targetSchema = typeof metadata.target === "string" ? metadata.target : metadata.target.name;
            _this.execute(value, targetSchema, errors);
          } else {
            var error = new ValidationError();
            error.value = value;
            error.property = metadata.propertyName;
            error.target = metadata.target;
            var _b = _this.createValidationError(metadata.target, value, metadata), type = _b[0], message = _b[1];
            error.constraints = (_a = {}, _a[type] = message, _a);
            errors.push(error);
          }
        });
      };
      ValidationExecutor2.prototype.mapContexts = function(object, value, metadatas, error) {
        var _this = this;
        return metadatas.forEach(function(metadata) {
          if (metadata.context) {
            var customConstraint = void 0;
            if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {
              var customConstraints = _this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);
              customConstraint = customConstraints[0];
            }
            var type = _this.getConstraintType(metadata, customConstraint);
            if (error.constraints[type]) {
              if (!error.contexts) {
                error.contexts = {};
              }
              error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);
            }
          }
        });
      };
      ValidationExecutor2.prototype.createValidationError = function(object, value, metadata, customValidatorMetadata) {
        var targetName = object.constructor ? object.constructor.name : void 0;
        var type = this.getConstraintType(metadata, customValidatorMetadata);
        var validationArguments = {
          targetName,
          property: metadata.propertyName,
          object,
          value,
          constraints: metadata.constraints
        };
        var message = metadata.message || "";
        if (!metadata.message && (!this.validatorOptions || this.validatorOptions && !this.validatorOptions.dismissDefaultMessages)) {
          if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {
            message = customValidatorMetadata.instance.defaultMessage(validationArguments);
          }
        }
        var messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);
        return [type, messageString];
      };
      ValidationExecutor2.prototype.getConstraintType = function(metadata, customValidatorMetadata) {
        var type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;
        return type;
      };
      return ValidationExecutor2;
    }();
  }
});

// node_modules/class-validator/esm5/validation/Validator.js
var __awaiter, __generator, Validator;
var init_Validator = __esm({
  "node_modules/class-validator/esm5/validation/Validator.js"() {
    init_ValidationExecutor();
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Validator = /** @class */
    function() {
      function Validator2() {
      }
      Validator2.prototype.validate = function(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions) {
        return this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);
      };
      Validator2.prototype.validateOrReject = function(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions) {
        return __awaiter(this, void 0, void 0, function() {
          var errors;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions)];
              case 1:
                errors = _a.sent();
                if (errors.length)
                  return [2, Promise.reject(errors)];
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      Validator2.prototype.validateSync = function(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions) {
        var object = typeof objectOrSchemaName === "string" ? objectOrValidationOptions : objectOrSchemaName;
        var options = typeof objectOrSchemaName === "string" ? maybeValidatorOptions : objectOrValidationOptions;
        var schema = typeof objectOrSchemaName === "string" ? objectOrSchemaName : void 0;
        var executor = new ValidationExecutor(this, options);
        executor.ignoreAsyncValidations = true;
        var validationErrors = [];
        executor.execute(object, schema, validationErrors);
        return executor.stripEmptyErrors(validationErrors);
      };
      Validator2.prototype.coreValidate = function(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions) {
        var object = typeof objectOrSchemaName === "string" ? objectOrValidationOptions : objectOrSchemaName;
        var options = typeof objectOrSchemaName === "string" ? maybeValidatorOptions : objectOrValidationOptions;
        var schema = typeof objectOrSchemaName === "string" ? objectOrSchemaName : void 0;
        var executor = new ValidationExecutor(this, options);
        var validationErrors = [];
        executor.execute(object, schema, validationErrors);
        return Promise.all(executor.awaitingPromises).then(function() {
          return executor.stripEmptyErrors(validationErrors);
        });
      };
      return Validator2;
    }();
  }
});

// node_modules/class-validator/esm5/container.js
function useContainer(iocContainer, options) {
  userContainer = iocContainer;
  userContainerOptions = options;
}
function getFromContainer(someClass) {
  if (userContainer) {
    try {
      var instance2 = userContainer.get(someClass);
      if (instance2)
        return instance2;
      if (!userContainerOptions || !userContainerOptions.fallback)
        return instance2;
    } catch (error) {
      if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)
        throw error;
    }
  }
  return defaultContainer.get(someClass);
}
var defaultContainer, userContainer, userContainerOptions;
var init_container = __esm({
  "node_modules/class-validator/esm5/container.js"() {
    defaultContainer = new /** @class */
    (function() {
      function class_1() {
        this.instances = [];
      }
      class_1.prototype.get = function(someClass) {
        var instance2 = this.instances.find(function(instance3) {
          return instance3.type === someClass;
        });
        if (!instance2) {
          instance2 = { type: someClass, object: new someClass() };
          this.instances.push(instance2);
        }
        return instance2.object;
      };
      return class_1;
    }())();
  }
});

// node_modules/class-validator/esm5/decorator/common/Allow.js
function Allow(validationOptions) {
  return function(object, propertyName) {
    var args = {
      type: ValidationTypes.WHITELIST,
      target: object.constructor,
      propertyName,
      validationOptions
    };
    getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));
  };
}
var init_Allow = __esm({
  "node_modules/class-validator/esm5/decorator/common/Allow.js"() {
    init_ValidationTypes();
    init_ValidationMetadata();
    init_MetadataStorage2();
  }
});

// node_modules/class-validator/esm5/metadata/ConstraintMetadata.js
var ConstraintMetadata;
var init_ConstraintMetadata = __esm({
  "node_modules/class-validator/esm5/metadata/ConstraintMetadata.js"() {
    init_container();
    ConstraintMetadata = /** @class */
    function() {
      function ConstraintMetadata2(target, name, async) {
        if (async === void 0) {
          async = false;
        }
        this.target = target;
        this.name = name;
        this.async = async;
      }
      Object.defineProperty(ConstraintMetadata2.prototype, "instance", {
        // -------------------------------------------------------------------------
        // Accessors
        // -------------------------------------------------------------------------
        /**
         * Instance of the target custom validation class which performs validation.
         */
        get: function() {
          return getFromContainer(this.target);
        },
        enumerable: false,
        configurable: true
      });
      return ConstraintMetadata2;
    }();
  }
});

// node_modules/class-validator/esm5/register-decorator.js
function registerDecorator(options) {
  var constraintCls;
  if (options.validator instanceof Function) {
    constraintCls = options.validator;
    var constraintClasses = getFromContainer(MetadataStorage2).getTargetValidatorConstraints(options.validator);
    if (constraintClasses.length > 1) {
      throw "More than one implementation of ValidatorConstraintInterface found for validator on: " + options.target.name + ":" + options.propertyName;
    }
  } else {
    var validator_1 = options.validator;
    constraintCls = /** @class */
    function() {
      function CustomConstraint() {
      }
      CustomConstraint.prototype.validate = function(value, validationArguments) {
        return validator_1.validate(value, validationArguments);
      };
      CustomConstraint.prototype.defaultMessage = function(validationArguments) {
        if (validator_1.defaultMessage) {
          return validator_1.defaultMessage(validationArguments);
        }
        return "";
      };
      return CustomConstraint;
    }();
    getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));
  }
  var validationMetadataArgs = {
    type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,
    target: options.target,
    propertyName: options.propertyName,
    validationOptions: options.options,
    constraintCls,
    constraints: options.constraints
  };
  getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));
}
var init_register_decorator = __esm({
  "node_modules/class-validator/esm5/register-decorator.js"() {
    init_ConstraintMetadata();
    init_ValidationMetadata();
    init_ValidationTypes();
    init_container();
    init_MetadataStorage2();
  }
});

// node_modules/class-validator/esm5/decorator/common/ValidateBy.js
function buildMessage(impl, validationOptions) {
  return function(validationArguments) {
    var eachPrefix = validationOptions && validationOptions.each ? "each value in " : "";
    return impl(eachPrefix, validationArguments);
  };
}
function ValidateBy(options, validationOptions) {
  return function(object, propertyName) {
    registerDecorator({
      name: options.name,
      target: object.constructor,
      propertyName,
      options: validationOptions,
      constraints: options.constraints,
      validator: options.validator
    });
  };
}
var init_ValidateBy = __esm({
  "node_modules/class-validator/esm5/decorator/common/ValidateBy.js"() {
    init_register_decorator();
  }
});

// node_modules/class-validator/esm5/decorator/common/IsDefined.js
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function IsDefined(validationOptions) {
  return ValidateBy({
    name: IS_DEFINED,
    validator: {
      validate: function(value) {
        return isDefined(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property should not be null or undefined";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_DEFINED;
var init_IsDefined = __esm({
  "node_modules/class-validator/esm5/decorator/common/IsDefined.js"() {
    init_ValidateBy();
    init_ValidationTypes();
    IS_DEFINED = ValidationTypes.IS_DEFINED;
  }
});

// node_modules/class-validator/esm5/decorator/common/IsOptional.js
function IsOptional(validationOptions) {
  return function(object, propertyName) {
    var args = {
      type: ValidationTypes.CONDITIONAL_VALIDATION,
      target: object.constructor,
      propertyName,
      constraints: [
        function(object2, value) {
          return object2[propertyName] !== null && object2[propertyName] !== void 0;
        }
      ],
      validationOptions
    };
    getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));
  };
}
var init_IsOptional = __esm({
  "node_modules/class-validator/esm5/decorator/common/IsOptional.js"() {
    init_ValidationTypes();
    init_ValidationMetadata();
    init_MetadataStorage2();
  }
});

// node_modules/class-validator/esm5/decorator/common/Validate.js
function ValidatorConstraint(options) {
  return function(target) {
    var isAsync = options && options.async;
    var name = options && options.name ? options.name : "";
    if (!name) {
      name = target.name;
      if (!name)
        name = name.replace(/\.?([A-Z]+)/g, function(x, y) {
          return "_" + y.toLowerCase();
        }).replace(/^_/, "");
    }
    var metadata = new ConstraintMetadata(target, name, isAsync);
    getMetadataStorage().addConstraintMetadata(metadata);
  };
}
function Validate(constraintClass, constraintsOrValidationOptions, maybeValidationOptions) {
  return function(object, propertyName) {
    var args = {
      type: ValidationTypes.CUSTOM_VALIDATION,
      target: object.constructor,
      propertyName,
      constraintCls: constraintClass,
      constraints: constraintsOrValidationOptions instanceof Array ? constraintsOrValidationOptions : void 0,
      validationOptions: !(constraintsOrValidationOptions instanceof Array) ? constraintsOrValidationOptions : maybeValidationOptions
    };
    getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));
  };
}
var init_Validate = __esm({
  "node_modules/class-validator/esm5/decorator/common/Validate.js"() {
    init_ValidationMetadata();
    init_MetadataStorage2();
    init_ValidationTypes();
    init_ConstraintMetadata();
  }
});

// node_modules/class-validator/esm5/decorator/common/ValidateIf.js
function ValidateIf(condition, validationOptions) {
  return function(object, propertyName) {
    var args = {
      type: ValidationTypes.CONDITIONAL_VALIDATION,
      target: object.constructor,
      propertyName,
      constraints: [condition],
      validationOptions
    };
    getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));
  };
}
var init_ValidateIf = __esm({
  "node_modules/class-validator/esm5/decorator/common/ValidateIf.js"() {
    init_ValidationTypes();
    init_ValidationMetadata();
    init_MetadataStorage2();
  }
});

// node_modules/class-validator/esm5/decorator/common/ValidateNested.js
function ValidateNested(validationOptions) {
  var opts = __assign2({}, validationOptions);
  var eachPrefix = opts.each ? "each value in " : "";
  opts.message = opts.message || eachPrefix + "nested property $property must be either object or array";
  return function(object, propertyName) {
    var args = {
      type: ValidationTypes.NESTED_VALIDATION,
      target: object.constructor,
      propertyName,
      validationOptions: opts
    };
    getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));
  };
}
var __assign2;
var init_ValidateNested = __esm({
  "node_modules/class-validator/esm5/decorator/common/ValidateNested.js"() {
    init_ValidationTypes();
    init_ValidationMetadata();
    init_MetadataStorage2();
    __assign2 = function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
  }
});

// node_modules/class-validator/esm5/decorator/common/ValidatePromise.js
function ValidatePromise(validationOptions) {
  return function(object, propertyName) {
    var args = {
      type: ValidationTypes.PROMISE_VALIDATION,
      target: object.constructor,
      propertyName,
      validationOptions
    };
    getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));
  };
}
var init_ValidatePromise = __esm({
  "node_modules/class-validator/esm5/decorator/common/ValidatePromise.js"() {
    init_ValidationTypes();
    init_ValidationMetadata();
    init_MetadataStorage2();
  }
});

// node_modules/validator/lib/util/assertString.js
var require_assertString = __commonJS({
  "node_modules/validator/lib/util/assertString.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = assertString;
    function _typeof5(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof5 = function _typeof6(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof5 = function _typeof6(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof5(obj);
    }
    function assertString(input) {
      var isString2 = typeof input === "string" || input instanceof String;
      if (!isString2) {
        var invalidType = _typeof5(input);
        if (input === null)
          invalidType = "null";
        else if (invalidType === "object")
          invalidType = input.constructor.name;
        throw new TypeError("Expected a string but received a ".concat(invalidType));
      }
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/util/merge.js
var require_merge = __commonJS({
  "node_modules/validator/lib/util/merge.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = merge;
    function merge() {
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var defaults = arguments.length > 1 ? arguments[1] : void 0;
      for (var key in defaults) {
        if (typeof obj[key] === "undefined") {
          obj[key] = defaults[key];
        }
      }
      return obj;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isLatLong.js
var require_isLatLong = __commonJS({
  "node_modules/validator/lib/isLatLong.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isLatLong2;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var lat = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/;
    var long = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/;
    var latDMS = /^(([1-8]?\d)\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|90\D+0\D+0)\D+[NSns]?$/i;
    var longDMS = /^\s*([1-7]?\d{1,2}\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|180\D+0\D+0)\D+[EWew]?$/i;
    var defaultLatLongOptions = {
      checkDMS: false
    };
    function isLatLong2(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, defaultLatLongOptions);
      if (!str.includes(","))
        return false;
      var pair = str.split(",");
      if (pair[0].startsWith("(") && !pair[1].endsWith(")") || pair[1].endsWith(")") && !pair[0].startsWith("("))
        return false;
      if (options.checkDMS) {
        return latDMS.test(pair[0]) && longDMS.test(pair[1]);
      }
      return lat.test(pair[0]) && long.test(pair[1]);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/common/IsLatLong.js
function isLatLong(value) {
  return typeof value === "string" && (0, import_isLatLong.default)(value);
}
function IsLatLong(validationOptions) {
  return ValidateBy({
    name: IS_LATLONG,
    validator: {
      validate: function(value, args) {
        return isLatLong(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a latitude,longitude string";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isLatLong, IS_LATLONG;
var init_IsLatLong = __esm({
  "node_modules/class-validator/esm5/decorator/common/IsLatLong.js"() {
    init_ValidateBy();
    import_isLatLong = __toESM(require_isLatLong());
    IS_LATLONG = "isLatLong";
  }
});

// node_modules/class-validator/esm5/decorator/common/IsLatitude.js
function isLatitude(value) {
  return (typeof value === "number" || typeof value === "string") && isLatLong(value + ",0");
}
function IsLatitude(validationOptions) {
  return ValidateBy({
    name: IS_LATITUDE,
    validator: {
      validate: function(value, args) {
        return isLatitude(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a latitude string or number";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_LATITUDE;
var init_IsLatitude = __esm({
  "node_modules/class-validator/esm5/decorator/common/IsLatitude.js"() {
    init_ValidateBy();
    init_IsLatLong();
    IS_LATITUDE = "isLatitude";
  }
});

// node_modules/class-validator/esm5/decorator/common/IsLongitude.js
function isLongitude(value) {
  return (typeof value === "number" || typeof value === "string") && isLatLong("0," + value);
}
function IsLongitude(validationOptions) {
  return ValidateBy({
    name: IS_LONGITUDE,
    validator: {
      validate: function(value, args) {
        return isLongitude(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a longitude string or number";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_LONGITUDE;
var init_IsLongitude = __esm({
  "node_modules/class-validator/esm5/decorator/common/IsLongitude.js"() {
    init_ValidateBy();
    init_IsLatLong();
    IS_LONGITUDE = "isLongitude";
  }
});

// node_modules/class-validator/esm5/decorator/common/Equals.js
function equals(value, comparison) {
  return value === comparison;
}
function Equals(comparison, validationOptions) {
  return ValidateBy({
    name: EQUALS,
    constraints: [comparison],
    validator: {
      validate: function(value, args) {
        return equals(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be equal to $constraint1";
      }, validationOptions)
    }
  }, validationOptions);
}
var EQUALS;
var init_Equals = __esm({
  "node_modules/class-validator/esm5/decorator/common/Equals.js"() {
    init_ValidateBy();
    EQUALS = "equals";
  }
});

// node_modules/class-validator/esm5/decorator/common/NotEquals.js
function notEquals(value, comparison) {
  return value !== comparison;
}
function NotEquals(comparison, validationOptions) {
  return ValidateBy({
    name: NOT_EQUALS,
    constraints: [comparison],
    validator: {
      validate: function(value, args) {
        return notEquals(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property should not be equal to $constraint1";
      }, validationOptions)
    }
  }, validationOptions);
}
var NOT_EQUALS;
var init_NotEquals = __esm({
  "node_modules/class-validator/esm5/decorator/common/NotEquals.js"() {
    init_ValidateBy();
    NOT_EQUALS = "notEquals";
  }
});

// node_modules/class-validator/esm5/decorator/common/IsEmpty.js
function isEmpty(value) {
  return value === "" || value === null || value === void 0;
}
function IsEmpty(validationOptions) {
  return ValidateBy({
    name: IS_EMPTY,
    validator: {
      validate: function(value, args) {
        return isEmpty(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be empty";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_EMPTY;
var init_IsEmpty = __esm({
  "node_modules/class-validator/esm5/decorator/common/IsEmpty.js"() {
    init_ValidateBy();
    IS_EMPTY = "isEmpty";
  }
});

// node_modules/class-validator/esm5/decorator/common/IsNotEmpty.js
function isNotEmpty(value) {
  return value !== "" && value !== null && value !== void 0;
}
function IsNotEmpty(validationOptions) {
  return ValidateBy({
    name: IS_NOT_EMPTY,
    validator: {
      validate: function(value, args) {
        return isNotEmpty(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property should not be empty";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_NOT_EMPTY;
var init_IsNotEmpty = __esm({
  "node_modules/class-validator/esm5/decorator/common/IsNotEmpty.js"() {
    init_ValidateBy();
    IS_NOT_EMPTY = "isNotEmpty";
  }
});

// node_modules/class-validator/esm5/decorator/common/IsIn.js
function isIn(value, possibleValues) {
  return !(possibleValues instanceof Array) || possibleValues.some(function(possibleValue) {
    return possibleValue === value;
  });
}
function IsIn(values, validationOptions) {
  return ValidateBy({
    name: IS_IN,
    constraints: [values],
    validator: {
      validate: function(value, args) {
        return isIn(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be one of the following values: $constraint1";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_IN;
var init_IsIn = __esm({
  "node_modules/class-validator/esm5/decorator/common/IsIn.js"() {
    init_ValidateBy();
    IS_IN = "isIn";
  }
});

// node_modules/class-validator/esm5/decorator/common/IsNotIn.js
function isNotIn(value, possibleValues) {
  return !(possibleValues instanceof Array) || !possibleValues.some(function(possibleValue) {
    return possibleValue === value;
  });
}
function IsNotIn(values, validationOptions) {
  return ValidateBy({
    name: IS_NOT_IN,
    constraints: [values],
    validator: {
      validate: function(value, args) {
        return isNotIn(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property should not be one of the following values: $constraint1";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_NOT_IN;
var init_IsNotIn = __esm({
  "node_modules/class-validator/esm5/decorator/common/IsNotIn.js"() {
    init_ValidateBy();
    IS_NOT_IN = "isNotIn";
  }
});

// node_modules/validator/lib/alpha.js
var require_alpha = __commonJS({
  "node_modules/validator/lib/alpha.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.commaDecimal = exports.dotDecimal = exports.bengaliLocales = exports.farsiLocales = exports.arabicLocales = exports.englishLocales = exports.decimal = exports.alphanumeric = exports.alpha = void 0;
    var alpha = {
      "en-US": /^[A-Z]+$/i,
      "az-AZ": /^[A-VXYZÇƏĞİıÖŞÜ]+$/i,
      "bg-BG": /^[А-Я]+$/i,
      "cs-CZ": /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
      "da-DK": /^[A-ZÆØÅ]+$/i,
      "de-DE": /^[A-ZÄÖÜß]+$/i,
      "el-GR": /^[Α-ώ]+$/i,
      "es-ES": /^[A-ZÁÉÍÑÓÚÜ]+$/i,
      "fa-IR": /^[ابپتثجچحخدذرزژسشصضطظعغفقکگلمنوهی]+$/i,
      "fi-FI": /^[A-ZÅÄÖ]+$/i,
      "fr-FR": /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
      "it-IT": /^[A-ZÀÉÈÌÎÓÒÙ]+$/i,
      "ja-JP": /^[ぁ-んァ-ヶｦ-ﾟ一-龠ー・。、]+$/i,
      "nb-NO": /^[A-ZÆØÅ]+$/i,
      "nl-NL": /^[A-ZÁÉËÏÓÖÜÚ]+$/i,
      "nn-NO": /^[A-ZÆØÅ]+$/i,
      "hu-HU": /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
      "pl-PL": /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
      "pt-PT": /^[A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
      "ru-RU": /^[А-ЯЁ]+$/i,
      "sl-SI": /^[A-ZČĆĐŠŽ]+$/i,
      "sk-SK": /^[A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
      "sr-RS@latin": /^[A-ZČĆŽŠĐ]+$/i,
      "sr-RS": /^[А-ЯЂЈЉЊЋЏ]+$/i,
      "sv-SE": /^[A-ZÅÄÖ]+$/i,
      "th-TH": /^[ก-๐\s]+$/i,
      "tr-TR": /^[A-ZÇĞİıÖŞÜ]+$/i,
      "uk-UA": /^[А-ЩЬЮЯЄIЇҐі]+$/i,
      "vi-VN": /^[A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i,
      "ko-KR": /^[ㄱ-ㅎㅏ-ㅣ가-힣]*$/,
      "ku-IQ": /^[ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
      ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
      he: /^[א-ת]+$/,
      fa: /^['آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی']+$/i,
      bn: /^['ঀঁংঃঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহ়ঽািীুূৃৄেৈোৌ্ৎৗড়ঢ়য়ৠৡৢৣৰৱ৲৳৴৵৶৷৸৹৺৻']+$/,
      "hi-IN": /^[\u0900-\u0961]+[\u0972-\u097F]*$/i,
      "si-LK": /^[\u0D80-\u0DFF]+$/
    };
    exports.alpha = alpha;
    var alphanumeric = {
      "en-US": /^[0-9A-Z]+$/i,
      "az-AZ": /^[0-9A-VXYZÇƏĞİıÖŞÜ]+$/i,
      "bg-BG": /^[0-9А-Я]+$/i,
      "cs-CZ": /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
      "da-DK": /^[0-9A-ZÆØÅ]+$/i,
      "de-DE": /^[0-9A-ZÄÖÜß]+$/i,
      "el-GR": /^[0-9Α-ω]+$/i,
      "es-ES": /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,
      "fi-FI": /^[0-9A-ZÅÄÖ]+$/i,
      "fr-FR": /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
      "it-IT": /^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i,
      "ja-JP": /^[0-9０-９ぁ-んァ-ヶｦ-ﾟ一-龠ー・。、]+$/i,
      "hu-HU": /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
      "nb-NO": /^[0-9A-ZÆØÅ]+$/i,
      "nl-NL": /^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i,
      "nn-NO": /^[0-9A-ZÆØÅ]+$/i,
      "pl-PL": /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
      "pt-PT": /^[0-9A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
      "ru-RU": /^[0-9А-ЯЁ]+$/i,
      "sl-SI": /^[0-9A-ZČĆĐŠŽ]+$/i,
      "sk-SK": /^[0-9A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
      "sr-RS@latin": /^[0-9A-ZČĆŽŠĐ]+$/i,
      "sr-RS": /^[0-9А-ЯЂЈЉЊЋЏ]+$/i,
      "sv-SE": /^[0-9A-ZÅÄÖ]+$/i,
      "th-TH": /^[ก-๙\s]+$/i,
      "tr-TR": /^[0-9A-ZÇĞİıÖŞÜ]+$/i,
      "uk-UA": /^[0-9А-ЩЬЮЯЄIЇҐі]+$/i,
      "ko-KR": /^[0-9ㄱ-ㅎㅏ-ㅣ가-힣]*$/,
      "ku-IQ": /^[٠١٢٣٤٥٦٧٨٩0-9ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
      "vi-VN": /^[0-9A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i,
      ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
      he: /^[0-9א-ת]+$/,
      fa: /^['0-9آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی۱۲۳۴۵۶۷۸۹۰']+$/i,
      bn: /^['ঀঁংঃঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহ়ঽািীুূৃৄেৈোৌ্ৎৗড়ঢ়য়ৠৡৢৣ০১২৩৪৫৬৭৮৯ৰৱ৲৳৴৵৶৷৸৹৺৻']+$/,
      "hi-IN": /^[\u0900-\u0963]+[\u0966-\u097F]*$/i,
      "si-LK": /^[0-9\u0D80-\u0DFF]+$/
    };
    exports.alphanumeric = alphanumeric;
    var decimal = {
      "en-US": ".",
      ar: "٫"
    };
    exports.decimal = decimal;
    var englishLocales = ["AU", "GB", "HK", "IN", "NZ", "ZA", "ZM"];
    exports.englishLocales = englishLocales;
    for (i = 0; i < englishLocales.length; i++) {
      locale = "en-".concat(englishLocales[i]);
      alpha[locale] = alpha["en-US"];
      alphanumeric[locale] = alphanumeric["en-US"];
      decimal[locale] = decimal["en-US"];
    }
    var locale;
    var i;
    var arabicLocales = ["AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE"];
    exports.arabicLocales = arabicLocales;
    for (_i = 0; _i < arabicLocales.length; _i++) {
      _locale = "ar-".concat(arabicLocales[_i]);
      alpha[_locale] = alpha.ar;
      alphanumeric[_locale] = alphanumeric.ar;
      decimal[_locale] = decimal.ar;
    }
    var _locale;
    var _i;
    var farsiLocales = ["IR", "AF"];
    exports.farsiLocales = farsiLocales;
    for (_i2 = 0; _i2 < farsiLocales.length; _i2++) {
      _locale2 = "fa-".concat(farsiLocales[_i2]);
      alphanumeric[_locale2] = alphanumeric.fa;
      decimal[_locale2] = decimal.ar;
    }
    var _locale2;
    var _i2;
    var bengaliLocales = ["BD", "IN"];
    exports.bengaliLocales = bengaliLocales;
    for (_i3 = 0; _i3 < bengaliLocales.length; _i3++) {
      _locale3 = "bn-".concat(bengaliLocales[_i3]);
      alpha[_locale3] = alpha.bn;
      alphanumeric[_locale3] = alphanumeric.bn;
      decimal[_locale3] = decimal["en-US"];
    }
    var _locale3;
    var _i3;
    var dotDecimal = ["ar-EG", "ar-LB", "ar-LY"];
    exports.dotDecimal = dotDecimal;
    var commaDecimal = ["bg-BG", "cs-CZ", "da-DK", "de-DE", "el-GR", "en-ZM", "es-ES", "fr-CA", "fr-FR", "id-ID", "it-IT", "ku-IQ", "hi-IN", "hu-HU", "nb-NO", "nn-NO", "nl-NL", "pl-PL", "pt-PT", "ru-RU", "si-LK", "sl-SI", "sr-RS@latin", "sr-RS", "sv-SE", "tr-TR", "uk-UA", "vi-VN"];
    exports.commaDecimal = commaDecimal;
    for (_i4 = 0; _i4 < dotDecimal.length; _i4++) {
      decimal[dotDecimal[_i4]] = decimal["en-US"];
    }
    var _i4;
    for (_i5 = 0; _i5 < commaDecimal.length; _i5++) {
      decimal[commaDecimal[_i5]] = ",";
    }
    var _i5;
    alpha["fr-CA"] = alpha["fr-FR"];
    alphanumeric["fr-CA"] = alphanumeric["fr-FR"];
    alpha["pt-BR"] = alpha["pt-PT"];
    alphanumeric["pt-BR"] = alphanumeric["pt-PT"];
    decimal["pt-BR"] = decimal["pt-PT"];
    alpha["pl-Pl"] = alpha["pl-PL"];
    alphanumeric["pl-Pl"] = alphanumeric["pl-PL"];
    decimal["pl-Pl"] = decimal["pl-PL"];
    alpha["fa-AF"] = alpha.fa;
  }
});

// node_modules/validator/lib/isFloat.js
var require_isFloat = __commonJS({
  "node_modules/validator/lib/isFloat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isFloat;
    exports.locales = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    var _alpha = require_alpha();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isFloat(str, options) {
      (0, _assertString.default)(str);
      options = options || {};
      var float = new RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\".concat(options.locale ? _alpha.decimal[options.locale] : ".", "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$"));
      if (str === "" || str === "." || str === "," || str === "-" || str === "+") {
        return false;
      }
      var value = parseFloat(str.replace(",", "."));
      return float.test(str) && (!options.hasOwnProperty("min") || value >= options.min) && (!options.hasOwnProperty("max") || value <= options.max) && (!options.hasOwnProperty("lt") || value < options.lt) && (!options.hasOwnProperty("gt") || value > options.gt);
    }
    var locales = Object.keys(_alpha.decimal);
    exports.locales = locales;
  }
});

// node_modules/validator/lib/toFloat.js
var require_toFloat = __commonJS({
  "node_modules/validator/lib/toFloat.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toFloat;
    var _isFloat = _interopRequireDefault(require_isFloat());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function toFloat(str) {
      if (!(0, _isFloat.default)(str))
        return NaN;
      return parseFloat(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isDivisibleBy.js
var require_isDivisibleBy = __commonJS({
  "node_modules/validator/lib/isDivisibleBy.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isDivisibleBy2;
    var _assertString = _interopRequireDefault(require_assertString());
    var _toFloat = _interopRequireDefault(require_toFloat());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isDivisibleBy2(str, num) {
      (0, _assertString.default)(str);
      return (0, _toFloat.default)(str) % parseInt(num, 10) === 0;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/number/IsDivisibleBy.js
function isDivisibleBy(value, num) {
  return typeof value === "number" && typeof num === "number" && (0, import_isDivisibleBy.default)(String(value), num);
}
function IsDivisibleBy(num, validationOptions) {
  return ValidateBy({
    name: IS_DIVISIBLE_BY,
    constraints: [num],
    validator: {
      validate: function(value, args) {
        return isDivisibleBy(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be divisible by $constraint1";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isDivisibleBy, IS_DIVISIBLE_BY;
var init_IsDivisibleBy = __esm({
  "node_modules/class-validator/esm5/decorator/number/IsDivisibleBy.js"() {
    init_ValidateBy();
    import_isDivisibleBy = __toESM(require_isDivisibleBy());
    IS_DIVISIBLE_BY = "isDivisibleBy";
  }
});

// node_modules/class-validator/esm5/decorator/number/IsPositive.js
function isPositive(value) {
  return typeof value === "number" && value > 0;
}
function IsPositive(validationOptions) {
  return ValidateBy({
    name: IS_POSITIVE,
    validator: {
      validate: function(value, args) {
        return isPositive(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a positive number";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_POSITIVE;
var init_IsPositive = __esm({
  "node_modules/class-validator/esm5/decorator/number/IsPositive.js"() {
    init_ValidateBy();
    IS_POSITIVE = "isPositive";
  }
});

// node_modules/class-validator/esm5/decorator/number/IsNegative.js
function isNegative(value) {
  return typeof value === "number" && value < 0;
}
function IsNegative(validationOptions) {
  return ValidateBy({
    name: IS_NEGATIVE,
    validator: {
      validate: function(value, args) {
        return isNegative(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a negative number";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_NEGATIVE;
var init_IsNegative = __esm({
  "node_modules/class-validator/esm5/decorator/number/IsNegative.js"() {
    init_ValidateBy();
    IS_NEGATIVE = "isNegative";
  }
});

// node_modules/class-validator/esm5/decorator/number/Max.js
function max(num, max2) {
  return typeof num === "number" && typeof max2 === "number" && num <= max2;
}
function Max(maxValue, validationOptions) {
  return ValidateBy({
    name: MAX,
    constraints: [maxValue],
    validator: {
      validate: function(value, args) {
        return max(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must not be greater than $constraint1";
      }, validationOptions)
    }
  }, validationOptions);
}
var MAX;
var init_Max = __esm({
  "node_modules/class-validator/esm5/decorator/number/Max.js"() {
    init_ValidateBy();
    MAX = "max";
  }
});

// node_modules/class-validator/esm5/decorator/number/Min.js
function min(num, min2) {
  return typeof num === "number" && typeof min2 === "number" && num >= min2;
}
function Min(minValue, validationOptions) {
  return ValidateBy({
    name: MIN,
    constraints: [minValue],
    validator: {
      validate: function(value, args) {
        return min(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must not be less than $constraint1";
      }, validationOptions)
    }
  }, validationOptions);
}
var MIN;
var init_Min = __esm({
  "node_modules/class-validator/esm5/decorator/number/Min.js"() {
    init_ValidateBy();
    MIN = "min";
  }
});

// node_modules/class-validator/esm5/decorator/date/MinDate.js
function minDate(date, minDate2) {
  return date instanceof Date && date.getTime() >= minDate2.getTime();
}
function MinDate(date, validationOptions) {
  return ValidateBy({
    name: MIN_DATE,
    constraints: [date],
    validator: {
      validate: function(value, args) {
        return minDate(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return "minimal allowed date for " + eachPrefix + "$property is $constraint1";
      }, validationOptions)
    }
  }, validationOptions);
}
var MIN_DATE;
var init_MinDate = __esm({
  "node_modules/class-validator/esm5/decorator/date/MinDate.js"() {
    init_ValidateBy();
    MIN_DATE = "minDate";
  }
});

// node_modules/class-validator/esm5/decorator/date/MaxDate.js
function maxDate(date, maxDate2) {
  return date instanceof Date && date.getTime() <= maxDate2.getTime();
}
function MaxDate(date, validationOptions) {
  return ValidateBy({
    name: MAX_DATE,
    constraints: [date],
    validator: {
      validate: function(value, args) {
        return maxDate(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return "maximal allowed date for " + eachPrefix + "$property is $constraint1";
      }, validationOptions)
    }
  }, validationOptions);
}
var MAX_DATE;
var init_MaxDate = __esm({
  "node_modules/class-validator/esm5/decorator/date/MaxDate.js"() {
    init_ValidateBy();
    MAX_DATE = "maxDate";
  }
});

// node_modules/validator/lib/util/toString.js
var require_toString = __commonJS({
  "node_modules/validator/lib/util/toString.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toString;
    function _typeof5(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof5 = function _typeof6(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof5 = function _typeof6(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof5(obj);
    }
    function toString(input) {
      if (_typeof5(input) === "object" && input !== null) {
        if (typeof input.toString === "function") {
          input = input.toString();
        } else {
          input = "[object Object]";
        }
      } else if (input === null || typeof input === "undefined" || isNaN(input) && !input.length) {
        input = "";
      }
      return String(input);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/contains.js
var require_contains = __commonJS({
  "node_modules/validator/lib/contains.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = contains2;
    var _assertString = _interopRequireDefault(require_assertString());
    var _toString = _interopRequireDefault(require_toString());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var defaulContainsOptions = {
      ignoreCase: false,
      minOccurrences: 1
    };
    function contains2(str, elem, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, defaulContainsOptions);
      if (options.ignoreCase) {
        return str.toLowerCase().split((0, _toString.default)(elem).toLowerCase()).length > options.minOccurrences;
      }
      return str.split((0, _toString.default)(elem)).length > options.minOccurrences;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/Contains.js
function contains(value, seed) {
  return typeof value === "string" && (0, import_contains.default)(value, seed);
}
function Contains(seed, validationOptions) {
  return ValidateBy({
    name: CONTAINS,
    constraints: [seed],
    validator: {
      validate: function(value, args) {
        return contains(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must contain a $constraint1 string";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_contains, CONTAINS;
var init_Contains = __esm({
  "node_modules/class-validator/esm5/decorator/string/Contains.js"() {
    init_ValidateBy();
    import_contains = __toESM(require_contains());
    CONTAINS = "contains";
  }
});

// node_modules/class-validator/esm5/decorator/string/NotContains.js
function notContains(value, seed) {
  return typeof value === "string" && !(0, import_contains2.default)(value, seed);
}
function NotContains(seed, validationOptions) {
  return ValidateBy({
    name: NOT_CONTAINS,
    constraints: [seed],
    validator: {
      validate: function(value, args) {
        return notContains(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property should not contain a $constraint1 string";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_contains2, NOT_CONTAINS;
var init_NotContains = __esm({
  "node_modules/class-validator/esm5/decorator/string/NotContains.js"() {
    init_ValidateBy();
    import_contains2 = __toESM(require_contains());
    NOT_CONTAINS = "notContains";
  }
});

// node_modules/validator/lib/isAlpha.js
var require_isAlpha = __commonJS({
  "node_modules/validator/lib/isAlpha.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isAlpha2;
    exports.locales = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    var _alpha = require_alpha();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isAlpha2(_str) {
      var locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US";
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      (0, _assertString.default)(_str);
      var str = _str;
      var ignore = options.ignore;
      if (ignore) {
        if (ignore instanceof RegExp) {
          str = str.replace(ignore, "");
        } else if (typeof ignore === "string") {
          str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
        } else {
          throw new Error("ignore should be instance of a String or RegExp");
        }
      }
      if (locale in _alpha.alpha) {
        return _alpha.alpha[locale].test(str);
      }
      throw new Error("Invalid locale '".concat(locale, "'"));
    }
    var locales = Object.keys(_alpha.alpha);
    exports.locales = locales;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsAlpha.js
function isAlpha(value, locale) {
  return typeof value === "string" && (0, import_isAlpha.default)(value, locale);
}
function IsAlpha(locale, validationOptions) {
  return ValidateBy({
    name: IS_ALPHA,
    constraints: [locale],
    validator: {
      validate: function(value, args) {
        return isAlpha(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must contain only letters (a-zA-Z)";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isAlpha, IS_ALPHA;
var init_IsAlpha = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsAlpha.js"() {
    init_ValidateBy();
    import_isAlpha = __toESM(require_isAlpha());
    IS_ALPHA = "isAlpha";
  }
});

// node_modules/validator/lib/isAlphanumeric.js
var require_isAlphanumeric = __commonJS({
  "node_modules/validator/lib/isAlphanumeric.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isAlphanumeric2;
    exports.locales = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    var _alpha = require_alpha();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isAlphanumeric2(_str) {
      var locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US";
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      (0, _assertString.default)(_str);
      var str = _str;
      var ignore = options.ignore;
      if (ignore) {
        if (ignore instanceof RegExp) {
          str = str.replace(ignore, "");
        } else if (typeof ignore === "string") {
          str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
        } else {
          throw new Error("ignore should be instance of a String or RegExp");
        }
      }
      if (locale in _alpha.alphanumeric) {
        return _alpha.alphanumeric[locale].test(str);
      }
      throw new Error("Invalid locale '".concat(locale, "'"));
    }
    var locales = Object.keys(_alpha.alphanumeric);
    exports.locales = locales;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsAlphanumeric.js
function isAlphanumeric(value, locale) {
  return typeof value === "string" && (0, import_isAlphanumeric.default)(value, locale);
}
function IsAlphanumeric(locale, validationOptions) {
  return ValidateBy({
    name: IS_ALPHANUMERIC,
    constraints: [locale],
    validator: {
      validate: function(value, args) {
        return isAlphanumeric(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must contain only letters and numbers";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isAlphanumeric, IS_ALPHANUMERIC;
var init_IsAlphanumeric = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsAlphanumeric.js"() {
    init_ValidateBy();
    import_isAlphanumeric = __toESM(require_isAlphanumeric());
    IS_ALPHANUMERIC = "isAlphanumeric";
  }
});

// node_modules/validator/lib/util/includes.js
var require_includes = __commonJS({
  "node_modules/validator/lib/util/includes.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var includes = function includes2(arr, val) {
      return arr.some(function(arrVal) {
        return val === arrVal;
      });
    };
    var _default = includes;
    exports.default = _default;
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isDecimal.js
var require_isDecimal = __commonJS({
  "node_modules/validator/lib/isDecimal.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isDecimal2;
    var _merge = _interopRequireDefault(require_merge());
    var _assertString = _interopRequireDefault(require_assertString());
    var _includes = _interopRequireDefault(require_includes());
    var _alpha = require_alpha();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function decimalRegExp(options) {
      var regExp = new RegExp("^[-+]?([0-9]+)?(\\".concat(_alpha.decimal[options.locale], "[0-9]{").concat(options.decimal_digits, "})").concat(options.force_decimal ? "" : "?", "$"));
      return regExp;
    }
    var default_decimal_options = {
      force_decimal: false,
      decimal_digits: "1,",
      locale: "en-US"
    };
    var blacklist = ["", "-", "+"];
    function isDecimal2(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, default_decimal_options);
      if (options.locale in _alpha.decimal) {
        return !(0, _includes.default)(blacklist, str.replace(/ /g, "")) && decimalRegExp(options).test(str);
      }
      throw new Error("Invalid locale '".concat(options.locale, "'"));
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsDecimal.js
function isDecimal(value, options) {
  return typeof value === "string" && (0, import_isDecimal.default)(value, options);
}
function IsDecimal(options, validationOptions) {
  return ValidateBy({
    name: IS_DECIMAL,
    constraints: [options],
    validator: {
      validate: function(value, args) {
        return isDecimal(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property is not a valid decimal number.";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isDecimal, IS_DECIMAL;
var init_IsDecimal = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsDecimal.js"() {
    init_ValidateBy();
    import_isDecimal = __toESM(require_isDecimal());
    IS_DECIMAL = "isDecimal";
  }
});

// node_modules/validator/lib/isAscii.js
var require_isAscii = __commonJS({
  "node_modules/validator/lib/isAscii.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isAscii2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ascii = /^[\x00-\x7F]+$/;
    function isAscii2(str) {
      (0, _assertString.default)(str);
      return ascii.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsAscii.js
function isAscii(value) {
  return typeof value === "string" && (0, import_isAscii.default)(value);
}
function IsAscii(validationOptions) {
  return ValidateBy({
    name: IS_ASCII,
    validator: {
      validate: function(value, args) {
        return isAscii(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must contain only ASCII characters";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isAscii, IS_ASCII;
var init_IsAscii = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsAscii.js"() {
    init_ValidateBy();
    import_isAscii = __toESM(require_isAscii());
    IS_ASCII = "isAscii";
  }
});

// node_modules/validator/lib/isBase64.js
var require_isBase64 = __commonJS({
  "node_modules/validator/lib/isBase64.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBase642;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var notBase64 = /[^A-Z0-9+\/=]/i;
    var urlSafeBase64 = /^[A-Z0-9_\-]*$/i;
    var defaultBase64Options = {
      urlSafe: false
    };
    function isBase642(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, defaultBase64Options);
      var len = str.length;
      if (options.urlSafe) {
        return urlSafeBase64.test(str);
      }
      if (len % 4 !== 0 || notBase64.test(str)) {
        return false;
      }
      var firstPaddingChar = str.indexOf("=");
      return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === "=";
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsBase64.js
function isBase64(value) {
  return typeof value === "string" && (0, import_isBase64.default)(value);
}
function IsBase64(validationOptions) {
  return ValidateBy({
    name: IS_BASE64,
    validator: {
      validate: function(value, args) {
        return isBase64(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be base64 encoded";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isBase64, IS_BASE64;
var init_IsBase64 = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsBase64.js"() {
    init_ValidateBy();
    import_isBase64 = __toESM(require_isBase64());
    IS_BASE64 = "isBase64";
  }
});

// node_modules/validator/lib/isByteLength.js
var require_isByteLength = __commonJS({
  "node_modules/validator/lib/isByteLength.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isByteLength2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof5(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof5 = function _typeof6(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof5 = function _typeof6(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof5(obj);
    }
    function isByteLength2(str, options) {
      (0, _assertString.default)(str);
      var min2;
      var max2;
      if (_typeof5(options) === "object") {
        min2 = options.min || 0;
        max2 = options.max;
      } else {
        min2 = arguments[1];
        max2 = arguments[2];
      }
      var len = encodeURI(str).split(/%..|./).length - 1;
      return len >= min2 && (typeof max2 === "undefined" || len <= max2);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsByteLength.js
function isByteLength(value, min2, max2) {
  return typeof value === "string" && (0, import_isByteLength.default)(value, { min: min2, max: max2 });
}
function IsByteLength(min2, max2, validationOptions) {
  return ValidateBy({
    name: IS_BYTE_LENGTH,
    constraints: [min2, max2],
    validator: {
      validate: function(value, args) {
        return isByteLength(value, args.constraints[0], args.constraints[1]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property's byte length must fall into ($constraint1, $constraint2) range";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isByteLength, IS_BYTE_LENGTH;
var init_IsByteLength = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsByteLength.js"() {
    init_ValidateBy();
    import_isByteLength = __toESM(require_isByteLength());
    IS_BYTE_LENGTH = "isByteLength";
  }
});

// node_modules/validator/lib/isLuhnNumber.js
var require_isLuhnNumber = __commonJS({
  "node_modules/validator/lib/isLuhnNumber.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isLuhnNumber;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isLuhnNumber(str) {
      (0, _assertString.default)(str);
      var sanitized = str.replace(/[- ]+/g, "");
      var sum = 0;
      var digit;
      var tmpNum;
      var shouldDouble;
      for (var i = sanitized.length - 1; i >= 0; i--) {
        digit = sanitized.substring(i, i + 1);
        tmpNum = parseInt(digit, 10);
        if (shouldDouble) {
          tmpNum *= 2;
          if (tmpNum >= 10) {
            sum += tmpNum % 10 + 1;
          } else {
            sum += tmpNum;
          }
        } else {
          sum += tmpNum;
        }
        shouldDouble = !shouldDouble;
      }
      return !!(sum % 10 === 0 ? sanitized : false);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isCreditCard.js
var require_isCreditCard = __commonJS({
  "node_modules/validator/lib/isCreditCard.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isCreditCard2;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isLuhnNumber = _interopRequireDefault(require_isLuhnNumber());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var cards = {
      amex: /^3[47][0-9]{13}$/,
      dinersclub: /^3(?:0[0-5]|[68][0-9])[0-9]{11}$/,
      discover: /^6(?:011|5[0-9][0-9])[0-9]{12,15}$/,
      jcb: /^(?:2131|1800|35\d{3})\d{11}$/,
      mastercard: /^5[1-5][0-9]{2}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$/,
      // /^[25][1-7][0-9]{14}$/;
      unionpay: /^(6[27][0-9]{14}|^(81[0-9]{14,17}))$/,
      visa: /^(?:4[0-9]{12})(?:[0-9]{3,6})?$/
    };
    var allCards = /^(?:4[0-9]{12}(?:[0-9]{3,6})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12,15}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14}|^(81[0-9]{14,17}))$/;
    function isCreditCard2(card) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      (0, _assertString.default)(card);
      var provider = options.provider;
      var sanitized = card.replace(/[- ]+/g, "");
      if (provider && provider.toLowerCase() in cards) {
        if (!cards[provider.toLowerCase()].test(sanitized)) {
          return false;
        }
      } else if (provider && !(provider.toLowerCase() in cards)) {
        throw new Error("".concat(provider, " is not a valid credit card provider."));
      } else if (!allCards.test(sanitized)) {
        return false;
      }
      return (0, _isLuhnNumber.default)(card);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsCreditCard.js
function isCreditCard(value) {
  return typeof value === "string" && (0, import_isCreditCard.default)(value);
}
function IsCreditCard(validationOptions) {
  return ValidateBy({
    name: IS_CREDIT_CARD,
    validator: {
      validate: function(value, args) {
        return isCreditCard(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a credit card";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isCreditCard, IS_CREDIT_CARD;
var init_IsCreditCard = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsCreditCard.js"() {
    init_ValidateBy();
    import_isCreditCard = __toESM(require_isCreditCard());
    IS_CREDIT_CARD = "isCreditCard";
  }
});

// node_modules/validator/lib/isCurrency.js
var require_isCurrency = __commonJS({
  "node_modules/validator/lib/isCurrency.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isCurrency2;
    var _merge = _interopRequireDefault(require_merge());
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function currencyRegex(options) {
      var decimal_digits = "\\d{".concat(options.digits_after_decimal[0], "}");
      options.digits_after_decimal.forEach(function(digit, index) {
        if (index !== 0)
          decimal_digits = "".concat(decimal_digits, "|\\d{").concat(digit, "}");
      });
      var symbol = "(".concat(options.symbol.replace(/\W/, function(m) {
        return "\\".concat(m);
      }), ")").concat(options.require_symbol ? "" : "?"), negative = "-?", whole_dollar_amount_without_sep = "[1-9]\\d*", whole_dollar_amount_with_sep = "[1-9]\\d{0,2}(\\".concat(options.thousands_separator, "\\d{3})*"), valid_whole_dollar_amounts = ["0", whole_dollar_amount_without_sep, whole_dollar_amount_with_sep], whole_dollar_amount = "(".concat(valid_whole_dollar_amounts.join("|"), ")?"), decimal_amount = "(\\".concat(options.decimal_separator, "(").concat(decimal_digits, "))").concat(options.require_decimal ? "" : "?");
      var pattern = whole_dollar_amount + (options.allow_decimal || options.require_decimal ? decimal_amount : "");
      if (options.allow_negatives && !options.parens_for_negatives) {
        if (options.negative_sign_after_digits) {
          pattern += negative;
        } else if (options.negative_sign_before_digits) {
          pattern = negative + pattern;
        }
      }
      if (options.allow_negative_sign_placeholder) {
        pattern = "( (?!\\-))?".concat(pattern);
      } else if (options.allow_space_after_symbol) {
        pattern = " ?".concat(pattern);
      } else if (options.allow_space_after_digits) {
        pattern += "( (?!$))?";
      }
      if (options.symbol_after_digits) {
        pattern += symbol;
      } else {
        pattern = symbol + pattern;
      }
      if (options.allow_negatives) {
        if (options.parens_for_negatives) {
          pattern = "(\\(".concat(pattern, "\\)|").concat(pattern, ")");
        } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
          pattern = negative + pattern;
        }
      }
      return new RegExp("^(?!-? )(?=.*\\d)".concat(pattern, "$"));
    }
    var default_currency_options = {
      symbol: "$",
      require_symbol: false,
      allow_space_after_symbol: false,
      symbol_after_digits: false,
      allow_negatives: true,
      parens_for_negatives: false,
      negative_sign_before_digits: false,
      negative_sign_after_digits: false,
      allow_negative_sign_placeholder: false,
      thousands_separator: ",",
      decimal_separator: ".",
      allow_decimal: true,
      require_decimal: false,
      digits_after_decimal: [2],
      allow_space_after_digits: false
    };
    function isCurrency2(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, default_currency_options);
      return currencyRegex(options).test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsCurrency.js
function isCurrency(value, options) {
  return typeof value === "string" && (0, import_isCurrency.default)(value, options);
}
function IsCurrency(options, validationOptions) {
  return ValidateBy({
    name: IS_CURRENCY,
    constraints: [options],
    validator: {
      validate: function(value, args) {
        return isCurrency(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a currency";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isCurrency, IS_CURRENCY;
var init_IsCurrency = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsCurrency.js"() {
    init_ValidateBy();
    import_isCurrency = __toESM(require_isCurrency());
    IS_CURRENCY = "isCurrency";
  }
});

// node_modules/validator/lib/isFQDN.js
var require_isFQDN = __commonJS({
  "node_modules/validator/lib/isFQDN.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isFQDN2;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var default_fqdn_options = {
      require_tld: true,
      allow_underscores: false,
      allow_trailing_dot: false,
      allow_numeric_tld: false,
      allow_wildcard: false,
      ignore_max_length: false
    };
    function isFQDN2(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, default_fqdn_options);
      if (options.allow_trailing_dot && str[str.length - 1] === ".") {
        str = str.substring(0, str.length - 1);
      }
      if (options.allow_wildcard === true && str.indexOf("*.") === 0) {
        str = str.substring(2);
      }
      var parts = str.split(".");
      var tld = parts[parts.length - 1];
      if (options.require_tld) {
        if (parts.length < 2) {
          return false;
        }
        if (!options.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
          return false;
        }
        if (/\s/.test(tld)) {
          return false;
        }
      }
      if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
        return false;
      }
      return parts.every(function(part) {
        if (part.length > 63 && !options.ignore_max_length) {
          return false;
        }
        if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
          return false;
        }
        if (/[\uff01-\uff5e]/.test(part)) {
          return false;
        }
        if (/^-|-$/.test(part)) {
          return false;
        }
        if (!options.allow_underscores && /_/.test(part)) {
          return false;
        }
        return true;
      });
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isIP.js
var require_isIP = __commonJS({
  "node_modules/validator/lib/isIP.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isIP2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var IPv4SegmentFormat = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
    var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
    var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
    var IPv6SegmentFormat = "(?:[0-9a-fA-F]{1,4})";
    var IPv6AddressRegExp = new RegExp("^(" + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ")(%[0-9a-zA-Z-.:]{1,})?$");
    function isIP2(str) {
      var version2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      (0, _assertString.default)(str);
      version2 = String(version2);
      if (!version2) {
        return isIP2(str, 4) || isIP2(str, 6);
      }
      if (version2 === "4") {
        return IPv4AddressRegExp.test(str);
      }
      if (version2 === "6") {
        return IPv6AddressRegExp.test(str);
      }
      return false;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isEmail.js
var require_isEmail = __commonJS({
  "node_modules/validator/lib/isEmail.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isEmail2;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge());
    var _isByteLength = _interopRequireDefault(require_isByteLength());
    var _isFQDN = _interopRequireDefault(require_isFQDN());
    var _isIP = _interopRequireDefault(require_isIP());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var default_email_options = {
      allow_display_name: false,
      require_display_name: false,
      allow_utf8_local_part: true,
      require_tld: true,
      blacklisted_chars: "",
      ignore_max_length: false,
      host_blacklist: [],
      host_whitelist: []
    };
    var splitNameAddress = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i;
    var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
    var gmailUserPart = /^[a-z\d]+$/;
    var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
    var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
    var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
    var defaultMaxEmailLength = 254;
    function validateDisplayName(display_name) {
      var display_name_without_quotes = display_name.replace(/^"(.+)"$/, "$1");
      if (!display_name_without_quotes.trim()) {
        return false;
      }
      var contains_illegal = /[\.";<>]/.test(display_name_without_quotes);
      if (contains_illegal) {
        if (display_name_without_quotes === display_name) {
          return false;
        }
        var all_start_with_back_slash = display_name_without_quotes.split('"').length === display_name_without_quotes.split('\\"').length;
        if (!all_start_with_back_slash) {
          return false;
        }
      }
      return true;
    }
    function isEmail2(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, default_email_options);
      if (options.require_display_name || options.allow_display_name) {
        var display_email = str.match(splitNameAddress);
        if (display_email) {
          var display_name = display_email[1];
          str = str.replace(display_name, "").replace(/(^<|>$)/g, "");
          if (display_name.endsWith(" ")) {
            display_name = display_name.slice(0, -1);
          }
          if (!validateDisplayName(display_name)) {
            return false;
          }
        } else if (options.require_display_name) {
          return false;
        }
      }
      if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {
        return false;
      }
      var parts = str.split("@");
      var domain = parts.pop();
      var lower_domain = domain.toLowerCase();
      if (options.host_blacklist.includes(lower_domain)) {
        return false;
      }
      if (options.host_whitelist.length > 0 && !options.host_whitelist.includes(lower_domain)) {
        return false;
      }
      var user = parts.join("@");
      if (options.domain_specific_validation && (lower_domain === "gmail.com" || lower_domain === "googlemail.com")) {
        user = user.toLowerCase();
        var username = user.split("+")[0];
        if (!(0, _isByteLength.default)(username.replace(/\./g, ""), {
          min: 6,
          max: 30
        })) {
          return false;
        }
        var _user_parts = username.split(".");
        for (var i = 0; i < _user_parts.length; i++) {
          if (!gmailUserPart.test(_user_parts[i])) {
            return false;
          }
        }
      }
      if (options.ignore_max_length === false && (!(0, _isByteLength.default)(user, {
        max: 64
      }) || !(0, _isByteLength.default)(domain, {
        max: 254
      }))) {
        return false;
      }
      if (!(0, _isFQDN.default)(domain, {
        require_tld: options.require_tld,
        ignore_max_length: options.ignore_max_length
      })) {
        if (!options.allow_ip_domain) {
          return false;
        }
        if (!(0, _isIP.default)(domain)) {
          if (!domain.startsWith("[") || !domain.endsWith("]")) {
            return false;
          }
          var noBracketdomain = domain.slice(1, -1);
          if (noBracketdomain.length === 0 || !(0, _isIP.default)(noBracketdomain)) {
            return false;
          }
        }
      }
      if (user[0] === '"') {
        user = user.slice(1, user.length - 1);
        return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
      }
      var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
      var user_parts = user.split(".");
      for (var _i = 0; _i < user_parts.length; _i++) {
        if (!pattern.test(user_parts[_i])) {
          return false;
        }
      }
      if (options.blacklisted_chars) {
        if (user.search(new RegExp("[".concat(options.blacklisted_chars, "]+"), "g")) !== -1)
          return false;
      }
      return true;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsEmail.js
function isEmail(value, options) {
  return typeof value === "string" && (0, import_isEmail.default)(value, options);
}
function IsEmail(options, validationOptions) {
  return ValidateBy({
    name: IS_EMAIL,
    constraints: [options],
    validator: {
      validate: function(value, args) {
        return isEmail(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be an email";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isEmail, IS_EMAIL;
var init_IsEmail = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsEmail.js"() {
    init_ValidateBy();
    import_isEmail = __toESM(require_isEmail());
    IS_EMAIL = "isEmail";
  }
});

// node_modules/class-validator/esm5/decorator/string/IsFQDN.js
function isFQDN(value, options) {
  return typeof value === "string" && (0, import_isFQDN.default)(value, options);
}
function IsFQDN(options, validationOptions) {
  return ValidateBy({
    name: IS_FQDN,
    constraints: [options],
    validator: {
      validate: function(value, args) {
        return isFQDN(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a valid domain name";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isFQDN, IS_FQDN;
var init_IsFQDN = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsFQDN.js"() {
    init_ValidateBy();
    import_isFQDN = __toESM(require_isFQDN());
    IS_FQDN = "isFqdn";
  }
});

// node_modules/validator/lib/isFullWidth.js
var require_isFullWidth = __commonJS({
  "node_modules/validator/lib/isFullWidth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isFullWidth2;
    exports.fullWidth = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
    exports.fullWidth = fullWidth;
    function isFullWidth2(str) {
      (0, _assertString.default)(str);
      return fullWidth.test(str);
    }
  }
});

// node_modules/class-validator/esm5/decorator/string/IsFullWidth.js
function isFullWidth(value) {
  return typeof value === "string" && (0, import_isFullWidth.default)(value);
}
function IsFullWidth(validationOptions) {
  return ValidateBy({
    name: IS_FULL_WIDTH,
    validator: {
      validate: function(value, args) {
        return isFullWidth(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must contain a full-width characters";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isFullWidth, IS_FULL_WIDTH;
var init_IsFullWidth = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsFullWidth.js"() {
    init_ValidateBy();
    import_isFullWidth = __toESM(require_isFullWidth());
    IS_FULL_WIDTH = "isFullWidth";
  }
});

// node_modules/validator/lib/isHalfWidth.js
var require_isHalfWidth = __commonJS({
  "node_modules/validator/lib/isHalfWidth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isHalfWidth2;
    exports.halfWidth = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
    exports.halfWidth = halfWidth;
    function isHalfWidth2(str) {
      (0, _assertString.default)(str);
      return halfWidth.test(str);
    }
  }
});

// node_modules/class-validator/esm5/decorator/string/IsHalfWidth.js
function isHalfWidth(value) {
  return typeof value === "string" && (0, import_isHalfWidth.default)(value);
}
function IsHalfWidth(validationOptions) {
  return ValidateBy({
    name: IS_HALF_WIDTH,
    validator: {
      validate: function(value, args) {
        return isHalfWidth(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must contain a half-width characters";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isHalfWidth, IS_HALF_WIDTH;
var init_IsHalfWidth = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsHalfWidth.js"() {
    init_ValidateBy();
    import_isHalfWidth = __toESM(require_isHalfWidth());
    IS_HALF_WIDTH = "isHalfWidth";
  }
});

// node_modules/validator/lib/isVariableWidth.js
var require_isVariableWidth = __commonJS({
  "node_modules/validator/lib/isVariableWidth.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isVariableWidth2;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isFullWidth = require_isFullWidth();
    var _isHalfWidth = require_isHalfWidth();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isVariableWidth2(str) {
      (0, _assertString.default)(str);
      return _isFullWidth.fullWidth.test(str) && _isHalfWidth.halfWidth.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsVariableWidth.js
function isVariableWidth(value) {
  return typeof value === "string" && (0, import_isVariableWidth.default)(value);
}
function IsVariableWidth(validationOptions) {
  return ValidateBy({
    name: IS_VARIABLE_WIDTH,
    validator: {
      validate: function(value, args) {
        return isVariableWidth(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must contain a full-width and half-width characters";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isVariableWidth, IS_VARIABLE_WIDTH;
var init_IsVariableWidth = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsVariableWidth.js"() {
    init_ValidateBy();
    import_isVariableWidth = __toESM(require_isVariableWidth());
    IS_VARIABLE_WIDTH = "isVariableWidth";
  }
});

// node_modules/validator/lib/isHexColor.js
var require_isHexColor = __commonJS({
  "node_modules/validator/lib/isHexColor.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isHexColor2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;
    function isHexColor2(str) {
      (0, _assertString.default)(str);
      return hexcolor.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsHexColor.js
function isHexColor(value) {
  return typeof value === "string" && (0, import_isHexColor.default)(value);
}
function IsHexColor(validationOptions) {
  return ValidateBy({
    name: IS_HEX_COLOR,
    validator: {
      validate: function(value, args) {
        return isHexColor(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a hexadecimal color";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isHexColor, IS_HEX_COLOR;
var init_IsHexColor = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsHexColor.js"() {
    init_ValidateBy();
    import_isHexColor = __toESM(require_isHexColor());
    IS_HEX_COLOR = "isHexColor";
  }
});

// node_modules/validator/lib/isHexadecimal.js
var require_isHexadecimal = __commonJS({
  "node_modules/validator/lib/isHexadecimal.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isHexadecimal2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hexadecimal = /^(0x|0h)?[0-9A-F]+$/i;
    function isHexadecimal2(str) {
      (0, _assertString.default)(str);
      return hexadecimal.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsHexadecimal.js
function isHexadecimal(value) {
  return typeof value === "string" && (0, import_isHexadecimal.default)(value);
}
function IsHexadecimal(validationOptions) {
  return ValidateBy({
    name: IS_HEXADECIMAL,
    validator: {
      validate: function(value, args) {
        return isHexadecimal(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a hexadecimal number";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isHexadecimal, IS_HEXADECIMAL;
var init_IsHexadecimal = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsHexadecimal.js"() {
    init_ValidateBy();
    import_isHexadecimal = __toESM(require_isHexadecimal());
    IS_HEXADECIMAL = "isHexadecimal";
  }
});

// node_modules/class-validator/esm5/decorator/ValidationOptions.js
function isValidationOptions(val) {
  if (!val) {
    return false;
  }
  return "each" in val || "message" in val || "groups" in val || "always" in val || "context" in val;
}
var init_ValidationOptions = __esm({
  "node_modules/class-validator/esm5/decorator/ValidationOptions.js"() {
  }
});

// node_modules/validator/lib/isMACAddress.js
var require_isMACAddress = __commonJS({
  "node_modules/validator/lib/isMACAddress.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isMACAddress2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var macAddress48 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){4}([0-9a-fA-F]{2})$/;
    var macAddress48NoSeparators = /^([0-9a-fA-F]){12}$/;
    var macAddress48WithDots = /^([0-9a-fA-F]{4}\.){2}([0-9a-fA-F]{4})$/;
    var macAddress64 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){6}([0-9a-fA-F]{2})$/;
    var macAddress64NoSeparators = /^([0-9a-fA-F]){16}$/;
    var macAddress64WithDots = /^([0-9a-fA-F]{4}\.){3}([0-9a-fA-F]{4})$/;
    function isMACAddress2(str, options) {
      (0, _assertString.default)(str);
      if (options !== null && options !== void 0 && options.eui) {
        options.eui = String(options.eui);
      }
      if (options !== null && options !== void 0 && options.no_colons || options !== null && options !== void 0 && options.no_separators) {
        if (options.eui === "48") {
          return macAddress48NoSeparators.test(str);
        }
        if (options.eui === "64") {
          return macAddress64NoSeparators.test(str);
        }
        return macAddress48NoSeparators.test(str) || macAddress64NoSeparators.test(str);
      }
      if ((options === null || options === void 0 ? void 0 : options.eui) === "48") {
        return macAddress48.test(str) || macAddress48WithDots.test(str);
      }
      if ((options === null || options === void 0 ? void 0 : options.eui) === "64") {
        return macAddress64.test(str) || macAddress64WithDots.test(str);
      }
      return isMACAddress2(str, {
        eui: "48"
      }) || isMACAddress2(str, {
        eui: "64"
      });
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsMacAddress.js
function isMACAddress(value, options) {
  return typeof value === "string" && (0, import_isMACAddress.default)(value, options);
}
function IsMACAddress(optionsOrValidationOptionsArg, validationOptionsArg) {
  var options = !isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : void 0;
  var validationOptions = isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : validationOptionsArg;
  return ValidateBy({
    name: IS_MAC_ADDRESS,
    constraints: [options],
    validator: {
      validate: function(value, args) {
        return isMACAddress(value, options);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a MAC Address";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isMACAddress, IS_MAC_ADDRESS;
var init_IsMacAddress = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsMacAddress.js"() {
    init_ValidationOptions();
    init_ValidateBy();
    import_isMACAddress = __toESM(require_isMACAddress());
    IS_MAC_ADDRESS = "isMacAddress";
  }
});

// node_modules/class-validator/esm5/decorator/string/IsIP.js
function isIP(value, version2) {
  var versionStr = version2 ? "" + version2 : void 0;
  return typeof value === "string" && (0, import_isIP.default)(value, versionStr);
}
function IsIP(version2, validationOptions) {
  return ValidateBy({
    name: IS_IP,
    constraints: [version2],
    validator: {
      validate: function(value, args) {
        return isIP(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be an ip address";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isIP, IS_IP;
var init_IsIP = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsIP.js"() {
    init_ValidateBy();
    import_isIP = __toESM(require_isIP());
    IS_IP = "isIp";
  }
});

// node_modules/validator/lib/isInt.js
var require_isInt = __commonJS({
  "node_modules/validator/lib/isInt.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isInt2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;
    var intLeadingZeroes = /^[-+]?[0-9]+$/;
    function isInt2(str, options) {
      (0, _assertString.default)(str);
      options = options || {};
      var regex = options.hasOwnProperty("allow_leading_zeroes") && !options.allow_leading_zeroes ? int : intLeadingZeroes;
      var minCheckPassed = !options.hasOwnProperty("min") || str >= options.min;
      var maxCheckPassed = !options.hasOwnProperty("max") || str <= options.max;
      var ltCheckPassed = !options.hasOwnProperty("lt") || str < options.lt;
      var gtCheckPassed = !options.hasOwnProperty("gt") || str > options.gt;
      return regex.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isPort.js
var require_isPort = __commonJS({
  "node_modules/validator/lib/isPort.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isPort2;
    var _isInt = _interopRequireDefault(require_isInt());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isPort2(str) {
      return (0, _isInt.default)(str, {
        min: 0,
        max: 65535
      });
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsPort.js
function isPort(value) {
  return typeof value === "string" && (0, import_isPort.default)(value);
}
function IsPort(validationOptions) {
  return ValidateBy({
    name: IS_PORT,
    validator: {
      validate: function(value, args) {
        return isPort(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a port";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isPort, IS_PORT;
var init_IsPort = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsPort.js"() {
    init_ValidateBy();
    import_isPort = __toESM(require_isPort());
    IS_PORT = "isPort";
  }
});

// node_modules/validator/lib/isISBN.js
var require_isISBN = __commonJS({
  "node_modules/validator/lib/isISBN.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isISBN2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var possibleIsbn10 = /^(?:[0-9]{9}X|[0-9]{10})$/;
    var possibleIsbn13 = /^(?:[0-9]{13})$/;
    var factor = [1, 3];
    function isISBN2(isbn, options) {
      (0, _assertString.default)(isbn);
      var version2 = String((options === null || options === void 0 ? void 0 : options.version) || options);
      if (!(options !== null && options !== void 0 && options.version || options)) {
        return isISBN2(isbn, {
          version: 10
        }) || isISBN2(isbn, {
          version: 13
        });
      }
      var sanitizedIsbn = isbn.replace(/[\s-]+/g, "");
      var checksum = 0;
      if (version2 === "10") {
        if (!possibleIsbn10.test(sanitizedIsbn)) {
          return false;
        }
        for (var i = 0; i < version2 - 1; i++) {
          checksum += (i + 1) * sanitizedIsbn.charAt(i);
        }
        if (sanitizedIsbn.charAt(9) === "X") {
          checksum += 10 * 10;
        } else {
          checksum += 10 * sanitizedIsbn.charAt(9);
        }
        if (checksum % 11 === 0) {
          return true;
        }
      } else if (version2 === "13") {
        if (!possibleIsbn13.test(sanitizedIsbn)) {
          return false;
        }
        for (var _i = 0; _i < 12; _i++) {
          checksum += factor[_i % 2] * sanitizedIsbn.charAt(_i);
        }
        if (sanitizedIsbn.charAt(12) - (10 - checksum % 10) % 10 === 0) {
          return true;
        }
      }
      return false;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsISBN.js
function isISBN(value, version2) {
  var versionStr = version2 ? "" + version2 : void 0;
  return typeof value === "string" && (0, import_isISBN.default)(value, versionStr);
}
function IsISBN(version2, validationOptions) {
  return ValidateBy({
    name: IS_ISBN,
    constraints: [version2],
    validator: {
      validate: function(value, args) {
        return isISBN(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be an ISBN";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isISBN, IS_ISBN;
var init_IsISBN = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsISBN.js"() {
    init_ValidateBy();
    import_isISBN = __toESM(require_isISBN());
    IS_ISBN = "isIsbn";
  }
});

// node_modules/validator/lib/isISIN.js
var require_isISIN = __commonJS({
  "node_modules/validator/lib/isISIN.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isISIN2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;
    function isISIN2(str) {
      (0, _assertString.default)(str);
      if (!isin.test(str)) {
        return false;
      }
      var double = true;
      var sum = 0;
      for (var i = str.length - 2; i >= 0; i--) {
        if (str[i] >= "A" && str[i] <= "Z") {
          var value = str[i].charCodeAt(0) - 55;
          var lo = value % 10;
          var hi = Math.trunc(value / 10);
          for (var _i = 0, _arr = [lo, hi]; _i < _arr.length; _i++) {
            var digit = _arr[_i];
            if (double) {
              if (digit >= 5) {
                sum += 1 + (digit - 5) * 2;
              } else {
                sum += digit * 2;
              }
            } else {
              sum += digit;
            }
            double = !double;
          }
        } else {
          var _digit = str[i].charCodeAt(0) - "0".charCodeAt(0);
          if (double) {
            if (_digit >= 5) {
              sum += 1 + (_digit - 5) * 2;
            } else {
              sum += _digit * 2;
            }
          } else {
            sum += _digit;
          }
          double = !double;
        }
      }
      var check = Math.trunc((sum + 9) / 10) * 10 - sum;
      return +str[str.length - 1] === check;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsISIN.js
function isISIN(value) {
  return typeof value === "string" && (0, import_isISIN.default)(value);
}
function IsISIN(validationOptions) {
  return ValidateBy({
    name: IS_ISIN,
    validator: {
      validate: function(value, args) {
        return isISIN(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be an ISIN (stock/security identifier)";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isISIN, IS_ISIN;
var init_IsISIN = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsISIN.js"() {
    init_ValidateBy();
    import_isISIN = __toESM(require_isISIN());
    IS_ISIN = "isIsin";
  }
});

// node_modules/validator/lib/isISO8601.js
var require_isISO8601 = __commonJS({
  "node_modules/validator/lib/isISO8601.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isISO86012;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
    var iso8601StrictSeparator = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
    var isValidDate = function isValidDate2(str) {
      var ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
      if (ordinalMatch) {
        var oYear = Number(ordinalMatch[1]);
        var oDay = Number(ordinalMatch[2]);
        if (oYear % 4 === 0 && oYear % 100 !== 0 || oYear % 400 === 0)
          return oDay <= 366;
        return oDay <= 365;
      }
      var match = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
      var year = match[1];
      var month = match[2];
      var day = match[3];
      var monthString = month ? "0".concat(month).slice(-2) : month;
      var dayString = day ? "0".concat(day).slice(-2) : day;
      var d = new Date("".concat(year, "-").concat(monthString || "01", "-").concat(dayString || "01"));
      if (month && day) {
        return d.getUTCFullYear() === year && d.getUTCMonth() + 1 === month && d.getUTCDate() === day;
      }
      return true;
    };
    function isISO86012(str) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      (0, _assertString.default)(str);
      var check = options.strictSeparator ? iso8601StrictSeparator.test(str) : iso8601.test(str);
      if (check && options.strict)
        return isValidDate(str);
      return check;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsISO8601.js
function isISO8601(value, options) {
  return typeof value === "string" && (0, import_isISO8601.default)(value, options);
}
function IsISO8601(options, validationOptions) {
  return ValidateBy({
    name: IS_ISO8601,
    constraints: [options],
    validator: {
      validate: function(value, args) {
        return isISO8601(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a valid ISO 8601 date string";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isISO8601, IS_ISO8601;
var init_IsISO8601 = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsISO8601.js"() {
    init_ValidateBy();
    import_isISO8601 = __toESM(require_isISO8601());
    IS_ISO8601 = "isIso8601";
  }
});

// node_modules/validator/lib/isJSON.js
var require_isJSON = __commonJS({
  "node_modules/validator/lib/isJSON.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isJSON2;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof5(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof5 = function _typeof6(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof5 = function _typeof6(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof5(obj);
    }
    var default_json_options = {
      allow_primitives: false
    };
    function isJSON2(str, options) {
      (0, _assertString.default)(str);
      try {
        options = (0, _merge.default)(options, default_json_options);
        var primitives = [];
        if (options.allow_primitives) {
          primitives = [null, false, true];
        }
        var obj = JSON.parse(str);
        return primitives.includes(obj) || !!obj && _typeof5(obj) === "object";
      } catch (e) {
      }
      return false;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsJSON.js
function isJSON(value) {
  return typeof value === "string" && (0, import_isJSON.default)(value);
}
function IsJSON(validationOptions) {
  return ValidateBy({
    name: IS_JSON,
    validator: {
      validate: function(value, args) {
        return isJSON(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a json string";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isJSON, IS_JSON;
var init_IsJSON = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsJSON.js"() {
    init_ValidateBy();
    import_isJSON = __toESM(require_isJSON());
    IS_JSON = "isJson";
  }
});

// node_modules/validator/lib/isJWT.js
var require_isJWT = __commonJS({
  "node_modules/validator/lib/isJWT.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isJWT2;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isBase = _interopRequireDefault(require_isBase64());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isJWT2(str) {
      (0, _assertString.default)(str);
      var dotSplit = str.split(".");
      var len = dotSplit.length;
      if (len > 3 || len < 2) {
        return false;
      }
      return dotSplit.reduce(function(acc, currElem) {
        return acc && (0, _isBase.default)(currElem, {
          urlSafe: true
        });
      }, true);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsJWT.js
function isJWT(value) {
  return typeof value === "string" && (0, import_isJWT.default)(value);
}
function IsJWT(validationOptions) {
  return ValidateBy({
    name: IS_JWT,
    validator: {
      validate: function(value, args) {
        return isJWT(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a jwt string";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isJWT, IS_JWT;
var init_IsJWT = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsJWT.js"() {
    init_ValidateBy();
    import_isJWT = __toESM(require_isJWT());
    IS_JWT = "isJwt";
  }
});

// node_modules/validator/lib/isLowercase.js
var require_isLowercase = __commonJS({
  "node_modules/validator/lib/isLowercase.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isLowercase2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isLowercase2(str) {
      (0, _assertString.default)(str);
      return str === str.toLowerCase();
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsLowercase.js
function isLowercase(value) {
  return typeof value === "string" && (0, import_isLowercase.default)(value);
}
function IsLowercase(validationOptions) {
  return ValidateBy({
    name: IS_LOWERCASE,
    validator: {
      validate: function(value, args) {
        return isLowercase(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a lowercase string";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isLowercase, IS_LOWERCASE;
var init_IsLowercase = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsLowercase.js"() {
    init_ValidateBy();
    import_isLowercase = __toESM(require_isLowercase());
    IS_LOWERCASE = "isLowercase";
  }
});

// node_modules/validator/lib/isMobilePhone.js
var require_isMobilePhone = __commonJS({
  "node_modules/validator/lib/isMobilePhone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isMobilePhone2;
    exports.locales = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var phones = {
      "am-AM": /^(\+?374|0)((10|[9|7][0-9])\d{6}$|[2-4]\d{7}$)/,
      "ar-AE": /^((\+?971)|0)?5[024568]\d{7}$/,
      "ar-BH": /^(\+?973)?(3|6)\d{7}$/,
      "ar-DZ": /^(\+?213|0)(5|6|7)\d{8}$/,
      "ar-LB": /^(\+?961)?((3|81)\d{6}|7\d{7})$/,
      "ar-EG": /^((\+?20)|0)?1[0125]\d{8}$/,
      "ar-IQ": /^(\+?964|0)?7[0-9]\d{8}$/,
      "ar-JO": /^(\+?962|0)?7[789]\d{7}$/,
      "ar-KW": /^(\+?965)([569]\d{7}|41\d{6})$/,
      "ar-LY": /^((\+?218)|0)?(9[1-6]\d{7}|[1-8]\d{7,9})$/,
      "ar-MA": /^(?:(?:\+|00)212|0)[5-7]\d{8}$/,
      "ar-OM": /^((\+|00)968)?(9[1-9])\d{6}$/,
      "ar-PS": /^(\+?970|0)5[6|9](\d{7})$/,
      "ar-SA": /^(!?(\+?966)|0)?5\d{8}$/,
      "ar-SY": /^(!?(\+?963)|0)?9\d{8}$/,
      "ar-TN": /^(\+?216)?[2459]\d{7}$/,
      "az-AZ": /^(\+994|0)(10|5[015]|7[07]|99)\d{7}$/,
      "bs-BA": /^((((\+|00)3876)|06))((([0-3]|[5-6])\d{6})|(4\d{7}))$/,
      "be-BY": /^(\+?375)?(24|25|29|33|44)\d{7}$/,
      "bg-BG": /^(\+?359|0)?8[789]\d{7}$/,
      "bn-BD": /^(\+?880|0)1[13456789][0-9]{8}$/,
      "ca-AD": /^(\+376)?[346]\d{5}$/,
      "cs-CZ": /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
      "da-DK": /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
      "de-DE": /^((\+49|0)1)(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7,9}$/,
      "de-AT": /^(\+43|0)\d{1,4}\d{3,12}$/,
      "de-CH": /^(\+41|0)([1-9])\d{1,9}$/,
      "de-LU": /^(\+352)?((6\d1)\d{6})$/,
      "dv-MV": /^(\+?960)?(7[2-9]|9[1-9])\d{5}$/,
      "el-GR": /^(\+?30|0)?6(8[5-9]|9(?![26])[0-9])\d{7}$/,
      "el-CY": /^(\+?357?)?(9(9|6)\d{6})$/,
      "en-AI": /^(\+?1|0)264(?:2(35|92)|4(?:6[1-2]|76|97)|5(?:3[6-9]|8[1-4])|7(?:2(4|9)|72))\d{4}$/,
      "en-AU": /^(\+?61|0)4\d{8}$/,
      "en-AG": /^(?:\+1|1)268(?:464|7(?:1[3-9]|[28]\d|3[0246]|64|7[0-689]))\d{4}$/,
      "en-BM": /^(\+?1)?441(((3|7)\d{6}$)|(5[0-3][0-9]\d{4}$)|(59\d{5}$))/,
      "en-BS": /^(\+?1[-\s]?|0)?\(?242\)?[-\s]?\d{3}[-\s]?\d{4}$/,
      "en-GB": /^(\+?44|0)7\d{9}$/,
      "en-GG": /^(\+?44|0)1481\d{6}$/,
      "en-GH": /^(\+233|0)(20|50|24|54|27|57|26|56|23|28|55|59)\d{7}$/,
      "en-GY": /^(\+592|0)6\d{6}$/,
      "en-HK": /^(\+?852[-\s]?)?[456789]\d{3}[-\s]?\d{4}$/,
      "en-MO": /^(\+?853[-\s]?)?[6]\d{3}[-\s]?\d{4}$/,
      "en-IE": /^(\+?353|0)8[356789]\d{7}$/,
      "en-IN": /^(\+?91|0)?[6789]\d{9}$/,
      "en-JM": /^(\+?876)?\d{7}$/,
      "en-KE": /^(\+?254|0)(7|1)\d{8}$/,
      "en-SS": /^(\+?211|0)(9[1257])\d{7}$/,
      "en-KI": /^((\+686|686)?)?( )?((6|7)(2|3|8)[0-9]{6})$/,
      "en-KN": /^(?:\+1|1)869(?:46\d|48[89]|55[6-8]|66\d|76[02-7])\d{4}$/,
      "en-LS": /^(\+?266)(22|28|57|58|59|27|52)\d{6}$/,
      "en-MT": /^(\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,
      "en-MU": /^(\+?230|0)?\d{8}$/,
      "en-NA": /^(\+?264|0)(6|8)\d{7}$/,
      "en-NG": /^(\+?234|0)?[789]\d{9}$/,
      "en-NZ": /^(\+?64|0)[28]\d{7,9}$/,
      "en-PG": /^(\+?675|0)?(7\d|8[18])\d{6}$/,
      "en-PK": /^((00|\+)?92|0)3[0-6]\d{8}$/,
      "en-PH": /^(09|\+639)\d{9}$/,
      "en-RW": /^(\+?250|0)?[7]\d{8}$/,
      "en-SG": /^(\+65)?[3689]\d{7}$/,
      "en-SL": /^(\+?232|0)\d{8}$/,
      "en-TZ": /^(\+?255|0)?[67]\d{8}$/,
      "en-UG": /^(\+?256|0)?[7]\d{8}$/,
      "en-US": /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
      "en-ZA": /^(\+?27|0)\d{9}$/,
      "en-ZM": /^(\+?26)?09[567]\d{7}$/,
      "en-ZW": /^(\+263)[0-9]{9}$/,
      "en-BW": /^(\+?267)?(7[1-8]{1})\d{6}$/,
      "es-AR": /^\+?549(11|[2368]\d)\d{8}$/,
      "es-BO": /^(\+?591)?(6|7)\d{7}$/,
      "es-CO": /^(\+?57)?3(0(0|1|2|4|5)|1\d|2[0-4]|5(0|1))\d{7}$/,
      "es-CL": /^(\+?56|0)[2-9]\d{1}\d{7}$/,
      "es-CR": /^(\+506)?[2-8]\d{7}$/,
      "es-CU": /^(\+53|0053)?5\d{7}/,
      "es-DO": /^(\+?1)?8[024]9\d{7}$/,
      "es-HN": /^(\+?504)?[9|8|3|2]\d{7}$/,
      "es-EC": /^(\+?593|0)([2-7]|9[2-9])\d{7}$/,
      "es-ES": /^(\+?34)?[6|7]\d{8}$/,
      "es-PE": /^(\+?51)?9\d{8}$/,
      "es-MX": /^(\+?52)?(1|01)?\d{10,11}$/,
      "es-NI": /^(\+?505)\d{7,8}$/,
      "es-PA": /^(\+?507)\d{7,8}$/,
      "es-PY": /^(\+?595|0)9[9876]\d{7}$/,
      "es-SV": /^(\+?503)?[67]\d{7}$/,
      "es-UY": /^(\+598|0)9[1-9][\d]{6}$/,
      "es-VE": /^(\+?58)?(2|4)\d{9}$/,
      "et-EE": /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
      "fa-IR": /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
      "fi-FI": /^(\+?358|0)\s?(4[0-6]|50)\s?(\d\s?){4,8}$/,
      "fj-FJ": /^(\+?679)?\s?\d{3}\s?\d{4}$/,
      "fo-FO": /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
      "fr-BF": /^(\+226|0)[67]\d{7}$/,
      "fr-BJ": /^(\+229)\d{8}$/,
      "fr-CD": /^(\+?243|0)?(8|9)\d{8}$/,
      "fr-CM": /^(\+?237)6[0-9]{8}$/,
      "fr-FR": /^(\+?33|0)[67]\d{8}$/,
      "fr-GF": /^(\+?594|0|00594)[67]\d{8}$/,
      "fr-GP": /^(\+?590|0|00590)[67]\d{8}$/,
      "fr-MQ": /^(\+?596|0|00596)[67]\d{8}$/,
      "fr-PF": /^(\+?689)?8[789]\d{6}$/,
      "fr-RE": /^(\+?262|0|00262)[67]\d{8}$/,
      "he-IL": /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
      "hu-HU": /^(\+?36|06)(20|30|31|50|70)\d{7}$/,
      "id-ID": /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
      "ir-IR": /^(\+98|0)?9\d{9}$/,
      "it-IT": /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
      "it-SM": /^((\+378)|(0549)|(\+390549)|(\+3780549))?6\d{5,9}$/,
      "ja-JP": /^(\+81[ \-]?(\(0\))?|0)[6789]0[ \-]?\d{4}[ \-]?\d{4}$/,
      "ka-GE": /^(\+?995)?(79\d{7}|5\d{8})$/,
      "kk-KZ": /^(\+?7|8)?7\d{9}$/,
      "kl-GL": /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
      "ko-KR": /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
      "ky-KG": /^(\+?7\s?\+?7|0)\s?\d{2}\s?\d{3}\s?\d{4}$/,
      "lt-LT": /^(\+370|8)\d{8}$/,
      "lv-LV": /^(\+?371)2\d{7}$/,
      "mg-MG": /^((\+?261|0)(2|3)\d)?\d{7}$/,
      "mn-MN": /^(\+|00|011)?976(77|81|88|91|94|95|96|99)\d{6}$/,
      "my-MM": /^(\+?959|09|9)(2[5-7]|3[1-2]|4[0-5]|6[6-9]|7[5-9]|9[6-9])[0-9]{7}$/,
      "ms-MY": /^(\+?60|0)1(([0145](-|\s)?\d{7,8})|([236-9](-|\s)?\d{7}))$/,
      "mz-MZ": /^(\+?258)?8[234567]\d{7}$/,
      "nb-NO": /^(\+?47)?[49]\d{7}$/,
      "ne-NP": /^(\+?977)?9[78]\d{8}$/,
      "nl-BE": /^(\+?32|0)4\d{8}$/,
      "nl-NL": /^(((\+|00)?31\(0\))|((\+|00)?31)|0)6{1}\d{8}$/,
      "nl-AW": /^(\+)?297(56|59|64|73|74|99)\d{5}$/,
      "nn-NO": /^(\+?47)?[49]\d{7}$/,
      "pl-PL": /^(\+?48)? ?[5-8]\d ?\d{3} ?\d{2} ?\d{2}$/,
      "pt-BR": /^((\+?55\ ?[1-9]{2}\ ?)|(\+?55\ ?\([1-9]{2}\)\ ?)|(0[1-9]{2}\ ?)|(\([1-9]{2}\)\ ?)|([1-9]{2}\ ?))((\d{4}\-?\d{4})|(9[1-9]{1}\d{3}\-?\d{4}))$/,
      "pt-PT": /^(\+?351)?9[1236]\d{7}$/,
      "pt-AO": /^(\+244)\d{9}$/,
      "ro-MD": /^(\+?373|0)((6(0|1|2|6|7|8|9))|(7(6|7|8|9)))\d{6}$/,
      "ro-RO": /^(\+?40|0)\s?7\d{2}(\/|\s|\.|-)?\d{3}(\s|\.|-)?\d{3}$/,
      "ru-RU": /^(\+?7|8)?9\d{9}$/,
      "si-LK": /^(?:0|94|\+94)?(7(0|1|2|4|5|6|7|8)( |-)?)\d{7}$/,
      "sl-SI": /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
      "sk-SK": /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
      "sq-AL": /^(\+355|0)6[789]\d{6}$/,
      "sr-RS": /^(\+3816|06)[- \d]{5,9}$/,
      "sv-SE": /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
      "tg-TJ": /^(\+?992)?[5][5]\d{7}$/,
      "th-TH": /^(\+66|66|0)\d{9}$/,
      "tr-TR": /^(\+?90|0)?5\d{9}$/,
      "tk-TM": /^(\+993|993|8)\d{8}$/,
      "uk-UA": /^(\+?38|8)?0\d{9}$/,
      "uz-UZ": /^(\+?998)?(6[125-79]|7[1-69]|88|9\d)\d{7}$/,
      "vi-VN": /^((\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9([0-9])))([0-9]{7})$/,
      "zh-CN": /^((\+|00)86)?(1[3-9]|9[28])\d{9}$/,
      "zh-TW": /^(\+?886\-?|0)?9\d{8}$/,
      "dz-BT": /^(\+?975|0)?(17|16|77|02)\d{6}$/,
      "ar-YE": /^(((\+|00)9677|0?7)[0137]\d{7}|((\+|00)967|0)[1-7]\d{6})$/,
      "ar-EH": /^(\+?212|0)[\s\-]?(5288|5289)[\s\-]?\d{5}$/,
      "fa-AF": /^(\+93|0)?(2{1}[0-8]{1}|[3-5]{1}[0-4]{1})(\d{7})$/
    };
    phones["en-CA"] = phones["en-US"];
    phones["fr-CA"] = phones["en-CA"];
    phones["fr-BE"] = phones["nl-BE"];
    phones["zh-HK"] = phones["en-HK"];
    phones["zh-MO"] = phones["en-MO"];
    phones["ga-IE"] = phones["en-IE"];
    phones["fr-CH"] = phones["de-CH"];
    phones["it-CH"] = phones["fr-CH"];
    function isMobilePhone2(str, locale, options) {
      (0, _assertString.default)(str);
      if (options && options.strictMode && !str.startsWith("+")) {
        return false;
      }
      if (Array.isArray(locale)) {
        return locale.some(function(key2) {
          if (phones.hasOwnProperty(key2)) {
            var phone2 = phones[key2];
            if (phone2.test(str)) {
              return true;
            }
          }
          return false;
        });
      } else if (locale in phones) {
        return phones[locale].test(str);
      } else if (!locale || locale === "any") {
        for (var key in phones) {
          if (phones.hasOwnProperty(key)) {
            var phone = phones[key];
            if (phone.test(str)) {
              return true;
            }
          }
        }
        return false;
      }
      throw new Error("Invalid locale '".concat(locale, "'"));
    }
    var locales = Object.keys(phones);
    exports.locales = locales;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsMobilePhone.js
function isMobilePhone(value, locale, options) {
  return typeof value === "string" && (0, import_isMobilePhone.default)(value, locale, options);
}
function IsMobilePhone(locale, options, validationOptions) {
  return ValidateBy({
    name: IS_MOBILE_PHONE,
    constraints: [locale, options],
    validator: {
      validate: function(value, args) {
        return isMobilePhone(value, args.constraints[0], args.constraints[1]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a phone number";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isMobilePhone, IS_MOBILE_PHONE;
var init_IsMobilePhone = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsMobilePhone.js"() {
    init_ValidateBy();
    import_isMobilePhone = __toESM(require_isMobilePhone());
    IS_MOBILE_PHONE = "isMobilePhone";
  }
});

// node_modules/validator/lib/isISO31661Alpha2.js
var require_isISO31661Alpha2 = __commonJS({
  "node_modules/validator/lib/isISO31661Alpha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isISO31661Alpha22;
    exports.CountryCodes = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var validISO31661Alpha2CountriesCodes = /* @__PURE__ */ new Set(["AD", "AE", "AF", "AG", "AI", "AL", "AM", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW"]);
    function isISO31661Alpha22(str) {
      (0, _assertString.default)(str);
      return validISO31661Alpha2CountriesCodes.has(str.toUpperCase());
    }
    var CountryCodes = validISO31661Alpha2CountriesCodes;
    exports.CountryCodes = CountryCodes;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsISO31661Alpha2.js
function isISO31661Alpha2(value) {
  return typeof value === "string" && (0, import_isISO31661Alpha2.default)(value);
}
function IsISO31661Alpha2(validationOptions) {
  return ValidateBy({
    name: IS_ISO31661_ALPHA_2,
    validator: {
      validate: function(value, args) {
        return isISO31661Alpha2(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a valid ISO31661 Alpha2 code";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isISO31661Alpha2, IS_ISO31661_ALPHA_2;
var init_IsISO31661Alpha2 = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsISO31661Alpha2.js"() {
    init_ValidateBy();
    import_isISO31661Alpha2 = __toESM(require_isISO31661Alpha2());
    IS_ISO31661_ALPHA_2 = "isISO31661Alpha2";
  }
});

// node_modules/validator/lib/isISO31661Alpha3.js
var require_isISO31661Alpha3 = __commonJS({
  "node_modules/validator/lib/isISO31661Alpha3.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isISO31661Alpha32;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var validISO31661Alpha3CountriesCodes = /* @__PURE__ */ new Set(["AFG", "ALA", "ALB", "DZA", "ASM", "AND", "AGO", "AIA", "ATA", "ATG", "ARG", "ARM", "ABW", "AUS", "AUT", "AZE", "BHS", "BHR", "BGD", "BRB", "BLR", "BEL", "BLZ", "BEN", "BMU", "BTN", "BOL", "BES", "BIH", "BWA", "BVT", "BRA", "IOT", "BRN", "BGR", "BFA", "BDI", "KHM", "CMR", "CAN", "CPV", "CYM", "CAF", "TCD", "CHL", "CHN", "CXR", "CCK", "COL", "COM", "COG", "COD", "COK", "CRI", "CIV", "HRV", "CUB", "CUW", "CYP", "CZE", "DNK", "DJI", "DMA", "DOM", "ECU", "EGY", "SLV", "GNQ", "ERI", "EST", "ETH", "FLK", "FRO", "FJI", "FIN", "FRA", "GUF", "PYF", "ATF", "GAB", "GMB", "GEO", "DEU", "GHA", "GIB", "GRC", "GRL", "GRD", "GLP", "GUM", "GTM", "GGY", "GIN", "GNB", "GUY", "HTI", "HMD", "VAT", "HND", "HKG", "HUN", "ISL", "IND", "IDN", "IRN", "IRQ", "IRL", "IMN", "ISR", "ITA", "JAM", "JPN", "JEY", "JOR", "KAZ", "KEN", "KIR", "PRK", "KOR", "KWT", "KGZ", "LAO", "LVA", "LBN", "LSO", "LBR", "LBY", "LIE", "LTU", "LUX", "MAC", "MKD", "MDG", "MWI", "MYS", "MDV", "MLI", "MLT", "MHL", "MTQ", "MRT", "MUS", "MYT", "MEX", "FSM", "MDA", "MCO", "MNG", "MNE", "MSR", "MAR", "MOZ", "MMR", "NAM", "NRU", "NPL", "NLD", "NCL", "NZL", "NIC", "NER", "NGA", "NIU", "NFK", "MNP", "NOR", "OMN", "PAK", "PLW", "PSE", "PAN", "PNG", "PRY", "PER", "PHL", "PCN", "POL", "PRT", "PRI", "QAT", "REU", "ROU", "RUS", "RWA", "BLM", "SHN", "KNA", "LCA", "MAF", "SPM", "VCT", "WSM", "SMR", "STP", "SAU", "SEN", "SRB", "SYC", "SLE", "SGP", "SXM", "SVK", "SVN", "SLB", "SOM", "ZAF", "SGS", "SSD", "ESP", "LKA", "SDN", "SUR", "SJM", "SWZ", "SWE", "CHE", "SYR", "TWN", "TJK", "TZA", "THA", "TLS", "TGO", "TKL", "TON", "TTO", "TUN", "TUR", "TKM", "TCA", "TUV", "UGA", "UKR", "ARE", "GBR", "USA", "UMI", "URY", "UZB", "VUT", "VEN", "VNM", "VGB", "VIR", "WLF", "ESH", "YEM", "ZMB", "ZWE"]);
    function isISO31661Alpha32(str) {
      (0, _assertString.default)(str);
      return validISO31661Alpha3CountriesCodes.has(str.toUpperCase());
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsISO31661Alpha3.js
function isISO31661Alpha3(value) {
  return typeof value === "string" && (0, import_isISO31661Alpha3.default)(value);
}
function IsISO31661Alpha3(validationOptions) {
  return ValidateBy({
    name: IS_ISO31661_ALPHA_3,
    validator: {
      validate: function(value, args) {
        return isISO31661Alpha3(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a valid ISO31661 Alpha3 code";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isISO31661Alpha3, IS_ISO31661_ALPHA_3;
var init_IsISO31661Alpha3 = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsISO31661Alpha3.js"() {
    init_ValidateBy();
    import_isISO31661Alpha3 = __toESM(require_isISO31661Alpha3());
    IS_ISO31661_ALPHA_3 = "isISO31661Alpha3";
  }
});

// node_modules/validator/lib/isMongoId.js
var require_isMongoId = __commonJS({
  "node_modules/validator/lib/isMongoId.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isMongoId2;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isHexadecimal = _interopRequireDefault(require_isHexadecimal());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isMongoId2(str) {
      (0, _assertString.default)(str);
      return (0, _isHexadecimal.default)(str) && str.length === 24;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsMongoId.js
function isMongoId(value) {
  return typeof value === "string" && (0, import_isMongoId.default)(value);
}
function IsMongoId(validationOptions) {
  return ValidateBy({
    name: IS_MONGO_ID,
    validator: {
      validate: function(value, args) {
        return isMongoId(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a mongodb id";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isMongoId, IS_MONGO_ID;
var init_IsMongoId = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsMongoId.js"() {
    init_ValidateBy();
    import_isMongoId = __toESM(require_isMongoId());
    IS_MONGO_ID = "isMongoId";
  }
});

// node_modules/validator/lib/isMultibyte.js
var require_isMultibyte = __commonJS({
  "node_modules/validator/lib/isMultibyte.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isMultibyte2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var multibyte = /[^\x00-\x7F]/;
    function isMultibyte2(str) {
      (0, _assertString.default)(str);
      return multibyte.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsMultibyte.js
function isMultibyte(value) {
  return typeof value === "string" && (0, import_isMultibyte.default)(value);
}
function IsMultibyte(validationOptions) {
  return ValidateBy({
    name: IS_MULTIBYTE,
    validator: {
      validate: function(value, args) {
        return isMultibyte(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must contain one or more multibyte chars";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isMultibyte, IS_MULTIBYTE;
var init_IsMultibyte = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsMultibyte.js"() {
    init_ValidateBy();
    import_isMultibyte = __toESM(require_isMultibyte());
    IS_MULTIBYTE = "isMultibyte";
  }
});

// node_modules/validator/lib/isSurrogatePair.js
var require_isSurrogatePair = __commonJS({
  "node_modules/validator/lib/isSurrogatePair.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isSurrogatePair2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
    function isSurrogatePair2(str) {
      (0, _assertString.default)(str);
      return surrogatePair.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsSurrogatePair.js
function isSurrogatePair(value) {
  return typeof value === "string" && (0, import_isSurrogatePair.default)(value);
}
function IsSurrogatePair(validationOptions) {
  return ValidateBy({
    name: IS_SURROGATE_PAIR,
    validator: {
      validate: function(value, args) {
        return isSurrogatePair(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must contain any surrogate pairs chars";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isSurrogatePair, IS_SURROGATE_PAIR;
var init_IsSurrogatePair = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsSurrogatePair.js"() {
    init_ValidateBy();
    import_isSurrogatePair = __toESM(require_isSurrogatePair());
    IS_SURROGATE_PAIR = "isSurrogatePair";
  }
});

// node_modules/validator/lib/isURL.js
var require_isURL = __commonJS({
  "node_modules/validator/lib/isURL.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isURL2;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isFQDN = _interopRequireDefault(require_isFQDN());
    var _isIP = _interopRequireDefault(require_isIP());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray4(arr, i) {
      return _arrayWithHoles4(arr) || _iterableToArrayLimit4(arr, i) || _unsupportedIterableToArray15(arr, i) || _nonIterableRest4();
    }
    function _nonIterableRest4() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray15(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray15(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray15(o, minLen);
    }
    function _arrayLikeToArray15(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit4(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles4(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    var default_url_options = {
      protocols: ["http", "https", "ftp"],
      require_tld: true,
      require_protocol: false,
      require_host: true,
      require_port: false,
      require_valid_protocol: true,
      allow_underscores: false,
      allow_trailing_dot: false,
      allow_protocol_relative_urls: false,
      allow_fragments: true,
      allow_query_components: true,
      validate_length: true
    };
    var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
    function isRegExp(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    function checkHost(host, matches2) {
      for (var i = 0; i < matches2.length; i++) {
        var match = matches2[i];
        if (host === match || isRegExp(match) && match.test(host)) {
          return true;
        }
      }
      return false;
    }
    function isURL2(url, options) {
      (0, _assertString.default)(url);
      if (!url || /[\s<>]/.test(url)) {
        return false;
      }
      if (url.indexOf("mailto:") === 0) {
        return false;
      }
      options = (0, _merge.default)(options, default_url_options);
      if (options.validate_length && url.length >= 2083) {
        return false;
      }
      if (!options.allow_fragments && url.includes("#")) {
        return false;
      }
      if (!options.allow_query_components && (url.includes("?") || url.includes("&"))) {
        return false;
      }
      var protocol, auth, host, hostname, port, port_str, split, ipv6;
      split = url.split("#");
      url = split.shift();
      split = url.split("?");
      url = split.shift();
      split = url.split("://");
      if (split.length > 1) {
        protocol = split.shift().toLowerCase();
        if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
          return false;
        }
      } else if (options.require_protocol) {
        return false;
      } else if (url.slice(0, 2) === "//") {
        if (!options.allow_protocol_relative_urls) {
          return false;
        }
        split[0] = url.slice(2);
      }
      url = split.join("://");
      if (url === "") {
        return false;
      }
      split = url.split("/");
      url = split.shift();
      if (url === "" && !options.require_host) {
        return true;
      }
      split = url.split("@");
      if (split.length > 1) {
        if (options.disallow_auth) {
          return false;
        }
        if (split[0] === "") {
          return false;
        }
        auth = split.shift();
        if (auth.indexOf(":") >= 0 && auth.split(":").length > 2) {
          return false;
        }
        var _auth$split = auth.split(":"), _auth$split2 = _slicedToArray4(_auth$split, 2), user = _auth$split2[0], password = _auth$split2[1];
        if (user === "" && password === "") {
          return false;
        }
      }
      hostname = split.join("@");
      port_str = null;
      ipv6 = null;
      var ipv6_match = hostname.match(wrapped_ipv6);
      if (ipv6_match) {
        host = "";
        ipv6 = ipv6_match[1];
        port_str = ipv6_match[2] || null;
      } else {
        split = hostname.split(":");
        host = split.shift();
        if (split.length) {
          port_str = split.join(":");
        }
      }
      if (port_str !== null && port_str.length > 0) {
        port = parseInt(port_str, 10);
        if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
          return false;
        }
      } else if (options.require_port) {
        return false;
      }
      if (options.host_whitelist) {
        return checkHost(host, options.host_whitelist);
      }
      if (host === "" && !options.require_host) {
        return true;
      }
      if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
        return false;
      }
      host = host || ipv6;
      if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
        return false;
      }
      return true;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsUrl.js
function isURL(value, options) {
  return typeof value === "string" && (0, import_isURL.default)(value, options);
}
function IsUrl(options, validationOptions) {
  return ValidateBy({
    name: IS_URL,
    constraints: [options],
    validator: {
      validate: function(value, args) {
        return isURL(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be an URL address";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isURL, IS_URL;
var init_IsUrl = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsUrl.js"() {
    init_ValidateBy();
    import_isURL = __toESM(require_isURL());
    IS_URL = "isUrl";
  }
});

// node_modules/validator/lib/isUUID.js
var require_isUUID = __commonJS({
  "node_modules/validator/lib/isUUID.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isUUID2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var uuid = {
      1: /^[0-9A-F]{8}-[0-9A-F]{4}-1[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
      2: /^[0-9A-F]{8}-[0-9A-F]{4}-2[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
      3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
      4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
      5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
      all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
    };
    function isUUID2(str, version2) {
      (0, _assertString.default)(str);
      var pattern = uuid[![void 0, null].includes(version2) ? version2 : "all"];
      return !!pattern && pattern.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsUUID.js
function isUUID(value, version2) {
  return typeof value === "string" && (0, import_isUUID.default)(value, version2);
}
function IsUUID(version2, validationOptions) {
  return ValidateBy({
    name: IS_UUID,
    constraints: [version2],
    validator: {
      validate: function(value, args) {
        return isUUID(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a UUID";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isUUID, IS_UUID;
var init_IsUUID = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsUUID.js"() {
    init_ValidateBy();
    import_isUUID = __toESM(require_isUUID());
    IS_UUID = "isUuid";
  }
});

// node_modules/class-validator/esm5/decorator/string/IsFirebasePushId.js
function isFirebasePushId(value) {
  var webSafeRegex = /^[a-zA-Z0-9_-]*$/;
  return typeof value === "string" && value.length === 20 && webSafeRegex.test(value);
}
function IsFirebasePushId(validationOptions) {
  return ValidateBy({
    name: IS_FIREBASE_PUSH_ID,
    validator: {
      validate: function(value, args) {
        return isFirebasePushId(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a Firebase Push Id";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_FIREBASE_PUSH_ID;
var init_IsFirebasePushId = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsFirebasePushId.js"() {
    init_ValidateBy();
    IS_FIREBASE_PUSH_ID = "IsFirebasePushId";
  }
});

// node_modules/validator/lib/isUppercase.js
var require_isUppercase = __commonJS({
  "node_modules/validator/lib/isUppercase.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isUppercase2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isUppercase2(str) {
      (0, _assertString.default)(str);
      return str === str.toUpperCase();
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsUppercase.js
function isUppercase(value) {
  return typeof value === "string" && (0, import_isUppercase.default)(value);
}
function IsUppercase(validationOptions) {
  return ValidateBy({
    name: IS_UPPERCASE,
    validator: {
      validate: function(value, args) {
        return isUppercase(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be uppercase";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isUppercase, IS_UPPERCASE;
var init_IsUppercase = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsUppercase.js"() {
    init_ValidateBy();
    import_isUppercase = __toESM(require_isUppercase());
    IS_UPPERCASE = "isUppercase";
  }
});

// node_modules/validator/lib/isLength.js
var require_isLength = __commonJS({
  "node_modules/validator/lib/isLength.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isLength;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof5(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof5 = function _typeof6(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof5 = function _typeof6(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof5(obj);
    }
    function isLength(str, options) {
      (0, _assertString.default)(str);
      var min2;
      var max2;
      if (_typeof5(options) === "object") {
        min2 = options.min || 0;
        max2 = options.max;
      } else {
        min2 = arguments[1] || 0;
        max2 = arguments[2];
      }
      var presentationSequences = str.match(/(\uFE0F|\uFE0E)/g) || [];
      var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
      var len = str.length - presentationSequences.length - surrogatePairs.length;
      return len >= min2 && (typeof max2 === "undefined" || len <= max2);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/Length.js
function length(value, min2, max2) {
  return typeof value === "string" && (0, import_isLength.default)(value, { min: min2, max: max2 });
}
function Length(min2, max2, validationOptions) {
  return ValidateBy({
    name: IS_LENGTH,
    constraints: [min2, max2],
    validator: {
      validate: function(value, args) {
        return length(value, args.constraints[0], args.constraints[1]);
      },
      defaultMessage: buildMessage(function(eachPrefix, args) {
        var isMinLength = args.constraints[0] !== null && args.constraints[0] !== void 0;
        var isMaxLength = args.constraints[1] !== null && args.constraints[1] !== void 0;
        if (isMinLength && (!args.value || args.value.length < args.constraints[0])) {
          return eachPrefix + "$property must be longer than or equal to $constraint1 characters";
        } else if (isMaxLength && args.value.length > args.constraints[1]) {
          return eachPrefix + "$property must be shorter than or equal to $constraint2 characters";
        }
        return eachPrefix + "$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isLength, IS_LENGTH;
var init_Length = __esm({
  "node_modules/class-validator/esm5/decorator/string/Length.js"() {
    init_ValidateBy();
    import_isLength = __toESM(require_isLength());
    IS_LENGTH = "isLength";
  }
});

// node_modules/class-validator/esm5/decorator/string/MaxLength.js
function maxLength(value, max2) {
  return typeof value === "string" && (0, import_isLength2.default)(value, { min: 0, max: max2 });
}
function MaxLength(max2, validationOptions) {
  return ValidateBy({
    name: MAX_LENGTH,
    constraints: [max2],
    validator: {
      validate: function(value, args) {
        return maxLength(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be shorter than or equal to $constraint1 characters";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isLength2, MAX_LENGTH;
var init_MaxLength = __esm({
  "node_modules/class-validator/esm5/decorator/string/MaxLength.js"() {
    init_ValidateBy();
    import_isLength2 = __toESM(require_isLength());
    MAX_LENGTH = "maxLength";
  }
});

// node_modules/class-validator/esm5/decorator/string/MinLength.js
function minLength(value, min2) {
  return typeof value === "string" && (0, import_isLength3.default)(value, { min: min2 });
}
function MinLength(min2, validationOptions) {
  return ValidateBy({
    name: MIN_LENGTH,
    constraints: [min2],
    validator: {
      validate: function(value, args) {
        return minLength(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be longer than or equal to $constraint1 characters";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isLength3, MIN_LENGTH;
var init_MinLength = __esm({
  "node_modules/class-validator/esm5/decorator/string/MinLength.js"() {
    init_ValidateBy();
    import_isLength3 = __toESM(require_isLength());
    MIN_LENGTH = "minLength";
  }
});

// node_modules/validator/lib/matches.js
var require_matches = __commonJS({
  "node_modules/validator/lib/matches.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = matches2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function matches2(str, pattern, modifiers) {
      (0, _assertString.default)(str);
      if (Object.prototype.toString.call(pattern) !== "[object RegExp]") {
        pattern = new RegExp(pattern, modifiers);
      }
      return !!str.match(pattern);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/Matches.js
function matches(value, pattern, modifiers) {
  return typeof value === "string" && (0, import_matches.default)(value, pattern, modifiers);
}
function Matches(pattern, modifiersOrAnnotationOptions, validationOptions) {
  var modifiers;
  if (modifiersOrAnnotationOptions && modifiersOrAnnotationOptions instanceof Object && !validationOptions) {
    validationOptions = modifiersOrAnnotationOptions;
  } else {
    modifiers = modifiersOrAnnotationOptions;
  }
  return ValidateBy({
    name: MATCHES,
    constraints: [pattern, modifiers],
    validator: {
      validate: function(value, args) {
        return matches(value, args.constraints[0], args.constraints[1]);
      },
      defaultMessage: buildMessage(function(eachPrefix, args) {
        return eachPrefix + "$property must match $constraint1 regular expression";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_matches, MATCHES;
var init_Matches = __esm({
  "node_modules/class-validator/esm5/decorator/string/Matches.js"() {
    init_ValidateBy();
    import_matches = __toESM(require_matches());
    MATCHES = "matches";
  }
});

// node_modules/libphonenumber-js/metadata.min.json.js
var metadata_min_json_default;
var init_metadata_min_json = __esm({
  "node_modules/libphonenumber-js/metadata.min.json.js"() {
    metadata_min_json_default = { "version": 4, "country_calling_codes": { "1": ["US", "AG", "AI", "AS", "BB", "BM", "BS", "CA", "DM", "DO", "GD", "GU", "JM", "KN", "KY", "LC", "MP", "MS", "PR", "SX", "TC", "TT", "VC", "VG", "VI"], "7": ["RU", "KZ"], "20": ["EG"], "27": ["ZA"], "30": ["GR"], "31": ["NL"], "32": ["BE"], "33": ["FR"], "34": ["ES"], "36": ["HU"], "39": ["IT", "VA"], "40": ["RO"], "41": ["CH"], "43": ["AT"], "44": ["GB", "GG", "IM", "JE"], "45": ["DK"], "46": ["SE"], "47": ["NO", "SJ"], "48": ["PL"], "49": ["DE"], "51": ["PE"], "52": ["MX"], "53": ["CU"], "54": ["AR"], "55": ["BR"], "56": ["CL"], "57": ["CO"], "58": ["VE"], "60": ["MY"], "61": ["AU", "CC", "CX"], "62": ["ID"], "63": ["PH"], "64": ["NZ"], "65": ["SG"], "66": ["TH"], "81": ["JP"], "82": ["KR"], "84": ["VN"], "86": ["CN"], "90": ["TR"], "91": ["IN"], "92": ["PK"], "93": ["AF"], "94": ["LK"], "95": ["MM"], "98": ["IR"], "211": ["SS"], "212": ["MA", "EH"], "213": ["DZ"], "216": ["TN"], "218": ["LY"], "220": ["GM"], "221": ["SN"], "222": ["MR"], "223": ["ML"], "224": ["GN"], "225": ["CI"], "226": ["BF"], "227": ["NE"], "228": ["TG"], "229": ["BJ"], "230": ["MU"], "231": ["LR"], "232": ["SL"], "233": ["GH"], "234": ["NG"], "235": ["TD"], "236": ["CF"], "237": ["CM"], "238": ["CV"], "239": ["ST"], "240": ["GQ"], "241": ["GA"], "242": ["CG"], "243": ["CD"], "244": ["AO"], "245": ["GW"], "246": ["IO"], "247": ["AC"], "248": ["SC"], "249": ["SD"], "250": ["RW"], "251": ["ET"], "252": ["SO"], "253": ["DJ"], "254": ["KE"], "255": ["TZ"], "256": ["UG"], "257": ["BI"], "258": ["MZ"], "260": ["ZM"], "261": ["MG"], "262": ["RE", "YT"], "263": ["ZW"], "264": ["NA"], "265": ["MW"], "266": ["LS"], "267": ["BW"], "268": ["SZ"], "269": ["KM"], "290": ["SH", "TA"], "291": ["ER"], "297": ["AW"], "298": ["FO"], "299": ["GL"], "350": ["GI"], "351": ["PT"], "352": ["LU"], "353": ["IE"], "354": ["IS"], "355": ["AL"], "356": ["MT"], "357": ["CY"], "358": ["FI", "AX"], "359": ["BG"], "370": ["LT"], "371": ["LV"], "372": ["EE"], "373": ["MD"], "374": ["AM"], "375": ["BY"], "376": ["AD"], "377": ["MC"], "378": ["SM"], "380": ["UA"], "381": ["RS"], "382": ["ME"], "383": ["XK"], "385": ["HR"], "386": ["SI"], "387": ["BA"], "389": ["MK"], "420": ["CZ"], "421": ["SK"], "423": ["LI"], "500": ["FK"], "501": ["BZ"], "502": ["GT"], "503": ["SV"], "504": ["HN"], "505": ["NI"], "506": ["CR"], "507": ["PA"], "508": ["PM"], "509": ["HT"], "590": ["GP", "BL", "MF"], "591": ["BO"], "592": ["GY"], "593": ["EC"], "594": ["GF"], "595": ["PY"], "596": ["MQ"], "597": ["SR"], "598": ["UY"], "599": ["CW", "BQ"], "670": ["TL"], "672": ["NF"], "673": ["BN"], "674": ["NR"], "675": ["PG"], "676": ["TO"], "677": ["SB"], "678": ["VU"], "679": ["FJ"], "680": ["PW"], "681": ["WF"], "682": ["CK"], "683": ["NU"], "685": ["WS"], "686": ["KI"], "687": ["NC"], "688": ["TV"], "689": ["PF"], "690": ["TK"], "691": ["FM"], "692": ["MH"], "850": ["KP"], "852": ["HK"], "853": ["MO"], "855": ["KH"], "856": ["LA"], "880": ["BD"], "886": ["TW"], "960": ["MV"], "961": ["LB"], "962": ["JO"], "963": ["SY"], "964": ["IQ"], "965": ["KW"], "966": ["SA"], "967": ["YE"], "968": ["OM"], "970": ["PS"], "971": ["AE"], "972": ["IL"], "973": ["BH"], "974": ["QA"], "975": ["BT"], "976": ["MN"], "977": ["NP"], "992": ["TJ"], "993": ["TM"], "994": ["AZ"], "995": ["GE"], "996": ["KG"], "998": ["UZ"] }, "countries": { "AC": ["247", "00", "(?:[01589]\\d|[46])\\d{4}", [5, 6]], "AD": ["376", "00", "(?:1|6\\d)\\d{7}|[135-9]\\d{5}", [6, 8, 9], [["(\\d{3})(\\d{3})", "$1 $2", ["[135-9]"]], ["(\\d{4})(\\d{4})", "$1 $2", ["1"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6"]]]], "AE": ["971", "00", "(?:[4-7]\\d|9[0-689])\\d{7}|800\\d{2,9}|[2-4679]\\d{7}", [5, 6, 7, 8, 9, 10, 11, 12], [["(\\d{3})(\\d{2,9})", "$1 $2", ["60|8"]], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[236]|[479][2-8]"], "0$1"], ["(\\d{3})(\\d)(\\d{5})", "$1 $2 $3", ["[479]"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["5"], "0$1"]], "0"], "AF": ["93", "00", "[2-7]\\d{8}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[2-7]"], "0$1"]], "0"], "AG": ["1", "011", "(?:268|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([457]\\d{6})$|1", "268$1", 0, "268"], "AI": ["1", "011", "(?:264|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2457]\\d{6})$|1", "264$1", 0, "264"], "AL": ["355", "00", "(?:700\\d\\d|900)\\d{3}|8\\d{5,7}|(?:[2-5]|6\\d)\\d{7}", [6, 7, 8, 9], [["(\\d{3})(\\d{3,4})", "$1 $2", ["80|9"], "0$1"], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["4[2-6]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2358][2-5]|4"], "0$1"], ["(\\d{3})(\\d{5})", "$1 $2", ["[23578]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["6"], "0$1"]], "0"], "AM": ["374", "00", "(?:[1-489]\\d|55|60|77)\\d{6}", [8], [["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["[89]0"], "0 $1"], ["(\\d{3})(\\d{5})", "$1 $2", ["2|3[12]"], "(0$1)"], ["(\\d{2})(\\d{6})", "$1 $2", ["1|47"], "(0$1)"], ["(\\d{2})(\\d{6})", "$1 $2", ["[3-9]"], "0$1"]], "0"], "AO": ["244", "00", "[29]\\d{8}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[29]"]]]], "AR": ["54", "00", "(?:11|[89]\\d\\d)\\d{8}|[2368]\\d{9}", [10, 11], [["(\\d{4})(\\d{2})(\\d{4})", "$1 $2-$3", ["2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9])", "2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8]))|2(?:2[24-9]|3[1-59]|47)", "2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5[56][46]|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]", "2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|58|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|54(?:4|5[13-7]|6[89])|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:454|85[56])[46]|3(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"], "0$1", 1], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2-$3", ["1"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2-$3", ["[68]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2-$3", ["[23]"], "0$1", 1], ["(\\d)(\\d{4})(\\d{2})(\\d{4})", "$2 15-$3-$4", ["9(?:2[2-469]|3[3-578])", "9(?:2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9]))", "9(?:2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8])))|92(?:2[24-9]|3[1-59]|47)", "9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5(?:[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]", "9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|5(?:4(?:4|5[13-7]|6[89])|[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"], "0$1", 0, "$1 $2 $3-$4"], ["(\\d)(\\d{2})(\\d{4})(\\d{4})", "$2 15-$3-$4", ["91"], "0$1", 0, "$1 $2 $3-$4"], ["(\\d{3})(\\d{3})(\\d{5})", "$1-$2-$3", ["8"], "0$1"], ["(\\d)(\\d{3})(\\d{3})(\\d{4})", "$2 15-$3-$4", ["9"], "0$1", 0, "$1 $2 $3-$4"]], "0", 0, "0?(?:(11|2(?:2(?:02?|[13]|2[13-79]|4[1-6]|5[2457]|6[124-8]|7[1-4]|8[13-6]|9[1267])|3(?:02?|1[467]|2[03-6]|3[13-8]|[49][2-6]|5[2-8]|[67])|4(?:7[3-578]|9)|6(?:[0136]|2[24-6]|4[6-8]?|5[15-8])|80|9(?:0[1-3]|[19]|2\\d|3[1-6]|4[02568]?|5[2-4]|6[2-46]|72?|8[23]?))|3(?:3(?:2[79]|6|8[2578])|4(?:0[0-24-9]|[12]|3[5-8]?|4[24-7]|5[4-68]?|6[02-9]|7[126]|8[2379]?|9[1-36-8])|5(?:1|2[1245]|3[237]?|4[1-46-9]|6[2-4]|7[1-6]|8[2-5]?)|6[24]|7(?:[069]|1[1568]|2[15]|3[145]|4[13]|5[14-8]|7[2-57]|8[126])|8(?:[01]|2[15-7]|3[2578]?|4[13-6]|5[4-8]?|6[1-357-9]|7[36-8]?|8[5-8]?|9[124])))15)?", "9$1"], "AS": ["1", "011", "(?:[58]\\d\\d|684|900)\\d{7}", [10], 0, "1", 0, "([267]\\d{6})$|1", "684$1", 0, "684"], "AT": ["43", "00", "1\\d{3,12}|2\\d{6,12}|43(?:(?:0\\d|5[02-9])\\d{3,9}|2\\d{4,5}|[3467]\\d{4}|8\\d{4,6}|9\\d{4,7})|5\\d{4,12}|8\\d{7,12}|9\\d{8,12}|(?:[367]\\d|4[0-24-9])\\d{4,11}", [4, 5, 6, 7, 8, 9, 10, 11, 12, 13], [["(\\d)(\\d{3,12})", "$1 $2", ["1(?:11|[2-9])"], "0$1"], ["(\\d{3})(\\d{2})", "$1 $2", ["517"], "0$1"], ["(\\d{2})(\\d{3,5})", "$1 $2", ["5[079]"], "0$1"], ["(\\d{3})(\\d{3,10})", "$1 $2", ["(?:31|4)6|51|6(?:5[0-3579]|[6-9])|7(?:20|32|8)|[89]"], "0$1"], ["(\\d{4})(\\d{3,9})", "$1 $2", ["[2-467]|5[2-6]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["5"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4,7})", "$1 $2 $3", ["5"], "0$1"]], "0"], "AU": ["61", "001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011", "1(?:[0-79]\\d{7}(?:\\d(?:\\d{2})?)?|8[0-24-9]\\d{7})|[2-478]\\d{8}|1\\d{4,7}", [5, 6, 7, 8, 9, 10, 12], [["(\\d{2})(\\d{3,4})", "$1 $2", ["16"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2,4})", "$1 $2 $3", ["16"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["14|4"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["[2378]"], "(0$1)"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1(?:30|[89])"]]], "0", 0, "(183[12])|0", 0, 0, 0, [["(?:(?:2(?:[0-26-9]\\d|3[0-8]|4[02-9]|5[0135-9])|3(?:[0-3589]\\d|4[0-578]|6[1-9]|7[0-35-9])|7(?:[013-57-9]\\d|2[0-8]))\\d{3}|8(?:51(?:0(?:0[03-9]|[12479]\\d|3[2-9]|5[0-8]|6[1-9]|8[0-7])|1(?:[0235689]\\d|1[0-69]|4[0-589]|7[0-47-9])|2(?:0[0-79]|[18][13579]|2[14-9]|3[0-46-9]|[4-6]\\d|7[89]|9[0-4]))|(?:6[0-8]|[78]\\d)\\d{3}|9(?:[02-9]\\d{3}|1(?:(?:[0-58]\\d|6[0135-9])\\d|7(?:0[0-24-9]|[1-9]\\d)|9(?:[0-46-9]\\d|5[0-79])))))\\d{3}", [9]], ["4(?:79[01]|83[0-389]|93[0-6])\\d{5}|4(?:[0-3]\\d|4[047-9]|5[0-25-9]|6[016-9]|7[02-8]|8[0-24-9]|9[0-27-9])\\d{6}", [9]], ["180(?:0\\d{3}|2)\\d{3}", [7, 10]], ["190[0-26]\\d{6}", [10]], 0, 0, 0, ["163\\d{2,6}", [5, 6, 7, 8, 9]], ["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}", [9]], ["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}", [6, 8, 10, 12]]], "0011"], "AW": ["297", "00", "(?:[25-79]\\d\\d|800)\\d{4}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[25-9]"]]]], "AX": ["358", "00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))", "2\\d{4,9}|35\\d{4,5}|(?:60\\d\\d|800)\\d{4,6}|7\\d{5,11}|(?:[14]\\d|3[0-46-9]|50)\\d{4,8}", [5, 6, 7, 8, 9, 10, 11, 12], 0, "0", 0, 0, 0, 0, "18", 0, "00"], "AZ": ["994", "00", "365\\d{6}|(?:[124579]\\d|60|88)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["90"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["1[28]|2|365|46", "1[28]|2|365[45]|46", "1[28]|2|365(?:4|5[02])|46"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[13-9]"], "0$1"]], "0"], "BA": ["387", "00", "6\\d{8}|(?:[35689]\\d|49|70)\\d{6}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["6[1-3]|[7-9]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2-$3", ["[3-5]|6[56]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["6"], "0$1"]], "0"], "BB": ["1", "011", "(?:246|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "246$1", 0, "246"], "BD": ["880", "00", "[1-469]\\d{9}|8[0-79]\\d{7,8}|[2-79]\\d{8}|[2-9]\\d{7}|[3-9]\\d{6}|[57-9]\\d{5}", [6, 7, 8, 9, 10], [["(\\d{2})(\\d{4,6})", "$1-$2", ["31[5-8]|[459]1"], "0$1"], ["(\\d{3})(\\d{3,7})", "$1-$2", ["3(?:[67]|8[013-9])|4(?:6[168]|7|[89][18])|5(?:6[128]|9)|6(?:28|4[14]|5)|7[2-589]|8(?:0[014-9]|[12])|9[358]|(?:3[2-5]|4[235]|5[2-578]|6[0389]|76|8[3-7]|9[24])1|(?:44|66)[01346-9]"], "0$1"], ["(\\d{4})(\\d{3,6})", "$1-$2", ["[13-9]|22"], "0$1"], ["(\\d)(\\d{7,8})", "$1-$2", ["2"], "0$1"]], "0"], "BE": ["32", "00", "4\\d{8}|[1-9]\\d{7}", [8, 9], [["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["(?:80|9)0"], "0$1"], ["(\\d)(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[239]|4[23]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[15-8]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["4"], "0$1"]], "0"], "BF": ["226", "00", "[025-7]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[025-7]"]]]], "BG": ["359", "00", "00800\\d{7}|[2-7]\\d{6,7}|[89]\\d{6,8}|2\\d{5}", [6, 7, 8, 9, 12], [["(\\d)(\\d)(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["2"], "0$1"], ["(\\d{3})(\\d{4})", "$1 $2", ["43[1-6]|70[1-9]"], "0$1"], ["(\\d)(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2,3})", "$1 $2 $3", ["[356]|4[124-7]|7[1-9]|8[1-6]|9[1-7]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["(?:70|8)0"], "0$1"], ["(\\d{3})(\\d{3})(\\d{2})", "$1 $2 $3", ["43[1-7]|7"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[48]|9[08]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["9"], "0$1"]], "0"], "BH": ["973", "00", "[136-9]\\d{7}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[13679]|8[047]"]]]], "BI": ["257", "00", "(?:[267]\\d|31)\\d{6}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2367]"]]]], "BJ": ["229", "00", "[24-689]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[24-689]"]]]], "BL": ["590", "00", "590\\d{6}|(?:69|80|9\\d)\\d{7}", [9], 0, "0", 0, 0, 0, 0, 0, [["590(?:2[7-9]|5[12]|87)\\d{4}"], ["69(?:0\\d\\d|1(?:2[2-9]|3[0-5]))\\d{4}"], ["80[0-5]\\d{6}"], 0, 0, 0, 0, 0, ["9(?:(?:395|76[018])\\d|475[0-2])\\d{4}"]]], "BM": ["1", "011", "(?:441|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "441$1", 0, "441"], "BN": ["673", "00", "[2-578]\\d{6}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-578]"]]]], "BO": ["591", "00(?:1\\d)?", "(?:[2-467]\\d\\d|8001)\\d{5}", [8, 9], [["(\\d)(\\d{7})", "$1 $2", ["[23]|4[46]"]], ["(\\d{8})", "$1", ["[67]"]], ["(\\d{3})(\\d{2})(\\d{4})", "$1 $2 $3", ["8"]]], "0", 0, "0(1\\d)?"], "BQ": ["599", "00", "(?:[34]1|7\\d)\\d{5}", [7], 0, 0, 0, 0, 0, 0, "[347]"], "BR": ["55", "00(?:1[245]|2[1-35]|31|4[13]|[56]5|99)", "(?:[1-46-9]\\d\\d|5(?:[0-46-9]\\d|5[0-46-9]))\\d{8}|[1-9]\\d{9}|[3589]\\d{8}|[34]\\d{7}", [8, 9, 10, 11], [["(\\d{4})(\\d{4})", "$1-$2", ["300|4(?:0[02]|37)", "4(?:02|37)0|[34]00"]], ["(\\d{3})(\\d{2,3})(\\d{4})", "$1 $2 $3", ["(?:[358]|90)0"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2-$3", ["(?:[14689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])[2-57]"], "($1)"], ["(\\d{2})(\\d{5})(\\d{4})", "$1 $2-$3", ["[16][1-9]|[2-57-9]"], "($1)"]], "0", 0, "(?:0|90)(?:(1[245]|2[1-35]|31|4[13]|[56]5|99)(\\d{10,11}))?", "$2"], "BS": ["1", "011", "(?:242|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([3-8]\\d{6})$|1", "242$1", 0, "242"], "BT": ["975", "00", "[17]\\d{7}|[2-8]\\d{6}", [7, 8], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-68]|7[246]"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["1[67]|7"]]]], "BW": ["267", "00", "(?:0800|(?:[37]|800)\\d)\\d{6}|(?:[2-6]\\d|90)\\d{5}", [7, 8, 10], [["(\\d{2})(\\d{5})", "$1 $2", ["90"]], ["(\\d{3})(\\d{4})", "$1 $2", ["[24-6]|3[15-79]"]], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[37]"]], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["0"]], ["(\\d{3})(\\d{4})(\\d{3})", "$1 $2 $3", ["8"]]]], "BY": ["375", "810", "(?:[12]\\d|33|44|902)\\d{7}|8(?:0[0-79]\\d{5,7}|[1-7]\\d{9})|8(?:1[0-489]|[5-79]\\d)\\d{7}|8[1-79]\\d{6,7}|8[0-79]\\d{5}|8\\d{5}", [6, 7, 8, 9, 10, 11], [["(\\d{3})(\\d{3})", "$1 $2", ["800"], "8 $1"], ["(\\d{3})(\\d{2})(\\d{2,4})", "$1 $2 $3", ["800"], "8 $1"], ["(\\d{4})(\\d{2})(\\d{3})", "$1 $2-$3", ["1(?:5[169]|6[3-5]|7[179])|2(?:1[35]|2[34]|3[3-5])", "1(?:5[169]|6(?:3[1-3]|4|5[125])|7(?:1[3-9]|7[0-24-6]|9[2-7]))|2(?:1[35]|2[34]|3[3-5])"], "8 0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["1(?:[56]|7[467])|2[1-3]"], "8 0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["[1-4]"], "8 0$1"], ["(\\d{3})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["[89]"], "8 $1"]], "8", 0, "0|80?", 0, 0, 0, 0, "8~10"], "BZ": ["501", "00", "(?:0800\\d|[2-8])\\d{6}", [7, 11], [["(\\d{3})(\\d{4})", "$1-$2", ["[2-8]"]], ["(\\d)(\\d{3})(\\d{4})(\\d{3})", "$1-$2-$3-$4", ["0"]]]], "CA": ["1", "011", "(?:[2-8]\\d|90)\\d{8}|3\\d{6}", [7, 10], 0, "1", 0, 0, 0, 0, 0, [["(?:2(?:04|[23]6|[48]9|50|63)|3(?:06|43|54|6[578]|82)|4(?:03|1[68]|[26]8|3[178]|50|74)|5(?:06|1[49]|48|79|8[147])|6(?:04|[18]3|39|47|72)|7(?:0[59]|42|53|78|8[02])|8(?:[06]7|19|25|73)|90[25])[2-9]\\d{6}", [10]], ["", [10]], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}", [10]], ["900[2-9]\\d{6}", [10]], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|(?:5(?:00|2[125-9]|33|44|66|77|88)|622)[2-9]\\d{6}", [10]], 0, ["310\\d{4}", [7]], 0, ["600[2-9]\\d{6}", [10]]]], "CC": ["61", "001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011", "1(?:[0-79]\\d{8}(?:\\d{2})?|8[0-24-9]\\d{7})|[148]\\d{8}|1\\d{5,7}", [6, 7, 8, 9, 10, 12], 0, "0", 0, "([59]\\d{7})$|0", "8$1", 0, 0, [["8(?:51(?:0(?:02|31|60|89)|1(?:18|76)|223)|91(?:0(?:1[0-2]|29)|1(?:[28]2|50|79)|2(?:10|64)|3(?:[06]8|22)|4[29]8|62\\d|70[23]|959))\\d{3}", [9]], ["4(?:79[01]|83[0-389]|93[0-6])\\d{5}|4(?:[0-3]\\d|4[047-9]|5[0-25-9]|6[016-9]|7[02-8]|8[0-24-9]|9[0-27-9])\\d{6}", [9]], ["180(?:0\\d{3}|2)\\d{3}", [7, 10]], ["190[0-26]\\d{6}", [10]], 0, 0, 0, 0, ["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}", [9]], ["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}", [6, 8, 10, 12]]], "0011"], "CD": ["243", "00", "[189]\\d{8}|[1-68]\\d{6}", [7, 9], [["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["88"], "0$1"], ["(\\d{2})(\\d{5})", "$1 $2", ["[1-6]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[89]"], "0$1"]], "0"], "CF": ["236", "00", "(?:[27]\\d{3}|8776)\\d{4}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[278]"]]]], "CG": ["242", "00", "222\\d{6}|(?:0\\d|80)\\d{7}", [9], [["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["8"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[02]"]]]], "CH": ["41", "00", "8\\d{11}|[2-9]\\d{8}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8[047]|90"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-79]|81"], "0$1"], ["(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["8"], "0$1"]], "0"], "CI": ["225", "00", "[02]\\d{9}", [10], [["(\\d{2})(\\d{2})(\\d)(\\d{5})", "$1 $2 $3 $4", ["2"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3 $4", ["0"]]]], "CK": ["682", "00", "[2-578]\\d{4}", [5], [["(\\d{2})(\\d{3})", "$1 $2", ["[2-578]"]]]], "CL": ["56", "(?:0|1(?:1[0-69]|2[02-5]|5[13-58]|69|7[0167]|8[018]))0", "12300\\d{6}|6\\d{9,10}|[2-9]\\d{8}", [9, 10, 11], [["(\\d{5})(\\d{4})", "$1 $2", ["219", "2196"], "($1)"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["44"]], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["2[1-36]"], "($1)"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["9[2-9]"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["3[2-5]|[47]|5[1-3578]|6[13-57]|8(?:0[1-9]|[1-9])"], "($1)"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["60|8"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]], ["(\\d{3})(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["60"]]]], "CM": ["237", "00", "[26]\\d{8}|88\\d{6,7}", [8, 9], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["88"]], ["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["[26]|88"]]]], "CN": ["86", "00|1(?:[12]\\d|79)\\d\\d00", "1[127]\\d{8,9}|2\\d{9}(?:\\d{2})?|[12]\\d{6,7}|86\\d{6}|(?:1[03-689]\\d|6)\\d{7,9}|(?:[3-579]\\d|8[0-57-9])\\d{6,9}", [7, 8, 9, 10, 11, 12], [["(\\d{2})(\\d{5,6})", "$1 $2", ["(?:10|2[0-57-9])[19]", "(?:10|2[0-57-9])(?:10|9[56])", "10(?:10|9[56])|2[0-57-9](?:100|9[56])"], "0$1"], ["(\\d{3})(\\d{5,6})", "$1 $2", ["3(?:[157]|35|49|9[1-68])|4(?:[17]|2[179]|6[47-9]|8[23])|5(?:[1357]|2[37]|4[36]|6[1-46]|80)|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]|4[13]|5[1-5])|(?:4[35]|59|85)[1-9]", "(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))[19]", "85[23](?:10|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:10|9[56])", "85[23](?:100|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:100|9[56])"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["(?:4|80)0"]], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["10|2(?:[02-57-9]|1[1-9])", "10|2(?:[02-57-9]|1[1-9])", "10[0-79]|2(?:[02-57-9]|1[1-79])|(?:10|21)8(?:0[1-9]|[1-9])"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["3(?:[3-59]|7[02-68])|4(?:[26-8]|3[3-9]|5[2-9])|5(?:3[03-9]|[468]|7[028]|9[2-46-9])|6|7(?:[0-247]|3[04-9]|5[0-4689]|6[2368])|8(?:[1-358]|9[1-7])|9(?:[013479]|5[1-5])|(?:[34]1|55|79|87)[02-9]"], "0$1", 1], ["(\\d{3})(\\d{7,8})", "$1 $2", ["9"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["80"], "0$1", 1], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["[3-578]"], "0$1", 1], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["1[3-9]"]], ["(\\d{2})(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3 $4", ["[12]"], "0$1", 1]], "0", 0, "(1(?:[12]\\d|79)\\d\\d)|0", 0, 0, 0, 0, "00"], "CO": ["57", "00(?:4(?:[14]4|56)|[579])", "(?:60\\d\\d|9101)\\d{6}|(?:1\\d|3)\\d{9}", [10, 11], [["(\\d{3})(\\d{7})", "$1 $2", ["6"], "($1)"], ["(\\d{3})(\\d{7})", "$1 $2", ["3[0-357]|91"]], ["(\\d)(\\d{3})(\\d{7})", "$1-$2-$3", ["1"], "0$1", 0, "$1 $2 $3"]], "0", 0, "0(4(?:[14]4|56)|[579])?"], "CR": ["506", "00", "(?:8\\d|90)\\d{8}|(?:[24-8]\\d{3}|3005)\\d{4}", [8, 10], [["(\\d{4})(\\d{4})", "$1 $2", ["[2-7]|8[3-9]"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2-$3", ["[89]"]]], 0, 0, "(19(?:0[0-2468]|1[09]|20|66|77|99))"], "CU": ["53", "119", "[27]\\d{6,7}|[34]\\d{5,7}|(?:5|8\\d\\d)\\d{7}", [6, 7, 8, 10], [["(\\d{2})(\\d{4,6})", "$1 $2", ["2[1-4]|[34]"], "(0$1)"], ["(\\d)(\\d{6,7})", "$1 $2", ["7"], "(0$1)"], ["(\\d)(\\d{7})", "$1 $2", ["5"], "0$1"], ["(\\d{3})(\\d{7})", "$1 $2", ["8"], "0$1"]], "0"], "CV": ["238", "0", "(?:[2-59]\\d\\d|800)\\d{4}", [7], [["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["[2-589]"]]]], "CW": ["599", "00", "(?:[34]1|60|(?:7|9\\d)\\d)\\d{5}", [7, 8], [["(\\d{3})(\\d{4})", "$1 $2", ["[3467]"]], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["9[4-8]"]]], 0, 0, 0, 0, 0, "[69]"], "CX": ["61", "001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011", "1(?:[0-79]\\d{8}(?:\\d{2})?|8[0-24-9]\\d{7})|[148]\\d{8}|1\\d{5,7}", [6, 7, 8, 9, 10, 12], 0, "0", 0, "([59]\\d{7})$|0", "8$1", 0, 0, [["8(?:51(?:0(?:01|30|59|88)|1(?:17|46|75)|2(?:22|35))|91(?:00[6-9]|1(?:[28]1|49|78)|2(?:09|63)|3(?:12|26|75)|4(?:56|97)|64\\d|7(?:0[01]|1[0-2])|958))\\d{3}", [9]], ["4(?:79[01]|83[0-389]|93[0-6])\\d{5}|4(?:[0-3]\\d|4[047-9]|5[0-25-9]|6[016-9]|7[02-8]|8[0-24-9]|9[0-27-9])\\d{6}", [9]], ["180(?:0\\d{3}|2)\\d{3}", [7, 10]], ["190[0-26]\\d{6}", [10]], 0, 0, 0, 0, ["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}", [9]], ["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}", [6, 8, 10, 12]]], "0011"], "CY": ["357", "00", "(?:[279]\\d|[58]0)\\d{6}", [8], [["(\\d{2})(\\d{6})", "$1 $2", ["[257-9]"]]]], "CZ": ["420", "00", "(?:[2-578]\\d|60)\\d{7}|9\\d{8,11}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-8]|9[015-7]"]], ["(\\d{2})(\\d{3})(\\d{3})(\\d{2})", "$1 $2 $3 $4", ["96"]], ["(\\d{2})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["9"]], ["(\\d{3})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["9"]]]], "DE": ["49", "00", "[2579]\\d{5,14}|49(?:[34]0|69|8\\d)\\d\\d?|49(?:37|49|60|7[089]|9\\d)\\d{1,3}|49(?:2[024-9]|3[2-689]|7[1-7])\\d{1,8}|(?:1|[368]\\d|4[0-8])\\d{3,13}|49(?:[015]\\d|2[13]|31|[46][1-8])\\d{1,9}", [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], [["(\\d{2})(\\d{3,13})", "$1 $2", ["3[02]|40|[68]9"], "0$1"], ["(\\d{3})(\\d{3,12})", "$1 $2", ["2(?:0[1-389]|1[124]|2[18]|3[14])|3(?:[35-9][15]|4[015])|906|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1", "2(?:0[1-389]|12[0-8])|3(?:[35-9][15]|4[015])|906|2(?:[13][14]|2[18])|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1"], "0$1"], ["(\\d{4})(\\d{2,11})", "$1 $2", ["[24-6]|3(?:[3569][02-46-9]|4[2-4679]|7[2-467]|8[2-46-8])|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]", "[24-6]|3(?:3(?:0[1-467]|2[127-9]|3[124578]|7[1257-9]|8[1256]|9[145])|4(?:2[135]|4[13578]|9[1346])|5(?:0[14]|2[1-3589]|6[1-4]|7[13468]|8[13568])|6(?:2[1-489]|3[124-6]|6[13]|7[12579]|8[1-356]|9[135])|7(?:2[1-7]|4[145]|6[1-5]|7[1-4])|8(?:21|3[1468]|6|7[1467]|8[136])|9(?:0[12479]|2[1358]|4[134679]|6[1-9]|7[136]|8[147]|9[1468]))|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]|3[68]4[1347]|3(?:47|60)[1356]|3(?:3[46]|46|5[49])[1246]|3[4579]3[1357]"], "0$1"], ["(\\d{3})(\\d{4})", "$1 $2", ["138"], "0$1"], ["(\\d{5})(\\d{2,10})", "$1 $2", ["3"], "0$1"], ["(\\d{3})(\\d{5,11})", "$1 $2", ["181"], "0$1"], ["(\\d{3})(\\d)(\\d{4,10})", "$1 $2 $3", ["1(?:3|80)|9"], "0$1"], ["(\\d{3})(\\d{7,8})", "$1 $2", ["1[67]"], "0$1"], ["(\\d{3})(\\d{7,12})", "$1 $2", ["8"], "0$1"], ["(\\d{5})(\\d{6})", "$1 $2", ["185", "1850", "18500"], "0$1"], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["7"], "0$1"], ["(\\d{4})(\\d{7})", "$1 $2", ["18[68]"], "0$1"], ["(\\d{5})(\\d{6})", "$1 $2", ["15[0568]"], "0$1"], ["(\\d{4})(\\d{7})", "$1 $2", ["15[1279]"], "0$1"], ["(\\d{3})(\\d{8})", "$1 $2", ["18"], "0$1"], ["(\\d{3})(\\d{2})(\\d{7,8})", "$1 $2 $3", ["1(?:6[023]|7)"], "0$1"], ["(\\d{4})(\\d{2})(\\d{7})", "$1 $2 $3", ["15[279]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{8})", "$1 $2 $3", ["15"], "0$1"]], "0"], "DJ": ["253", "00", "(?:2\\d|77)\\d{6}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[27]"]]]], "DK": ["45", "00", "[2-9]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-9]"]]]], "DM": ["1", "011", "(?:[58]\\d\\d|767|900)\\d{7}", [10], 0, "1", 0, "([2-7]\\d{6})$|1", "767$1", 0, "767"], "DO": ["1", "011", "(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, 0, 0, 0, "8001|8[024]9"], "DZ": ["213", "00", "(?:[1-4]|[5-79]\\d|80)\\d{7}", [8, 9], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[1-4]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["9"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-8]"], "0$1"]], "0"], "EC": ["593", "00", "1\\d{9,10}|(?:[2-7]|9\\d)\\d{7}", [8, 9, 10, 11], [["(\\d)(\\d{3})(\\d{4})", "$1 $2-$3", ["[2-7]"], "(0$1)", 0, "$1-$2-$3"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["9"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["1"]]], "0"], "EE": ["372", "00", "8\\d{9}|[4578]\\d{7}|(?:[3-8]\\d|90)\\d{5}", [7, 8, 10], [["(\\d{3})(\\d{4})", "$1 $2", ["[369]|4[3-8]|5(?:[0-2]|5[0-478]|6[45])|7[1-9]|88", "[369]|4[3-8]|5(?:[02]|1(?:[0-8]|95)|5[0-478]|6(?:4[0-4]|5[1-589]))|7[1-9]|88"]], ["(\\d{4})(\\d{3,4})", "$1 $2", ["[45]|8(?:00|[1-49])", "[45]|8(?:00[1-9]|[1-49])"]], ["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["7"]], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]]]], "EG": ["20", "00", "[189]\\d{8,9}|[24-6]\\d{8}|[135]\\d{7}", [8, 9, 10], [["(\\d)(\\d{7,8})", "$1 $2", ["[23]"], "0$1"], ["(\\d{2})(\\d{6,7})", "$1 $2", ["1[35]|[4-6]|8[2468]|9[235-7]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[189]"], "0$1"]], "0"], "EH": ["212", "00", "[5-8]\\d{8}", [9], 0, "0", 0, 0, 0, 0, "528[89]"], "ER": ["291", "00", "[178]\\d{6}", [7], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[178]"], "0$1"]], "0"], "ES": ["34", "00", "[5-9]\\d{8}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[89]00"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-9]"]]]], "ET": ["251", "00", "(?:11|[2-579]\\d)\\d{7}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1-579]"], "0$1"]], "0"], "FI": ["358", "00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))", "[1-35689]\\d{4}|7\\d{10,11}|(?:[124-7]\\d|3[0-46-9])\\d{8}|[1-9]\\d{5,8}", [5, 6, 7, 8, 9, 10, 11, 12], [["(\\d)(\\d{4,9})", "$1 $2", ["[2568][1-8]|3(?:0[1-9]|[1-9])|9"], "0$1"], ["(\\d{3})(\\d{3,7})", "$1 $2", ["[12]00|[368]|70[07-9]"], "0$1"], ["(\\d{2})(\\d{4,8})", "$1 $2", ["[1245]|7[135]"], "0$1"], ["(\\d{2})(\\d{6,10})", "$1 $2", ["7"], "0$1"]], "0", 0, 0, 0, 0, "1[03-79]|[2-9]", 0, "00"], "FJ": ["679", "0(?:0|52)", "45\\d{5}|(?:0800\\d|[235-9])\\d{6}", [7, 11], [["(\\d{3})(\\d{4})", "$1 $2", ["[235-9]|45"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["0"]]], 0, 0, 0, 0, 0, 0, 0, "00"], "FK": ["500", "00", "[2-7]\\d{4}", [5]], "FM": ["691", "00", "(?:[39]\\d\\d|820)\\d{4}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[389]"]]]], "FO": ["298", "00", "[2-9]\\d{5}", [6], [["(\\d{6})", "$1", ["[2-9]"]]], 0, 0, "(10(?:01|[12]0|88))"], "FR": ["33", "00", "[1-9]\\d{8}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0 $1"], ["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["[1-79]"], "0$1"]], "0"], "GA": ["241", "00", "(?:[067]\\d|11)\\d{6}|[2-7]\\d{6}", [7, 8], [["(\\d)(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-7]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["0"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["11|[67]"], "0$1"]], 0, 0, "0(11\\d{6}|60\\d{6}|61\\d{6}|6[256]\\d{6}|7[467]\\d{6})", "$1"], "GB": ["44", "00", "[1-357-9]\\d{9}|[18]\\d{8}|8\\d{6}", [7, 9, 10], [["(\\d{3})(\\d{4})", "$1 $2", ["800", "8001", "80011", "800111", "8001111"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["845", "8454", "84546", "845464"], "0$1"], ["(\\d{3})(\\d{6})", "$1 $2", ["800"], "0$1"], ["(\\d{5})(\\d{4,5})", "$1 $2", ["1(?:38|5[23]|69|76|94)", "1(?:(?:38|69)7|5(?:24|39)|768|946)", "1(?:3873|5(?:242|39[4-6])|(?:697|768)[347]|9467)"], "0$1"], ["(\\d{4})(\\d{5,6})", "$1 $2", ["1(?:[2-69][02-9]|[78])"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["[25]|7(?:0|6[02-9])", "[25]|7(?:0|6(?:[03-9]|2[356]))"], "0$1"], ["(\\d{4})(\\d{6})", "$1 $2", ["7"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1389]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:1(?:1(?:3(?:[0-58]\\d\\d|73[0235])|4(?:[0-5]\\d\\d|69[7-9]|70[0-579])|(?:(?:5[0-26-9]|[78][0-49])\\d|6(?:[0-4]\\d|50))\\d)|2(?:(?:0[024-9]|2[3-9]|3[3-79]|4[1-689]|[58][02-9]|6[0-47-9]|7[013-9]|9\\d)\\d\\d|1(?:[0-7]\\d\\d|8(?:[02]\\d|1[0-46-9])))|(?:3(?:0\\d|1[0-8]|[25][02-9]|3[02-579]|[468][0-46-9]|7[1-35-79]|9[2-578])|4(?:0[03-9]|[137]\\d|[28][02-57-9]|4[02-69]|5[0-8]|[69][0-79])|5(?:0[1-35-9]|[16]\\d|2[024-9]|3[015689]|4[02-9]|5[03-9]|7[0-35-9]|8[0-468]|9[0-57-9])|6(?:0[034689]|1\\d|2[0-35689]|[38][013-9]|4[1-467]|5[0-69]|6[13-9]|7[0-8]|9[0-24578])|7(?:0[0246-9]|2\\d|3[0236-8]|4[03-9]|5[0-46-9]|6[013-9]|7[0-35-9]|8[024-9]|9[02-9])|8(?:0[35-9]|2[1-57-9]|3[02-578]|4[0-578]|5[124-9]|6[2-69]|7\\d|8[02-9]|9[02569])|9(?:0[02-589]|[18]\\d|2[02-689]|3[1-57-9]|4[2-9]|5[0-579]|6[2-47-9]|7[0-24578]|9[2-57]))\\d\\d)|2(?:0[013478]|3[0189]|4[017]|8[0-46-9]|9[0-2])\\d{3})\\d{4}|1(?:2(?:0(?:46[1-4]|87[2-9])|545[1-79]|76(?:2\\d|3[1-8]|6[1-6])|9(?:7(?:2[0-4]|3[2-5])|8(?:2[2-8]|7[0-47-9]|8[3-5])))|3(?:6(?:38[2-5]|47[23])|8(?:47[04-9]|64[0157-9]))|4(?:044[1-7]|20(?:2[23]|8\\d)|6(?:0(?:30|5[2-57]|6[1-8]|7[2-8])|140)|8(?:052|87[1-3]))|5(?:2(?:4(?:3[2-79]|6\\d)|76\\d)|6(?:26[06-9]|686))|6(?:06(?:4\\d|7[4-79])|295[5-7]|35[34]\\d|47(?:24|61)|59(?:5[08]|6[67]|74)|9(?:55[0-4]|77[23]))|7(?:26(?:6[13-9]|7[0-7])|(?:442|688)\\d|50(?:2[0-3]|[3-68]2|76))|8(?:27[56]\\d|37(?:5[2-5]|8[239])|843[2-58])|9(?:0(?:0(?:6[1-8]|85)|52\\d)|3583|4(?:66[1-8]|9(?:2[01]|81))|63(?:23|3[1-4])|9561))\\d{3}", [9, 10]], ["7(?:457[0-57-9]|700[01]|911[028])\\d{5}|7(?:[1-3]\\d\\d|4(?:[0-46-9]\\d|5[0-689])|5(?:0[0-8]|[13-9]\\d|2[0-35-9])|7(?:0[1-9]|[1-7]\\d|8[02-9]|9[0-689])|8(?:[014-9]\\d|[23][0-8])|9(?:[024-9]\\d|1[02-9]|3[0-689]))\\d{6}", [10]], ["80[08]\\d{7}|800\\d{6}|8001111"], ["(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[2-49]))\\d{7}|845464\\d", [7, 10]], ["70\\d{8}", [10]], 0, ["(?:3[0347]|55)\\d{8}", [10]], ["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}", [10]], ["56\\d{8}", [10]]], 0, " x"], "GD": ["1", "011", "(?:473|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "473$1", 0, "473"], "GE": ["995", "00", "(?:[3-57]\\d\\d|800)\\d{6}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["70"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["32"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[57]"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[348]"], "0$1"]], "0"], "GF": ["594", "00", "[56]94\\d{6}|(?:80|9\\d)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[56]|9[47]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[89]"], "0$1"]], "0"], "GG": ["44", "00", "(?:1481|[357-9]\\d{3})\\d{6}|8\\d{6}(?:\\d{2})?", [7, 9, 10], 0, "0", 0, "([25-9]\\d{5})$|0", "1481$1", 0, 0, [["1481[25-9]\\d{5}", [10]], ["7(?:(?:781|839)\\d|911[17])\\d{5}", [10]], ["80[08]\\d{7}|800\\d{6}|8001111"], ["(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[0-3]))\\d{7}|845464\\d", [7, 10]], ["70\\d{8}", [10]], 0, ["(?:3[0347]|55)\\d{8}", [10]], ["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}", [10]], ["56\\d{8}", [10]]]], "GH": ["233", "00", "(?:[235]\\d{3}|800)\\d{5}", [8, 9], [["(\\d{3})(\\d{5})", "$1 $2", ["8"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[235]"], "0$1"]], "0"], "GI": ["350", "00", "(?:[25]\\d|60)\\d{6}", [8], [["(\\d{3})(\\d{5})", "$1 $2", ["2"]]]], "GL": ["299", "00", "(?:19|[2-689]\\d|70)\\d{4}", [6], [["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["19|[2-9]"]]]], "GM": ["220", "00", "[2-9]\\d{6}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-9]"]]]], "GN": ["224", "00", "722\\d{6}|(?:3|6\\d)\\d{7}", [8, 9], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["3"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[67]"]]]], "GP": ["590", "00", "590\\d{6}|(?:69|80|9\\d)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[569]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0$1"]], "0", 0, 0, 0, 0, 0, [["590(?:0[1-68]|[14][0-24-9]|2[0-68]|3[1289]|5[3-579]|[68][0-689]|7[08]|9\\d)\\d{4}"], ["69(?:0\\d\\d|1(?:2[2-9]|3[0-5]))\\d{4}"], ["80[0-5]\\d{6}"], 0, 0, 0, 0, 0, ["9(?:(?:395|76[018])\\d|475[0-2])\\d{4}"]]], "GQ": ["240", "00", "222\\d{6}|(?:3\\d|55|[89]0)\\d{7}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[235]"]], ["(\\d{3})(\\d{6})", "$1 $2", ["[89]"]]]], "GR": ["30", "00", "5005000\\d{3}|8\\d{9,11}|(?:[269]\\d|70)\\d{8}", [10, 11, 12], [["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["21|7"]], ["(\\d{4})(\\d{6})", "$1 $2", ["2(?:2|3[2-57-9]|4[2-469]|5[2-59]|6[2-9]|7[2-69]|8[2-49])|5"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[2689]"]], ["(\\d{3})(\\d{3,4})(\\d{5})", "$1 $2 $3", ["8"]]]], "GT": ["502", "00", "(?:1\\d{3}|[2-7])\\d{7}", [8, 11], [["(\\d{4})(\\d{4})", "$1 $2", ["[2-7]"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]]]], "GU": ["1", "011", "(?:[58]\\d\\d|671|900)\\d{7}", [10], 0, "1", 0, "([3-9]\\d{6})$|1", "671$1", 0, "671"], "GW": ["245", "00", "[49]\\d{8}|4\\d{6}", [7, 9], [["(\\d{3})(\\d{4})", "$1 $2", ["40"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[49]"]]]], "GY": ["592", "001", "9008\\d{3}|(?:[2-467]\\d\\d|862)\\d{4}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-46-9]"]]]], "HK": ["852", "00(?:30|5[09]|[126-9]?)", "8[0-46-9]\\d{6,7}|9\\d{4,7}|(?:[2-7]|9\\d{3})\\d{7}", [5, 6, 7, 8, 9, 11], [["(\\d{3})(\\d{2,5})", "$1 $2", ["900", "9003"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[2-7]|8[1-4]|9(?:0[1-9]|[1-8])"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]], ["(\\d{3})(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["9"]]], 0, 0, 0, 0, 0, 0, 0, "00"], "HN": ["504", "00", "8\\d{10}|[237-9]\\d{7}", [8, 11], [["(\\d{4})(\\d{4})", "$1-$2", ["[237-9]"]]]], "HR": ["385", "00", "(?:[24-69]\\d|3[0-79])\\d{7}|80\\d{5,7}|[1-79]\\d{7}|6\\d{5,6}", [6, 7, 8, 9], [["(\\d{2})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["6[01]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["8"], "0$1"], ["(\\d)(\\d{4})(\\d{3})", "$1 $2 $3", ["1"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[67]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["9"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-5]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"], "0$1"]], "0"], "HT": ["509", "00", "(?:[2-489]\\d|55)\\d{6}", [8], [["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["[2-589]"]]]], "HU": ["36", "00", "[235-7]\\d{8}|[1-9]\\d{7}", [8, 9], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "(06 $1)"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[27][2-9]|3[2-7]|4[24-9]|5[2-79]|6|8[2-57-9]|9[2-69]"], "(06 $1)"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-9]"], "06 $1"]], "06"], "ID": ["62", "00[89]", "(?:(?:00[1-9]|8\\d)\\d{4}|[1-36])\\d{6}|00\\d{10}|[1-9]\\d{8,10}|[2-9]\\d{7}", [7, 8, 9, 10, 11, 12, 13], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["15"]], ["(\\d{2})(\\d{5,9})", "$1 $2", ["2[124]|[36]1"], "(0$1)"], ["(\\d{3})(\\d{5,7})", "$1 $2", ["800"], "0$1"], ["(\\d{3})(\\d{5,8})", "$1 $2", ["[2-79]"], "(0$1)"], ["(\\d{3})(\\d{3,4})(\\d{3})", "$1-$2-$3", ["8[1-35-9]"], "0$1"], ["(\\d{3})(\\d{6,8})", "$1 $2", ["1"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["804"], "0$1"], ["(\\d{3})(\\d)(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["80"], "0$1"], ["(\\d{3})(\\d{4})(\\d{4,5})", "$1-$2-$3", ["8"], "0$1"]], "0"], "IE": ["353", "00", "(?:1\\d|[2569])\\d{6,8}|4\\d{6,9}|7\\d{8}|8\\d{8,9}", [7, 8, 9, 10], [["(\\d{2})(\\d{5})", "$1 $2", ["2[24-9]|47|58|6[237-9]|9[35-9]"], "(0$1)"], ["(\\d{3})(\\d{5})", "$1 $2", ["[45]0"], "(0$1)"], ["(\\d)(\\d{3,4})(\\d{4})", "$1 $2 $3", ["1"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2569]|4[1-69]|7[14]"], "(0$1)"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["70"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["81"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[78]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["4"], "(0$1)"], ["(\\d{2})(\\d)(\\d{3})(\\d{4})", "$1 $2 $3 $4", ["8"], "0$1"]], "0"], "IL": ["972", "0(?:0|1[2-9])", "1\\d{6}(?:\\d{3,5})?|[57]\\d{8}|[1-489]\\d{7}", [7, 8, 9, 10, 11, 12], [["(\\d{4})(\\d{3})", "$1-$2", ["125"]], ["(\\d{4})(\\d{2})(\\d{2})", "$1-$2-$3", ["121"]], ["(\\d)(\\d{3})(\\d{4})", "$1-$2-$3", ["[2-489]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["[57]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1-$2-$3", ["12"]], ["(\\d{4})(\\d{6})", "$1-$2", ["159"]], ["(\\d)(\\d{3})(\\d{3})(\\d{3})", "$1-$2-$3-$4", ["1[7-9]"]], ["(\\d{3})(\\d{1,2})(\\d{3})(\\d{4})", "$1-$2 $3-$4", ["15"]]], "0"], "IM": ["44", "00", "1624\\d{6}|(?:[3578]\\d|90)\\d{8}", [10], 0, "0", 0, "([25-8]\\d{5})$|0", "1624$1", 0, "74576|(?:16|7[56])24"], "IN": ["91", "00", "(?:000800|[2-9]\\d\\d)\\d{7}|1\\d{7,12}", [8, 9, 10, 11, 12, 13], [["(\\d{8})", "$1", ["5(?:0|2[23]|3[03]|[67]1|88)", "5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|888)", "5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|8888)"], 0, 1], ["(\\d{4})(\\d{4,5})", "$1 $2", ["180", "1800"], 0, 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["140"], 0, 1], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["11|2[02]|33|4[04]|79[1-7]|80[2-46]", "11|2[02]|33|4[04]|79(?:[1-6]|7[19])|80(?:[2-4]|6[0-589])", "11|2[02]|33|4[04]|79(?:[124-6]|3(?:[02-9]|1[0-24-9])|7(?:1|9[1-6]))|80(?:[2-4]|6[0-589])"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["1(?:2[0-249]|3[0-25]|4[145]|[68]|7[1257])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|5[12]|[78]1)|6(?:12|[2-4]1|5[17]|6[13]|80)|7(?:12|3[134]|4[47]|61|88)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91)|(?:43|59|75)[15]|(?:1[59]|29|67|72)[14]", "1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|674|7(?:(?:2[14]|3[34]|5[15])[2-6]|61[346]|88[0-8])|8(?:70[2-6]|84[235-7]|91[3-7])|(?:1(?:29|60|8[06])|261|552|6(?:12|[2-47]1|5[17]|6[13]|80)|7(?:12|31|4[47])|8(?:16|2[014]|3[126]|6[136]|7[78]|83))[2-7]", "1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|6(?:12(?:[2-6]|7[0-8])|74[2-7])|7(?:(?:2[14]|5[15])[2-6]|3171|61[346]|88(?:[2-7]|82))|8(?:70[2-6]|84(?:[2356]|7[19])|91(?:[3-6]|7[19]))|73[134][2-6]|(?:74[47]|8(?:16|2[014]|3[126]|6[136]|7[78]|83))(?:[2-6]|7[19])|(?:1(?:29|60|8[06])|261|552|6(?:[2-4]1|5[17]|6[13]|7(?:1|4[0189])|80)|7(?:12|88[01]))[2-7]"], "0$1", 1], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2[2457-9]|3[2-5]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1[013-9]|28|3[129]|4[1-35689]|5[29]|6[02-5]|70)|807", "1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2(?:[2457]|84|95)|3(?:[2-4]|55)|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1(?:[013-8]|9[6-9])|28[6-8]|3(?:17|2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4|5[0-367])|70[13-7])|807[19]", "1(?:[2-479]|5(?:[0236-9]|5[013-9]))|[2-5]|6(?:2(?:84|95)|355|83)|73179|807(?:1|9[1-3])|(?:1552|6(?:1[1358]|2[2457]|3[2-4]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[124-6])\\d|7(?:1(?:[013-8]\\d|9[6-9])|28[6-8]|3(?:2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]\\d|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4\\d|5[0-367])|70[13-7]))[2-7]"], "0$1", 1], ["(\\d{5})(\\d{5})", "$1 $2", ["[6-9]"], "0$1", 1], ["(\\d{4})(\\d{2,4})(\\d{4})", "$1 $2 $3", ["1(?:6|8[06])", "1(?:6|8[06]0)"], 0, 1], ["(\\d{4})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["18"], 0, 1]], "0"], "IO": ["246", "00", "3\\d{6}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["3"]]]], "IQ": ["964", "00", "(?:1|7\\d\\d)\\d{7}|[2-6]\\d{7,8}", [8, 9, 10], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-6]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "0$1"]], "0"], "IR": ["98", "00", "[1-9]\\d{9}|(?:[1-8]\\d\\d|9)\\d{3,4}", [4, 5, 6, 7, 10], [["(\\d{4,5})", "$1", ["96"], "0$1"], ["(\\d{2})(\\d{4,5})", "$1 $2", ["(?:1[137]|2[13-68]|3[1458]|4[145]|5[1468]|6[16]|7[1467]|8[13467])[12689]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["9"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["[1-8]"], "0$1"]], "0"], "IS": ["354", "00|1(?:0(?:01|[12]0)|100)", "(?:38\\d|[4-9])\\d{6}", [7, 9], [["(\\d{3})(\\d{4})", "$1 $2", ["[4-9]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["3"]]], 0, 0, 0, 0, 0, 0, 0, "00"], "IT": ["39", "00", "0\\d{5,10}|1\\d{8,10}|3(?:[0-8]\\d{7,10}|9\\d{7,8})|(?:55|70)\\d{8}|8\\d{5}(?:\\d{2,4})?", [6, 7, 8, 9, 10, 11], [["(\\d{2})(\\d{4,6})", "$1 $2", ["0[26]"]], ["(\\d{3})(\\d{3,6})", "$1 $2", ["0[13-57-9][0159]|8(?:03|4[17]|9[2-5])", "0[13-57-9][0159]|8(?:03|4[17]|9(?:2|3[04]|[45][0-4]))"]], ["(\\d{4})(\\d{2,6})", "$1 $2", ["0(?:[13-579][2-46-8]|8[236-8])"]], ["(\\d{4})(\\d{4})", "$1 $2", ["894"]], ["(\\d{2})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["0[26]|5"]], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["1(?:44|[679])|[378]"]], ["(\\d{3})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["0[13-57-9][0159]|14"]], ["(\\d{2})(\\d{4})(\\d{5})", "$1 $2 $3", ["0[26]"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["0"]], ["(\\d{3})(\\d{4})(\\d{4,5})", "$1 $2 $3", ["3"]]], 0, 0, 0, 0, 0, 0, [["0669[0-79]\\d{1,6}|0(?:1(?:[0159]\\d|[27][1-5]|31|4[1-4]|6[1356]|8[2-57])|2\\d\\d|3(?:[0159]\\d|2[1-4]|3[12]|[48][1-6]|6[2-59]|7[1-7])|4(?:[0159]\\d|[23][1-9]|4[245]|6[1-5]|7[1-4]|81)|5(?:[0159]\\d|2[1-5]|3[2-6]|4[1-79]|6[4-6]|7[1-578]|8[3-8])|6(?:[0-57-9]\\d|6[0-8])|7(?:[0159]\\d|2[12]|3[1-7]|4[2-46]|6[13569]|7[13-6]|8[1-59])|8(?:[0159]\\d|2[3-578]|3[1-356]|[6-8][1-5])|9(?:[0159]\\d|[238][1-5]|4[12]|6[1-8]|7[1-6]))\\d{2,7}"], ["3[1-9]\\d{8}|3[2-9]\\d{7}", [9, 10]], ["80(?:0\\d{3}|3)\\d{3}", [6, 9]], ["(?:0878\\d{3}|89(?:2\\d|3[04]|4(?:[0-4]|[5-9]\\d\\d)|5[0-4]))\\d\\d|(?:1(?:44|6[346])|89(?:38|5[5-9]|9))\\d{6}", [6, 8, 9, 10]], ["1(?:78\\d|99)\\d{6}", [9, 10]], 0, 0, 0, ["55\\d{8}", [10]], ["84(?:[08]\\d{3}|[17])\\d{3}", [6, 9]]]], "JE": ["44", "00", "1534\\d{6}|(?:[3578]\\d|90)\\d{8}", [10], 0, "0", 0, "([0-24-8]\\d{5})$|0", "1534$1", 0, 0, [["1534[0-24-8]\\d{5}"], ["7(?:(?:(?:50|82)9|937)\\d|7(?:00[378]|97[7-9]))\\d{5}"], ["80(?:07(?:35|81)|8901)\\d{4}"], ["(?:8(?:4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|90(?:066[59]|1810|71(?:07|55)))\\d{4}"], ["701511\\d{4}"], 0, ["(?:3(?:0(?:07(?:35|81)|8901)|3\\d{4}|4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|55\\d{4})\\d{4}"], ["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}"], ["56\\d{8}"]]], "JM": ["1", "011", "(?:[58]\\d\\d|658|900)\\d{7}", [10], 0, "1", 0, 0, 0, 0, "658|876"], "JO": ["962", "00", "(?:(?:[2689]|7\\d)\\d|32|53)\\d{6}", [8, 9], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[2356]|87"], "(0$1)"], ["(\\d{3})(\\d{5,6})", "$1 $2", ["[89]"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["70"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["7"], "0$1"]], "0"], "JP": ["81", "010", "00[1-9]\\d{6,14}|[257-9]\\d{9}|(?:00|[1-9]\\d\\d)\\d{6}", [8, 9, 10, 11, 12, 13, 14, 15, 16, 17], [["(\\d{3})(\\d{3})(\\d{3})", "$1-$2-$3", ["(?:12|57|99)0"], "0$1"], ["(\\d{4})(\\d)(\\d{4})", "$1-$2-$3", ["1(?:26|3[79]|4[56]|5[4-68]|6[3-5])|499|5(?:76|97)|746|8(?:3[89]|47|51|63)|9(?:80|9[16])", "1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:76|97)9|7468|8(?:3(?:8[7-9]|96)|477|51[2-9]|636)|9(?:802|9(?:1[23]|69))|1(?:45|58)[67]", "1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:769|979[2-69])|7468|8(?:3(?:8[7-9]|96[2457-9])|477|51[2-9]|636[457-9])|9(?:802|9(?:1[23]|69))|1(?:45|58)[67]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["60"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1-$2-$3", ["[36]|4(?:2[09]|7[01])", "[36]|4(?:2(?:0|9[02-69])|7(?:0[019]|1))"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["1(?:1|5[45]|77|88|9[69])|2(?:2[1-37]|3[0-269]|4[59]|5|6[24]|7[1-358]|8[1369]|9[0-38])|4(?:[28][1-9]|3[0-57]|[45]|6[248]|7[2-579]|9[29])|5(?:2|3[045]|4[0-369]|5[29]|8[02389]|9[0-389])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9[2-6])|8(?:2[124589]|3[27-9]|49|51|6|7[0-468]|8[68]|9[019])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9[1-489])", "1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2(?:[127]|3[014-9])|3[0-269]|4[59]|5(?:[1-3]|5[0-69]|9[19])|62|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|8[1-9])|5(?:2|3[045]|4[0-369]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0-2469])|49|51|6(?:[0-24]|36|5[0-3589]|72|9[01459])|7[0-468]|8[68])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9(?:[1289]|3[34]|4[0178]))|(?:49|55|83)[29]|(?:264|837)[016-9]|2(?:57|93)[015-9]|(?:25[0468]|422|838)[01]|(?:47[59]|59[89]|8(?:6[68]|9))[019]", "1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2[127]|3[0-269]|4[59]|5(?:[1-3]|5[0-69]|9(?:17|99))|6(?:2|4[016-9])|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|9[29])|5(?:2|3[045]|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0169])|3(?:[29]|7(?:[017-9]|6[6-8]))|49|51|6(?:[0-24]|36[23]|5(?:[0-389]|5[23])|6(?:[01]|9[178])|72|9[0145])|7[0-468]|8[68])|9(?:4[15]|5[138]|7[156]|8[189]|9(?:[1289]|3(?:31|4[357])|4[0178]))|(?:8294|96)[1-3]|2(?:57|93)[015-9]|(?:223|8699)[014-9]|(?:25[0468]|422|838)[01]|(?:48|8292|9[23])[1-9]|(?:47[59]|59[89]|8(?:68|9))[019]", "1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2[127]|3[0-269]|4[59]|5(?:[1-3]|5[0-69]|7[015-9]|9(?:17|99))|6(?:2|4[016-9])|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17|3[015-9]))|4(?:2(?:[13-79]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|9[29])|5(?:2|3[045]|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9(?:[019]|4[1-3]|6(?:[0-47-9]|5[01346-9])))|3(?:[29]|7(?:[017-9]|6[6-8]))|49|51|6(?:[0-24]|36[23]|5(?:[0-389]|5[23])|6(?:[01]|9[178])|72|9[0145])|7[0-468]|8[68])|9(?:4[15]|5[138]|6[1-3]|7[156]|8[189]|9(?:[1289]|3(?:31|4[357])|4[0178]))|(?:223|8699)[014-9]|(?:25[0468]|422|838)[01]|(?:48|829(?:2|66)|9[23])[1-9]|(?:47[59]|59[89]|8(?:68|9))[019]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{4})", "$1-$2-$3", ["[14]|[289][2-9]|5[3-9]|7[2-4679]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2-$3", ["800"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1-$2-$3", ["[257-9]"], "0$1"]], "0"], "KE": ["254", "000", "(?:[17]\\d\\d|900)\\d{6}|(?:2|80)0\\d{6,7}|[4-6]\\d{6,8}", [7, 8, 9, 10], [["(\\d{2})(\\d{5,7})", "$1 $2", ["[24-6]"], "0$1"], ["(\\d{3})(\\d{6})", "$1 $2", ["[17]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[89]"], "0$1"]], "0"], "KG": ["996", "00", "8\\d{9}|(?:[235-8]\\d|99)\\d{7}", [9, 10], [["(\\d{4})(\\d{5})", "$1 $2", ["3(?:1[346]|[24-79])"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[235-79]|88"], "0$1"], ["(\\d{3})(\\d{3})(\\d)(\\d{2,3})", "$1 $2 $3 $4", ["8"], "0$1"]], "0"], "KH": ["855", "00[14-9]", "1\\d{9}|[1-9]\\d{7,8}", [8, 9, 10], [["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[1-9]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]]], "0"], "KI": ["686", "00", "(?:[37]\\d|6[0-79])\\d{6}|(?:[2-48]\\d|50)\\d{3}", [5, 8], 0, "0"], "KM": ["269", "00", "[3478]\\d{6}", [7], [["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["[3478]"]]]], "KN": ["1", "011", "(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-7]\\d{6})$|1", "869$1", 0, "869"], "KP": ["850", "00|99", "85\\d{6}|(?:19\\d|[2-7])\\d{7}", [8, 10], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"], "0$1"], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[2-7]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"]], "0"], "KR": ["82", "00(?:[125689]|3(?:[46]5|91)|7(?:00|27|3|55|6[126]))", "00[1-9]\\d{8,11}|(?:[12]|5\\d{3})\\d{7}|[13-6]\\d{9}|(?:[1-6]\\d|80)\\d{7}|[3-6]\\d{4,5}|(?:00|7)0\\d{8}", [5, 6, 8, 9, 10, 11, 12, 13, 14], [["(\\d{2})(\\d{3,4})", "$1-$2", ["(?:3[1-3]|[46][1-4]|5[1-5])1"], "0$1"], ["(\\d{4})(\\d{4})", "$1-$2", ["1"]], ["(\\d)(\\d{3,4})(\\d{4})", "$1-$2-$3", ["2"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["60|8"], "0$1"], ["(\\d{2})(\\d{3,4})(\\d{4})", "$1-$2-$3", ["[1346]|5[1-5]"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1-$2-$3", ["[57]"], "0$1"], ["(\\d{2})(\\d{5})(\\d{4})", "$1-$2-$3", ["5"], "0$1"]], "0", 0, "0(8(?:[1-46-8]|5\\d\\d))?"], "KW": ["965", "00", "18\\d{5}|(?:[2569]\\d|41)\\d{6}", [7, 8], [["(\\d{4})(\\d{3,4})", "$1 $2", ["[169]|2(?:[235]|4[1-35-9])|52"]], ["(\\d{3})(\\d{5})", "$1 $2", ["[245]"]]]], "KY": ["1", "011", "(?:345|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "345$1", 0, "345"], "KZ": ["7", "810", "(?:33622|8\\d{8})\\d{5}|[78]\\d{9}", [10, 14], 0, "8", 0, 0, 0, 0, "33|7", 0, "8~10"], "LA": ["856", "00", "[23]\\d{9}|3\\d{8}|(?:[235-8]\\d|41)\\d{6}", [8, 9, 10], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["2[13]|3[14]|[4-8]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["30[013-9]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["[23]"], "0$1"]], "0"], "LB": ["961", "00", "[27-9]\\d{7}|[13-9]\\d{6}", [7, 8], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[13-69]|7(?:[2-57]|62|8[0-7]|9[04-9])|8[02-9]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[27-9]"]]], "0"], "LC": ["1", "011", "(?:[58]\\d\\d|758|900)\\d{7}", [10], 0, "1", 0, "([2-8]\\d{6})$|1", "758$1", 0, "758"], "LI": ["423", "00", "[68]\\d{8}|(?:[2378]\\d|90)\\d{5}", [7, 9], [["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["[2379]|8(?:0[09]|7)", "[2379]|8(?:0(?:02|9)|7)"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["69"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6"]]], "0", 0, "(1001)|0"], "LK": ["94", "00", "[1-9]\\d{8}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[1-689]"], "0$1"]], "0"], "LR": ["231", "00", "(?:[25]\\d|33|77|88)\\d{7}|(?:2\\d|[4-6])\\d{6}", [7, 8, 9], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[4-6]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[23578]"], "0$1"]], "0"], "LS": ["266", "00", "(?:[256]\\d\\d|800)\\d{5}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[2568]"]]]], "LT": ["370", "00", "(?:[3469]\\d|52|[78]0)\\d{6}", [8], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["52[0-7]"], "(8-$1)", 1], ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["[7-9]"], "8 $1", 1], ["(\\d{2})(\\d{6})", "$1 $2", ["37|4(?:[15]|6[1-8])"], "(8-$1)", 1], ["(\\d{3})(\\d{5})", "$1 $2", ["[3-6]"], "(8-$1)", 1]], "8", 0, "[08]"], "LU": ["352", "00", "35[013-9]\\d{4,8}|6\\d{8}|35\\d{2,4}|(?:[2457-9]\\d|3[0-46-9])\\d{2,9}", [4, 5, 6, 7, 8, 9, 10, 11], [["(\\d{2})(\\d{3})", "$1 $2", ["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"]], ["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"]], ["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["20[2-689]"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})", "$1 $2 $3 $4", ["2(?:[0367]|4[3-8])"]], ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["80[01]|90[015]"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["20"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})", "$1 $2 $3 $4 $5", ["2(?:[0367]|4[3-8])"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{1,5})", "$1 $2 $3 $4", ["[3-57]|8[13-9]|9(?:0[89]|[2-579])|(?:2|80)[2-9]"]]], 0, 0, "(15(?:0[06]|1[12]|[35]5|4[04]|6[26]|77|88|99)\\d)"], "LV": ["371", "00", "(?:[268]\\d|90)\\d{6}", [8], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[269]|8[01]"]]]], "LY": ["218", "00", "[2-9]\\d{8}", [9], [["(\\d{2})(\\d{7})", "$1-$2", ["[2-9]"], "0$1"]], "0"], "MA": ["212", "00", "[5-8]\\d{8}", [9], [["(\\d{5})(\\d{4})", "$1-$2", ["5(?:29|38)", "5(?:29[1289]|389)", "529(?:1[1-46-9]|2[013-8]|90)|5(?:298|389)[0-46-9]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["5[45]"], "0$1"], ["(\\d{4})(\\d{5})", "$1-$2", ["5(?:2[2-489]|3[5-9]|9)|892", "5(?:2(?:[2-49]|8[235-9])|3[5-9]|9)|892"], "0$1"], ["(\\d{2})(\\d{7})", "$1-$2", ["8"], "0$1"], ["(\\d{3})(\\d{6})", "$1-$2", ["[5-7]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["5293[01]\\d{4}|5(?:2(?:[0-25-7]\\d|3[1-578]|4[02-46-8]|8[0235-7]|9[0-289])|3(?:[0-47]\\d|5[02-9]|6[02-8]|8[0189]|9[3-9])|(?:4[067]|5[03])\\d)\\d{5}"], ["(?:6(?:[0-79]\\d|8[0-247-9])|7(?:[017]\\d|2[0-2]|6[0-8]|8[0-3]))\\d{6}"], ["80\\d{7}"], ["89\\d{7}"], 0, 0, 0, 0, ["592(?:4[0-2]|93)\\d{4}"]]], "MC": ["377", "00", "(?:[3489]|6\\d)\\d{7}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["4"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[389]"]], ["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["6"], "0$1"]], "0"], "MD": ["373", "00", "(?:[235-7]\\d|[89]0)\\d{6}", [8], [["(\\d{3})(\\d{5})", "$1 $2", ["[89]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["22|3"], "0$1"], ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["[25-7]"], "0$1"]], "0"], "ME": ["382", "00", "(?:20|[3-79]\\d)\\d{6}|80\\d{6,7}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-9]"], "0$1"]], "0"], "MF": ["590", "00", "590\\d{6}|(?:69|80|9\\d)\\d{7}", [9], 0, "0", 0, 0, 0, 0, 0, [["590(?:0[079]|[14]3|[27][79]|30|5[0-268]|87)\\d{4}"], ["69(?:0\\d\\d|1(?:2[2-9]|3[0-5]))\\d{4}"], ["80[0-5]\\d{6}"], 0, 0, 0, 0, 0, ["9(?:(?:395|76[018])\\d|475[0-2])\\d{4}"]]], "MG": ["261", "00", "[23]\\d{8}", [9], [["(\\d{2})(\\d{2})(\\d{3})(\\d{2})", "$1 $2 $3 $4", ["[23]"], "0$1"]], "0", 0, "([24-9]\\d{6})$|0", "20$1"], "MH": ["692", "011", "329\\d{4}|(?:[256]\\d|45)\\d{5}", [7], [["(\\d{3})(\\d{4})", "$1-$2", ["[2-6]"]]], "1"], "MK": ["389", "00", "[2-578]\\d{7}", [8], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["2|34[47]|4(?:[37]7|5[47]|64)"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[347]"], "0$1"], ["(\\d{3})(\\d)(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[58]"], "0$1"]], "0"], "ML": ["223", "00", "[24-9]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[24-9]"]]]], "MM": ["95", "00", "1\\d{5,7}|95\\d{6}|(?:[4-7]|9[0-46-9])\\d{6,8}|(?:2|8\\d)\\d{5,8}", [6, 7, 8, 9, 10], [["(\\d)(\\d{2})(\\d{3})", "$1 $2 $3", ["16|2"], "0$1"], ["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["[45]|6(?:0[23]|[1-689]|7[235-7])|7(?:[0-4]|5[2-7])|8[1-6]"], "0$1"], ["(\\d)(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[12]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[4-7]|8[1-35]"], "0$1"], ["(\\d)(\\d{3})(\\d{4,6})", "$1 $2 $3", ["9(?:2[0-4]|[35-9]|4[137-9])"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"], "0$1"], ["(\\d)(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["92"], "0$1"], ["(\\d)(\\d{5})(\\d{4})", "$1 $2 $3", ["9"], "0$1"]], "0"], "MN": ["976", "001", "[12]\\d{7,9}|[5-9]\\d{7}", [8, 9, 10], [["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["[12]1"], "0$1"], ["(\\d{4})(\\d{4})", "$1 $2", ["[5-9]"]], ["(\\d{3})(\\d{5,6})", "$1 $2", ["[12]2[1-3]"], "0$1"], ["(\\d{4})(\\d{5,6})", "$1 $2", ["[12](?:27|3[2-8]|4[2-68]|5[1-4689])", "[12](?:27|3[2-8]|4[2-68]|5[1-4689])[0-3]"], "0$1"], ["(\\d{5})(\\d{4,5})", "$1 $2", ["[12]"], "0$1"]], "0"], "MO": ["853", "00", "0800\\d{3}|(?:28|[68]\\d)\\d{6}", [7, 8], [["(\\d{4})(\\d{3})", "$1 $2", ["0"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[268]"]]]], "MP": ["1", "011", "[58]\\d{9}|(?:67|90)0\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "670$1", 0, "670"], "MQ": ["596", "00", "596\\d{6}|(?:69|80|9\\d)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[569]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0$1"]], "0"], "MR": ["222", "00", "(?:[2-4]\\d\\d|800)\\d{5}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-48]"]]]], "MS": ["1", "011", "(?:[58]\\d\\d|664|900)\\d{7}", [10], 0, "1", 0, "([34]\\d{6})$|1", "664$1", 0, "664"], "MT": ["356", "00", "3550\\d{4}|(?:[2579]\\d\\d|800)\\d{5}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[2357-9]"]]]], "MU": ["230", "0(?:0|[24-7]0|3[03])", "(?:[57]|8\\d\\d)\\d{7}|[2-468]\\d{6}", [7, 8, 10], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-46]|8[013]"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[57]"]], ["(\\d{5})(\\d{5})", "$1 $2", ["8"]]], 0, 0, 0, 0, 0, 0, 0, "020"], "MV": ["960", "0(?:0|19)", "(?:800|9[0-57-9]\\d)\\d{7}|[34679]\\d{6}", [7, 10], [["(\\d{3})(\\d{4})", "$1-$2", ["[34679]"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[89]"]]], 0, 0, 0, 0, 0, 0, 0, "00"], "MW": ["265", "00", "(?:[1289]\\d|31|77)\\d{7}|1\\d{6}", [7, 9], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["1[2-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[137-9]"], "0$1"]], "0"], "MX": ["52", "0[09]", "1(?:(?:[27]2|44|99)[1-9]|65[0-689])\\d{7}|(?:1(?:[01]\\d|2[13-9]|[35][1-9]|4[0-35-9]|6[0-46-9]|7[013-9]|8[1-79]|9[1-8])|[2-9]\\d)\\d{8}", [10, 11], [["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["33|5[56]|81"], 0, 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[2-9]"], 0, 1], ["(\\d)(\\d{2})(\\d{4})(\\d{4})", "$2 $3 $4", ["1(?:33|5[56]|81)"], 0, 1], ["(\\d)(\\d{3})(\\d{3})(\\d{4})", "$2 $3 $4", ["1"], 0, 1]], "01", 0, "0(?:[12]|4[45])|1", 0, 0, 0, 0, "00"], "MY": ["60", "00", "1\\d{8,9}|(?:3\\d|[4-9])\\d{7}", [8, 9, 10], [["(\\d)(\\d{3})(\\d{4})", "$1-$2 $3", ["[4-79]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1-$2 $3", ["1(?:[02469]|[378][1-9]|53)|8", "1(?:[02469]|[37][1-9]|53|8(?:[1-46-9]|5[7-9]))|8"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1-$2 $3", ["3"], "0$1"], ["(\\d)(\\d{3})(\\d{2})(\\d{4})", "$1-$2-$3-$4", ["1(?:[367]|80)"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2 $3", ["15"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1-$2 $3", ["1"], "0$1"]], "0"], "MZ": ["258", "00", "(?:2|8\\d)\\d{7}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2|8[2-79]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]]]], "NA": ["264", "00", "[68]\\d{7,8}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["88"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["6"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["87"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"], "0$1"]], "0"], "NC": ["687", "00", "(?:050|[2-57-9]\\d\\d)\\d{3}", [6], [["(\\d{2})(\\d{2})(\\d{2})", "$1.$2.$3", ["[02-57-9]"]]]], "NE": ["227", "00", "[027-9]\\d{7}", [8], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["08"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[089]|2[013]|7[04]"]]]], "NF": ["672", "00", "[13]\\d{5}", [6], [["(\\d{2})(\\d{4})", "$1 $2", ["1[0-3]"]], ["(\\d)(\\d{5})", "$1 $2", ["[13]"]]], 0, 0, "([0-258]\\d{4})$", "3$1"], "NG": ["234", "009", "(?:[124-7]|9\\d{3})\\d{6}|[1-9]\\d{7}|[78]\\d{9,13}", [7, 8, 10, 11, 12, 13, 14], [["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["78"], "0$1"], ["(\\d)(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[12]|9(?:0[3-9]|[1-9])"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2,3})", "$1 $2 $3", ["[3-7]|8[2-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[7-9]"], "0$1"], ["(\\d{3})(\\d{4})(\\d{4,5})", "$1 $2 $3", ["[78]"], "0$1"], ["(\\d{3})(\\d{5})(\\d{5,6})", "$1 $2 $3", ["[78]"], "0$1"]], "0"], "NI": ["505", "00", "(?:1800|[25-8]\\d{3})\\d{4}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[125-8]"]]]], "NL": ["31", "00", "(?:[124-7]\\d\\d|3(?:[02-9]\\d|1[0-8]))\\d{6}|8\\d{6,9}|9\\d{6,10}|1\\d{4,5}", [5, 6, 7, 8, 9, 10, 11], [["(\\d{3})(\\d{4,7})", "$1 $2", ["[89]0"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["66"], "0$1"], ["(\\d)(\\d{8})", "$1 $2", ["6"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["1[16-8]|2[259]|3[124]|4[17-9]|5[124679]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1-578]|91"], "0$1"], ["(\\d{3})(\\d{3})(\\d{5})", "$1 $2 $3", ["9"], "0$1"]], "0"], "NO": ["47", "00", "(?:0|[2-9]\\d{3})\\d{4}", [5, 8], [["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["[489]|59"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[235-7]"]]], 0, 0, 0, 0, 0, "[02-689]|7[0-8]"], "NP": ["977", "00", "(?:1\\d|9)\\d{9}|[1-9]\\d{7}", [8, 10, 11], [["(\\d)(\\d{7})", "$1-$2", ["1[2-6]"], "0$1"], ["(\\d{2})(\\d{6})", "$1-$2", ["1[01]|[2-8]|9(?:[1-59]|[67][2-6])"], "0$1"], ["(\\d{3})(\\d{7})", "$1-$2", ["9"]]], "0"], "NR": ["674", "00", "(?:444|(?:55|8\\d)\\d|666)\\d{4}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[4-68]"]]]], "NU": ["683", "00", "(?:[47]|888\\d)\\d{3}", [4, 7], [["(\\d{3})(\\d{4})", "$1 $2", ["8"]]]], "NZ": ["64", "0(?:0|161)", "[29]\\d{7,9}|50\\d{5}(?:\\d{2,3})?|6[0-35-9]\\d{6}|7\\d{7,8}|8\\d{4,9}|(?:11\\d|[34])\\d{7}", [5, 6, 7, 8, 9, 10], [["(\\d{2})(\\d{3,8})", "$1 $2", ["8[1-579]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["50[036-8]|[89]0", "50(?:[0367]|88)|[89]0"], "0$1"], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["24|[346]|7[2-57-9]|9[2-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2(?:10|74)|[59]|80"], "0$1"], ["(\\d{2})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["1|2[028]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,5})", "$1 $2 $3", ["2(?:[169]|7[0-35-9])|7|86"], "0$1"]], "0", 0, 0, 0, 0, 0, 0, "00"], "OM": ["968", "00", "(?:1505|[279]\\d{3}|500)\\d{4}|800\\d{5,6}", [7, 8, 9], [["(\\d{3})(\\d{4,6})", "$1 $2", ["[58]"]], ["(\\d{2})(\\d{6})", "$1 $2", ["2"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[179]"]]]], "PA": ["507", "00", "(?:00800|8\\d{3})\\d{6}|[68]\\d{7}|[1-57-9]\\d{6}", [7, 8, 10, 11], [["(\\d{3})(\\d{4})", "$1-$2", ["[1-57-9]"]], ["(\\d{4})(\\d{4})", "$1-$2", ["[68]"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"]]]], "PE": ["51", "00|19(?:1[124]|77|90)00", "(?:[14-8]|9\\d)\\d{7}", [8, 9], [["(\\d{3})(\\d{5})", "$1 $2", ["80"], "(0$1)"], ["(\\d)(\\d{7})", "$1 $2", ["1"], "(0$1)"], ["(\\d{2})(\\d{6})", "$1 $2", ["[4-8]"], "(0$1)"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["9"]]], "0", 0, 0, 0, 0, 0, 0, "00", " Anexo "], "PF": ["689", "00", "4\\d{5}(?:\\d{2})?|8\\d{7,8}", [6, 8, 9], [["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["44"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["4|8[7-9]"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"]]]], "PG": ["675", "00|140[1-3]", "(?:180|[78]\\d{3})\\d{4}|(?:[2-589]\\d|64)\\d{5}", [7, 8], [["(\\d{3})(\\d{4})", "$1 $2", ["18|[2-69]|85"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[78]"]]], 0, 0, 0, 0, 0, 0, 0, "00"], "PH": ["63", "00", "(?:[2-7]|9\\d)\\d{8}|2\\d{5}|(?:1800|8)\\d{7,9}", [6, 8, 9, 10, 11, 12, 13], [["(\\d)(\\d{5})", "$1 $2", ["2"], "(0$1)"], ["(\\d{4})(\\d{4,6})", "$1 $2", ["3(?:23|39|46)|4(?:2[3-6]|[35]9|4[26]|76)|544|88[245]|(?:52|64|86)2", "3(?:230|397|461)|4(?:2(?:35|[46]4|51)|396|4(?:22|63)|59[347]|76[15])|5(?:221|446)|642[23]|8(?:622|8(?:[24]2|5[13]))"], "(0$1)"], ["(\\d{5})(\\d{4})", "$1 $2", ["346|4(?:27|9[35])|883", "3469|4(?:279|9(?:30|56))|8834"], "(0$1)"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["2"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[3-7]|8[2-8]"], "(0$1)"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[89]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]], ["(\\d{4})(\\d{1,2})(\\d{3})(\\d{4})", "$1 $2 $3 $4", ["1"]]], "0"], "PK": ["92", "00", "122\\d{6}|[24-8]\\d{10,11}|9(?:[013-9]\\d{8,10}|2(?:[01]\\d\\d|2(?:[06-8]\\d|1[01]))\\d{7})|(?:[2-8]\\d{3}|92(?:[0-7]\\d|8[1-9]))\\d{6}|[24-9]\\d{8}|[89]\\d{7}", [8, 9, 10, 11, 12], [["(\\d{3})(\\d{3})(\\d{2,7})", "$1 $2 $3", ["[89]0"], "0$1"], ["(\\d{4})(\\d{5})", "$1 $2", ["1"]], ["(\\d{3})(\\d{6,7})", "$1 $2", ["2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:2[2-8]|3[27-9]|4[2-6]|6[3569]|9[25-8])", "9(?:2[3-8]|98)|(?:2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:22|3[27-9]|4[2-6]|6[3569]|9[25-7]))[2-9]"], "(0$1)"], ["(\\d{2})(\\d{7,8})", "$1 $2", ["(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]"], "(0$1)"], ["(\\d{5})(\\d{5})", "$1 $2", ["58"], "(0$1)"], ["(\\d{3})(\\d{7})", "$1 $2", ["3"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91"], "(0$1)"], ["(\\d{3})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["[24-9]"], "(0$1)"]], "0"], "PL": ["48", "00", "(?:6|8\\d\\d)\\d{7}|[1-9]\\d{6}(?:\\d{2})?|[26]\\d{5}", [6, 7, 8, 9, 10], [["(\\d{5})", "$1", ["19"]], ["(\\d{3})(\\d{3})", "$1 $2", ["11|20|64"]], ["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])1", "(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])19"]], ["(\\d{3})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["64"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["21|39|45|5[0137]|6[0469]|7[02389]|8(?:0[14]|8)"]], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["1[2-8]|[2-7]|8[1-79]|9[145]"]], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["8"]]]], "PM": ["508", "00", "[45]\\d{5}|(?:708|80\\d)\\d{6}", [6, 9], [["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["[45]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["7"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0$1"]], "0"], "PR": ["1", "011", "(?:[589]\\d\\d|787)\\d{7}", [10], 0, "1", 0, 0, 0, 0, "787|939"], "PS": ["970", "00", "[2489]2\\d{6}|(?:1\\d|5)\\d{8}", [8, 9, 10], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[2489]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["5"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]]], "0"], "PT": ["351", "00", "1693\\d{5}|(?:[26-9]\\d|30)\\d{7}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["2[12]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["16|[236-9]"]]]], "PW": ["680", "01[12]", "(?:[24-8]\\d\\d|345|900)\\d{4}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-9]"]]]], "PY": ["595", "00", "59\\d{4,6}|9\\d{5,10}|(?:[2-46-8]\\d|5[0-8])\\d{4,7}", [6, 7, 8, 9, 10, 11], [["(\\d{3})(\\d{3,6})", "$1 $2", ["[2-9]0"], "0$1"], ["(\\d{2})(\\d{5})", "$1 $2", ["[26]1|3[289]|4[1246-8]|7[1-3]|8[1-36]"], "(0$1)"], ["(\\d{3})(\\d{4,5})", "$1 $2", ["2[279]|3[13-5]|4[359]|5|6(?:[34]|7[1-46-8])|7[46-8]|85"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2[14-68]|3[26-9]|4[1246-8]|6(?:1|75)|7[1-35]|8[1-36]"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["87"]], ["(\\d{3})(\\d{6})", "$1 $2", ["9(?:[5-79]|8[1-6])"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-8]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["9"]]], "0"], "QA": ["974", "00", "800\\d{4}|(?:2|800)\\d{6}|(?:0080|[3-7])\\d{7}", [7, 8, 9, 11], [["(\\d{3})(\\d{4})", "$1 $2", ["2[16]|8"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[3-7]"]]]], "RE": ["262", "00", "(?:26|[689]\\d)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2689]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["26(?:2\\d\\d|3(?:0\\d|1[0-3]))\\d{4}"], ["(?:69(?:2\\d\\d|3(?:0[0-46]|1[013]|2[0-2]|3[0-39]|4\\d|5[0-5]|6[0-6]|7[0-27]|8[0-8]|9[0-479]))|9(?:399[0-3]|479[0-2]|76(?:2[27]|3[0-37]|9\\d)))\\d{4}"], ["80\\d{7}"], ["89[1-37-9]\\d{6}"], 0, 0, 0, 0, 0, ["8(?:1[019]|2[0156]|84|90)\\d{6}"]]], "RO": ["40", "00", "(?:[2378]\\d|90)\\d{7}|[23]\\d{5}", [6, 9], [["(\\d{3})(\\d{3})", "$1 $2", ["2[3-6]", "2[3-6]\\d9"], "0$1"], ["(\\d{2})(\\d{4})", "$1 $2", ["219|31"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[23]1"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[237-9]"], "0$1"]], "0", 0, 0, 0, 0, 0, 0, 0, " int "], "RS": ["381", "00", "38[02-9]\\d{6,9}|6\\d{7,9}|90\\d{4,8}|38\\d{5,6}|(?:7\\d\\d|800)\\d{3,9}|(?:[12]\\d|3[0-79])\\d{5,10}", [6, 7, 8, 9, 10, 11, 12], [["(\\d{3})(\\d{3,9})", "$1 $2", ["(?:2[389]|39)0|[7-9]"], "0$1"], ["(\\d{2})(\\d{5,10})", "$1 $2", ["[1-36]"], "0$1"]], "0"], "RU": ["7", "810", "8\\d{13}|[347-9]\\d{9}", [10, 14], [["(\\d{4})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["7(?:1[0-8]|2[1-9])", "7(?:1(?:[0-356]2|4[29]|7|8[27])|2(?:1[23]|[2-9]2))", "7(?:1(?:[0-356]2|4[29]|7|8[27])|2(?:13[03-69]|62[013-9]))|72[1-57-9]2"], "8 ($1)", 1], ["(\\d{5})(\\d)(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["7(?:1[0-68]|2[1-9])", "7(?:1(?:[06][3-6]|[18]|2[35]|[3-5][3-5])|2(?:[13][3-5]|[24-689]|7[457]))", "7(?:1(?:0(?:[356]|4[023])|[18]|2(?:3[013-9]|5)|3[45]|43[013-79]|5(?:3[1-8]|4[1-7]|5)|6(?:3[0-35-9]|[4-6]))|2(?:1(?:3[178]|[45])|[24-689]|3[35]|7[457]))|7(?:14|23)4[0-8]|71(?:33|45)[1-79]"], "8 ($1)", 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "8 ($1)", 1], ["(\\d{3})(\\d{3})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["[349]|8(?:[02-7]|1[1-8])"], "8 ($1)", 1], ["(\\d{4})(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["8"], "8 ($1)"]], "8", 0, 0, 0, 0, "3[04-689]|[489]", 0, "8~10"], "RW": ["250", "00", "(?:06|[27]\\d\\d|[89]00)\\d{6}", [8, 9], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["0"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[7-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["2"]]], "0"], "SA": ["966", "00", "92\\d{7}|(?:[15]|8\\d)\\d{8}", [9, 10], [["(\\d{4})(\\d{5})", "$1 $2", ["9"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["5"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["81"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"]]], "0"], "SB": ["677", "0[01]", "(?:[1-6]|[7-9]\\d\\d)\\d{4}", [5, 7], [["(\\d{2})(\\d{5})", "$1 $2", ["7|8[4-9]|9(?:[1-8]|9[0-8])"]]]], "SC": ["248", "010|0[0-2]", "800\\d{4}|(?:[249]\\d|64)\\d{5}", [7], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[246]|9[57]"]]], 0, 0, 0, 0, 0, 0, 0, "00"], "SD": ["249", "00", "[19]\\d{8}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[19]"], "0$1"]], "0"], "SE": ["46", "00", "(?:[26]\\d\\d|9)\\d{9}|[1-9]\\d{8}|[1-689]\\d{7}|[1-4689]\\d{6}|2\\d{5}", [6, 7, 8, 9, 10], [["(\\d{2})(\\d{2,3})(\\d{2})", "$1-$2 $3", ["20"], "0$1", 0, "$1 $2 $3"], ["(\\d{3})(\\d{4})", "$1-$2", ["9(?:00|39|44|9)"], "0$1", 0, "$1 $2"], ["(\\d{2})(\\d{3})(\\d{2})", "$1-$2 $3", ["[12][136]|3[356]|4[0246]|6[03]|90[1-9]"], "0$1", 0, "$1 $2 $3"], ["(\\d)(\\d{2,3})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["8"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{3})(\\d{2,3})(\\d{2})", "$1-$2 $3", ["1[2457]|2(?:[247-9]|5[0138])|3[0247-9]|4[1357-9]|5[0-35-9]|6(?:[125689]|4[02-57]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"], "0$1", 0, "$1 $2 $3"], ["(\\d{3})(\\d{2,3})(\\d{3})", "$1-$2 $3", ["9(?:00|39|44)"], "0$1", 0, "$1 $2 $3"], ["(\\d{2})(\\d{2,3})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["1[13689]|2[0136]|3[1356]|4[0246]|54|6[03]|90[1-9]"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["10|7"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d)(\\d{3})(\\d{3})(\\d{2})", "$1-$2 $3 $4", ["8"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["[13-5]|2(?:[247-9]|5[0138])|6(?:[124-689]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{3})", "$1-$2 $3 $4", ["9"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1-$2 $3 $4 $5", ["[26]"], "0$1", 0, "$1 $2 $3 $4 $5"]], "0"], "SG": ["65", "0[0-3]\\d", "(?:(?:1\\d|8)\\d\\d|7000)\\d{7}|[3689]\\d{7}", [8, 10, 11], [["(\\d{4})(\\d{4})", "$1 $2", ["[369]|8(?:0[1-6]|[1-9])"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"]], ["(\\d{4})(\\d{4})(\\d{3})", "$1 $2 $3", ["7"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]]]], "SH": ["290", "00", "(?:[256]\\d|8)\\d{3}", [4, 5], 0, 0, 0, 0, 0, 0, "[256]"], "SI": ["386", "00|10(?:22|66|88|99)", "[1-7]\\d{7}|8\\d{4,7}|90\\d{4,6}", [5, 6, 7, 8], [["(\\d{2})(\\d{3,6})", "$1 $2", ["8[09]|9"], "0$1"], ["(\\d{3})(\\d{5})", "$1 $2", ["59|8"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[37][01]|4[0139]|51|6"], "0$1"], ["(\\d)(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[1-57]"], "(0$1)"]], "0", 0, 0, 0, 0, 0, 0, "00"], "SJ": ["47", "00", "0\\d{4}|(?:[489]\\d|[57]9)\\d{6}", [5, 8], 0, 0, 0, 0, 0, 0, "79"], "SK": ["421", "00", "[2-689]\\d{8}|[2-59]\\d{6}|[2-5]\\d{5}", [6, 7, 9], [["(\\d)(\\d{2})(\\d{3,4})", "$1 $2 $3", ["21"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["[3-5][1-8]1", "[3-5][1-8]1[67]"], "0$1"], ["(\\d)(\\d{3})(\\d{3})(\\d{2})", "$1/$2 $3 $4", ["2"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[689]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1/$2 $3 $4", ["[3-5]"], "0$1"]], "0"], "SL": ["232", "00", "(?:[237-9]\\d|66)\\d{6}", [8], [["(\\d{2})(\\d{6})", "$1 $2", ["[236-9]"], "(0$1)"]], "0"], "SM": ["378", "00", "(?:0549|[5-7]\\d)\\d{6}", [8, 10], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-7]"]], ["(\\d{4})(\\d{6})", "$1 $2", ["0"]]], 0, 0, "([89]\\d{5})$", "0549$1"], "SN": ["221", "00", "(?:[378]\\d|93)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"]], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[379]"]]]], "SO": ["252", "00", "[346-9]\\d{8}|[12679]\\d{7}|[1-5]\\d{6}|[1348]\\d{5}", [6, 7, 8, 9], [["(\\d{2})(\\d{4})", "$1 $2", ["8[125]"]], ["(\\d{6})", "$1", ["[134]"]], ["(\\d)(\\d{6})", "$1 $2", ["[15]|2[0-79]|3[0-46-8]|4[0-7]"]], ["(\\d)(\\d{7})", "$1 $2", ["(?:2|90)4|[67]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[3478]|64|90"]], ["(\\d{2})(\\d{5,7})", "$1 $2", ["1|28|6(?:0[5-7]|[1-35-9])|9[2-9]"]]], "0"], "SR": ["597", "00", "(?:[2-5]|68|[78]\\d)\\d{5}", [6, 7], [["(\\d{2})(\\d{2})(\\d{2})", "$1-$2-$3", ["56"]], ["(\\d{3})(\\d{3})", "$1-$2", ["[2-5]"]], ["(\\d{3})(\\d{4})", "$1-$2", ["[6-8]"]]]], "SS": ["211", "00", "[19]\\d{8}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[19]"], "0$1"]], "0"], "ST": ["239", "00", "(?:22|9\\d)\\d{5}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[29]"]]]], "SV": ["503", "00", "[267]\\d{7}|[89]00\\d{4}(?:\\d{4})?", [7, 8, 11], [["(\\d{3})(\\d{4})", "$1 $2", ["[89]"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[267]"]], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["[89]"]]]], "SX": ["1", "011", "7215\\d{6}|(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "(5\\d{6})$|1", "721$1", 0, "721"], "SY": ["963", "00", "[1-39]\\d{8}|[1-5]\\d{7}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[1-5]"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["9"], "0$1", 1]], "0"], "SZ": ["268", "00", "0800\\d{4}|(?:[237]\\d|900)\\d{6}", [8, 9], [["(\\d{4})(\\d{4})", "$1 $2", ["[0237]"]], ["(\\d{5})(\\d{4})", "$1 $2", ["9"]]]], "TA": ["290", "00", "8\\d{3}", [4], 0, 0, 0, 0, 0, 0, "8"], "TC": ["1", "011", "(?:[58]\\d\\d|649|900)\\d{7}", [10], 0, "1", 0, "([2-479]\\d{6})$|1", "649$1", 0, "649"], "TD": ["235", "00|16", "(?:22|[69]\\d|77)\\d{6}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2679]"]]], 0, 0, 0, 0, 0, 0, 0, "00"], "TG": ["228", "00", "[279]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[279]"]]]], "TH": ["66", "00[1-9]", "(?:001800|[2-57]|[689]\\d)\\d{7}|1\\d{7,9}", [8, 9, 10, 13], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[13-9]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]]], "0"], "TJ": ["992", "810", "[0-57-9]\\d{8}", [9], [["(\\d{6})(\\d)(\\d{2})", "$1 $2 $3", ["331", "3317"]], ["(\\d{3})(\\d{2})(\\d{4})", "$1 $2 $3", ["[34]7|91[78]"]], ["(\\d{4})(\\d)(\\d{4})", "$1 $2 $3", ["3[1-5]"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[0-57-9]"]]], 0, 0, 0, 0, 0, 0, 0, "8~10"], "TK": ["690", "00", "[2-47]\\d{3,6}", [4, 5, 6, 7]], "TL": ["670", "00", "7\\d{7}|(?:[2-47]\\d|[89]0)\\d{5}", [7, 8], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-489]|70"]], ["(\\d{4})(\\d{4})", "$1 $2", ["7"]]]], "TM": ["993", "810", "[1-6]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["12"], "(8 $1)"], ["(\\d{3})(\\d)(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["[1-5]"], "(8 $1)"], ["(\\d{2})(\\d{6})", "$1 $2", ["6"], "8 $1"]], "8", 0, 0, 0, 0, 0, 0, "8~10"], "TN": ["216", "00", "[2-57-9]\\d{7}", [8], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-57-9]"]]]], "TO": ["676", "00", "(?:0800|(?:[5-8]\\d\\d|999)\\d)\\d{3}|[2-8]\\d{4}", [5, 7], [["(\\d{2})(\\d{3})", "$1-$2", ["[2-4]|50|6[09]|7[0-24-69]|8[05]"]], ["(\\d{4})(\\d{3})", "$1 $2", ["0"]], ["(\\d{3})(\\d{4})", "$1 $2", ["[5-9]"]]]], "TR": ["90", "00", "4\\d{6}|8\\d{11,12}|(?:[2-58]\\d\\d|900)\\d{7}", [7, 10, 12, 13], [["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["512|8[01589]|90"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["5(?:[0-59]|61)", "5(?:[0-59]|616)", "5(?:[0-59]|6161)"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[24][1-8]|3[1-9]"], "(0$1)", 1], ["(\\d{3})(\\d{3})(\\d{6,7})", "$1 $2 $3", ["80"], "0$1", 1]], "0"], "TT": ["1", "011", "(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-46-8]\\d{6})$|1", "868$1", 0, "868"], "TV": ["688", "00", "(?:2|7\\d\\d|90)\\d{4}", [5, 6, 7], [["(\\d{2})(\\d{3})", "$1 $2", ["2"]], ["(\\d{2})(\\d{4})", "$1 $2", ["90"]], ["(\\d{2})(\\d{5})", "$1 $2", ["7"]]]], "TW": ["886", "0(?:0[25-79]|19)", "[2-689]\\d{8}|7\\d{9,10}|[2-8]\\d{7}|2\\d{6}", [7, 8, 9, 10, 11], [["(\\d{2})(\\d)(\\d{4})", "$1 $2 $3", ["202"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[258]0"], "0$1"], ["(\\d)(\\d{3,4})(\\d{4})", "$1 $2 $3", ["[23568]|4(?:0[02-48]|[1-47-9])|7[1-9]", "[23568]|4(?:0[2-48]|[1-47-9])|(?:400|7)[1-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[49]"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4,5})", "$1 $2 $3", ["7"], "0$1"]], "0", 0, 0, 0, 0, 0, 0, 0, "#"], "TZ": ["255", "00[056]", "(?:[25-8]\\d|41|90)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{4})", "$1 $2 $3", ["[89]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[24]"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["5"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[67]"], "0$1"]], "0"], "UA": ["380", "00", "[89]\\d{9}|[3-9]\\d{8}", [9, 10], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6[12][29]|(?:3[1-8]|4[136-8]|5[12457]|6[49])2|(?:56|65)[24]", "6[12][29]|(?:35|4[1378]|5[12457]|6[49])2|(?:56|65)[24]|(?:3[1-46-8]|46)2[013-9]"], "0$1"], ["(\\d{4})(\\d{5})", "$1 $2", ["3[1-8]|4(?:[1367]|[45][6-9]|8[4-6])|5(?:[1-5]|6[0135689]|7[4-6])|6(?:[12][3-7]|[459])", "3[1-8]|4(?:[1367]|[45][6-9]|8[4-6])|5(?:[1-5]|6(?:[015689]|3[02389])|7[4-6])|6(?:[12][3-7]|[459])"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[3-7]|89|9[1-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[89]"], "0$1"]], "0", 0, 0, 0, 0, 0, 0, "0~0"], "UG": ["256", "00[057]", "800\\d{6}|(?:[29]0|[347]\\d)\\d{7}", [9], [["(\\d{4})(\\d{5})", "$1 $2", ["202", "2024"], "0$1"], ["(\\d{3})(\\d{6})", "$1 $2", ["[27-9]|4(?:6[45]|[7-9])"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["[34]"], "0$1"]], "0"], "US": ["1", "011", "[2-9]\\d{9}|3\\d{6}", [10], [["(\\d{3})(\\d{4})", "$1-$2", ["310"], 0, 1], ["(\\d{3})(\\d{3})(\\d{4})", "($1) $2-$3", ["[2-9]"], 0, 1, "$1-$2-$3"]], "1", 0, 0, 0, 0, 0, [["(?:4722(?:0[0-35]|27)|505(?:[2-57-9]\\d\\d|6(?:[0-35-9]\\d|4[46])))\\d{4}|(?:2(?:0[1-35-9]|1[02-9]|2[03-589]|3[149]|4[08]|5[1-46]|6[0279]|7[0269]|8[13])|3(?:0[1-57-9]|1[02-9]|2[01356]|3[0-24679]|4[167]|5[0-2]|6[014]|8[056])|4(?:0[124-9]|1[02-579]|2[3-5]|3[0245]|4[023578]|58|6[349]|7[0589]|8[04])|5(?:0[1-47-9]|1[0235-8]|20|3[0149]|4[01]|5[179]|6[1-47]|7[0-5]|8[0256])|6(?:0[1-35-9]|1[024-9]|2[03689]|[34][016]|5[01679]|6[0-279]|78|8[0-29])|7(?:0[1-46-8]|1[2-9]|2[04-7]|3[1247]|4[037]|5[47]|6[02359]|7[0-59]|8[156])|8(?:0[1-68]|1[02-8]|2[068]|3[0-2589]|4[03578]|5[046-9]|6[02-5]|7[028])|9(?:0[1346-9]|1[02-9]|2[0589]|3[0146-8]|4[01357-9]|5[12469]|7[0-389]|8[04-69]))[2-9]\\d{6}"], [""], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"]]], "UY": ["598", "0(?:0|1[3-9]\\d)", "(?:0004|4)\\d{9}|[1249]\\d{7}|(?:[49]\\d|80)\\d{5}", [7, 8, 10, 13], [["(\\d{3})(\\d{4})", "$1 $2", ["405|8|90"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["9"], "0$1"], ["(\\d{4})(\\d{4})", "$1 $2", ["[124]"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["4"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3 $4", ["0"]]], "0", 0, 0, 0, 0, 0, 0, "00", " int. "], "UZ": ["998", "810", "(?:33|[5-79]\\d|88)\\d{7}", [9], [["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[35-9]"], "8 $1"]], "8", 0, 0, 0, 0, 0, 0, "8~10"], "VA": ["39", "00", "0\\d{5,10}|3[0-8]\\d{7,10}|55\\d{8}|8\\d{5}(?:\\d{2,4})?|(?:1\\d|39)\\d{7,8}", [6, 7, 8, 9, 10, 11], 0, 0, 0, 0, 0, 0, "06698"], "VC": ["1", "011", "(?:[58]\\d\\d|784|900)\\d{7}", [10], 0, "1", 0, "([2-7]\\d{6})$|1", "784$1", 0, "784"], "VE": ["58", "00", "[68]00\\d{7}|(?:[24]\\d|[59]0)\\d{8}", [10], [["(\\d{3})(\\d{7})", "$1-$2", ["[24-689]"], "0$1"]], "0"], "VG": ["1", "011", "(?:284|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-578]\\d{6})$|1", "284$1", 0, "284"], "VI": ["1", "011", "[58]\\d{9}|(?:34|90)0\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "340$1", 0, "340"], "VN": ["84", "00", "[12]\\d{9}|[135-9]\\d{8}|[16]\\d{7}|[16-8]\\d{6}", [7, 8, 9, 10], [["(\\d{2})(\\d{5})", "$1 $2", ["80"], "0$1", 1], ["(\\d{4})(\\d{4,6})", "$1 $2", ["1"], 0, 1], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[69]"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[3578]"], "0$1", 1], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["2[48]"], "0$1", 1], ["(\\d{3})(\\d{4})(\\d{3})", "$1 $2 $3", ["2"], "0$1", 1]], "0"], "VU": ["678", "00", "[57-9]\\d{6}|(?:[238]\\d|48)\\d{3}", [5, 7], [["(\\d{3})(\\d{4})", "$1 $2", ["[57-9]"]]]], "WF": ["681", "00", "(?:40|72)\\d{4}|8\\d{5}(?:\\d{3})?", [6, 9], [["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["[478]"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"]]]], "WS": ["685", "0", "(?:[2-6]|8\\d{5})\\d{4}|[78]\\d{6}|[68]\\d{5}", [5, 6, 7, 10], [["(\\d{5})", "$1", ["[2-5]|6[1-9]"]], ["(\\d{3})(\\d{3,7})", "$1 $2", ["[68]"]], ["(\\d{2})(\\d{5})", "$1 $2", ["7"]]]], "XK": ["383", "00", "[23]\\d{7,8}|(?:4\\d\\d|[89]00)\\d{5}", [8, 9], [["(\\d{3})(\\d{5})", "$1 $2", ["[89]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-4]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[23]"], "0$1"]], "0"], "YE": ["967", "00", "(?:1|7\\d)\\d{7}|[1-7]\\d{6}", [7, 8, 9], [["(\\d)(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[1-6]|7(?:[24-6]|8[0-7])"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["7"], "0$1"]], "0"], "YT": ["262", "00", "(?:(?:(?:26|63)9|80\\d)\\d|9398)\\d{5}", [9], 0, "0", 0, 0, 0, 0, "269|63|9398"], "ZA": ["27", "00", "[1-79]\\d{8}|8\\d{4,9}", [5, 6, 7, 8, 9, 10], [["(\\d{2})(\\d{3,4})", "$1 $2", ["8[1-4]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2,3})", "$1 $2 $3", ["8[1-4]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["860"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"], "0$1"]], "0"], "ZM": ["260", "00", "800\\d{6}|(?:21|63|[79]\\d)\\d{7}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[28]"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["[79]"], "0$1"]], "0"], "ZW": ["263", "00", "2(?:[0-57-9]\\d{6,8}|6[0-24-9]\\d{6,7})|[38]\\d{9}|[35-8]\\d{8}|[3-6]\\d{7}|[1-689]\\d{6}|[1-3569]\\d{5}|[1356]\\d{4}", [5, 6, 7, 8, 9, 10], [["(\\d{3})(\\d{3,5})", "$1 $2", ["2(?:0[45]|2[278]|[49]8)|3(?:[09]8|17)|6(?:[29]8|37|75)|[23][78]|(?:33|5[15]|6[68])[78]"], "0$1"], ["(\\d)(\\d{3})(\\d{2,4})", "$1 $2 $3", ["[49]"], "0$1"], ["(\\d{3})(\\d{4})", "$1 $2", ["80"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["24|8[13-59]|(?:2[05-79]|39|5[45]|6[15-8])2", "2(?:02[014]|4|[56]20|[79]2)|392|5(?:42|525)|6(?:[16-8]21|52[013])|8[13-59]"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2(?:1[39]|2[0157]|[378]|[56][14])|3(?:12|29)", "2(?:1[39]|2[0157]|[378]|[56][14])|3(?:123|29)"], "0$1"], ["(\\d{4})(\\d{6})", "$1 $2", ["8"], "0$1"], ["(\\d{2})(\\d{3,5})", "$1 $2", ["1|2(?:0[0-36-9]|12|29|[56])|3(?:1[0-689]|[24-6])|5(?:[0236-9]|1[2-4])|6(?:[013-59]|7[0-46-9])|(?:33|55|6[68])[0-69]|(?:29|3[09]|62)[0-79]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["29[013-9]|39|54"], "0$1"], ["(\\d{4})(\\d{3,5})", "$1 $2", ["(?:25|54)8", "258|5483"], "0$1"]], "0"] }, "nonGeographic": { "800": ["800", 0, "(?:00|[1-9]\\d)\\d{6}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["\\d"]]], 0, 0, 0, 0, 0, 0, [0, 0, ["(?:00|[1-9]\\d)\\d{6}"]]], "808": ["808", 0, "[1-9]\\d{7}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[1-9]"]]], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, 0, 0, 0, ["[1-9]\\d{7}"]]], "870": ["870", 0, "7\\d{11}|[35-7]\\d{8}", [9, 12], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[35-7]"]]], 0, 0, 0, 0, 0, 0, [0, ["(?:[356]|774[45])\\d{8}|7[6-8]\\d{7}"]]], "878": ["878", 0, "10\\d{10}", [12], [["(\\d{2})(\\d{5})(\\d{5})", "$1 $2 $3", ["1"]]], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, 0, 0, ["10\\d{10}"]]], "881": ["881", 0, "[0-36-9]\\d{8}", [9], [["(\\d)(\\d{3})(\\d{5})", "$1 $2 $3", ["[0-36-9]"]]], 0, 0, 0, 0, 0, 0, [0, ["[0-36-9]\\d{8}"]]], "882": ["882", 0, "[13]\\d{6}(?:\\d{2,5})?|[19]\\d{7}|(?:[25]\\d\\d|4)\\d{7}(?:\\d{2})?", [7, 8, 9, 10, 11, 12], [["(\\d{2})(\\d{5})", "$1 $2", ["16|342"]], ["(\\d{2})(\\d{6})", "$1 $2", ["49"]], ["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["1[36]|9"]], ["(\\d{2})(\\d{4})(\\d{3})", "$1 $2 $3", ["3[23]"]], ["(\\d{2})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["16"]], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["10|23|3(?:[15]|4[57])|4|51"]], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["34"]], ["(\\d{2})(\\d{4,5})(\\d{5})", "$1 $2 $3", ["[1-35]"]]], 0, 0, 0, 0, 0, 0, [0, ["342\\d{4}|(?:337|49)\\d{6}|(?:3(?:2|47|7\\d{3})|50\\d{3})\\d{7}", [7, 8, 9, 10, 12]], 0, 0, 0, 0, 0, 0, ["1(?:3(?:0[0347]|[13][0139]|2[035]|4[013568]|6[0459]|7[06]|8[15-8]|9[0689])\\d{4}|6\\d{5,10})|(?:345\\d|9[89])\\d{6}|(?:10|2(?:3|85\\d)|3(?:[15]|[69]\\d\\d)|4[15-8]|51)\\d{8}"]]], "883": ["883", 0, "(?:[1-4]\\d|51)\\d{6,10}", [8, 9, 10, 11, 12], [["(\\d{3})(\\d{3})(\\d{2,8})", "$1 $2 $3", ["[14]|2[24-689]|3[02-689]|51[24-9]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["510"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["21"]], ["(\\d{4})(\\d{4})(\\d{4})", "$1 $2 $3", ["51[13]"]], ["(\\d{3})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["[235]"]]], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, 0, 0, ["(?:2(?:00\\d\\d|10)|(?:370[1-9]|51\\d0)\\d)\\d{7}|51(?:00\\d{5}|[24-9]0\\d{4,7})|(?:1[013-79]|2[24-689]|3[02-689]|4[0-4])0\\d{5,9}"]]], "888": ["888", 0, "\\d{11}", [11], [["(\\d{3})(\\d{3})(\\d{5})", "$1 $2 $3"]], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, ["\\d{11}"]]], "979": ["979", 0, "[1359]\\d{8}", [9], [["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["[1359]"]]], 0, 0, 0, 0, 0, 0, [0, 0, 0, ["[1359]\\d{8}"]]] } };
  }
});

// node_modules/libphonenumber-js/min/exports/withMetadataArgument.js
function withMetadataArgument(func, _arguments) {
  var args = Array.prototype.slice.call(_arguments);
  args.push(metadata_min_json_default);
  return func.apply(this, args);
}
var init_withMetadataArgument = __esm({
  "node_modules/libphonenumber-js/min/exports/withMetadataArgument.js"() {
    init_metadata_min_json();
  }
});

// node_modules/libphonenumber-js/es6/ParseError.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result2 = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result2);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance2 = new Constructor();
      if (Class2)
        _setPrototypeOf(instance2, Class2.prototype);
      return instance2;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
var ParseError;
var init_ParseError = __esm({
  "node_modules/libphonenumber-js/es6/ParseError.js"() {
    ParseError = function(_Error) {
      _inherits(ParseError2, _Error);
      var _super = _createSuper(ParseError2);
      function ParseError2(code) {
        var _this;
        _classCallCheck(this, ParseError2);
        _this = _super.call(this, code);
        Object.setPrototypeOf(_assertThisInitialized(_this), ParseError2.prototype);
        _this.name = _this.constructor.name;
        return _this;
      }
      return _createClass(ParseError2);
    }(_wrapNativeSuper(Error));
  }
});

// node_modules/libphonenumber-js/es6/constants.js
var MIN_LENGTH_FOR_NSN, MAX_LENGTH_FOR_NSN, MAX_LENGTH_COUNTRY_CODE, VALID_DIGITS, DASHES, SLASHES, DOTS, WHITESPACE, BRACKETS, TILDES, VALID_PUNCTUATION, PLUS_CHARS;
var init_constants = __esm({
  "node_modules/libphonenumber-js/es6/constants.js"() {
    MIN_LENGTH_FOR_NSN = 2;
    MAX_LENGTH_FOR_NSN = 17;
    MAX_LENGTH_COUNTRY_CODE = 3;
    VALID_DIGITS = "0-9０-９٠-٩۰-۹";
    DASHES = "-‐-―−ー－";
    SLASHES = "／/";
    DOTS = "．.";
    WHITESPACE = "  ­​⁠　";
    BRACKETS = "()（）［］\\[\\]";
    TILDES = "~⁓∼～";
    VALID_PUNCTUATION = "".concat(DASHES).concat(SLASHES).concat(DOTS).concat(WHITESPACE).concat(BRACKETS).concat(TILDES);
    PLUS_CHARS = "+＋";
  }
});

// node_modules/libphonenumber-js/es6/tools/semver-compare.js
function semver_compare_default(a, b) {
  a = a.split("-");
  b = b.split("-");
  var pa = a[0].split(".");
  var pb = b[0].split(".");
  for (var i = 0; i < 3; i++) {
    var na = Number(pa[i]);
    var nb = Number(pb[i]);
    if (na > nb)
      return 1;
    if (nb > na)
      return -1;
    if (!isNaN(na) && isNaN(nb))
      return 1;
    if (isNaN(na) && !isNaN(nb))
      return -1;
  }
  if (a[1] && b[1]) {
    return a[1] > b[1] ? 1 : a[1] < b[1] ? -1 : 0;
  }
  return !a[1] && b[1] ? 1 : a[1] && !b[1] ? -1 : 0;
}
var init_semver_compare = __esm({
  "node_modules/libphonenumber-js/es6/tools/semver-compare.js"() {
  }
});

// node_modules/libphonenumber-js/es6/metadata.js
function _typeof2(obj) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof2(obj);
}
function _classCallCheck2(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function getType(types, type) {
  switch (type) {
    case "FIXED_LINE":
      return types[0];
    case "MOBILE":
      return types[1];
    case "TOLL_FREE":
      return types[2];
    case "PREMIUM_RATE":
      return types[3];
    case "PERSONAL_NUMBER":
      return types[4];
    case "VOICEMAIL":
      return types[5];
    case "UAN":
      return types[6];
    case "PAGER":
      return types[7];
    case "VOIP":
      return types[8];
    case "SHARED_COST":
      return types[9];
  }
}
function validateMetadata(metadata) {
  if (!metadata) {
    throw new Error("[libphonenumber-js] `metadata` argument not passed. Check your arguments.");
  }
  if (!is_object(metadata) || !is_object(metadata.countries)) {
    throw new Error("[libphonenumber-js] `metadata` argument was passed but it's not a valid metadata. Must be an object having `.countries` child object property. Got ".concat(is_object(metadata) ? "an object of shape: { " + Object.keys(metadata).join(", ") + " }" : "a " + type_of(metadata) + ": " + metadata, "."));
  }
}
function getCountryCallingCode(country2, metadata) {
  metadata = new Metadata(metadata);
  if (metadata.hasCountry(country2)) {
    return metadata.country(country2).countryCallingCode();
  }
  throw new Error("Unknown country: ".concat(country2));
}
function isSupportedCountry(country2, metadata) {
  return metadata.countries[country2] !== void 0;
}
function setVersion(metadata) {
  var version2 = metadata.version;
  if (typeof version2 === "number") {
    this.v1 = version2 === 1;
    this.v2 = version2 === 2;
    this.v3 = version2 === 3;
    this.v4 = version2 === 4;
  } else {
    if (!version2) {
      this.v1 = true;
    } else if (semver_compare_default(version2, V3) === -1) {
      this.v2 = true;
    } else if (semver_compare_default(version2, V4) === -1) {
      this.v3 = true;
    } else {
      this.v4 = true;
    }
  }
}
var V3, V4, DEFAULT_EXT_PREFIX, CALLING_CODE_REG_EXP, Metadata, NumberingPlan, Format, FIRST_GROUP_ONLY_PREFIX_PATTERN, Type2, is_object, type_of;
var init_metadata = __esm({
  "node_modules/libphonenumber-js/es6/metadata.js"() {
    init_semver_compare();
    V3 = "1.2.0";
    V4 = "1.7.35";
    DEFAULT_EXT_PREFIX = " ext. ";
    CALLING_CODE_REG_EXP = /^\d+$/;
    Metadata = function() {
      function Metadata3(metadata) {
        _classCallCheck2(this, Metadata3);
        validateMetadata(metadata);
        this.metadata = metadata;
        setVersion.call(this, metadata);
      }
      _createClass2(Metadata3, [{
        key: "getCountries",
        value: function getCountries3() {
          return Object.keys(this.metadata.countries).filter(function(_) {
            return _ !== "001";
          });
        }
      }, {
        key: "getCountryMetadata",
        value: function getCountryMetadata(countryCode) {
          return this.metadata.countries[countryCode];
        }
      }, {
        key: "nonGeographic",
        value: function nonGeographic() {
          if (this.v1 || this.v2 || this.v3)
            return;
          return this.metadata.nonGeographic || this.metadata.nonGeographical;
        }
      }, {
        key: "hasCountry",
        value: function hasCountry(country2) {
          return this.getCountryMetadata(country2) !== void 0;
        }
      }, {
        key: "hasCallingCode",
        value: function hasCallingCode(callingCode) {
          if (this.getCountryCodesForCallingCode(callingCode)) {
            return true;
          }
          if (this.nonGeographic()) {
            if (this.nonGeographic()[callingCode]) {
              return true;
            }
          } else {
            var countryCodes = this.countryCallingCodes()[callingCode];
            if (countryCodes && countryCodes.length === 1 && countryCodes[0] === "001") {
              return true;
            }
          }
        }
      }, {
        key: "isNonGeographicCallingCode",
        value: function isNonGeographicCallingCode(callingCode) {
          if (this.nonGeographic()) {
            return this.nonGeographic()[callingCode] ? true : false;
          } else {
            return this.getCountryCodesForCallingCode(callingCode) ? false : true;
          }
        }
        // Deprecated.
      }, {
        key: "country",
        value: function country2(countryCode) {
          return this.selectNumberingPlan(countryCode);
        }
      }, {
        key: "selectNumberingPlan",
        value: function selectNumberingPlan(countryCode, callingCode) {
          if (countryCode && CALLING_CODE_REG_EXP.test(countryCode)) {
            callingCode = countryCode;
            countryCode = null;
          }
          if (countryCode && countryCode !== "001") {
            if (!this.hasCountry(countryCode)) {
              throw new Error("Unknown country: ".concat(countryCode));
            }
            this.numberingPlan = new NumberingPlan(this.getCountryMetadata(countryCode), this);
          } else if (callingCode) {
            if (!this.hasCallingCode(callingCode)) {
              throw new Error("Unknown calling code: ".concat(callingCode));
            }
            this.numberingPlan = new NumberingPlan(this.getNumberingPlanMetadata(callingCode), this);
          } else {
            this.numberingPlan = void 0;
          }
          return this;
        }
      }, {
        key: "getCountryCodesForCallingCode",
        value: function getCountryCodesForCallingCode(callingCode) {
          var countryCodes = this.countryCallingCodes()[callingCode];
          if (countryCodes) {
            if (countryCodes.length === 1 && countryCodes[0].length === 3) {
              return;
            }
            return countryCodes;
          }
        }
      }, {
        key: "getCountryCodeForCallingCode",
        value: function getCountryCodeForCallingCode(callingCode) {
          var countryCodes = this.getCountryCodesForCallingCode(callingCode);
          if (countryCodes) {
            return countryCodes[0];
          }
        }
      }, {
        key: "getNumberingPlanMetadata",
        value: function getNumberingPlanMetadata(callingCode) {
          var countryCode = this.getCountryCodeForCallingCode(callingCode);
          if (countryCode) {
            return this.getCountryMetadata(countryCode);
          }
          if (this.nonGeographic()) {
            var metadata = this.nonGeographic()[callingCode];
            if (metadata) {
              return metadata;
            }
          } else {
            var countryCodes = this.countryCallingCodes()[callingCode];
            if (countryCodes && countryCodes.length === 1 && countryCodes[0] === "001") {
              return this.metadata.countries["001"];
            }
          }
        }
        // Deprecated.
      }, {
        key: "countryCallingCode",
        value: function countryCallingCode() {
          return this.numberingPlan.callingCode();
        }
        // Deprecated.
      }, {
        key: "IDDPrefix",
        value: function IDDPrefix() {
          return this.numberingPlan.IDDPrefix();
        }
        // Deprecated.
      }, {
        key: "defaultIDDPrefix",
        value: function defaultIDDPrefix() {
          return this.numberingPlan.defaultIDDPrefix();
        }
        // Deprecated.
      }, {
        key: "nationalNumberPattern",
        value: function nationalNumberPattern() {
          return this.numberingPlan.nationalNumberPattern();
        }
        // Deprecated.
      }, {
        key: "possibleLengths",
        value: function possibleLengths() {
          return this.numberingPlan.possibleLengths();
        }
        // Deprecated.
      }, {
        key: "formats",
        value: function formats() {
          return this.numberingPlan.formats();
        }
        // Deprecated.
      }, {
        key: "nationalPrefixForParsing",
        value: function nationalPrefixForParsing() {
          return this.numberingPlan.nationalPrefixForParsing();
        }
        // Deprecated.
      }, {
        key: "nationalPrefixTransformRule",
        value: function nationalPrefixTransformRule() {
          return this.numberingPlan.nationalPrefixTransformRule();
        }
        // Deprecated.
      }, {
        key: "leadingDigits",
        value: function leadingDigits() {
          return this.numberingPlan.leadingDigits();
        }
        // Deprecated.
      }, {
        key: "hasTypes",
        value: function hasTypes() {
          return this.numberingPlan.hasTypes();
        }
        // Deprecated.
      }, {
        key: "type",
        value: function type(_type) {
          return this.numberingPlan.type(_type);
        }
        // Deprecated.
      }, {
        key: "ext",
        value: function ext() {
          return this.numberingPlan.ext();
        }
      }, {
        key: "countryCallingCodes",
        value: function countryCallingCodes() {
          if (this.v1)
            return this.metadata.country_phone_code_to_countries;
          return this.metadata.country_calling_codes;
        }
        // Deprecated.
      }, {
        key: "chooseCountryByCountryCallingCode",
        value: function chooseCountryByCountryCallingCode(callingCode) {
          return this.selectNumberingPlan(callingCode);
        }
      }, {
        key: "hasSelectedNumberingPlan",
        value: function hasSelectedNumberingPlan() {
          return this.numberingPlan !== void 0;
        }
      }]);
      return Metadata3;
    }();
    NumberingPlan = function() {
      function NumberingPlan2(metadata, globalMetadataObject) {
        _classCallCheck2(this, NumberingPlan2);
        this.globalMetadataObject = globalMetadataObject;
        this.metadata = metadata;
        setVersion.call(this, globalMetadataObject.metadata);
      }
      _createClass2(NumberingPlan2, [{
        key: "callingCode",
        value: function callingCode() {
          return this.metadata[0];
        }
        // Formatting information for regions which share
        // a country calling code is contained by only one region
        // for performance reasons. For example, for NANPA region
        // ("North American Numbering Plan Administration",
        //  which includes USA, Canada, Cayman Islands, Bahamas, etc)
        // it will be contained in the metadata for `US`.
      }, {
        key: "getDefaultCountryMetadataForRegion",
        value: function getDefaultCountryMetadataForRegion() {
          return this.globalMetadataObject.getNumberingPlanMetadata(this.callingCode());
        }
        // Is always present.
      }, {
        key: "IDDPrefix",
        value: function IDDPrefix() {
          if (this.v1 || this.v2)
            return;
          return this.metadata[1];
        }
        // Is only present when a country supports multiple IDD prefixes.
      }, {
        key: "defaultIDDPrefix",
        value: function defaultIDDPrefix() {
          if (this.v1 || this.v2)
            return;
          return this.metadata[12];
        }
      }, {
        key: "nationalNumberPattern",
        value: function nationalNumberPattern() {
          if (this.v1 || this.v2)
            return this.metadata[1];
          return this.metadata[2];
        }
        // "possible length" data is always present in Google's metadata.
      }, {
        key: "possibleLengths",
        value: function possibleLengths() {
          if (this.v1)
            return;
          return this.metadata[this.v2 ? 2 : 3];
        }
      }, {
        key: "_getFormats",
        value: function _getFormats(metadata) {
          return metadata[this.v1 ? 2 : this.v2 ? 3 : 4];
        }
        // For countries of the same region (e.g. NANPA)
        // formats are all stored in the "main" country for that region.
        // E.g. "RU" and "KZ", "US" and "CA".
      }, {
        key: "formats",
        value: function formats() {
          var _this = this;
          var formats2 = this._getFormats(this.metadata) || this._getFormats(this.getDefaultCountryMetadataForRegion()) || [];
          return formats2.map(function(_) {
            return new Format(_, _this);
          });
        }
      }, {
        key: "nationalPrefix",
        value: function nationalPrefix() {
          return this.metadata[this.v1 ? 3 : this.v2 ? 4 : 5];
        }
      }, {
        key: "_getNationalPrefixFormattingRule",
        value: function _getNationalPrefixFormattingRule(metadata) {
          return metadata[this.v1 ? 4 : this.v2 ? 5 : 6];
        }
        // For countries of the same region (e.g. NANPA)
        // national prefix formatting rule is stored in the "main" country for that region.
        // E.g. "RU" and "KZ", "US" and "CA".
      }, {
        key: "nationalPrefixFormattingRule",
        value: function nationalPrefixFormattingRule() {
          return this._getNationalPrefixFormattingRule(this.metadata) || this._getNationalPrefixFormattingRule(this.getDefaultCountryMetadataForRegion());
        }
      }, {
        key: "_nationalPrefixForParsing",
        value: function _nationalPrefixForParsing() {
          return this.metadata[this.v1 ? 5 : this.v2 ? 6 : 7];
        }
      }, {
        key: "nationalPrefixForParsing",
        value: function nationalPrefixForParsing() {
          return this._nationalPrefixForParsing() || this.nationalPrefix();
        }
      }, {
        key: "nationalPrefixTransformRule",
        value: function nationalPrefixTransformRule() {
          return this.metadata[this.v1 ? 6 : this.v2 ? 7 : 8];
        }
      }, {
        key: "_getNationalPrefixIsOptionalWhenFormatting",
        value: function _getNationalPrefixIsOptionalWhenFormatting() {
          return !!this.metadata[this.v1 ? 7 : this.v2 ? 8 : 9];
        }
        // For countries of the same region (e.g. NANPA)
        // "national prefix is optional when formatting" flag is
        // stored in the "main" country for that region.
        // E.g. "RU" and "KZ", "US" and "CA".
      }, {
        key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
        value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {
          return this._getNationalPrefixIsOptionalWhenFormatting(this.metadata) || this._getNationalPrefixIsOptionalWhenFormatting(this.getDefaultCountryMetadataForRegion());
        }
      }, {
        key: "leadingDigits",
        value: function leadingDigits() {
          return this.metadata[this.v1 ? 8 : this.v2 ? 9 : 10];
        }
      }, {
        key: "types",
        value: function types() {
          return this.metadata[this.v1 ? 9 : this.v2 ? 10 : 11];
        }
      }, {
        key: "hasTypes",
        value: function hasTypes() {
          if (this.types() && this.types().length === 0) {
            return false;
          }
          return !!this.types();
        }
      }, {
        key: "type",
        value: function type(_type2) {
          if (this.hasTypes() && getType(this.types(), _type2)) {
            return new Type2(getType(this.types(), _type2), this);
          }
        }
      }, {
        key: "ext",
        value: function ext() {
          if (this.v1 || this.v2)
            return DEFAULT_EXT_PREFIX;
          return this.metadata[13] || DEFAULT_EXT_PREFIX;
        }
      }]);
      return NumberingPlan2;
    }();
    Format = function() {
      function Format2(format2, metadata) {
        _classCallCheck2(this, Format2);
        this._format = format2;
        this.metadata = metadata;
      }
      _createClass2(Format2, [{
        key: "pattern",
        value: function pattern() {
          return this._format[0];
        }
      }, {
        key: "format",
        value: function format2() {
          return this._format[1];
        }
      }, {
        key: "leadingDigitsPatterns",
        value: function leadingDigitsPatterns() {
          return this._format[2] || [];
        }
      }, {
        key: "nationalPrefixFormattingRule",
        value: function nationalPrefixFormattingRule() {
          return this._format[3] || this.metadata.nationalPrefixFormattingRule();
        }
      }, {
        key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
        value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {
          return !!this._format[4] || this.metadata.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
        }
      }, {
        key: "nationalPrefixIsMandatoryWhenFormattingInNationalFormat",
        value: function nationalPrefixIsMandatoryWhenFormattingInNationalFormat() {
          return this.usesNationalPrefix() && !this.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
        }
        // Checks whether national prefix formatting rule contains national prefix.
      }, {
        key: "usesNationalPrefix",
        value: function usesNationalPrefix() {
          return this.nationalPrefixFormattingRule() && // Check that national prefix formatting rule is not a "dummy" one.
          !FIRST_GROUP_ONLY_PREFIX_PATTERN.test(this.nationalPrefixFormattingRule()) ? true : false;
        }
      }, {
        key: "internationalFormat",
        value: function internationalFormat() {
          return this._format[5] || this.format();
        }
      }]);
      return Format2;
    }();
    FIRST_GROUP_ONLY_PREFIX_PATTERN = /^\(?\$1\)?$/;
    Type2 = function() {
      function Type3(type, metadata) {
        _classCallCheck2(this, Type3);
        this.type = type;
        this.metadata = metadata;
      }
      _createClass2(Type3, [{
        key: "pattern",
        value: function pattern() {
          if (this.metadata.v1)
            return this.type;
          return this.type[0];
        }
      }, {
        key: "possibleLengths",
        value: function possibleLengths() {
          if (this.metadata.v1)
            return;
          return this.type[1] || this.metadata.possibleLengths();
        }
      }]);
      return Type3;
    }();
    is_object = function is_object2(_) {
      return _typeof2(_) === "object";
    };
    type_of = function type_of2(_) {
      return _typeof2(_);
    };
  }
});

// node_modules/libphonenumber-js/es6/helpers/extension/createExtensionPattern.js
function createExtensionPattern(purpose) {
  var extLimitAfterExplicitLabel = "20";
  var extLimitAfterLikelyLabel = "15";
  var extLimitAfterAmbiguousChar = "9";
  var extLimitWhenNotSure = "6";
  var possibleSeparatorsBetweenNumberAndExtLabel = "[  \\t,]*";
  var possibleCharsAfterExtLabel = "[:\\.．]?[  \\t,-]*";
  var optionalExtnSuffix = "#?";
  var explicitExtLabels = "(?:e?xt(?:ensi(?:ó?|ó))?n?|ｅ?ｘｔｎ?|доб|anexo)";
  var ambiguousExtLabels = "(?:[xｘ#＃~～]|int|ｉｎｔ)";
  var ambiguousSeparator = "[- ]+";
  var possibleSeparatorsNumberExtLabelNoComma = "[  \\t]*";
  var autoDiallingAndExtLabelsFound = "(?:,{2}|;)";
  var rfcExtn = RFC3966_EXTN_PREFIX + getExtensionDigitsPattern(extLimitAfterExplicitLabel);
  var explicitExtn = possibleSeparatorsBetweenNumberAndExtLabel + explicitExtLabels + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterExplicitLabel) + optionalExtnSuffix;
  var ambiguousExtn = possibleSeparatorsBetweenNumberAndExtLabel + ambiguousExtLabels + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterAmbiguousChar) + optionalExtnSuffix;
  var americanStyleExtnWithSuffix = ambiguousSeparator + getExtensionDigitsPattern(extLimitWhenNotSure) + "#";
  var autoDiallingExtn = possibleSeparatorsNumberExtLabelNoComma + autoDiallingAndExtLabelsFound + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterLikelyLabel) + optionalExtnSuffix;
  var onlyCommasExtn = possibleSeparatorsNumberExtLabelNoComma + "(?:,)+" + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterAmbiguousChar) + optionalExtnSuffix;
  return rfcExtn + "|" + explicitExtn + "|" + ambiguousExtn + "|" + americanStyleExtnWithSuffix + "|" + autoDiallingExtn + "|" + onlyCommasExtn;
}
var RFC3966_EXTN_PREFIX, getExtensionDigitsPattern;
var init_createExtensionPattern = __esm({
  "node_modules/libphonenumber-js/es6/helpers/extension/createExtensionPattern.js"() {
    init_constants();
    RFC3966_EXTN_PREFIX = ";ext=";
    getExtensionDigitsPattern = function getExtensionDigitsPattern2(maxLength2) {
      return "([".concat(VALID_DIGITS, "]{1,").concat(maxLength2, "})");
    };
  }
});

// node_modules/libphonenumber-js/es6/helpers/isViablePhoneNumber.js
function isViablePhoneNumber(number) {
  return number.length >= MIN_LENGTH_FOR_NSN && VALID_PHONE_NUMBER_PATTERN.test(number);
}
function isViablePhoneNumberStart(number) {
  return VALID_PHONE_NUMBER_START_REG_EXP.test(number);
}
var MIN_LENGTH_PHONE_NUMBER_PATTERN, VALID_PHONE_NUMBER, VALID_PHONE_NUMBER_START_REG_EXP, VALID_PHONE_NUMBER_WITH_EXTENSION, VALID_PHONE_NUMBER_PATTERN;
var init_isViablePhoneNumber = __esm({
  "node_modules/libphonenumber-js/es6/helpers/isViablePhoneNumber.js"() {
    init_constants();
    init_createExtensionPattern();
    MIN_LENGTH_PHONE_NUMBER_PATTERN = "[" + VALID_DIGITS + "]{" + MIN_LENGTH_FOR_NSN + "}";
    VALID_PHONE_NUMBER = "[" + PLUS_CHARS + "]{0,1}(?:[" + VALID_PUNCTUATION + "]*[" + VALID_DIGITS + "]){3,}[" + VALID_PUNCTUATION + VALID_DIGITS + "]*";
    VALID_PHONE_NUMBER_START_REG_EXP = new RegExp("^[" + PLUS_CHARS + "]{0,1}(?:[" + VALID_PUNCTUATION + "]*[" + VALID_DIGITS + "]){1,2}$", "i");
    VALID_PHONE_NUMBER_WITH_EXTENSION = VALID_PHONE_NUMBER + // Phone number extensions
    "(?:" + createExtensionPattern() + ")?";
    VALID_PHONE_NUMBER_PATTERN = new RegExp(
      // Either a short two-digit-only phone number
      "^" + MIN_LENGTH_PHONE_NUMBER_PATTERN + "$|^" + VALID_PHONE_NUMBER_WITH_EXTENSION + "$",
      "i"
    );
  }
});

// node_modules/libphonenumber-js/es6/helpers/extension/extractExtension.js
function extractExtension(number) {
  var start = number.search(EXTN_PATTERN);
  if (start < 0) {
    return {};
  }
  var numberWithoutExtension = number.slice(0, start);
  var matches2 = number.match(EXTN_PATTERN);
  var i = 1;
  while (i < matches2.length) {
    if (matches2[i]) {
      return {
        number: numberWithoutExtension,
        ext: matches2[i]
      };
    }
    i++;
  }
}
var EXTN_PATTERN;
var init_extractExtension = __esm({
  "node_modules/libphonenumber-js/es6/helpers/extension/extractExtension.js"() {
    init_createExtensionPattern();
    EXTN_PATTERN = new RegExp("(?:" + createExtensionPattern() + ")$", "i");
  }
});

// node_modules/libphonenumber-js/es6/helpers/parseDigits.js
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function parseDigit(character) {
  return DIGITS[character];
}
function parseDigits(string) {
  var result2 = "";
  for (var _iterator = _createForOfIteratorHelperLoose(string.split("")), _step; !(_step = _iterator()).done; ) {
    var character = _step.value;
    var digit = parseDigit(character);
    if (digit) {
      result2 += digit;
    }
  }
  return result2;
}
var DIGITS;
var init_parseDigits = __esm({
  "node_modules/libphonenumber-js/es6/helpers/parseDigits.js"() {
    DIGITS = {
      "0": "0",
      "1": "1",
      "2": "2",
      "3": "3",
      "4": "4",
      "5": "5",
      "6": "6",
      "7": "7",
      "8": "8",
      "9": "9",
      "０": "0",
      // Fullwidth digit 0
      "１": "1",
      // Fullwidth digit 1
      "２": "2",
      // Fullwidth digit 2
      "３": "3",
      // Fullwidth digit 3
      "４": "4",
      // Fullwidth digit 4
      "５": "5",
      // Fullwidth digit 5
      "６": "6",
      // Fullwidth digit 6
      "７": "7",
      // Fullwidth digit 7
      "８": "8",
      // Fullwidth digit 8
      "９": "9",
      // Fullwidth digit 9
      "٠": "0",
      // Arabic-indic digit 0
      "١": "1",
      // Arabic-indic digit 1
      "٢": "2",
      // Arabic-indic digit 2
      "٣": "3",
      // Arabic-indic digit 3
      "٤": "4",
      // Arabic-indic digit 4
      "٥": "5",
      // Arabic-indic digit 5
      "٦": "6",
      // Arabic-indic digit 6
      "٧": "7",
      // Arabic-indic digit 7
      "٨": "8",
      // Arabic-indic digit 8
      "٩": "9",
      // Arabic-indic digit 9
      "۰": "0",
      // Eastern-Arabic digit 0
      "۱": "1",
      // Eastern-Arabic digit 1
      "۲": "2",
      // Eastern-Arabic digit 2
      "۳": "3",
      // Eastern-Arabic digit 3
      "۴": "4",
      // Eastern-Arabic digit 4
      "۵": "5",
      // Eastern-Arabic digit 5
      "۶": "6",
      // Eastern-Arabic digit 6
      "۷": "7",
      // Eastern-Arabic digit 7
      "۸": "8",
      // Eastern-Arabic digit 8
      "۹": "9"
      // Eastern-Arabic digit 9
    };
  }
});

// node_modules/libphonenumber-js/es6/parseIncompletePhoneNumber.js
function _createForOfIteratorHelperLoose2(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray2(o, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function parseIncompletePhoneNumber(string) {
  var result2 = "";
  for (var _iterator = _createForOfIteratorHelperLoose2(string.split("")), _step; !(_step = _iterator()).done; ) {
    var character = _step.value;
    result2 += parsePhoneNumberCharacter(character, result2) || "";
  }
  return result2;
}
function parsePhoneNumberCharacter(character, prevParsedCharacters) {
  if (character === "+") {
    if (prevParsedCharacters) {
      return;
    }
    return "+";
  }
  return parseDigit(character);
}
var init_parseIncompletePhoneNumber = __esm({
  "node_modules/libphonenumber-js/es6/parseIncompletePhoneNumber.js"() {
    init_parseDigits();
  }
});

// node_modules/libphonenumber-js/es6/getCountryCallingCode.js
var init_getCountryCallingCode = __esm({
  "node_modules/libphonenumber-js/es6/getCountryCallingCode.js"() {
    init_metadata();
  }
});

// node_modules/libphonenumber-js/es6/helpers/mergeArrays.js
function _createForOfIteratorHelperLoose3(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray3(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray3(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray3(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray3(o, minLen);
}
function _arrayLikeToArray3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function mergeArrays(a, b) {
  var merged = a.slice();
  for (var _iterator = _createForOfIteratorHelperLoose3(b), _step; !(_step = _iterator()).done; ) {
    var element = _step.value;
    if (a.indexOf(element) < 0) {
      merged.push(element);
    }
  }
  return merged.sort(function(a2, b2) {
    return a2 - b2;
  });
}
var init_mergeArrays = __esm({
  "node_modules/libphonenumber-js/es6/helpers/mergeArrays.js"() {
  }
});

// node_modules/libphonenumber-js/es6/helpers/checkNumberLength.js
function checkNumberLength(nationalNumber, metadata) {
  return checkNumberLengthForType(nationalNumber, void 0, metadata);
}
function checkNumberLengthForType(nationalNumber, type, metadata) {
  var type_info = metadata.type(type);
  var possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths();
  if (!possible_lengths) {
    return "IS_POSSIBLE";
  }
  if (type === "FIXED_LINE_OR_MOBILE") {
    if (!metadata.type("FIXED_LINE")) {
      return checkNumberLengthForType(nationalNumber, "MOBILE", metadata);
    }
    var mobile_type = metadata.type("MOBILE");
    if (mobile_type) {
      possible_lengths = mergeArrays(possible_lengths, mobile_type.possibleLengths());
    }
  } else if (type && !type_info) {
    return "INVALID_LENGTH";
  }
  var actual_length = nationalNumber.length;
  var minimum_length = possible_lengths[0];
  if (minimum_length === actual_length) {
    return "IS_POSSIBLE";
  }
  if (minimum_length > actual_length) {
    return "TOO_SHORT";
  }
  if (possible_lengths[possible_lengths.length - 1] < actual_length) {
    return "TOO_LONG";
  }
  return possible_lengths.indexOf(actual_length, 1) >= 0 ? "IS_POSSIBLE" : "INVALID_LENGTH";
}
var init_checkNumberLength = __esm({
  "node_modules/libphonenumber-js/es6/helpers/checkNumberLength.js"() {
    init_mergeArrays();
  }
});

// node_modules/libphonenumber-js/es6/isPossible.js
function isPossiblePhoneNumber(input, options, metadata) {
  if (options === void 0) {
    options = {};
  }
  metadata = new Metadata(metadata);
  if (options.v2) {
    if (!input.countryCallingCode) {
      throw new Error("Invalid phone number object passed");
    }
    metadata.selectNumberingPlan(input.countryCallingCode);
  } else {
    if (!input.phone) {
      return false;
    }
    if (input.country) {
      if (!metadata.hasCountry(input.country)) {
        throw new Error("Unknown country: ".concat(input.country));
      }
      metadata.country(input.country);
    } else {
      if (!input.countryCallingCode) {
        throw new Error("Invalid phone number object passed");
      }
      metadata.selectNumberingPlan(input.countryCallingCode);
    }
  }
  if (metadata.possibleLengths()) {
    return isPossibleNumber(input.phone || input.nationalNumber, metadata);
  } else {
    if (input.countryCallingCode && metadata.isNonGeographicCallingCode(input.countryCallingCode)) {
      return true;
    } else {
      throw new Error('Missing "possibleLengths" in metadata. Perhaps the metadata has been generated before v1.0.18.');
    }
  }
}
function isPossibleNumber(nationalNumber, metadata) {
  switch (checkNumberLength(nationalNumber, metadata)) {
    case "IS_POSSIBLE":
      return true;
    default:
      return false;
  }
}
var init_isPossible = __esm({
  "node_modules/libphonenumber-js/es6/isPossible.js"() {
    init_metadata();
    init_checkNumberLength();
  }
});

// node_modules/libphonenumber-js/es6/helpers/matchesEntirely.js
function matchesEntirely(text, regular_expression) {
  text = text || "";
  return new RegExp("^(?:" + regular_expression + ")$").test(text);
}
var init_matchesEntirely = __esm({
  "node_modules/libphonenumber-js/es6/helpers/matchesEntirely.js"() {
  }
});

// node_modules/libphonenumber-js/es6/helpers/getNumberType.js
function _createForOfIteratorHelperLoose4(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray4(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray4(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray4(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray4(o, minLen);
}
function _arrayLikeToArray4(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function getNumberType(input, options, metadata) {
  options = options || {};
  if (!input.country) {
    return;
  }
  metadata = new Metadata(metadata);
  metadata.selectNumberingPlan(input.country, input.countryCallingCode);
  var nationalNumber = options.v2 ? input.nationalNumber : input.phone;
  if (!matchesEntirely(nationalNumber, metadata.nationalNumberPattern())) {
    return;
  }
  if (isNumberTypeEqualTo(nationalNumber, "FIXED_LINE", metadata)) {
    if (metadata.type("MOBILE") && metadata.type("MOBILE").pattern() === "") {
      return "FIXED_LINE_OR_MOBILE";
    }
    if (!metadata.type("MOBILE")) {
      return "FIXED_LINE_OR_MOBILE";
    }
    if (isNumberTypeEqualTo(nationalNumber, "MOBILE", metadata)) {
      return "FIXED_LINE_OR_MOBILE";
    }
    return "FIXED_LINE";
  }
  for (var _iterator = _createForOfIteratorHelperLoose4(NON_FIXED_LINE_PHONE_TYPES), _step; !(_step = _iterator()).done; ) {
    var type = _step.value;
    if (isNumberTypeEqualTo(nationalNumber, type, metadata)) {
      return type;
    }
  }
}
function isNumberTypeEqualTo(nationalNumber, type, metadata) {
  type = metadata.type(type);
  if (!type || !type.pattern()) {
    return false;
  }
  if (type.possibleLengths() && type.possibleLengths().indexOf(nationalNumber.length) < 0) {
    return false;
  }
  return matchesEntirely(nationalNumber, type.pattern());
}
var NON_FIXED_LINE_PHONE_TYPES;
var init_getNumberType = __esm({
  "node_modules/libphonenumber-js/es6/helpers/getNumberType.js"() {
    init_metadata();
    init_matchesEntirely();
    NON_FIXED_LINE_PHONE_TYPES = ["MOBILE", "PREMIUM_RATE", "TOLL_FREE", "SHARED_COST", "VOIP", "PERSONAL_NUMBER", "PAGER", "UAN", "VOICEMAIL"];
  }
});

// node_modules/libphonenumber-js/es6/isValid.js
function isValidNumber(input, options, metadata) {
  options = options || {};
  metadata = new Metadata(metadata);
  metadata.selectNumberingPlan(input.country, input.countryCallingCode);
  if (metadata.hasTypes()) {
    return getNumberType(input, options, metadata.metadata) !== void 0;
  }
  var nationalNumber = options.v2 ? input.nationalNumber : input.phone;
  return matchesEntirely(nationalNumber, metadata.nationalNumberPattern());
}
var init_isValid = __esm({
  "node_modules/libphonenumber-js/es6/isValid.js"() {
    init_metadata();
    init_matchesEntirely();
    init_getNumberType();
  }
});

// node_modules/libphonenumber-js/es6/helpers/getPossibleCountriesForNumber.js
function getPossibleCountriesForNumber(callingCode, nationalNumber, metadata) {
  var _metadata = new Metadata(metadata);
  var possibleCountries = _metadata.getCountryCodesForCallingCode(callingCode);
  if (!possibleCountries) {
    return [];
  }
  return possibleCountries.filter(function(country2) {
    return couldNationalNumberBelongToCountry(nationalNumber, country2, metadata);
  });
}
function couldNationalNumberBelongToCountry(nationalNumber, country2, metadata) {
  var _metadata = new Metadata(metadata);
  _metadata.selectNumberingPlan(country2);
  if (_metadata.numberingPlan.possibleLengths().indexOf(nationalNumber.length) >= 0) {
    return true;
  }
  return false;
}
var init_getPossibleCountriesForNumber = __esm({
  "node_modules/libphonenumber-js/es6/helpers/getPossibleCountriesForNumber.js"() {
    init_metadata();
  }
});

// node_modules/libphonenumber-js/es6/helpers/applyInternationalSeparatorStyle.js
function applyInternationalSeparatorStyle(formattedNumber) {
  return formattedNumber.replace(new RegExp("[".concat(VALID_PUNCTUATION, "]+"), "g"), " ").trim();
}
var init_applyInternationalSeparatorStyle = __esm({
  "node_modules/libphonenumber-js/es6/helpers/applyInternationalSeparatorStyle.js"() {
    init_constants();
  }
});

// node_modules/libphonenumber-js/es6/helpers/formatNationalNumberUsingFormat.js
function formatNationalNumberUsingFormat(number, format2, _ref) {
  var useInternationalFormat = _ref.useInternationalFormat, withNationalPrefix = _ref.withNationalPrefix, carrierCode = _ref.carrierCode, metadata = _ref.metadata;
  var formattedNumber = number.replace(new RegExp(format2.pattern()), useInternationalFormat ? format2.internationalFormat() : (
    // This library doesn't use `domestic_carrier_code_formatting_rule`,
    // because that one is only used when formatting phone numbers
    // for dialing from a mobile phone, and this is not a dialing library.
    // carrierCode && format.domesticCarrierCodeFormattingRule()
    // 	// First, replace the $CC in the formatting rule with the desired carrier code.
    // 	// Then, replace the $FG in the formatting rule with the first group
    // 	// and the carrier code combined in the appropriate way.
    // 	? format.format().replace(FIRST_GROUP_PATTERN, format.domesticCarrierCodeFormattingRule().replace('$CC', carrierCode))
    // 	: (
    // 		withNationalPrefix && format.nationalPrefixFormattingRule()
    // 			? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule())
    // 			: format.format()
    // 	)
    withNationalPrefix && format2.nationalPrefixFormattingRule() ? format2.format().replace(FIRST_GROUP_PATTERN, format2.nationalPrefixFormattingRule()) : format2.format()
  ));
  if (useInternationalFormat) {
    return applyInternationalSeparatorStyle(formattedNumber);
  }
  return formattedNumber;
}
var FIRST_GROUP_PATTERN;
var init_formatNationalNumberUsingFormat = __esm({
  "node_modules/libphonenumber-js/es6/helpers/formatNationalNumberUsingFormat.js"() {
    init_applyInternationalSeparatorStyle();
    FIRST_GROUP_PATTERN = /(\$\d)/;
  }
});

// node_modules/libphonenumber-js/es6/helpers/getIddPrefix.js
function getIddPrefix(country2, callingCode, metadata) {
  var countryMetadata = new Metadata(metadata);
  countryMetadata.selectNumberingPlan(country2, callingCode);
  if (countryMetadata.defaultIDDPrefix()) {
    return countryMetadata.defaultIDDPrefix();
  }
  if (SINGLE_IDD_PREFIX_REG_EXP.test(countryMetadata.IDDPrefix())) {
    return countryMetadata.IDDPrefix();
  }
}
var SINGLE_IDD_PREFIX_REG_EXP;
var init_getIddPrefix = __esm({
  "node_modules/libphonenumber-js/es6/helpers/getIddPrefix.js"() {
    init_metadata();
    SINGLE_IDD_PREFIX_REG_EXP = /^[\d]+(?:[~\u2053\u223C\uFF5E][\d]+)?$/;
  }
});

// node_modules/libphonenumber-js/es6/helpers/RFC3966.js
function formatRFC3966(_ref) {
  var number = _ref.number, ext = _ref.ext;
  if (!number) {
    return "";
  }
  if (number[0] !== "+") {
    throw new Error('"formatRFC3966()" expects "number" to be in E.164 format.');
  }
  return "tel:".concat(number).concat(ext ? ";ext=" + ext : "");
}
var init_RFC3966 = __esm({
  "node_modules/libphonenumber-js/es6/helpers/RFC3966.js"() {
    init_isViablePhoneNumber();
  }
});

// node_modules/libphonenumber-js/es6/format.js
function _createForOfIteratorHelperLoose5(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray5(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray5(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray5(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray5(o, minLen);
}
function _arrayLikeToArray5(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function formatNumber2(input, format2, options, metadata) {
  if (options) {
    options = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);
  } else {
    options = DEFAULT_OPTIONS;
  }
  metadata = new Metadata(metadata);
  if (input.country && input.country !== "001") {
    if (!metadata.hasCountry(input.country)) {
      throw new Error("Unknown country: ".concat(input.country));
    }
    metadata.country(input.country);
  } else if (input.countryCallingCode) {
    metadata.selectNumberingPlan(input.countryCallingCode);
  } else
    return input.phone || "";
  var countryCallingCode = metadata.countryCallingCode();
  var nationalNumber = options.v2 ? input.nationalNumber : input.phone;
  var number;
  switch (format2) {
    case "NATIONAL":
      if (!nationalNumber) {
        return "";
      }
      number = formatNationalNumber(nationalNumber, input.carrierCode, "NATIONAL", metadata, options);
      return addExtension(number, input.ext, metadata, options.formatExtension);
    case "INTERNATIONAL":
      if (!nationalNumber) {
        return "+".concat(countryCallingCode);
      }
      number = formatNationalNumber(nationalNumber, null, "INTERNATIONAL", metadata, options);
      number = "+".concat(countryCallingCode, " ").concat(number);
      return addExtension(number, input.ext, metadata, options.formatExtension);
    case "E.164":
      return "+".concat(countryCallingCode).concat(nationalNumber);
    case "RFC3966":
      return formatRFC3966({
        number: "+".concat(countryCallingCode).concat(nationalNumber),
        ext: input.ext
      });
    case "IDD":
      if (!options.fromCountry) {
        return;
      }
      var formattedNumber = formatIDD(nationalNumber, input.carrierCode, countryCallingCode, options.fromCountry, metadata);
      return addExtension(formattedNumber, input.ext, metadata, options.formatExtension);
    default:
      throw new Error('Unknown "format" argument passed to "formatNumber()": "'.concat(format2, '"'));
  }
}
function formatNationalNumber(number, carrierCode, formatAs, metadata, options) {
  var format2 = chooseFormatForNumber(metadata.formats(), number);
  if (!format2) {
    return number;
  }
  return formatNationalNumberUsingFormat(number, format2, {
    useInternationalFormat: formatAs === "INTERNATIONAL",
    withNationalPrefix: format2.nationalPrefixIsOptionalWhenFormattingInNationalFormat() && options && options.nationalPrefix === false ? false : true,
    carrierCode,
    metadata
  });
}
function chooseFormatForNumber(availableFormats, nationalNnumber) {
  for (var _iterator = _createForOfIteratorHelperLoose5(availableFormats), _step; !(_step = _iterator()).done; ) {
    var format2 = _step.value;
    if (format2.leadingDigitsPatterns().length > 0) {
      var lastLeadingDigitsPattern = format2.leadingDigitsPatterns()[format2.leadingDigitsPatterns().length - 1];
      if (nationalNnumber.search(lastLeadingDigitsPattern) !== 0) {
        continue;
      }
    }
    if (matchesEntirely(nationalNnumber, format2.pattern())) {
      return format2;
    }
  }
}
function addExtension(formattedNumber, ext, metadata, formatExtension2) {
  return ext ? formatExtension2(formattedNumber, ext, metadata) : formattedNumber;
}
function formatIDD(nationalNumber, carrierCode, countryCallingCode, fromCountry, metadata) {
  var fromCountryCallingCode = getCountryCallingCode(fromCountry, metadata.metadata);
  if (fromCountryCallingCode === countryCallingCode) {
    var formattedNumber = formatNationalNumber(nationalNumber, carrierCode, "NATIONAL", metadata);
    if (countryCallingCode === "1") {
      return countryCallingCode + " " + formattedNumber;
    }
    return formattedNumber;
  }
  var iddPrefix = getIddPrefix(fromCountry, void 0, metadata.metadata);
  if (iddPrefix) {
    return "".concat(iddPrefix, " ").concat(countryCallingCode, " ").concat(formatNationalNumber(nationalNumber, null, "INTERNATIONAL", metadata));
  }
}
var DEFAULT_OPTIONS;
var init_format = __esm({
  "node_modules/libphonenumber-js/es6/format.js"() {
    init_matchesEntirely();
    init_formatNationalNumberUsingFormat();
    init_metadata();
    init_getIddPrefix();
    init_RFC3966();
    DEFAULT_OPTIONS = {
      formatExtension: function formatExtension(formattedNumber, extension, metadata) {
        return "".concat(formattedNumber).concat(metadata.ext()).concat(extension);
      }
    };
  }
});

// node_modules/libphonenumber-js/es6/PhoneNumber.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck3(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties3(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadataJson) {
  var country2;
  var countryCallingCode;
  var metadata = new Metadata(metadataJson);
  if (isCountryCode(countryOrCountryCallingCode)) {
    country2 = countryOrCountryCallingCode;
    metadata.selectNumberingPlan(country2);
    countryCallingCode = metadata.countryCallingCode();
  } else {
    countryCallingCode = countryOrCountryCallingCode;
    if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {
      if (metadata.isNonGeographicCallingCode(countryCallingCode)) {
        country2 = "001";
      }
    }
  }
  return {
    country: country2,
    countryCallingCode
  };
}
var USE_NON_GEOGRAPHIC_COUNTRY_CODE, PhoneNumber, isCountryCode;
var init_PhoneNumber = __esm({
  "node_modules/libphonenumber-js/es6/PhoneNumber.js"() {
    init_metadata();
    init_isPossible();
    init_isValid();
    init_getNumberType();
    init_getPossibleCountriesForNumber();
    init_format();
    USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;
    PhoneNumber = function() {
      function PhoneNumber2(countryOrCountryCallingCode, nationalNumber, metadata) {
        _classCallCheck3(this, PhoneNumber2);
        if (!countryOrCountryCallingCode) {
          throw new TypeError("`country` or `countryCallingCode` not passed");
        }
        if (!nationalNumber) {
          throw new TypeError("`nationalNumber` not passed");
        }
        if (!metadata) {
          throw new TypeError("`metadata` not passed");
        }
        var _getCountryAndCountry = getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadata), country2 = _getCountryAndCountry.country, countryCallingCode = _getCountryAndCountry.countryCallingCode;
        this.country = country2;
        this.countryCallingCode = countryCallingCode;
        this.nationalNumber = nationalNumber;
        this.number = "+" + this.countryCallingCode + this.nationalNumber;
        this.metadata = metadata;
      }
      _createClass3(PhoneNumber2, [{
        key: "setExt",
        value: function setExt(ext) {
          this.ext = ext;
        }
      }, {
        key: "getPossibleCountries",
        value: function getPossibleCountries() {
          if (this.country) {
            return [this.country];
          }
          return getPossibleCountriesForNumber(this.countryCallingCode, this.nationalNumber, this.metadata);
        }
      }, {
        key: "isPossible",
        value: function isPossible() {
          return isPossiblePhoneNumber(this, {
            v2: true
          }, this.metadata);
        }
      }, {
        key: "isValid",
        value: function isValid() {
          return isValidNumber(this, {
            v2: true
          }, this.metadata);
        }
      }, {
        key: "isNonGeographic",
        value: function isNonGeographic() {
          var metadata = new Metadata(this.metadata);
          return metadata.isNonGeographicCallingCode(this.countryCallingCode);
        }
      }, {
        key: "isEqual",
        value: function isEqual(phoneNumber) {
          return this.number === phoneNumber.number && this.ext === phoneNumber.ext;
        }
        // This function was originally meant to be an equivalent for `validatePhoneNumberLength()`,
        // but later it was found out that it doesn't include the possible `TOO_SHORT` result
        // returned from `parsePhoneNumberWithError()` in the original `validatePhoneNumberLength()`,
        // so eventually I simply commented out this method from the `PhoneNumber` class
        // and just left the `validatePhoneNumberLength()` function, even though that one would require
        // and additional step to also validate the actual country / calling code of the phone number.
        // validateLength() {
        // 	const metadata = new Metadata(this.metadata)
        // 	metadata.selectNumberingPlan(this.countryCallingCode)
        // 	const result = checkNumberLength(this.nationalNumber, metadata)
        // 	if (result !== 'IS_POSSIBLE') {
        // 		return result
        // 	}
        // }
      }, {
        key: "getType",
        value: function getType2() {
          return getNumberType(this, {
            v2: true
          }, this.metadata);
        }
      }, {
        key: "format",
        value: function format2(_format, options) {
          return formatNumber2(this, _format, options ? _objectSpread2(_objectSpread2({}, options), {}, {
            v2: true
          }) : {
            v2: true
          }, this.metadata);
        }
      }, {
        key: "formatNational",
        value: function formatNational(options) {
          return this.format("NATIONAL", options);
        }
      }, {
        key: "formatInternational",
        value: function formatInternational(options) {
          return this.format("INTERNATIONAL", options);
        }
      }, {
        key: "getURI",
        value: function getURI(options) {
          return this.format("RFC3966", options);
        }
      }]);
      return PhoneNumber2;
    }();
    isCountryCode = function isCountryCode2(value) {
      return /^[A-Z]{2}$/.test(value);
    };
  }
});

// node_modules/libphonenumber-js/es6/helpers/stripIddPrefix.js
function stripIddPrefix(number, country2, callingCode, metadata) {
  if (!country2) {
    return;
  }
  var countryMetadata = new Metadata(metadata);
  countryMetadata.selectNumberingPlan(country2, callingCode);
  var IDDPrefixPattern = new RegExp(countryMetadata.IDDPrefix());
  if (number.search(IDDPrefixPattern) !== 0) {
    return;
  }
  number = number.slice(number.match(IDDPrefixPattern)[0].length);
  var matchedGroups = number.match(CAPTURING_DIGIT_PATTERN);
  if (matchedGroups && matchedGroups[1] != null && matchedGroups[1].length > 0) {
    if (matchedGroups[1] === "0") {
      return;
    }
  }
  return number;
}
var CAPTURING_DIGIT_PATTERN;
var init_stripIddPrefix = __esm({
  "node_modules/libphonenumber-js/es6/helpers/stripIddPrefix.js"() {
    init_metadata();
    init_constants();
    CAPTURING_DIGIT_PATTERN = new RegExp("([" + VALID_DIGITS + "])");
  }
});

// node_modules/libphonenumber-js/es6/helpers/extractNationalNumberFromPossiblyIncompleteNumber.js
function extractNationalNumberFromPossiblyIncompleteNumber(number, metadata) {
  if (number && metadata.numberingPlan.nationalPrefixForParsing()) {
    var prefixPattern = new RegExp("^(?:" + metadata.numberingPlan.nationalPrefixForParsing() + ")");
    var prefixMatch = prefixPattern.exec(number);
    if (prefixMatch) {
      var nationalNumber;
      var carrierCode;
      var capturedGroupsCount = prefixMatch.length - 1;
      var hasCapturedGroups = capturedGroupsCount > 0 && prefixMatch[capturedGroupsCount];
      if (metadata.nationalPrefixTransformRule() && hasCapturedGroups) {
        nationalNumber = number.replace(prefixPattern, metadata.nationalPrefixTransformRule());
        if (capturedGroupsCount > 1) {
          carrierCode = prefixMatch[1];
        }
      } else {
        var prefixBeforeNationalNumber = prefixMatch[0];
        nationalNumber = number.slice(prefixBeforeNationalNumber.length);
        if (hasCapturedGroups) {
          carrierCode = prefixMatch[1];
        }
      }
      var nationalPrefix;
      if (hasCapturedGroups) {
        var possiblePositionOfTheFirstCapturedGroup = number.indexOf(prefixMatch[1]);
        var possibleNationalPrefix = number.slice(0, possiblePositionOfTheFirstCapturedGroup);
        if (possibleNationalPrefix === metadata.numberingPlan.nationalPrefix()) {
          nationalPrefix = metadata.numberingPlan.nationalPrefix();
        }
      } else {
        nationalPrefix = prefixMatch[0];
      }
      return {
        nationalNumber,
        nationalPrefix,
        carrierCode
      };
    }
  }
  return {
    nationalNumber: number
  };
}
var init_extractNationalNumberFromPossiblyIncompleteNumber = __esm({
  "node_modules/libphonenumber-js/es6/helpers/extractNationalNumberFromPossiblyIncompleteNumber.js"() {
  }
});

// node_modules/libphonenumber-js/es6/helpers/extractNationalNumber.js
function extractNationalNumber(number, metadata) {
  var _extractNationalNumbe = extractNationalNumberFromPossiblyIncompleteNumber(number, metadata), carrierCode = _extractNationalNumbe.carrierCode, nationalNumber = _extractNationalNumbe.nationalNumber;
  if (nationalNumber !== number) {
    if (!shouldHaveExtractedNationalPrefix(number, nationalNumber, metadata)) {
      return {
        nationalNumber: number
      };
    }
    if (metadata.possibleLengths()) {
      if (!isPossibleIncompleteNationalNumber(nationalNumber, metadata)) {
        return {
          nationalNumber: number
        };
      }
    }
  }
  return {
    nationalNumber,
    carrierCode
  };
}
function shouldHaveExtractedNationalPrefix(nationalNumberBefore, nationalNumberAfter, metadata) {
  if (matchesEntirely(nationalNumberBefore, metadata.nationalNumberPattern()) && !matchesEntirely(nationalNumberAfter, metadata.nationalNumberPattern())) {
    return false;
  }
  return true;
}
function isPossibleIncompleteNationalNumber(nationalNumber, metadata) {
  switch (checkNumberLength(nationalNumber, metadata)) {
    case "TOO_SHORT":
    case "INVALID_LENGTH":
      return false;
    default:
      return true;
  }
}
var init_extractNationalNumber = __esm({
  "node_modules/libphonenumber-js/es6/helpers/extractNationalNumber.js"() {
    init_extractNationalNumberFromPossiblyIncompleteNumber();
    init_matchesEntirely();
    init_checkNumberLength();
  }
});

// node_modules/libphonenumber-js/es6/helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js
function extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(number, country2, callingCode, metadata) {
  var countryCallingCode = country2 ? getCountryCallingCode(country2, metadata) : callingCode;
  if (number.indexOf(countryCallingCode) === 0) {
    metadata = new Metadata(metadata);
    metadata.selectNumberingPlan(country2, callingCode);
    var possibleShorterNumber = number.slice(countryCallingCode.length);
    var _extractNationalNumbe = extractNationalNumber(possibleShorterNumber, metadata), possibleShorterNationalNumber = _extractNationalNumbe.nationalNumber;
    var _extractNationalNumbe2 = extractNationalNumber(number, metadata), nationalNumber = _extractNationalNumbe2.nationalNumber;
    if (!matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) && matchesEntirely(possibleShorterNationalNumber, metadata.nationalNumberPattern()) || checkNumberLength(nationalNumber, metadata) === "TOO_LONG") {
      return {
        countryCallingCode,
        number: possibleShorterNumber
      };
    }
  }
  return {
    number
  };
}
var init_extractCountryCallingCodeFromInternationalNumberWithoutPlusSign = __esm({
  "node_modules/libphonenumber-js/es6/helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js"() {
    init_metadata();
    init_matchesEntirely();
    init_extractNationalNumber();
    init_checkNumberLength();
    init_getCountryCallingCode();
  }
});

// node_modules/libphonenumber-js/es6/helpers/extractCountryCallingCode.js
function extractCountryCallingCode(number, country2, callingCode, metadata) {
  if (!number) {
    return {};
  }
  var isNumberWithIddPrefix;
  if (number[0] !== "+") {
    var numberWithoutIDD = stripIddPrefix(number, country2, callingCode, metadata);
    if (numberWithoutIDD && numberWithoutIDD !== number) {
      isNumberWithIddPrefix = true;
      number = "+" + numberWithoutIDD;
    } else {
      if (country2 || callingCode) {
        var _extractCountryCallin = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(number, country2, callingCode, metadata), countryCallingCode = _extractCountryCallin.countryCallingCode, shorterNumber = _extractCountryCallin.number;
        if (countryCallingCode) {
          return {
            countryCallingCodeSource: "FROM_NUMBER_WITHOUT_PLUS_SIGN",
            countryCallingCode,
            number: shorterNumber
          };
        }
      }
      return {
        // No need to set it to `UNSPECIFIED`. It can be just `undefined`.
        // countryCallingCodeSource: 'UNSPECIFIED',
        number
      };
    }
  }
  if (number[1] === "0") {
    return {};
  }
  metadata = new Metadata(metadata);
  var i = 2;
  while (i - 1 <= MAX_LENGTH_COUNTRY_CODE && i <= number.length) {
    var _countryCallingCode = number.slice(1, i);
    if (metadata.hasCallingCode(_countryCallingCode)) {
      metadata.selectNumberingPlan(_countryCallingCode);
      return {
        countryCallingCodeSource: isNumberWithIddPrefix ? "FROM_NUMBER_WITH_IDD" : "FROM_NUMBER_WITH_PLUS_SIGN",
        countryCallingCode: _countryCallingCode,
        number: number.slice(i)
      };
    }
    i++;
  }
  return {};
}
var init_extractCountryCallingCode = __esm({
  "node_modules/libphonenumber-js/es6/helpers/extractCountryCallingCode.js"() {
    init_stripIddPrefix();
    init_extractCountryCallingCodeFromInternationalNumberWithoutPlusSign();
    init_metadata();
    init_constants();
  }
});

// node_modules/libphonenumber-js/es6/helpers/getCountryByNationalNumber.js
function _createForOfIteratorHelperLoose6(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray6(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray6(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray6(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray6(o, minLen);
}
function _arrayLikeToArray6(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function getCountryByNationalNumber(possibleCountries, nationalPhoneNumber, metadata) {
  metadata = new Metadata(metadata);
  for (var _iterator = _createForOfIteratorHelperLoose6(possibleCountries), _step; !(_step = _iterator()).done; ) {
    var country2 = _step.value;
    metadata.country(country2);
    if (metadata.leadingDigits()) {
      if (nationalPhoneNumber && nationalPhoneNumber.search(metadata.leadingDigits()) === 0) {
        return country2;
      }
    } else if (getNumberType({
      phone: nationalPhoneNumber,
      country: country2
    }, void 0, metadata.metadata)) {
      return country2;
    }
  }
}
var init_getCountryByNationalNumber = __esm({
  "node_modules/libphonenumber-js/es6/helpers/getCountryByNationalNumber.js"() {
    init_metadata();
    init_getNumberType();
  }
});

// node_modules/libphonenumber-js/es6/helpers/getCountryByCallingCode.js
function getCountryByCallingCode(callingCode, nationalPhoneNumber, metadata) {
  if (USE_NON_GEOGRAPHIC_COUNTRY_CODE2) {
    if (metadata.isNonGeographicCallingCode(callingCode)) {
      return "001";
    }
  }
  var possibleCountries = metadata.getCountryCodesForCallingCode(callingCode);
  if (!possibleCountries) {
    return;
  }
  if (possibleCountries.length === 1) {
    return possibleCountries[0];
  }
  return getCountryByNationalNumber(possibleCountries, nationalPhoneNumber, metadata.metadata);
}
var USE_NON_GEOGRAPHIC_COUNTRY_CODE2;
var init_getCountryByCallingCode = __esm({
  "node_modules/libphonenumber-js/es6/helpers/getCountryByCallingCode.js"() {
    init_getCountryByNationalNumber();
    USE_NON_GEOGRAPHIC_COUNTRY_CODE2 = false;
  }
});

// node_modules/libphonenumber-js/es6/helpers/extractPhoneContext.js
function extractPhoneContext(numberToExtractFrom) {
  var indexOfPhoneContext = numberToExtractFrom.indexOf(RFC3966_PHONE_CONTEXT_);
  if (indexOfPhoneContext < 0) {
    return null;
  }
  var phoneContextStart = indexOfPhoneContext + RFC3966_PHONE_CONTEXT_.length;
  if (phoneContextStart >= numberToExtractFrom.length) {
    return "";
  }
  var phoneContextEnd = numberToExtractFrom.indexOf(";", phoneContextStart);
  if (phoneContextEnd >= 0) {
    return numberToExtractFrom.substring(phoneContextStart, phoneContextEnd);
  } else {
    return numberToExtractFrom.substring(phoneContextStart);
  }
}
function isPhoneContextValid(phoneContext) {
  if (phoneContext === null) {
    return true;
  }
  if (phoneContext.length === 0) {
    return false;
  }
  return RFC3966_GLOBAL_NUMBER_DIGITS_PATTERN_.test(phoneContext) || RFC3966_DOMAINNAME_PATTERN_.test(phoneContext);
}
var PLUS_SIGN, RFC3966_VISUAL_SEPARATOR_, RFC3966_PHONE_DIGIT_, RFC3966_GLOBAL_NUMBER_DIGITS_, RFC3966_GLOBAL_NUMBER_DIGITS_PATTERN_, ALPHANUM_, RFC3966_DOMAINLABEL_, VALID_ALPHA_, RFC3966_TOPLABEL_, RFC3966_DOMAINNAME_, RFC3966_DOMAINNAME_PATTERN_, RFC3966_PREFIX_, RFC3966_PHONE_CONTEXT_, RFC3966_ISDN_SUBADDRESS_;
var init_extractPhoneContext = __esm({
  "node_modules/libphonenumber-js/es6/helpers/extractPhoneContext.js"() {
    init_constants();
    PLUS_SIGN = "+";
    RFC3966_VISUAL_SEPARATOR_ = "[\\-\\.\\(\\)]?";
    RFC3966_PHONE_DIGIT_ = "([" + VALID_DIGITS + "]|" + RFC3966_VISUAL_SEPARATOR_ + ")";
    RFC3966_GLOBAL_NUMBER_DIGITS_ = "^\\" + PLUS_SIGN + RFC3966_PHONE_DIGIT_ + "*[" + VALID_DIGITS + "]" + RFC3966_PHONE_DIGIT_ + "*$";
    RFC3966_GLOBAL_NUMBER_DIGITS_PATTERN_ = new RegExp(RFC3966_GLOBAL_NUMBER_DIGITS_, "g");
    ALPHANUM_ = VALID_DIGITS;
    RFC3966_DOMAINLABEL_ = "[" + ALPHANUM_ + "]+((\\-)*[" + ALPHANUM_ + "])*";
    VALID_ALPHA_ = "a-zA-Z";
    RFC3966_TOPLABEL_ = "[" + VALID_ALPHA_ + "]+((\\-)*[" + ALPHANUM_ + "])*";
    RFC3966_DOMAINNAME_ = "^(" + RFC3966_DOMAINLABEL_ + "\\.)*" + RFC3966_TOPLABEL_ + "\\.?$";
    RFC3966_DOMAINNAME_PATTERN_ = new RegExp(RFC3966_DOMAINNAME_, "g");
    RFC3966_PREFIX_ = "tel:";
    RFC3966_PHONE_CONTEXT_ = ";phone-context=";
    RFC3966_ISDN_SUBADDRESS_ = ";isub=";
  }
});

// node_modules/libphonenumber-js/es6/helpers/extractFormattedPhoneNumberFromPossibleRfc3966NumberUri.js
function extractFormattedPhoneNumberFromPossibleRfc3966NumberUri(numberToParse, _ref) {
  var extractFormattedPhoneNumber2 = _ref.extractFormattedPhoneNumber;
  var phoneContext = extractPhoneContext(numberToParse);
  if (!isPhoneContextValid(phoneContext)) {
    throw new ParseError("NOT_A_NUMBER");
  }
  var phoneNumberString;
  if (phoneContext === null) {
    phoneNumberString = extractFormattedPhoneNumber2(numberToParse) || "";
  } else {
    phoneNumberString = "";
    if (phoneContext.charAt(0) === PLUS_SIGN) {
      phoneNumberString += phoneContext;
    }
    var indexOfRfc3966Prefix = numberToParse.indexOf(RFC3966_PREFIX_);
    var indexOfNationalNumber;
    if (indexOfRfc3966Prefix >= 0) {
      indexOfNationalNumber = indexOfRfc3966Prefix + RFC3966_PREFIX_.length;
    } else {
      indexOfNationalNumber = 0;
    }
    var indexOfPhoneContext = numberToParse.indexOf(RFC3966_PHONE_CONTEXT_);
    phoneNumberString += numberToParse.substring(indexOfNationalNumber, indexOfPhoneContext);
  }
  var indexOfIsdn = phoneNumberString.indexOf(RFC3966_ISDN_SUBADDRESS_);
  if (indexOfIsdn > 0) {
    phoneNumberString = phoneNumberString.substring(0, indexOfIsdn);
  }
  if (phoneNumberString !== "") {
    return phoneNumberString;
  }
}
var init_extractFormattedPhoneNumberFromPossibleRfc3966NumberUri = __esm({
  "node_modules/libphonenumber-js/es6/helpers/extractFormattedPhoneNumberFromPossibleRfc3966NumberUri.js"() {
    init_extractPhoneContext();
    init_ParseError();
  }
});

// node_modules/libphonenumber-js/es6/parse.js
function parse(text, options, metadata) {
  options = options || {};
  metadata = new Metadata(metadata);
  if (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {
    if (options.v2) {
      throw new ParseError("INVALID_COUNTRY");
    }
    throw new Error("Unknown country: ".concat(options.defaultCountry));
  }
  var _parseInput = parseInput(text, options.v2, options.extract), formattedPhoneNumber = _parseInput.number, ext = _parseInput.ext, error = _parseInput.error;
  if (!formattedPhoneNumber) {
    if (options.v2) {
      if (error === "TOO_SHORT") {
        throw new ParseError("TOO_SHORT");
      }
      throw new ParseError("NOT_A_NUMBER");
    }
    return {};
  }
  var _parsePhoneNumber = parsePhoneNumber(formattedPhoneNumber, options.defaultCountry, options.defaultCallingCode, metadata), country2 = _parsePhoneNumber.country, nationalNumber = _parsePhoneNumber.nationalNumber, countryCallingCode = _parsePhoneNumber.countryCallingCode, countryCallingCodeSource = _parsePhoneNumber.countryCallingCodeSource, carrierCode = _parsePhoneNumber.carrierCode;
  if (!metadata.hasSelectedNumberingPlan()) {
    if (options.v2) {
      throw new ParseError("INVALID_COUNTRY");
    }
    return {};
  }
  if (!nationalNumber || nationalNumber.length < MIN_LENGTH_FOR_NSN) {
    if (options.v2) {
      throw new ParseError("TOO_SHORT");
    }
    return {};
  }
  if (nationalNumber.length > MAX_LENGTH_FOR_NSN) {
    if (options.v2) {
      throw new ParseError("TOO_LONG");
    }
    return {};
  }
  if (options.v2) {
    var phoneNumber = new PhoneNumber(countryCallingCode, nationalNumber, metadata.metadata);
    if (country2) {
      phoneNumber.country = country2;
    }
    if (carrierCode) {
      phoneNumber.carrierCode = carrierCode;
    }
    if (ext) {
      phoneNumber.ext = ext;
    }
    phoneNumber.__countryCallingCodeSource = countryCallingCodeSource;
    return phoneNumber;
  }
  var valid = (options.extended ? metadata.hasSelectedNumberingPlan() : country2) ? matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) : false;
  if (!options.extended) {
    return valid ? result(country2, nationalNumber, ext) : {};
  }
  return {
    country: country2,
    countryCallingCode,
    carrierCode,
    valid,
    possible: valid ? true : options.extended === true && metadata.possibleLengths() && isPossibleNumber(nationalNumber, metadata) ? true : false,
    phone: nationalNumber,
    ext
  };
}
function _extractFormattedPhoneNumber(text, extract, throwOnError) {
  if (!text) {
    return;
  }
  if (text.length > MAX_INPUT_STRING_LENGTH) {
    if (throwOnError) {
      throw new ParseError("TOO_LONG");
    }
    return;
  }
  if (extract === false) {
    return text;
  }
  var startsAt = text.search(PHONE_NUMBER_START_PATTERN);
  if (startsAt < 0) {
    return;
  }
  return text.slice(startsAt).replace(AFTER_PHONE_NUMBER_END_PATTERN, "");
}
function parseInput(text, v2, extract) {
  var number = extractFormattedPhoneNumberFromPossibleRfc3966NumberUri(text, {
    extractFormattedPhoneNumber: function extractFormattedPhoneNumber2(text2) {
      return _extractFormattedPhoneNumber(text2, extract, v2);
    }
  });
  if (!number) {
    return {};
  }
  if (!isViablePhoneNumber(number)) {
    if (isViablePhoneNumberStart(number)) {
      return {
        error: "TOO_SHORT"
      };
    }
    return {};
  }
  var withExtensionStripped = extractExtension(number);
  if (withExtensionStripped.ext) {
    return withExtensionStripped;
  }
  return {
    number
  };
}
function result(country2, nationalNumber, ext) {
  var result2 = {
    country: country2,
    phone: nationalNumber
  };
  if (ext) {
    result2.ext = ext;
  }
  return result2;
}
function parsePhoneNumber(formattedPhoneNumber, defaultCountry, defaultCallingCode, metadata) {
  var _extractCountryCallin = extractCountryCallingCode(parseIncompletePhoneNumber(formattedPhoneNumber), defaultCountry, defaultCallingCode, metadata.metadata), countryCallingCodeSource = _extractCountryCallin.countryCallingCodeSource, countryCallingCode = _extractCountryCallin.countryCallingCode, number = _extractCountryCallin.number;
  var country2;
  if (countryCallingCode) {
    metadata.selectNumberingPlan(countryCallingCode);
  } else if (number && (defaultCountry || defaultCallingCode)) {
    metadata.selectNumberingPlan(defaultCountry, defaultCallingCode);
    if (defaultCountry) {
      country2 = defaultCountry;
    } else {
      if (USE_NON_GEOGRAPHIC_COUNTRY_CODE3) {
        if (metadata.isNonGeographicCallingCode(defaultCallingCode)) {
          country2 = "001";
        }
      }
    }
    countryCallingCode = defaultCallingCode || getCountryCallingCode(defaultCountry, metadata.metadata);
  } else
    return {};
  if (!number) {
    return {
      countryCallingCodeSource,
      countryCallingCode
    };
  }
  var _extractNationalNumbe = extractNationalNumber(parseIncompletePhoneNumber(number), metadata), nationalNumber = _extractNationalNumbe.nationalNumber, carrierCode = _extractNationalNumbe.carrierCode;
  var exactCountry = getCountryByCallingCode(countryCallingCode, nationalNumber, metadata);
  if (exactCountry) {
    country2 = exactCountry;
    if (exactCountry === "001") {
    } else {
      metadata.country(country2);
    }
  }
  return {
    country: country2,
    countryCallingCode,
    countryCallingCodeSource,
    nationalNumber,
    carrierCode
  };
}
var MAX_INPUT_STRING_LENGTH, PHONE_NUMBER_START_PATTERN, AFTER_PHONE_NUMBER_END_PATTERN, USE_NON_GEOGRAPHIC_COUNTRY_CODE3;
var init_parse = __esm({
  "node_modules/libphonenumber-js/es6/parse.js"() {
    init_constants();
    init_ParseError();
    init_metadata();
    init_isViablePhoneNumber();
    init_extractExtension();
    init_parseIncompletePhoneNumber();
    init_getCountryCallingCode();
    init_isPossible();
    init_PhoneNumber();
    init_matchesEntirely();
    init_extractCountryCallingCode();
    init_extractNationalNumber();
    init_stripIddPrefix();
    init_getCountryByCallingCode();
    init_extractFormattedPhoneNumberFromPossibleRfc3966NumberUri();
    MAX_INPUT_STRING_LENGTH = 250;
    PHONE_NUMBER_START_PATTERN = new RegExp("[" + PLUS_CHARS + VALID_DIGITS + "]");
    AFTER_PHONE_NUMBER_END_PATTERN = new RegExp("[^" + VALID_DIGITS + "#]+$");
    USE_NON_GEOGRAPHIC_COUNTRY_CODE3 = false;
  }
});

// node_modules/libphonenumber-js/es6/parsePhoneNumberWithError_.js
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
      _defineProperty3(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function parsePhoneNumberWithError(text, options, metadata) {
  return parse(text, _objectSpread3(_objectSpread3({}, options), {}, {
    v2: true
  }), metadata);
}
var init_parsePhoneNumberWithError = __esm({
  "node_modules/libphonenumber-js/es6/parsePhoneNumberWithError_.js"() {
    init_parse();
  }
});

// node_modules/libphonenumber-js/es6/normalizeArguments.js
function _typeof3(obj) {
  "@babel/helpers - typeof";
  return _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof3(obj);
}
function ownKeys4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys4(Object(source), true).forEach(function(key) {
      _defineProperty4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray7(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray7(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray7(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray7(o, minLen);
}
function _arrayLikeToArray7(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function normalizeArguments(args) {
  var _Array$prototype$slic = Array.prototype.slice.call(args), _Array$prototype$slic2 = _slicedToArray(_Array$prototype$slic, 4), arg_1 = _Array$prototype$slic2[0], arg_2 = _Array$prototype$slic2[1], arg_3 = _Array$prototype$slic2[2], arg_4 = _Array$prototype$slic2[3];
  var text;
  var options;
  var metadata;
  if (typeof arg_1 === "string") {
    text = arg_1;
  } else
    throw new TypeError("A text for parsing must be a string.");
  if (!arg_2 || typeof arg_2 === "string") {
    if (arg_4) {
      options = arg_3;
      metadata = arg_4;
    } else {
      options = void 0;
      metadata = arg_3;
    }
    if (arg_2) {
      options = _objectSpread4({
        defaultCountry: arg_2
      }, options);
    }
  } else if (isObject(arg_2)) {
    if (arg_3) {
      options = arg_2;
      metadata = arg_3;
    } else {
      metadata = arg_2;
    }
  } else
    throw new Error("Invalid second argument: ".concat(arg_2));
  return {
    text,
    options,
    metadata
  };
}
var isObject;
var init_normalizeArguments = __esm({
  "node_modules/libphonenumber-js/es6/normalizeArguments.js"() {
    isObject = function isObject2(_) {
      return _typeof3(_) === "object";
    };
  }
});

// node_modules/libphonenumber-js/es6/parsePhoneNumberWithError.js
var init_parsePhoneNumberWithError2 = __esm({
  "node_modules/libphonenumber-js/es6/parsePhoneNumberWithError.js"() {
    init_parsePhoneNumberWithError();
    init_normalizeArguments();
  }
});

// node_modules/libphonenumber-js/es6/parsePhoneNumber_.js
function ownKeys5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys5(Object(source), true).forEach(function(key) {
      _defineProperty5(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function parsePhoneNumber2(text, options, metadata) {
  if (options && options.defaultCountry && !isSupportedCountry(options.defaultCountry, metadata)) {
    options = _objectSpread5(_objectSpread5({}, options), {}, {
      defaultCountry: void 0
    });
  }
  try {
    return parsePhoneNumberWithError(text, options, metadata);
  } catch (error) {
    if (error instanceof ParseError) {
    } else {
      throw error;
    }
  }
}
var init_parsePhoneNumber = __esm({
  "node_modules/libphonenumber-js/es6/parsePhoneNumber_.js"() {
    init_parsePhoneNumberWithError();
    init_ParseError();
    init_metadata();
  }
});

// node_modules/libphonenumber-js/es6/parsePhoneNumber.js
function parsePhoneNumber3() {
  var _normalizeArguments = normalizeArguments(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata = _normalizeArguments.metadata;
  return parsePhoneNumber2(text, options, metadata);
}
var init_parsePhoneNumber2 = __esm({
  "node_modules/libphonenumber-js/es6/parsePhoneNumber.js"() {
    init_normalizeArguments();
    init_parsePhoneNumber();
  }
});

// node_modules/libphonenumber-js/es6/isValidPhoneNumber.js
var init_isValidPhoneNumber = __esm({
  "node_modules/libphonenumber-js/es6/isValidPhoneNumber.js"() {
    init_normalizeArguments();
    init_parsePhoneNumber();
  }
});

// node_modules/libphonenumber-js/es6/isPossiblePhoneNumber.js
var init_isPossiblePhoneNumber = __esm({
  "node_modules/libphonenumber-js/es6/isPossiblePhoneNumber.js"() {
    init_normalizeArguments();
    init_parsePhoneNumber();
  }
});

// node_modules/libphonenumber-js/es6/validatePhoneNumberLength.js
var init_validatePhoneNumberLength = __esm({
  "node_modules/libphonenumber-js/es6/validatePhoneNumberLength.js"() {
    init_normalizeArguments();
    init_parsePhoneNumberWithError();
    init_ParseError();
    init_metadata();
    init_checkNumberLength();
  }
});

// node_modules/libphonenumber-js/es6/findNumbers/LRUCache.js
function _defineProperties4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties4(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck4(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var Node, LRUCache;
var init_LRUCache = __esm({
  "node_modules/libphonenumber-js/es6/findNumbers/LRUCache.js"() {
    Node = _createClass4(function Node2(key, value) {
      var next = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      var prev = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      _classCallCheck4(this, Node2);
      this.key = key;
      this.value = value;
      this.next = next;
      this.prev = prev;
    });
    LRUCache = function() {
      function LRUCache2() {
        var limit2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
        _classCallCheck4(this, LRUCache2);
        this.size = 0;
        this.limit = limit2;
        this.head = null;
        this.tail = null;
        this.cache = {};
      }
      _createClass4(LRUCache2, [{
        key: "put",
        value: function put(key, value) {
          this.ensureLimit();
          if (!this.head) {
            this.head = this.tail = new Node(key, value);
          } else {
            var node = new Node(key, value, this.head);
            this.head.prev = node;
            this.head = node;
          }
          this.cache[key] = this.head;
          this.size++;
        }
        // Read from cache map and make that node as new Head of LinkedList
      }, {
        key: "get",
        value: function get(key) {
          if (this.cache[key]) {
            var value = this.cache[key].value;
            this.remove(key);
            this.put(key, value);
            return value;
          }
          console.log("Item not available in cache for key ".concat(key));
        }
      }, {
        key: "ensureLimit",
        value: function ensureLimit() {
          if (this.size === this.limit) {
            this.remove(this.tail.key);
          }
        }
      }, {
        key: "remove",
        value: function remove(key) {
          var node = this.cache[key];
          if (node.prev !== null) {
            node.prev.next = node.next;
          } else {
            this.head = node.next;
          }
          if (node.next !== null) {
            node.next.prev = node.prev;
          } else {
            this.tail = node.prev;
          }
          delete this.cache[key];
          this.size--;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = null;
          this.tail = null;
          this.size = 0;
          this.cache = {};
        }
        // // Invokes the callback function with every node of the chain and the index of the node.
        // forEach(fn) {
        //   let node = this.head;
        //   let counter = 0;
        //   while (node) {
        //     fn(node, counter);
        //     node = node.next;
        //     counter++;
        //   }
        // }
        // // To iterate over LRU with a 'for...of' loop
        // *[Symbol.iterator]() {
        //   let node = this.head;
        //   while (node) {
        //     yield node;
        //     node = node.next;
        //   }
        // }
      }]);
      return LRUCache2;
    }();
  }
});

// node_modules/libphonenumber-js/es6/findNumbers/RegExpCache.js
function _classCallCheck5(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties5(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass5(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties5(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties5(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var RegExpCache;
var init_RegExpCache = __esm({
  "node_modules/libphonenumber-js/es6/findNumbers/RegExpCache.js"() {
    init_LRUCache();
    RegExpCache = function() {
      function RegExpCache2(size) {
        _classCallCheck5(this, RegExpCache2);
        this.cache = new LRUCache(size);
      }
      _createClass5(RegExpCache2, [{
        key: "getPatternForRegExp",
        value: function getPatternForRegExp(pattern) {
          var regExp = this.cache.get(pattern);
          if (!regExp) {
            regExp = new RegExp("^" + pattern);
            this.cache.put(pattern, regExp);
          }
          return regExp;
        }
      }]);
      return RegExpCache2;
    }();
  }
});

// node_modules/libphonenumber-js/es6/findNumbers/util.js
function limit(lower, upper) {
  if (lower < 0 || upper <= 0 || upper < lower) {
    throw new TypeError();
  }
  return "{".concat(lower, ",").concat(upper, "}");
}
function trimAfterFirstMatch(regexp, string) {
  var index = string.search(regexp);
  if (index >= 0) {
    return string.slice(0, index);
  }
  return string;
}
function startsWith(string, substring) {
  return string.indexOf(substring) === 0;
}
function endsWith(string, substring) {
  return string.indexOf(substring, string.length - substring.length) === string.length - substring.length;
}
var init_util = __esm({
  "node_modules/libphonenumber-js/es6/findNumbers/util.js"() {
  }
});

// node_modules/libphonenumber-js/es6/findNumbers/utf-8.js
function isLatinLetter(letter) {
  if (!pL_regexp.test(letter) && !pMn_regexp.test(letter)) {
    return false;
  }
  return latinLetterRegexp.test(letter);
}
function isInvalidPunctuationSymbol(character) {
  return character === "%" || pSc_regexp.test(character);
}
var _pZ, pZ, PZ, _pN, _pNd, pNd, _pL, pL, pL_regexp, _pSc, pSc, pSc_regexp, _pMn, pMn, pMn_regexp, _InBasic_Latin, _InLatin_1_Supplement, _InLatin_Extended_A, _InLatin_Extended_Additional, _InLatin_Extended_B, _InCombining_Diacritical_Marks, latinLetterRegexp;
var init_utf_8 = __esm({
  "node_modules/libphonenumber-js/es6/findNumbers/utf-8.js"() {
    _pZ = "   ᠎ - \u2028\u2029  　";
    pZ = "[".concat(_pZ, "]");
    PZ = "[^".concat(_pZ, "]");
    _pN = "0-9²³¹¼-¾٠-٩۰-۹߀-߉०-९০-৯৴-৹੦-੯૦-૯୦-୯୲-୷௦-௲౦-౯౸-౾೦-೯൦-൵๐-๙໐-໙༠-༳၀-၉႐-႙፩-፼ᛮ-ᛰ០-៩៰-៹᠐-᠙᥆-᥏᧐-᧚᪀-᪉᪐-᪙᭐-᭙᮰-᮹᱀-᱉᱐-᱙⁰⁴-⁹₀-₉⅐-ↂↅ-↉①-⒛⓪-⓿❶-➓⳽〇〡-〩〸-〺㆒-㆕㈠-㈩㉈-㉏㉑-㉟㊀-㊉㊱-㊿꘠-꘩ꛦ-ꛯ꠰-꠵꣐-꣙꤀-꤉꧐-꧙꩐-꩙꯰-꯹０-９";
    _pNd = "0-9٠-٩۰-۹߀-߉०-९০-৯੦-੯૦-૯୦-୯௦-௯౦-౯೦-೯൦-൯๐-๙໐-໙༠-༩၀-၉႐-႙០-៩᠐-᠙᥆-᥏᧐-᧙᪀-᪉᪐-᪙᭐-᭙᮰-᮹᱀-᱉᱐-᱙꘠-꘩꣐-꣙꤀-꤉꧐-꧙꩐-꩙꯰-꯹０-９";
    pNd = "[".concat(_pNd, "]");
    _pL = "A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԧԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠࢢ-ࢬऄ-हऽॐक़-ॡॱ-ॷॹ-ॿঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-ళవ-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤜᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎↃↄⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々〆〱-〵〻〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚗꚠ-ꛥꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞓꞠ-Ɦꟸ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꪀ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
    pL = "[".concat(_pL, "]");
    pL_regexp = new RegExp(pL);
    _pSc = "$¢-¥֏؋৲৳৻૱௹฿៛₠-₹꠸﷼﹩＄￠￡￥￦";
    pSc = "[".concat(_pSc, "]");
    pSc_regexp = new RegExp(pSc);
    _pMn = "̀-ͯ҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-ٰٟۖ-ۜ۟-۪ۤۧۨ-ܑۭܰ-݊ަ-ް߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣤ-ࣾऀ-ंऺ़ु-ै्॑-ॗॢॣঁ়ু-ৄ্ৢৣਁਂ਼ੁੂੇੈੋ-੍ੑੰੱੵઁં઼ુ-ૅેૈ્ૢૣଁ଼ିୁ-ୄ୍ୖୢୣஂீ்ా-ీె-ైొ-్ౕౖౢౣ಼ಿೆೌ್ೢೣു-ൄ്ൢൣ්ි-ුූัิ-ฺ็-๎ັິ-ູົຼ່-ໍཱ༹༘༙༵༷-ཾྀ-྄྆྇ྍ-ྗྙ-ྼ࿆ိ-ူဲ-့္်ွှၘၙၞ-ၠၱ-ၴႂႅႆႍႝ፝-፟ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴឵ិ-ួំ៉-៓៝᠋-᠍ᢩᤠ-ᤢᤧᤨᤲ᤹-᤻ᨘᨗᩖᩘ-ᩞ᩠ᩢᩥ-ᩬᩳ-᩿᩼ᬀ-ᬃ᬴ᬶ-ᬺᬼᭂ᭫-᭳ᮀᮁᮢ-ᮥᮨᮩ᯦᮫ᯨᯩᯭᯯ-ᯱᰬ-ᰳᰶ᰷᳐-᳔᳒-᳢᳠-᳨᳭᳴᷀-ᷦ᷼-᷿⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〭꙯ꙴ-꙽ꚟ꛰꛱ꠂ꠆ꠋꠥꠦ꣄꣠-꣱ꤦ-꤭ꥇ-ꥑꦀ-ꦂ꦳ꦶ-ꦹꦼꨩ-ꨮꨱꨲꨵꨶꩃꩌꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫬꫭ꫶ꯥꯨ꯭ﬞ︀-️︠-︦";
    pMn = "[".concat(_pMn, "]");
    pMn_regexp = new RegExp(pMn);
    _InBasic_Latin = "\0-";
    _InLatin_1_Supplement = "-ÿ";
    _InLatin_Extended_A = "Ā-ſ";
    _InLatin_Extended_Additional = "Ḁ-ỿ";
    _InLatin_Extended_B = "ƀ-ɏ";
    _InCombining_Diacritical_Marks = "̀-ͯ";
    latinLetterRegexp = new RegExp("[" + _InBasic_Latin + _InLatin_1_Supplement + _InLatin_Extended_A + _InLatin_Extended_Additional + _InLatin_Extended_B + _InCombining_Diacritical_Marks + "]");
  }
});

// node_modules/libphonenumber-js/es6/findNumbers/matchPhoneNumberStringAgainstPhoneNumber.js
function matchPhoneNumberStringAgainstPhoneNumber(phoneNumberString, phoneNumber, metadata) {
  var phoneNumberStringContainsCallingCode = true;
  var parsedPhoneNumber = parsePhoneNumber3(phoneNumberString, metadata);
  if (!parsedPhoneNumber) {
    phoneNumberStringContainsCallingCode = false;
    parsedPhoneNumber = parsePhoneNumber3(phoneNumberString, {
      defaultCallingCode: phoneNumber.countryCallingCode
    }, metadata);
  }
  if (!parsedPhoneNumber) {
    return "INVALID_NUMBER";
  }
  if (phoneNumber.ext) {
    if (parsedPhoneNumber.ext !== phoneNumber.ext) {
      return "NO_MATCH";
    }
  } else {
    if (parsedPhoneNumber.ext) {
      return "NO_MATCH";
    }
  }
  if (phoneNumberStringContainsCallingCode) {
    if (phoneNumber.countryCallingCode !== parsedPhoneNumber.countryCallingCode) {
      return "NO_MATCH";
    }
  }
  if (phoneNumber.number === parsedPhoneNumber.number) {
    if (phoneNumberStringContainsCallingCode) {
      return "EXACT_MATCH";
    } else {
      return "NSN_MATCH";
    }
  }
  if (phoneNumber.nationalNumber.indexOf(parsedPhoneNumber.nationalNumber) === 0 || parsedPhoneNumber.nationalNumber.indexOf(phoneNumber.nationalNumber) === 0) {
    return "SHORT_NSN_MATCH";
  }
  return "NO_MATCH";
}
var init_matchPhoneNumberStringAgainstPhoneNumber = __esm({
  "node_modules/libphonenumber-js/es6/findNumbers/matchPhoneNumberStringAgainstPhoneNumber.js"() {
    init_parsePhoneNumber2();
  }
});

// node_modules/libphonenumber-js/es6/findNumbers/Leniency.js
function _createForOfIteratorHelperLoose7(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray8(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray8(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray8(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray8(o, minLen);
}
function _arrayLikeToArray8(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function containsOnlyValidXChars(phoneNumber, candidate, metadata) {
  for (var index = 0; index < candidate.length - 1; index++) {
    var charAtIndex = candidate.charAt(index);
    if (charAtIndex === "x" || charAtIndex === "X") {
      var charAtNextIndex = candidate.charAt(index + 1);
      if (charAtNextIndex === "x" || charAtNextIndex === "X") {
        index++;
        if (matchPhoneNumberStringAgainstPhoneNumber(candidate.substring(index), phoneNumber, metadata) !== "NSN_MATCH") {
          return false;
        }
      } else {
        var ext = parseDigits(candidate.substring(index));
        if (ext) {
          if (phoneNumber.ext !== ext) {
            return false;
          }
        } else {
          if (phoneNumber.ext) {
            return false;
          }
        }
      }
    }
  }
  return true;
}
function isNationalPrefixPresentIfRequired(phoneNumber, _metadata) {
  if (phoneNumber.__countryCallingCodeSource !== "FROM_DEFAULT_COUNTRY") {
    return true;
  }
  var metadata = new Metadata(_metadata);
  metadata.selectNumberingPlan(phoneNumber.countryCallingCode);
  var phoneNumberRegion = phoneNumber.country || getCountryByCallingCode(phoneNumber.countryCallingCode, phoneNumber.nationalNumber, metadata);
  var nationalNumber = phoneNumber.nationalNumber;
  var format2 = chooseFormatForNumber(metadata.numberingPlan.formats(), nationalNumber);
  if (format2.nationalPrefixFormattingRule()) {
    if (metadata.numberingPlan.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {
      return true;
    }
    if (!format2.usesNationalPrefix()) {
      return true;
    }
    return Boolean(phoneNumber.nationalPrefix);
  }
  return true;
}
function containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) {
  var firstSlashInBodyIndex = candidate.indexOf("/");
  if (firstSlashInBodyIndex < 0) {
    return false;
  }
  var secondSlashInBodyIndex = candidate.indexOf("/", firstSlashInBodyIndex + 1);
  if (secondSlashInBodyIndex < 0) {
    return false;
  }
  var candidateHasCountryCode = phoneNumber.__countryCallingCodeSource === "FROM_NUMBER_WITH_PLUS_SIGN" || phoneNumber.__countryCallingCodeSource === "FROM_NUMBER_WITHOUT_PLUS_SIGN";
  if (candidateHasCountryCode && parseDigits(candidate.substring(0, firstSlashInBodyIndex)) === phoneNumber.countryCallingCode) {
    return candidate.slice(secondSlashInBodyIndex + 1).indexOf("/") >= 0;
  }
  return true;
}
function checkNumberGroupingIsValid(number, candidate, metadata, checkGroups, regExpCache) {
  throw new Error("This part of code hasn't been ported");
  var normalizedCandidate = normalizeDigits(
    candidate,
    true
    /* keep non-digits */
  );
  var formattedNumberGroups = getNationalNumberGroups(metadata, number, null);
  if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {
    return true;
  }
  var alternateFormats = MetadataManager.getAlternateFormatsForCountry(number.getCountryCode());
  var nationalSignificantNumber = util.getNationalSignificantNumber(number);
  if (alternateFormats) {
    for (var _iterator = _createForOfIteratorHelperLoose7(alternateFormats.numberFormats()), _step; !(_step = _iterator()).done; ) {
      var alternateFormat = _step.value;
      if (alternateFormat.leadingDigitsPatterns().length > 0) {
        var leadingDigitsRegExp = regExpCache.getPatternForRegExp("^" + alternateFormat.leadingDigitsPatterns()[0]);
        if (!leadingDigitsRegExp.test(nationalSignificantNumber)) {
          continue;
        }
      }
      formattedNumberGroups = getNationalNumberGroups(metadata, number, alternateFormat);
      if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {
        return true;
      }
    }
  }
  return false;
}
function getNationalNumberGroups(metadata, number, formattingPattern) {
  throw new Error("This part of code hasn't been ported");
  if (formattingPattern) {
    var nationalSignificantNumber = util.getNationalSignificantNumber(number);
    return util.formatNsnUsingPattern(nationalSignificantNumber, formattingPattern, "RFC3966", metadata).split("-");
  }
  var rfc3966Format = formatNumber(number, "RFC3966", metadata);
  var endIndex = rfc3966Format.indexOf(";");
  if (endIndex < 0) {
    endIndex = rfc3966Format.length;
  }
  var startIndex = rfc3966Format.indexOf("-") + 1;
  return rfc3966Format.slice(startIndex, endIndex).split("-");
}
function allNumberGroupsAreExactlyPresent(metadata, number, normalizedCandidate, formattedNumberGroups) {
  throw new Error("This part of code hasn't been ported");
  var candidateGroups = normalizedCandidate.split(NON_DIGITS_PATTERN);
  var candidateNumberGroupIndex = number.hasExtension() ? candidateGroups.length - 2 : candidateGroups.length - 1;
  if (candidateGroups.length == 1 || candidateGroups[candidateNumberGroupIndex].contains(util.getNationalSignificantNumber(number))) {
    return true;
  }
  var formattedNumberGroupIndex = formattedNumberGroups.length - 1;
  while (formattedNumberGroupIndex > 0 && candidateNumberGroupIndex >= 0) {
    if (candidateGroups[candidateNumberGroupIndex] !== formattedNumberGroups[formattedNumberGroupIndex]) {
      return false;
    }
    formattedNumberGroupIndex--;
    candidateNumberGroupIndex--;
  }
  return candidateNumberGroupIndex >= 0 && endsWith(candidateGroups[candidateNumberGroupIndex], formattedNumberGroups[0]);
}
function allNumberGroupsRemainGrouped(metadata, number, normalizedCandidate, formattedNumberGroups) {
  throw new Error("This part of code hasn't been ported");
  var fromIndex = 0;
  if (number.getCountryCodeSource() !== CountryCodeSource.FROM_DEFAULT_COUNTRY) {
    var countryCode = String(number.getCountryCode());
    fromIndex = normalizedCandidate.indexOf(countryCode) + countryCode.length();
  }
  for (var i = 0; i < formattedNumberGroups.length; i++) {
    fromIndex = normalizedCandidate.indexOf(formattedNumberGroups[i], fromIndex);
    if (fromIndex < 0) {
      return false;
    }
    fromIndex += formattedNumberGroups[i].length();
    if (i == 0 && fromIndex < normalizedCandidate.length()) {
      var region = util.getRegionCodeForCountryCode(number.getCountryCode());
      if (util.getNddPrefixForRegion(region, true) != null && Character.isDigit(normalizedCandidate.charAt(fromIndex))) {
        var nationalSignificantNumber = util.getNationalSignificantNumber(number);
        return startsWith(normalizedCandidate.slice(fromIndex - formattedNumberGroups[i].length), nationalSignificantNumber);
      }
    }
  }
  return normalizedCandidate.slice(fromIndex).contains(number.getExtension());
}
var Leniency_default;
var init_Leniency = __esm({
  "node_modules/libphonenumber-js/es6/findNumbers/Leniency.js"() {
    init_isValid();
    init_parseDigits();
    init_matchPhoneNumberStringAgainstPhoneNumber();
    init_metadata();
    init_getCountryByCallingCode();
    init_format();
    init_util();
    Leniency_default = {
      /**
       * Phone numbers accepted are "possible", but not necessarily "valid".
       */
      POSSIBLE: function POSSIBLE(phoneNumber, candidate, metadata) {
        return true;
      },
      /**
       * Phone numbers accepted are "possible" and "valid".
       * Numbers written in national format must have their national-prefix
       * present if it is usually written for a number of this type.
       */
      VALID: function VALID(phoneNumber, candidate, metadata) {
        if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata)) {
          return false;
        }
        return true;
      },
      /**
       * Phone numbers accepted are "valid" and
       * are grouped in a possible way for this locale. For example, a US number written as
       * "65 02 53 00 00" and "650253 0000" are not accepted at this leniency level, whereas
       * "650 253 0000", "650 2530000" or "6502530000" are.
       * Numbers with more than one '/' symbol in the national significant number
       * are also dropped at this level.
       *
       * Warning: This level might result in lower coverage especially for regions outside of
       * country code "+1". If you are not sure about which level to use,
       * email the discussion group libphonenumber-discuss@googlegroups.com.
       */
      STRICT_GROUPING: function STRICT_GROUPING(phoneNumber, candidate, metadata, regExpCache) {
        if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata) || containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) || !isNationalPrefixPresentIfRequired(phoneNumber, metadata)) {
          return false;
        }
        return checkNumberGroupingIsValid(phoneNumber, candidate, metadata, allNumberGroupsRemainGrouped, regExpCache);
      },
      /**
       * Phone numbers accepted are "valid" and are grouped in the same way
       * that we would have formatted it, or as a single block.
       * For example, a US number written as "650 2530000" is not accepted
       * at this leniency level, whereas "650 253 0000" or "6502530000" are.
       * Numbers with more than one '/' symbol are also dropped at this level.
       *
       * Warning: This level might result in lower coverage especially for regions outside of
       * country code "+1". If you are not sure about which level to use, email the discussion group
       * libphonenumber-discuss@googlegroups.com.
       */
      EXACT_GROUPING: function EXACT_GROUPING(phoneNumber, candidate, metadata, regExpCache) {
        if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata) || containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) || !isNationalPrefixPresentIfRequired(phoneNumber, metadata)) {
          return false;
        }
        return checkNumberGroupingIsValid(phoneNumber, candidate, metadata, allNumberGroupsAreExactlyPresent, regExpCache);
      }
    };
  }
});

// node_modules/libphonenumber-js/es6/findNumbers/parsePreCandidate.js
function parsePreCandidate(candidate) {
  return trimAfterFirstMatch(SECOND_NUMBER_START_PATTERN, candidate);
}
var SECOND_NUMBER_START_PATTERN;
var init_parsePreCandidate = __esm({
  "node_modules/libphonenumber-js/es6/findNumbers/parsePreCandidate.js"() {
    init_util();
    SECOND_NUMBER_START_PATTERN = /[\\/] *x/;
  }
});

// node_modules/libphonenumber-js/es6/findNumbers/isValidPreCandidate.js
function isValidPreCandidate(candidate, offset, text) {
  if (SLASH_SEPARATED_DATES.test(candidate)) {
    return false;
  }
  if (TIME_STAMPS.test(candidate)) {
    var followingText = text.slice(offset + candidate.length);
    if (TIME_STAMPS_SUFFIX_LEADING.test(followingText)) {
      return false;
    }
  }
  return true;
}
var SLASH_SEPARATED_DATES, TIME_STAMPS, TIME_STAMPS_SUFFIX_LEADING;
var init_isValidPreCandidate = __esm({
  "node_modules/libphonenumber-js/es6/findNumbers/isValidPreCandidate.js"() {
    SLASH_SEPARATED_DATES = /(?:(?:[0-3]?\d\/[01]?\d)|(?:[01]?\d\/[0-3]?\d))\/(?:[12]\d)?\d{2}/;
    TIME_STAMPS = /[12]\d{3}[-/]?[01]\d[-/]?[0-3]\d +[0-2]\d$/;
    TIME_STAMPS_SUFFIX_LEADING = /^:[0-5]\d/;
  }
});

// node_modules/libphonenumber-js/es6/findNumbers/isValidCandidate.js
function isValidCandidate(candidate, offset, text, leniency) {
  if (!MATCHING_BRACKETS_ENTIRE.test(candidate) || PUB_PAGES.test(candidate)) {
    return;
  }
  if (leniency !== "POSSIBLE") {
    if (offset > 0 && !LEAD_CLASS_LEADING.test(candidate)) {
      var previousChar = text[offset - 1];
      if (isInvalidPunctuationSymbol(previousChar) || isLatinLetter(previousChar)) {
        return false;
      }
    }
    var lastCharIndex = offset + candidate.length;
    if (lastCharIndex < text.length) {
      var nextChar = text[lastCharIndex];
      if (isInvalidPunctuationSymbol(nextChar) || isLatinLetter(nextChar)) {
        return false;
      }
    }
  }
  return true;
}
var OPENING_PARENS, CLOSING_PARENS, NON_PARENS, LEAD_CLASS, LEAD_CLASS_LEADING, BRACKET_PAIR_LIMIT, MATCHING_BRACKETS_ENTIRE, PUB_PAGES;
var init_isValidCandidate = __esm({
  "node_modules/libphonenumber-js/es6/findNumbers/isValidCandidate.js"() {
    init_constants();
    init_util();
    init_utf_8();
    OPENING_PARENS = "(\\[（［";
    CLOSING_PARENS = ")\\]）］";
    NON_PARENS = "[^".concat(OPENING_PARENS).concat(CLOSING_PARENS, "]");
    LEAD_CLASS = "[".concat(OPENING_PARENS).concat(PLUS_CHARS, "]");
    LEAD_CLASS_LEADING = new RegExp("^" + LEAD_CLASS);
    BRACKET_PAIR_LIMIT = limit(0, 3);
    MATCHING_BRACKETS_ENTIRE = new RegExp("^(?:[" + OPENING_PARENS + "])?(?:" + NON_PARENS + "+[" + CLOSING_PARENS + "])?" + NON_PARENS + "+(?:[" + OPENING_PARENS + "]" + NON_PARENS + "+[" + CLOSING_PARENS + "])" + BRACKET_PAIR_LIMIT + NON_PARENS + "*$");
    PUB_PAGES = /\d{1,5}-+\d{1,5}\s{0,4}\(\d{1,4}/;
  }
});

// node_modules/libphonenumber-js/es6/PhoneNumberMatcher.js
function _createForOfIteratorHelperLoose8(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray9(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray9(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray9(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray9(o, minLen);
}
function _arrayLikeToArray9(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck6(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties6(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass6(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties6(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties6(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var USE_NON_GEOGRAPHIC_COUNTRY_CODE4, EXTN_PATTERNS_FOR_MATCHING, INNER_MATCHES, leadLimit, punctuationLimit, digitBlockLimit, blockLimit, punctuation, digitSequence, PATTERN, UNWANTED_END_CHAR_PATTERN, MAX_SAFE_INTEGER, PhoneNumberMatcher;
var init_PhoneNumberMatcher = __esm({
  "node_modules/libphonenumber-js/es6/PhoneNumberMatcher.js"() {
    init_PhoneNumber();
    init_constants();
    init_createExtensionPattern();
    init_RegExpCache();
    init_util();
    init_utf_8();
    init_Leniency();
    init_parsePreCandidate();
    init_isValidPreCandidate();
    init_isValidCandidate();
    init_metadata();
    init_parsePhoneNumber2();
    USE_NON_GEOGRAPHIC_COUNTRY_CODE4 = false;
    EXTN_PATTERNS_FOR_MATCHING = createExtensionPattern("matching");
    INNER_MATCHES = [
      // Breaks on the slash - e.g. "651-234-2345/332-445-1234"
      "\\/+(.*)/",
      // Note that the bracket here is inside the capturing group, since we consider it part of the
      // phone number. Will match a pattern like "(650) 223 3345 (754) 223 3321".
      "(\\([^(]*)",
      // Breaks on a hyphen - e.g. "12345 - 332-445-1234 is my number."
      // We require a space on either side of the hyphen for it to be considered a separator.
      "(?:".concat(pZ, "-|-").concat(pZ, ")").concat(pZ, "*(.+)"),
      // Various types of wide hyphens. Note we have decided not to enforce a space here, since it's
      // possible that it's supposed to be used to break two numbers without spaces, and we haven't
      // seen many instances of it used within a number.
      "[‒-―－]".concat(pZ, "*(.+)"),
      // Breaks on a full stop - e.g. "12345. 332-445-1234 is my number."
      "\\.+".concat(pZ, "*([^.]+)"),
      // Breaks on space - e.g. "3324451234 8002341234"
      "".concat(pZ, "+(").concat(PZ, "+)")
    ];
    leadLimit = limit(0, 2);
    punctuationLimit = limit(0, 4);
    digitBlockLimit = MAX_LENGTH_FOR_NSN + MAX_LENGTH_COUNTRY_CODE;
    blockLimit = limit(0, digitBlockLimit);
    punctuation = "[".concat(VALID_PUNCTUATION, "]") + punctuationLimit;
    digitSequence = pNd + limit(1, digitBlockLimit);
    PATTERN = "(?:" + LEAD_CLASS + punctuation + ")" + leadLimit + digitSequence + "(?:" + punctuation + digitSequence + ")" + blockLimit + "(?:" + EXTN_PATTERNS_FOR_MATCHING + ")?";
    UNWANTED_END_CHAR_PATTERN = new RegExp("[^".concat(_pN).concat(_pL, "#]+$"));
    MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
    PhoneNumberMatcher = function() {
      function PhoneNumberMatcher3() {
        var text = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var metadata = arguments.length > 2 ? arguments[2] : void 0;
        _classCallCheck6(this, PhoneNumberMatcher3);
        options = {
          v2: options.v2,
          defaultCallingCode: options.defaultCallingCode,
          defaultCountry: options.defaultCountry && isSupportedCountry(options.defaultCountry, metadata) ? options.defaultCountry : void 0,
          leniency: options.leniency || (options.extended ? "POSSIBLE" : "VALID"),
          maxTries: options.maxTries || MAX_SAFE_INTEGER
        };
        if (!options.leniency) {
          throw new TypeError("`leniency` is required");
        }
        if (options.leniency !== "POSSIBLE" && options.leniency !== "VALID") {
          throw new TypeError('Invalid `leniency`: "'.concat(options.leniency, '". Supported values: "POSSIBLE", "VALID".'));
        }
        if (options.maxTries < 0) {
          throw new TypeError("`maxTries` must be `>= 0`");
        }
        this.text = text;
        this.options = options;
        this.metadata = metadata;
        this.leniency = Leniency_default[options.leniency];
        if (!this.leniency) {
          throw new TypeError('Unknown leniency: "'.concat(options.leniency, '"'));
        }
        this.maxTries = options.maxTries;
        this.PATTERN = new RegExp(PATTERN, "ig");
        this.state = "NOT_READY";
        this.searchIndex = 0;
        this.regExpCache = new RegExpCache(32);
      }
      _createClass6(PhoneNumberMatcher3, [{
        key: "find",
        value: function find() {
          var matches2;
          while (this.maxTries > 0 && (matches2 = this.PATTERN.exec(this.text)) !== null) {
            var candidate = matches2[0];
            var offset = matches2.index;
            candidate = parsePreCandidate(candidate);
            if (isValidPreCandidate(candidate, offset, this.text)) {
              var match = (
                // Try to come up with a valid match given the entire candidate.
                this.parseAndVerify(candidate, offset, this.text) || this.extractInnerMatch(candidate, offset, this.text)
              );
              if (match) {
                if (this.options.v2) {
                  return {
                    startsAt: match.startsAt,
                    endsAt: match.endsAt,
                    number: match.phoneNumber
                  };
                } else {
                  var phoneNumber = match.phoneNumber;
                  var result2 = {
                    startsAt: match.startsAt,
                    endsAt: match.endsAt,
                    phone: phoneNumber.nationalNumber
                  };
                  if (phoneNumber.country) {
                    if (USE_NON_GEOGRAPHIC_COUNTRY_CODE4 && country === "001") {
                      result2.countryCallingCode = phoneNumber.countryCallingCode;
                    } else {
                      result2.country = phoneNumber.country;
                    }
                  } else {
                    result2.countryCallingCode = phoneNumber.countryCallingCode;
                  }
                  if (phoneNumber.ext) {
                    result2.ext = phoneNumber.ext;
                  }
                  return result2;
                }
              }
            }
            this.maxTries--;
          }
        }
        /**
         * Attempts to extract a match from `substring`
         * if the substring itself does not qualify as a match.
         */
      }, {
        key: "extractInnerMatch",
        value: function extractInnerMatch(substring, offset, text) {
          for (var _iterator = _createForOfIteratorHelperLoose8(INNER_MATCHES), _step; !(_step = _iterator()).done; ) {
            var innerMatchPattern = _step.value;
            var isFirstMatch = true;
            var candidateMatch = void 0;
            var innerMatchRegExp = new RegExp(innerMatchPattern, "g");
            while (this.maxTries > 0 && (candidateMatch = innerMatchRegExp.exec(substring)) !== null) {
              if (isFirstMatch) {
                var _candidate = trimAfterFirstMatch(UNWANTED_END_CHAR_PATTERN, substring.slice(0, candidateMatch.index));
                var _match2 = this.parseAndVerify(_candidate, offset, text);
                if (_match2) {
                  return _match2;
                }
                this.maxTries--;
                isFirstMatch = false;
              }
              var candidate = trimAfterFirstMatch(UNWANTED_END_CHAR_PATTERN, candidateMatch[1]);
              var candidateIndexGuess = substring.indexOf(candidate, candidateMatch.index);
              var match = this.parseAndVerify(candidate, offset + candidateIndexGuess, text);
              if (match) {
                return match;
              }
              this.maxTries--;
            }
          }
        }
        /**
         * Parses a phone number from the `candidate` using `parse` and
         * verifies it matches the requested `leniency`. If parsing and verification succeed,
         * a corresponding `PhoneNumberMatch` is returned, otherwise this method returns `null`.
         *
         * @param candidate  the candidate match
         * @param offset  the offset of {@code candidate} within {@link #text}
         * @return  the parsed and validated phone number match, or null
         */
      }, {
        key: "parseAndVerify",
        value: function parseAndVerify(candidate, offset, text) {
          if (!isValidCandidate(candidate, offset, text, this.options.leniency)) {
            return;
          }
          var phoneNumber = parsePhoneNumber3(candidate, {
            extended: true,
            defaultCountry: this.options.defaultCountry,
            defaultCallingCode: this.options.defaultCallingCode
          }, this.metadata);
          if (!phoneNumber) {
            return;
          }
          if (!phoneNumber.isPossible()) {
            return;
          }
          if (this.leniency(phoneNumber, candidate, this.metadata, this.regExpCache)) {
            return {
              startsAt: offset,
              endsAt: offset + candidate.length,
              phoneNumber
            };
          }
        }
      }, {
        key: "hasNext",
        value: function hasNext() {
          if (this.state === "NOT_READY") {
            this.lastMatch = this.find();
            if (this.lastMatch) {
              this.state = "READY";
            } else {
              this.state = "DONE";
            }
          }
          return this.state === "READY";
        }
      }, {
        key: "next",
        value: function next() {
          if (!this.hasNext()) {
            throw new Error("No next element");
          }
          var result2 = this.lastMatch;
          this.lastMatch = null;
          this.state = "NOT_READY";
          return result2;
        }
      }]);
      return PhoneNumberMatcher3;
    }();
  }
});

// node_modules/libphonenumber-js/es6/legacy/findNumbers.js
var init_findNumbers = __esm({
  "node_modules/libphonenumber-js/es6/legacy/findNumbers.js"() {
    init_PhoneNumberMatcher();
    init_normalizeArguments();
  }
});

// node_modules/libphonenumber-js/es6/legacy/searchNumbers.js
var init_searchNumbers = __esm({
  "node_modules/libphonenumber-js/es6/legacy/searchNumbers.js"() {
    init_normalizeArguments();
    init_PhoneNumberMatcher();
  }
});

// node_modules/libphonenumber-js/es6/findPhoneNumbersInText.js
var init_findPhoneNumbersInText = __esm({
  "node_modules/libphonenumber-js/es6/findPhoneNumbersInText.js"() {
    init_PhoneNumberMatcher();
    init_normalizeArguments();
  }
});

// node_modules/libphonenumber-js/es6/searchPhoneNumbersInText.js
var init_searchPhoneNumbersInText = __esm({
  "node_modules/libphonenumber-js/es6/searchPhoneNumbersInText.js"() {
    init_PhoneNumberMatcher();
    init_normalizeArguments();
  }
});

// node_modules/libphonenumber-js/es6/AsYouTypeState.js
function _classCallCheck7(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties7(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass7(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties7(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties7(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var AsYouTypeState;
var init_AsYouTypeState = __esm({
  "node_modules/libphonenumber-js/es6/AsYouTypeState.js"() {
    AsYouTypeState = function() {
      function AsYouTypeState2(_ref) {
        var onCountryChange = _ref.onCountryChange, onCallingCodeChange = _ref.onCallingCodeChange;
        _classCallCheck7(this, AsYouTypeState2);
        this.onCountryChange = onCountryChange;
        this.onCallingCodeChange = onCallingCodeChange;
      }
      _createClass7(AsYouTypeState2, [{
        key: "reset",
        value: function reset(_ref2) {
          var country2 = _ref2.country, callingCode = _ref2.callingCode;
          this.international = false;
          this.IDDPrefix = void 0;
          this.missingPlus = void 0;
          this.callingCode = void 0;
          this.digits = "";
          this.resetNationalSignificantNumber();
          this.initCountryAndCallingCode(country2, callingCode);
        }
      }, {
        key: "resetNationalSignificantNumber",
        value: function resetNationalSignificantNumber() {
          this.nationalSignificantNumber = this.getNationalDigits();
          this.nationalSignificantNumberMatchesInput = true;
          this.nationalPrefix = void 0;
          this.carrierCode = void 0;
          this.complexPrefixBeforeNationalSignificantNumber = void 0;
        }
      }, {
        key: "update",
        value: function update(properties) {
          for (var _i = 0, _Object$keys = Object.keys(properties); _i < _Object$keys.length; _i++) {
            var key = _Object$keys[_i];
            this[key] = properties[key];
          }
        }
      }, {
        key: "initCountryAndCallingCode",
        value: function initCountryAndCallingCode(country2, callingCode) {
          this.setCountry(country2);
          this.setCallingCode(callingCode);
        }
      }, {
        key: "setCountry",
        value: function setCountry(country2) {
          this.country = country2;
          this.onCountryChange(country2);
        }
      }, {
        key: "setCallingCode",
        value: function setCallingCode(callingCode) {
          this.callingCode = callingCode;
          this.onCallingCodeChange(callingCode, this.country);
        }
      }, {
        key: "startInternationalNumber",
        value: function startInternationalNumber(country2, callingCode) {
          this.international = true;
          this.initCountryAndCallingCode(country2, callingCode);
        }
      }, {
        key: "appendDigits",
        value: function appendDigits(nextDigits) {
          this.digits += nextDigits;
        }
      }, {
        key: "appendNationalSignificantNumberDigits",
        value: function appendNationalSignificantNumberDigits(nextDigits) {
          this.nationalSignificantNumber += nextDigits;
        }
        /**
         * Returns the part of `this.digits` that corresponds to the national number.
         * Basically, all digits that have been input by the user, except for the
         * international prefix and the country calling code part
         * (if the number is an international one).
         * @return {string}
         */
      }, {
        key: "getNationalDigits",
        value: function getNationalDigits() {
          if (this.international) {
            return this.digits.slice((this.IDDPrefix ? this.IDDPrefix.length : 0) + (this.callingCode ? this.callingCode.length : 0));
          }
          return this.digits;
        }
      }, {
        key: "getDigitsWithoutInternationalPrefix",
        value: function getDigitsWithoutInternationalPrefix() {
          if (this.international) {
            if (this.IDDPrefix) {
              return this.digits.slice(this.IDDPrefix.length);
            }
          }
          return this.digits;
        }
      }]);
      return AsYouTypeState2;
    }();
  }
});

// node_modules/libphonenumber-js/es6/AsYouTypeFormatter.util.js
function _createForOfIteratorHelperLoose9(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray10(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray10(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray10(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray10(o, minLen);
}
function _arrayLikeToArray10(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function repeat(string, times) {
  if (times < 1) {
    return "";
  }
  var result2 = "";
  while (times > 1) {
    if (times & 1) {
      result2 += string;
    }
    times >>= 1;
    string += string;
  }
  return result2 + string;
}
function cutAndStripNonPairedParens(string, cutBeforeIndex) {
  if (string[cutBeforeIndex] === ")") {
    cutBeforeIndex++;
  }
  return stripNonPairedParens(string.slice(0, cutBeforeIndex));
}
function stripNonPairedParens(string) {
  var dangling_braces = [];
  var i = 0;
  while (i < string.length) {
    if (string[i] === "(") {
      dangling_braces.push(i);
    } else if (string[i] === ")") {
      dangling_braces.pop();
    }
    i++;
  }
  var start = 0;
  var cleared_string = "";
  dangling_braces.push(string.length);
  for (var _i = 0, _dangling_braces = dangling_braces; _i < _dangling_braces.length; _i++) {
    var index = _dangling_braces[_i];
    cleared_string += string.slice(start, index);
    start = index + 1;
  }
  return cleared_string;
}
function populateTemplateWithDigits(template, position, digits) {
  for (var _iterator2 = _createForOfIteratorHelperLoose9(digits.split("")), _step2; !(_step2 = _iterator2()).done; ) {
    var digit = _step2.value;
    if (template.slice(position + 1).search(DIGIT_PLACEHOLDER_MATCHER) < 0) {
      return;
    }
    position = template.search(DIGIT_PLACEHOLDER_MATCHER);
    template = template.replace(DIGIT_PLACEHOLDER_MATCHER, digit);
  }
  return [template, position];
}
var DIGIT_PLACEHOLDER, DIGIT_PLACEHOLDER_MATCHER;
var init_AsYouTypeFormatter_util = __esm({
  "node_modules/libphonenumber-js/es6/AsYouTypeFormatter.util.js"() {
    DIGIT_PLACEHOLDER = "x";
    DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER);
  }
});

// node_modules/libphonenumber-js/es6/AsYouTypeFormatter.complete.js
function formatCompleteNumber(state, format2, _ref) {
  var metadata = _ref.metadata, shouldTryNationalPrefixFormattingRule = _ref.shouldTryNationalPrefixFormattingRule, getSeparatorAfterNationalPrefix = _ref.getSeparatorAfterNationalPrefix;
  var matcher = new RegExp("^(?:".concat(format2.pattern(), ")$"));
  if (matcher.test(state.nationalSignificantNumber)) {
    return formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(state, format2, {
      metadata,
      shouldTryNationalPrefixFormattingRule,
      getSeparatorAfterNationalPrefix
    });
  }
}
function canFormatCompleteNumber(nationalSignificantNumber, metadata) {
  return checkNumberLength(nationalSignificantNumber, metadata) === "IS_POSSIBLE";
}
function formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(state, format2, _ref2) {
  var metadata = _ref2.metadata, shouldTryNationalPrefixFormattingRule = _ref2.shouldTryNationalPrefixFormattingRule, getSeparatorAfterNationalPrefix = _ref2.getSeparatorAfterNationalPrefix;
  var nationalSignificantNumber = state.nationalSignificantNumber, international = state.international, nationalPrefix = state.nationalPrefix, carrierCode = state.carrierCode;
  if (shouldTryNationalPrefixFormattingRule(format2)) {
    var formattedNumber = formatNationalNumber2(state, format2, {
      useNationalPrefixFormattingRule: true,
      getSeparatorAfterNationalPrefix,
      metadata
    });
    if (formattedNumber) {
      return formattedNumber;
    }
  }
  return formatNationalNumber2(state, format2, {
    useNationalPrefixFormattingRule: false,
    getSeparatorAfterNationalPrefix,
    metadata
  });
}
function formatNationalNumber2(state, format2, _ref3) {
  var metadata = _ref3.metadata, useNationalPrefixFormattingRule = _ref3.useNationalPrefixFormattingRule, getSeparatorAfterNationalPrefix = _ref3.getSeparatorAfterNationalPrefix;
  var formattedNationalNumber = formatNationalNumberUsingFormat(state.nationalSignificantNumber, format2, {
    carrierCode: state.carrierCode,
    useInternationalFormat: state.international,
    withNationalPrefix: useNationalPrefixFormattingRule,
    metadata
  });
  if (!useNationalPrefixFormattingRule) {
    if (state.nationalPrefix) {
      formattedNationalNumber = state.nationalPrefix + getSeparatorAfterNationalPrefix(format2) + formattedNationalNumber;
    } else if (state.complexPrefixBeforeNationalSignificantNumber) {
      formattedNationalNumber = state.complexPrefixBeforeNationalSignificantNumber + " " + formattedNationalNumber;
    }
  }
  if (isValidFormattedNationalNumber(formattedNationalNumber, state)) {
    return formattedNationalNumber;
  }
}
function isValidFormattedNationalNumber(formattedNationalNumber, state) {
  return parseDigits(formattedNationalNumber) === state.getNationalDigits();
}
var init_AsYouTypeFormatter_complete = __esm({
  "node_modules/libphonenumber-js/es6/AsYouTypeFormatter.complete.js"() {
    init_checkNumberLength();
    init_parseDigits();
    init_formatNationalNumberUsingFormat();
  }
});

// node_modules/libphonenumber-js/es6/AsYouTypeFormatter.PatternParser.js
function _classCallCheck8(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties8(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass8(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties8(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties8(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function parseOneOfSet(pattern) {
  var values = [];
  var i = 0;
  while (i < pattern.length) {
    if (pattern[i] === "-") {
      if (i === 0 || i === pattern.length - 1) {
        throw new Error("Couldn't parse a one-of set pattern: ".concat(pattern));
      }
      var prevValue = pattern[i - 1].charCodeAt(0) + 1;
      var nextValue = pattern[i + 1].charCodeAt(0) - 1;
      var value = prevValue;
      while (value <= nextValue) {
        values.push(String.fromCharCode(value));
        value++;
      }
    } else {
      values.push(pattern[i]);
    }
    i++;
  }
  return values;
}
function expandSingleElementArray(array) {
  if (array.length === 1) {
    return array[0];
  }
  return array;
}
var PatternParser, ILLEGAL_CHARACTER_REGEXP, OPERATOR;
var init_AsYouTypeFormatter_PatternParser = __esm({
  "node_modules/libphonenumber-js/es6/AsYouTypeFormatter.PatternParser.js"() {
    PatternParser = function() {
      function PatternParser2() {
        _classCallCheck8(this, PatternParser2);
      }
      _createClass8(PatternParser2, [{
        key: "parse",
        value: function parse4(pattern) {
          this.context = [{
            or: true,
            instructions: []
          }];
          this.parsePattern(pattern);
          if (this.context.length !== 1) {
            throw new Error("Non-finalized contexts left when pattern parse ended");
          }
          var _this$context$ = this.context[0], branches = _this$context$.branches, instructions = _this$context$.instructions;
          if (branches) {
            return {
              op: "|",
              args: branches.concat([expandSingleElementArray(instructions)])
            };
          }
          if (instructions.length === 0) {
            throw new Error("Pattern is required");
          }
          if (instructions.length === 1) {
            return instructions[0];
          }
          return instructions;
        }
      }, {
        key: "startContext",
        value: function startContext(context2) {
          this.context.push(context2);
        }
      }, {
        key: "endContext",
        value: function endContext() {
          this.context.pop();
        }
      }, {
        key: "getContext",
        value: function getContext() {
          return this.context[this.context.length - 1];
        }
      }, {
        key: "parsePattern",
        value: function parsePattern(pattern) {
          if (!pattern) {
            throw new Error("Pattern is required");
          }
          var match = pattern.match(OPERATOR);
          if (!match) {
            if (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {
              throw new Error("Illegal characters found in a pattern: ".concat(pattern));
            }
            this.getContext().instructions = this.getContext().instructions.concat(pattern.split(""));
            return;
          }
          var operator = match[1];
          var before = pattern.slice(0, match.index);
          var rightPart = pattern.slice(match.index + operator.length);
          switch (operator) {
            case "(?:":
              if (before) {
                this.parsePattern(before);
              }
              this.startContext({
                or: true,
                instructions: [],
                branches: []
              });
              break;
            case ")":
              if (!this.getContext().or) {
                throw new Error('")" operator must be preceded by "(?:" operator');
              }
              if (before) {
                this.parsePattern(before);
              }
              if (this.getContext().instructions.length === 0) {
                throw new Error('No instructions found after "|" operator in an "or" group');
              }
              var _this$getContext = this.getContext(), branches = _this$getContext.branches;
              branches.push(expandSingleElementArray(this.getContext().instructions));
              this.endContext();
              this.getContext().instructions.push({
                op: "|",
                args: branches
              });
              break;
            case "|":
              if (!this.getContext().or) {
                throw new Error('"|" operator can only be used inside "or" groups');
              }
              if (before) {
                this.parsePattern(before);
              }
              if (!this.getContext().branches) {
                if (this.context.length === 1) {
                  this.getContext().branches = [];
                } else {
                  throw new Error('"branches" not found in an "or" group context');
                }
              }
              this.getContext().branches.push(expandSingleElementArray(this.getContext().instructions));
              this.getContext().instructions = [];
              break;
            case "[":
              if (before) {
                this.parsePattern(before);
              }
              this.startContext({
                oneOfSet: true
              });
              break;
            case "]":
              if (!this.getContext().oneOfSet) {
                throw new Error('"]" operator must be preceded by "[" operator');
              }
              this.endContext();
              this.getContext().instructions.push({
                op: "[]",
                args: parseOneOfSet(before)
              });
              break;
            default:
              throw new Error("Unknown operator: ".concat(operator));
          }
          if (rightPart) {
            this.parsePattern(rightPart);
          }
        }
      }]);
      return PatternParser2;
    }();
    ILLEGAL_CHARACTER_REGEXP = /[\(\)\[\]\?\:\|]/;
    OPERATOR = new RegExp(
      // any of:
      "(\\||\\(\\?\\:|\\)|\\[|\\])"
    );
  }
});

// node_modules/libphonenumber-js/es6/AsYouTypeFormatter.PatternMatcher.js
function _createForOfIteratorHelperLoose10(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray11(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray11(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray11(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray11(o, minLen);
}
function _arrayLikeToArray11(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck9(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties9(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass9(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties9(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties9(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _match(characters, tree, last) {
  if (typeof tree === "string") {
    var characterString = characters.join("");
    if (tree.indexOf(characterString) === 0) {
      if (characters.length === tree.length) {
        return {
          match: true,
          matchedChars: characters
        };
      }
      return {
        partialMatch: true
        // matchedChars: characters
      };
    }
    if (characterString.indexOf(tree) === 0) {
      if (last) {
        if (characters.length > tree.length) {
          return {
            overflow: true
          };
        }
      }
      return {
        match: true,
        matchedChars: characters.slice(0, tree.length)
      };
    }
    return;
  }
  if (Array.isArray(tree)) {
    var restCharacters = characters.slice();
    var i = 0;
    while (i < tree.length) {
      var subtree = tree[i];
      var result2 = _match(restCharacters, subtree, last && i === tree.length - 1);
      if (!result2) {
        return;
      } else if (result2.overflow) {
        return result2;
      } else if (result2.match) {
        restCharacters = restCharacters.slice(result2.matchedChars.length);
        if (restCharacters.length === 0) {
          if (i === tree.length - 1) {
            return {
              match: true,
              matchedChars: characters
            };
          } else {
            return {
              partialMatch: true
              // matchedChars: characters
            };
          }
        }
      } else {
        if (result2.partialMatch) {
          return {
            partialMatch: true
            // matchedChars: characters
          };
        } else {
          throw new Error("Unsupported match result:\n".concat(JSON.stringify(result2, null, 2)));
        }
      }
      i++;
    }
    if (last) {
      return {
        overflow: true
      };
    }
    return {
      match: true,
      matchedChars: characters.slice(0, characters.length - restCharacters.length)
    };
  }
  switch (tree.op) {
    case "|":
      var partialMatch;
      for (var _iterator = _createForOfIteratorHelperLoose10(tree.args), _step; !(_step = _iterator()).done; ) {
        var branch = _step.value;
        var _result = _match(characters, branch, last);
        if (_result) {
          if (_result.overflow) {
            return _result;
          } else if (_result.match) {
            return {
              match: true,
              matchedChars: _result.matchedChars
            };
          } else {
            if (_result.partialMatch) {
              partialMatch = true;
            } else {
              throw new Error("Unsupported match result:\n".concat(JSON.stringify(_result, null, 2)));
            }
          }
        }
      }
      if (partialMatch) {
        return {
          partialMatch: true
          // matchedChars: ...
        };
      }
      return;
    case "[]":
      for (var _iterator2 = _createForOfIteratorHelperLoose10(tree.args), _step2; !(_step2 = _iterator2()).done; ) {
        var _char = _step2.value;
        if (characters[0] === _char) {
          if (characters.length === 1) {
            return {
              match: true,
              matchedChars: characters
            };
          }
          if (last) {
            return {
              overflow: true
            };
          }
          return {
            match: true,
            matchedChars: [_char]
          };
        }
      }
      return;
    default:
      throw new Error("Unsupported instruction tree: ".concat(tree));
  }
}
var PatternMatcher;
var init_AsYouTypeFormatter_PatternMatcher = __esm({
  "node_modules/libphonenumber-js/es6/AsYouTypeFormatter.PatternMatcher.js"() {
    init_AsYouTypeFormatter_PatternParser();
    PatternMatcher = function() {
      function PatternMatcher2(pattern) {
        _classCallCheck9(this, PatternMatcher2);
        this.matchTree = new PatternParser().parse(pattern);
      }
      _createClass9(PatternMatcher2, [{
        key: "match",
        value: function match(string) {
          var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, allowOverflow = _ref.allowOverflow;
          if (!string) {
            throw new Error("String is required");
          }
          var result2 = _match(string.split(""), this.matchTree, true);
          if (result2 && result2.match) {
            delete result2.matchedChars;
          }
          if (result2 && result2.overflow) {
            if (!allowOverflow) {
              return;
            }
          }
          return result2;
        }
      }]);
      return PatternMatcher2;
    }();
  }
});

// node_modules/libphonenumber-js/es6/AsYouTypeFormatter.js
function _createForOfIteratorHelperLoose11(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray12(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray12(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray12(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray12(o, minLen);
}
function _arrayLikeToArray12(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck10(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties10(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass10(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties10(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties10(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH, LONGEST_DUMMY_PHONE_NUMBER, NATIONAL_PREFIX_SEPARATORS_PATTERN, SUPPORT_LEGACY_FORMATTING_PATTERNS, CREATE_CHARACTER_CLASS_PATTERN, CREATE_STANDALONE_DIGIT_PATTERN, NON_ALTERING_FORMAT_REG_EXP, MIN_LEADING_DIGITS_LENGTH, AsYouTypeFormatter;
var init_AsYouTypeFormatter = __esm({
  "node_modules/libphonenumber-js/es6/AsYouTypeFormatter.js"() {
    init_AsYouTypeFormatter_util();
    init_AsYouTypeFormatter_complete();
    init_AsYouTypeFormatter_PatternMatcher();
    init_parseDigits();
    init_AsYouTypeFormatter_util();
    init_formatNationalNumberUsingFormat();
    init_constants();
    init_applyInternationalSeparatorStyle();
    DUMMY_DIGIT = "9";
    LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15;
    LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH);
    NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/;
    SUPPORT_LEGACY_FORMATTING_PATTERNS = true;
    CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function() {
      return /\[([^\[\]])*\]/g;
    };
    CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function() {
      return /\d(?=[^,}][^,}])/g;
    };
    NON_ALTERING_FORMAT_REG_EXP = new RegExp("[" + VALID_PUNCTUATION + "]*\\$1[" + VALID_PUNCTUATION + "]*(\\$\\d[" + VALID_PUNCTUATION + "]*)*$");
    MIN_LEADING_DIGITS_LENGTH = 3;
    AsYouTypeFormatter = function() {
      function AsYouTypeFormatter2(_ref) {
        var state = _ref.state, metadata = _ref.metadata;
        _classCallCheck10(this, AsYouTypeFormatter2);
        this.metadata = metadata;
        this.resetFormat();
      }
      _createClass10(AsYouTypeFormatter2, [{
        key: "resetFormat",
        value: function resetFormat() {
          this.chosenFormat = void 0;
          this.template = void 0;
          this.nationalNumberTemplate = void 0;
          this.populatedNationalNumberTemplate = void 0;
          this.populatedNationalNumberTemplatePosition = -1;
        }
      }, {
        key: "reset",
        value: function reset(numberingPlan, state) {
          this.resetFormat();
          if (numberingPlan) {
            this.isNANP = numberingPlan.callingCode() === "1";
            this.matchingFormats = numberingPlan.formats();
            if (state.nationalSignificantNumber) {
              this.narrowDownMatchingFormats(state);
            }
          } else {
            this.isNANP = void 0;
            this.matchingFormats = [];
          }
        }
        /**
         * Formats an updated phone number.
         * @param  {string} nextDigits — Additional phone number digits.
         * @param  {object} state — `AsYouType` state.
         * @return {[string]} Returns undefined if the updated phone number can't be formatted using any of the available formats.
         */
      }, {
        key: "format",
        value: function format2(nextDigits, state) {
          var _this = this;
          if (canFormatCompleteNumber(state.nationalSignificantNumber, this.metadata)) {
            for (var _iterator = _createForOfIteratorHelperLoose11(this.matchingFormats), _step; !(_step = _iterator()).done; ) {
              var format3 = _step.value;
              var formattedCompleteNumber = formatCompleteNumber(state, format3, {
                metadata: this.metadata,
                shouldTryNationalPrefixFormattingRule: function shouldTryNationalPrefixFormattingRule(format4) {
                  return _this.shouldTryNationalPrefixFormattingRule(format4, {
                    international: state.international,
                    nationalPrefix: state.nationalPrefix
                  });
                },
                getSeparatorAfterNationalPrefix: function getSeparatorAfterNationalPrefix(format4) {
                  return _this.getSeparatorAfterNationalPrefix(format4);
                }
              });
              if (formattedCompleteNumber) {
                this.resetFormat();
                this.chosenFormat = format3;
                this.setNationalNumberTemplate(formattedCompleteNumber.replace(/\d/g, DIGIT_PLACEHOLDER), state);
                this.populatedNationalNumberTemplate = formattedCompleteNumber;
                this.populatedNationalNumberTemplatePosition = this.template.lastIndexOf(DIGIT_PLACEHOLDER);
                return formattedCompleteNumber;
              }
            }
          }
          return this.formatNationalNumberWithNextDigits(nextDigits, state);
        }
        // Formats the next phone number digits.
      }, {
        key: "formatNationalNumberWithNextDigits",
        value: function formatNationalNumberWithNextDigits(nextDigits, state) {
          var previouslyChosenFormat = this.chosenFormat;
          var newlyChosenFormat = this.chooseFormat(state);
          if (newlyChosenFormat) {
            if (newlyChosenFormat === previouslyChosenFormat) {
              return this.formatNextNationalNumberDigits(nextDigits);
            } else {
              return this.formatNextNationalNumberDigits(state.getNationalDigits());
            }
          }
        }
      }, {
        key: "narrowDownMatchingFormats",
        value: function narrowDownMatchingFormats(_ref2) {
          var _this2 = this;
          var nationalSignificantNumber = _ref2.nationalSignificantNumber, nationalPrefix = _ref2.nationalPrefix, international = _ref2.international;
          var leadingDigits = nationalSignificantNumber;
          var leadingDigitsPatternIndex = leadingDigits.length - MIN_LEADING_DIGITS_LENGTH;
          if (leadingDigitsPatternIndex < 0) {
            leadingDigitsPatternIndex = 0;
          }
          this.matchingFormats = this.matchingFormats.filter(function(format2) {
            return _this2.formatSuits(format2, international, nationalPrefix) && _this2.formatMatches(format2, leadingDigits, leadingDigitsPatternIndex);
          });
          if (this.chosenFormat && this.matchingFormats.indexOf(this.chosenFormat) === -1) {
            this.resetFormat();
          }
        }
      }, {
        key: "formatSuits",
        value: function formatSuits(format2, international, nationalPrefix) {
          if (nationalPrefix && !format2.usesNationalPrefix() && // !format.domesticCarrierCodeFormattingRule() &&
          !format2.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {
            return false;
          }
          if (!international && !nationalPrefix && format2.nationalPrefixIsMandatoryWhenFormattingInNationalFormat()) {
            return false;
          }
          return true;
        }
      }, {
        key: "formatMatches",
        value: function formatMatches(format2, leadingDigits, leadingDigitsPatternIndex) {
          var leadingDigitsPatternsCount = format2.leadingDigitsPatterns().length;
          if (leadingDigitsPatternsCount === 0) {
            return true;
          }
          leadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1);
          var leadingDigitsPattern = format2.leadingDigitsPatterns()[leadingDigitsPatternIndex];
          if (leadingDigits.length < MIN_LEADING_DIGITS_LENGTH) {
            try {
              return new PatternMatcher(leadingDigitsPattern).match(leadingDigits, {
                allowOverflow: true
              }) !== void 0;
            } catch (error) {
              console.error(error);
              return true;
            }
          }
          return new RegExp("^(".concat(leadingDigitsPattern, ")")).test(leadingDigits);
        }
      }, {
        key: "getFormatFormat",
        value: function getFormatFormat(format2, international) {
          return international ? format2.internationalFormat() : format2.format();
        }
      }, {
        key: "chooseFormat",
        value: function chooseFormat(state) {
          var _this3 = this;
          var _loop = function _loop2() {
            var format2 = _step2.value;
            if (_this3.chosenFormat === format2) {
              return "break";
            }
            if (!NON_ALTERING_FORMAT_REG_EXP.test(_this3.getFormatFormat(format2, state.international))) {
              return "continue";
            }
            if (!_this3.createTemplateForFormat(format2, state)) {
              _this3.matchingFormats = _this3.matchingFormats.filter(function(_) {
                return _ !== format2;
              });
              return "continue";
            }
            _this3.chosenFormat = format2;
            return "break";
          };
          for (var _iterator2 = _createForOfIteratorHelperLoose11(this.matchingFormats.slice()), _step2; !(_step2 = _iterator2()).done; ) {
            var _ret = _loop();
            if (_ret === "break")
              break;
            if (_ret === "continue")
              continue;
          }
          if (!this.chosenFormat) {
            this.resetFormat();
          }
          return this.chosenFormat;
        }
      }, {
        key: "createTemplateForFormat",
        value: function createTemplateForFormat(format2, state) {
          if (SUPPORT_LEGACY_FORMATTING_PATTERNS && format2.pattern().indexOf("|") >= 0) {
            return;
          }
          var template = this.getTemplateForFormat(format2, state);
          if (template) {
            this.setNationalNumberTemplate(template, state);
            return true;
          }
        }
      }, {
        key: "getSeparatorAfterNationalPrefix",
        value: function getSeparatorAfterNationalPrefix(format2) {
          if (this.isNANP) {
            return " ";
          }
          if (format2 && format2.nationalPrefixFormattingRule() && NATIONAL_PREFIX_SEPARATORS_PATTERN.test(format2.nationalPrefixFormattingRule())) {
            return " ";
          }
          return "";
        }
      }, {
        key: "getInternationalPrefixBeforeCountryCallingCode",
        value: function getInternationalPrefixBeforeCountryCallingCode(_ref3, options) {
          var IDDPrefix = _ref3.IDDPrefix, missingPlus = _ref3.missingPlus;
          if (IDDPrefix) {
            return options && options.spacing === false ? IDDPrefix : IDDPrefix + " ";
          }
          if (missingPlus) {
            return "";
          }
          return "+";
        }
      }, {
        key: "getTemplate",
        value: function getTemplate(state) {
          if (!this.template) {
            return;
          }
          var index = -1;
          var i = 0;
          var internationalPrefix = state.international ? this.getInternationalPrefixBeforeCountryCallingCode(state, {
            spacing: false
          }) : "";
          while (i < internationalPrefix.length + state.getDigitsWithoutInternationalPrefix().length) {
            index = this.template.indexOf(DIGIT_PLACEHOLDER, index + 1);
            i++;
          }
          return cutAndStripNonPairedParens(this.template, index + 1);
        }
      }, {
        key: "setNationalNumberTemplate",
        value: function setNationalNumberTemplate(template, state) {
          this.nationalNumberTemplate = template;
          this.populatedNationalNumberTemplate = template;
          this.populatedNationalNumberTemplatePosition = -1;
          if (state.international) {
            this.template = this.getInternationalPrefixBeforeCountryCallingCode(state).replace(/[\d\+]/g, DIGIT_PLACEHOLDER) + repeat(DIGIT_PLACEHOLDER, state.callingCode.length) + " " + template;
          } else {
            this.template = template;
          }
        }
        /**
         * Generates formatting template for a national phone number,
         * optionally containing a national prefix, for a format.
         * @param  {Format} format
         * @param  {string} nationalPrefix
         * @return {string}
         */
      }, {
        key: "getTemplateForFormat",
        value: function getTemplateForFormat(format2, _ref4) {
          var nationalSignificantNumber = _ref4.nationalSignificantNumber, international = _ref4.international, nationalPrefix = _ref4.nationalPrefix, complexPrefixBeforeNationalSignificantNumber = _ref4.complexPrefixBeforeNationalSignificantNumber;
          var pattern = format2.pattern();
          if (SUPPORT_LEGACY_FORMATTING_PATTERNS) {
            pattern = pattern.replace(CREATE_CHARACTER_CLASS_PATTERN(), "\\d").replace(CREATE_STANDALONE_DIGIT_PATTERN(), "\\d");
          }
          var digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0];
          if (nationalSignificantNumber.length > digits.length) {
            return;
          }
          var strictPattern = new RegExp("^" + pattern + "$");
          var nationalNumberDummyDigits = nationalSignificantNumber.replace(/\d/g, DUMMY_DIGIT);
          if (strictPattern.test(nationalNumberDummyDigits)) {
            digits = nationalNumberDummyDigits;
          }
          var numberFormat = this.getFormatFormat(format2, international);
          var nationalPrefixIncludedInTemplate;
          if (this.shouldTryNationalPrefixFormattingRule(format2, {
            international,
            nationalPrefix
          })) {
            var numberFormatWithNationalPrefix = numberFormat.replace(FIRST_GROUP_PATTERN, format2.nationalPrefixFormattingRule());
            if (parseDigits(format2.nationalPrefixFormattingRule()) === (nationalPrefix || "") + parseDigits("$1")) {
              numberFormat = numberFormatWithNationalPrefix;
              nationalPrefixIncludedInTemplate = true;
              if (nationalPrefix) {
                var i = nationalPrefix.length;
                while (i > 0) {
                  numberFormat = numberFormat.replace(/\d/, DIGIT_PLACEHOLDER);
                  i--;
                }
              }
            }
          }
          var template = digits.replace(new RegExp(pattern), numberFormat).replace(new RegExp(DUMMY_DIGIT, "g"), DIGIT_PLACEHOLDER);
          if (!nationalPrefixIncludedInTemplate) {
            if (complexPrefixBeforeNationalSignificantNumber) {
              template = repeat(DIGIT_PLACEHOLDER, complexPrefixBeforeNationalSignificantNumber.length) + " " + template;
            } else if (nationalPrefix) {
              template = repeat(DIGIT_PLACEHOLDER, nationalPrefix.length) + this.getSeparatorAfterNationalPrefix(format2) + template;
            }
          }
          if (international) {
            template = applyInternationalSeparatorStyle(template);
          }
          return template;
        }
      }, {
        key: "formatNextNationalNumberDigits",
        value: function formatNextNationalNumberDigits(digits) {
          var result2 = populateTemplateWithDigits(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition, digits);
          if (!result2) {
            this.resetFormat();
            return;
          }
          this.populatedNationalNumberTemplate = result2[0];
          this.populatedNationalNumberTemplatePosition = result2[1];
          return cutAndStripNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1);
        }
      }, {
        key: "shouldTryNationalPrefixFormattingRule",
        value: function shouldTryNationalPrefixFormattingRule(format2, _ref5) {
          var international = _ref5.international, nationalPrefix = _ref5.nationalPrefix;
          if (format2.nationalPrefixFormattingRule()) {
            var usesNationalPrefix = format2.usesNationalPrefix();
            if (usesNationalPrefix && nationalPrefix || !usesNationalPrefix && !international) {
              return true;
            }
          }
        }
      }]);
      return AsYouTypeFormatter2;
    }();
  }
});

// node_modules/libphonenumber-js/es6/AsYouTypeParser.js
function _slicedToArray2(arr, i) {
  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray13(arr, i) || _nonIterableRest2();
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray13(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray13(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray13(o, minLen);
}
function _arrayLikeToArray13(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit2(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck11(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties11(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass11(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties11(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties11(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function extractFormattedPhoneNumber(text) {
  var startsAt = text.search(VALID_FORMATTED_PHONE_NUMBER_PART);
  if (startsAt < 0) {
    return;
  }
  text = text.slice(startsAt);
  var hasPlus;
  if (text[0] === "+") {
    hasPlus = true;
    text = text.slice("+".length);
  }
  text = text.replace(AFTER_PHONE_NUMBER_DIGITS_END_PATTERN, "");
  if (hasPlus) {
    text = "+" + text;
  }
  return text;
}
function _extractFormattedDigitsAndPlus(text) {
  var extractedNumber = extractFormattedPhoneNumber(text) || "";
  if (extractedNumber[0] === "+") {
    return [extractedNumber.slice("+".length), true];
  }
  return [extractedNumber];
}
function extractFormattedDigitsAndPlus(text) {
  var _extractFormattedDigi3 = _extractFormattedDigitsAndPlus(text), _extractFormattedDigi4 = _slicedToArray2(_extractFormattedDigi3, 2), formattedDigits = _extractFormattedDigi4[0], hasPlus = _extractFormattedDigi4[1];
  if (!VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN.test(formattedDigits)) {
    formattedDigits = "";
  }
  return [formattedDigits, hasPlus];
}
var VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART, VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN, VALID_FORMATTED_PHONE_NUMBER_PART, AFTER_PHONE_NUMBER_DIGITS_END_PATTERN, COMPLEX_NATIONAL_PREFIX, AsYouTypeParser;
var init_AsYouTypeParser = __esm({
  "node_modules/libphonenumber-js/es6/AsYouTypeParser.js"() {
    init_extractCountryCallingCode();
    init_extractCountryCallingCodeFromInternationalNumberWithoutPlusSign();
    init_extractNationalNumberFromPossiblyIncompleteNumber();
    init_stripIddPrefix();
    init_parseDigits();
    init_constants();
    VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART = "[" + VALID_PUNCTUATION + VALID_DIGITS + "]+";
    VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN = new RegExp("^" + VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART + "$", "i");
    VALID_FORMATTED_PHONE_NUMBER_PART = "(?:[" + PLUS_CHARS + "][" + VALID_PUNCTUATION + VALID_DIGITS + "]*|[" + VALID_PUNCTUATION + VALID_DIGITS + "]+)";
    AFTER_PHONE_NUMBER_DIGITS_END_PATTERN = new RegExp("[^" + VALID_PUNCTUATION + VALID_DIGITS + "]+.*$");
    COMPLEX_NATIONAL_PREFIX = /[^\d\[\]]/;
    AsYouTypeParser = function() {
      function AsYouTypeParser2(_ref) {
        var defaultCountry = _ref.defaultCountry, defaultCallingCode = _ref.defaultCallingCode, metadata = _ref.metadata, onNationalSignificantNumberChange = _ref.onNationalSignificantNumberChange;
        _classCallCheck11(this, AsYouTypeParser2);
        this.defaultCountry = defaultCountry;
        this.defaultCallingCode = defaultCallingCode;
        this.metadata = metadata;
        this.onNationalSignificantNumberChange = onNationalSignificantNumberChange;
      }
      _createClass11(AsYouTypeParser2, [{
        key: "input",
        value: function input(text, state) {
          var _extractFormattedDigi = extractFormattedDigitsAndPlus(text), _extractFormattedDigi2 = _slicedToArray2(_extractFormattedDigi, 2), formattedDigits = _extractFormattedDigi2[0], hasPlus = _extractFormattedDigi2[1];
          var digits = parseDigits(formattedDigits);
          var justLeadingPlus;
          if (hasPlus) {
            if (!state.digits) {
              state.startInternationalNumber();
              if (!digits) {
                justLeadingPlus = true;
              }
            }
          }
          if (digits) {
            this.inputDigits(digits, state);
          }
          return {
            digits,
            justLeadingPlus
          };
        }
        /**
         * Inputs "next" phone number digits.
         * @param  {string} digits
         * @return {string} [formattedNumber] Formatted national phone number (if it can be formatted at this stage). Returning `undefined` means "don't format the national phone number at this stage".
         */
      }, {
        key: "inputDigits",
        value: function inputDigits(nextDigits, state) {
          var digits = state.digits;
          var hasReceivedThreeLeadingDigits = digits.length < 3 && digits.length + nextDigits.length >= 3;
          state.appendDigits(nextDigits);
          if (hasReceivedThreeLeadingDigits) {
            this.extractIddPrefix(state);
          }
          if (this.isWaitingForCountryCallingCode(state)) {
            if (!this.extractCountryCallingCode(state)) {
              return;
            }
          } else {
            state.appendNationalSignificantNumberDigits(nextDigits);
          }
          if (!state.international) {
            if (!this.hasExtractedNationalSignificantNumber) {
              this.extractNationalSignificantNumber(state.getNationalDigits(), function(stateUpdate) {
                return state.update(stateUpdate);
              });
            }
          }
        }
      }, {
        key: "isWaitingForCountryCallingCode",
        value: function isWaitingForCountryCallingCode(_ref2) {
          var international = _ref2.international, callingCode = _ref2.callingCode;
          return international && !callingCode;
        }
        // Extracts a country calling code from a number
        // being entered in internatonal format.
      }, {
        key: "extractCountryCallingCode",
        value: function extractCountryCallingCode2(state) {
          var _extractCountryCallin = extractCountryCallingCode("+" + state.getDigitsWithoutInternationalPrefix(), this.defaultCountry, this.defaultCallingCode, this.metadata.metadata), countryCallingCode = _extractCountryCallin.countryCallingCode, number = _extractCountryCallin.number;
          if (countryCallingCode) {
            state.setCallingCode(countryCallingCode);
            state.update({
              nationalSignificantNumber: number
            });
            return true;
          }
        }
      }, {
        key: "reset",
        value: function reset(numberingPlan) {
          if (numberingPlan) {
            this.hasSelectedNumberingPlan = true;
            var nationalPrefixForParsing = numberingPlan._nationalPrefixForParsing();
            this.couldPossiblyExtractAnotherNationalSignificantNumber = nationalPrefixForParsing && COMPLEX_NATIONAL_PREFIX.test(nationalPrefixForParsing);
          } else {
            this.hasSelectedNumberingPlan = void 0;
            this.couldPossiblyExtractAnotherNationalSignificantNumber = void 0;
          }
        }
        /**
         * Extracts a national (significant) number from user input.
         * Google's library is different in that it only applies `national_prefix_for_parsing`
         * and doesn't apply `national_prefix_transform_rule` after that.
         * https://github.com/google/libphonenumber/blob/a3d70b0487875475e6ad659af404943211d26456/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L539
         * @return {boolean} [extracted]
         */
      }, {
        key: "extractNationalSignificantNumber",
        value: function extractNationalSignificantNumber(nationalDigits, setState) {
          if (!this.hasSelectedNumberingPlan) {
            return;
          }
          var _extractNationalNumbe = extractNationalNumberFromPossiblyIncompleteNumber(nationalDigits, this.metadata), nationalPrefix = _extractNationalNumbe.nationalPrefix, nationalNumber = _extractNationalNumbe.nationalNumber, carrierCode = _extractNationalNumbe.carrierCode;
          if (nationalNumber === nationalDigits) {
            return;
          }
          this.onExtractedNationalNumber(nationalPrefix, carrierCode, nationalNumber, nationalDigits, setState);
          return true;
        }
        /**
         * In Google's code this function is called "attempt to extract longer NDD".
         * "Some national prefixes are a substring of others", they say.
         * @return {boolean} [result] — Returns `true` if extracting a national prefix produced different results from what they were.
         */
      }, {
        key: "extractAnotherNationalSignificantNumber",
        value: function extractAnotherNationalSignificantNumber(nationalDigits, prevNationalSignificantNumber, setState) {
          if (!this.hasExtractedNationalSignificantNumber) {
            return this.extractNationalSignificantNumber(nationalDigits, setState);
          }
          if (!this.couldPossiblyExtractAnotherNationalSignificantNumber) {
            return;
          }
          var _extractNationalNumbe2 = extractNationalNumberFromPossiblyIncompleteNumber(nationalDigits, this.metadata), nationalPrefix = _extractNationalNumbe2.nationalPrefix, nationalNumber = _extractNationalNumbe2.nationalNumber, carrierCode = _extractNationalNumbe2.carrierCode;
          if (nationalNumber === prevNationalSignificantNumber) {
            return;
          }
          this.onExtractedNationalNumber(nationalPrefix, carrierCode, nationalNumber, nationalDigits, setState);
          return true;
        }
      }, {
        key: "onExtractedNationalNumber",
        value: function onExtractedNationalNumber(nationalPrefix, carrierCode, nationalSignificantNumber, nationalDigits, setState) {
          var complexPrefixBeforeNationalSignificantNumber;
          var nationalSignificantNumberMatchesInput;
          var nationalSignificantNumberIndex = nationalDigits.lastIndexOf(nationalSignificantNumber);
          if (nationalSignificantNumberIndex >= 0 && nationalSignificantNumberIndex === nationalDigits.length - nationalSignificantNumber.length) {
            nationalSignificantNumberMatchesInput = true;
            var prefixBeforeNationalNumber = nationalDigits.slice(0, nationalSignificantNumberIndex);
            if (prefixBeforeNationalNumber !== nationalPrefix) {
              complexPrefixBeforeNationalSignificantNumber = prefixBeforeNationalNumber;
            }
          }
          setState({
            nationalPrefix,
            carrierCode,
            nationalSignificantNumber,
            nationalSignificantNumberMatchesInput,
            complexPrefixBeforeNationalSignificantNumber
          });
          this.hasExtractedNationalSignificantNumber = true;
          this.onNationalSignificantNumberChange();
        }
      }, {
        key: "reExtractNationalSignificantNumber",
        value: function reExtractNationalSignificantNumber(state) {
          if (this.extractAnotherNationalSignificantNumber(state.getNationalDigits(), state.nationalSignificantNumber, function(stateUpdate) {
            return state.update(stateUpdate);
          })) {
            return true;
          }
          if (this.extractIddPrefix(state)) {
            this.extractCallingCodeAndNationalSignificantNumber(state);
            return true;
          }
          if (this.fixMissingPlus(state)) {
            this.extractCallingCodeAndNationalSignificantNumber(state);
            return true;
          }
        }
      }, {
        key: "extractIddPrefix",
        value: function extractIddPrefix(state) {
          var international = state.international, IDDPrefix = state.IDDPrefix, digits = state.digits, nationalSignificantNumber = state.nationalSignificantNumber;
          if (international || IDDPrefix) {
            return;
          }
          var numberWithoutIDD = stripIddPrefix(digits, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata);
          if (numberWithoutIDD !== void 0 && numberWithoutIDD !== digits) {
            state.update({
              IDDPrefix: digits.slice(0, digits.length - numberWithoutIDD.length)
            });
            this.startInternationalNumber(state, {
              country: void 0,
              callingCode: void 0
            });
            return true;
          }
        }
      }, {
        key: "fixMissingPlus",
        value: function fixMissingPlus(state) {
          if (!state.international) {
            var _extractCountryCallin2 = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(state.digits, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata), newCallingCode = _extractCountryCallin2.countryCallingCode, number = _extractCountryCallin2.number;
            if (newCallingCode) {
              state.update({
                missingPlus: true
              });
              this.startInternationalNumber(state, {
                country: state.country,
                callingCode: newCallingCode
              });
              return true;
            }
          }
        }
      }, {
        key: "startInternationalNumber",
        value: function startInternationalNumber(state, _ref3) {
          var country2 = _ref3.country, callingCode = _ref3.callingCode;
          state.startInternationalNumber(country2, callingCode);
          if (state.nationalSignificantNumber) {
            state.resetNationalSignificantNumber();
            this.onNationalSignificantNumberChange();
            this.hasExtractedNationalSignificantNumber = void 0;
          }
        }
      }, {
        key: "extractCallingCodeAndNationalSignificantNumber",
        value: function extractCallingCodeAndNationalSignificantNumber(state) {
          if (this.extractCountryCallingCode(state)) {
            this.extractNationalSignificantNumber(state.getNationalDigits(), function(stateUpdate) {
              return state.update(stateUpdate);
            });
          }
        }
      }]);
      return AsYouTypeParser2;
    }();
  }
});

// node_modules/libphonenumber-js/es6/AsYouType.js
function _typeof4(obj) {
  "@babel/helpers - typeof";
  return _typeof4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof4(obj);
}
function _slicedToArray3(arr, i) {
  return _arrayWithHoles3(arr) || _iterableToArrayLimit3(arr, i) || _unsupportedIterableToArray14(arr, i) || _nonIterableRest3();
}
function _nonIterableRest3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray14(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray14(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray14(o, minLen);
}
function _arrayLikeToArray14(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit3(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles3(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck12(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties12(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass12(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties12(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties12(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var USE_NON_GEOGRAPHIC_COUNTRY_CODE5, AsYouType;
var init_AsYouType = __esm({
  "node_modules/libphonenumber-js/es6/AsYouType.js"() {
    init_metadata();
    init_PhoneNumber();
    init_AsYouTypeState();
    init_AsYouTypeFormatter();
    init_AsYouTypeParser();
    init_getCountryByCallingCode();
    USE_NON_GEOGRAPHIC_COUNTRY_CODE5 = false;
    AsYouType = function() {
      function AsYouType3(optionsOrDefaultCountry, metadata) {
        _classCallCheck12(this, AsYouType3);
        this.metadata = new Metadata(metadata);
        var _this$getCountryAndCa = this.getCountryAndCallingCode(optionsOrDefaultCountry), _this$getCountryAndCa2 = _slicedToArray3(_this$getCountryAndCa, 2), defaultCountry = _this$getCountryAndCa2[0], defaultCallingCode = _this$getCountryAndCa2[1];
        this.defaultCountry = defaultCountry;
        this.defaultCallingCode = defaultCallingCode;
        this.reset();
      }
      _createClass12(AsYouType3, [{
        key: "getCountryAndCallingCode",
        value: function getCountryAndCallingCode(optionsOrDefaultCountry) {
          var defaultCountry;
          var defaultCallingCode;
          if (optionsOrDefaultCountry) {
            if (_typeof4(optionsOrDefaultCountry) === "object") {
              defaultCountry = optionsOrDefaultCountry.defaultCountry;
              defaultCallingCode = optionsOrDefaultCountry.defaultCallingCode;
            } else {
              defaultCountry = optionsOrDefaultCountry;
            }
          }
          if (defaultCountry && !this.metadata.hasCountry(defaultCountry)) {
            defaultCountry = void 0;
          }
          if (defaultCallingCode) {
            if (USE_NON_GEOGRAPHIC_COUNTRY_CODE5) {
              if (this.metadata.isNonGeographicCallingCode(defaultCallingCode)) {
                defaultCountry = "001";
              }
            }
          }
          return [defaultCountry, defaultCallingCode];
        }
        /**
         * Inputs "next" phone number characters.
         * @param  {string} text
         * @return {string} Formatted phone number characters that have been input so far.
         */
      }, {
        key: "input",
        value: function input(text) {
          var _this$parser$input = this.parser.input(text, this.state), digits = _this$parser$input.digits, justLeadingPlus = _this$parser$input.justLeadingPlus;
          if (justLeadingPlus) {
            this.formattedOutput = "+";
          } else if (digits) {
            this.determineTheCountryIfNeeded();
            if (this.state.nationalSignificantNumber) {
              this.formatter.narrowDownMatchingFormats(this.state);
            }
            var formattedNationalNumber;
            if (this.metadata.hasSelectedNumberingPlan()) {
              formattedNationalNumber = this.formatter.format(digits, this.state);
            }
            if (formattedNationalNumber === void 0) {
              if (this.parser.reExtractNationalSignificantNumber(this.state)) {
                this.determineTheCountryIfNeeded();
                var nationalDigits = this.state.getNationalDigits();
                if (nationalDigits) {
                  formattedNationalNumber = this.formatter.format(nationalDigits, this.state);
                }
              }
            }
            this.formattedOutput = formattedNationalNumber ? this.getFullNumber(formattedNationalNumber) : this.getNonFormattedNumber();
          }
          return this.formattedOutput;
        }
      }, {
        key: "reset",
        value: function reset() {
          var _this = this;
          this.state = new AsYouTypeState({
            onCountryChange: function onCountryChange(country2) {
              _this.country = country2;
            },
            onCallingCodeChange: function onCallingCodeChange(callingCode, country2) {
              _this.metadata.selectNumberingPlan(country2, callingCode);
              _this.formatter.reset(_this.metadata.numberingPlan, _this.state);
              _this.parser.reset(_this.metadata.numberingPlan);
            }
          });
          this.formatter = new AsYouTypeFormatter({
            state: this.state,
            metadata: this.metadata
          });
          this.parser = new AsYouTypeParser({
            defaultCountry: this.defaultCountry,
            defaultCallingCode: this.defaultCallingCode,
            metadata: this.metadata,
            state: this.state,
            onNationalSignificantNumberChange: function onNationalSignificantNumberChange() {
              _this.determineTheCountryIfNeeded();
              _this.formatter.reset(_this.metadata.numberingPlan, _this.state);
            }
          });
          this.state.reset({
            country: this.defaultCountry,
            callingCode: this.defaultCallingCode
          });
          this.formattedOutput = "";
          return this;
        }
        /**
         * Returns `true` if the phone number is being input in international format.
         * In other words, returns `true` if and only if the parsed phone number starts with a `"+"`.
         * @return {boolean}
         */
      }, {
        key: "isInternational",
        value: function isInternational() {
          return this.state.international;
        }
        /**
         * Returns the "calling code" part of the phone number when it's being input
         * in an international format.
         * If no valid calling code has been entered so far, returns `undefined`.
         * @return {string} [callingCode]
         */
      }, {
        key: "getCallingCode",
        value: function getCallingCode() {
          if (this.isInternational()) {
            return this.state.callingCode;
          }
        }
        // A legacy alias.
      }, {
        key: "getCountryCallingCode",
        value: function getCountryCallingCode3() {
          return this.getCallingCode();
        }
        /**
         * Returns a two-letter country code of the phone number.
         * Returns `undefined` for "non-geographic" phone numbering plans.
         * Returns `undefined` if no phone number has been input yet.
         * @return {string} [country]
         */
      }, {
        key: "getCountry",
        value: function getCountry() {
          var digits = this.state.digits;
          if (digits) {
            return this._getCountry();
          }
        }
        /**
         * Returns a two-letter country code of the phone number.
         * Returns `undefined` for "non-geographic" phone numbering plans.
         * @return {string} [country]
         */
      }, {
        key: "_getCountry",
        value: function _getCountry() {
          var country2 = this.state.country;
          if (USE_NON_GEOGRAPHIC_COUNTRY_CODE5) {
            if (country2 === "001") {
              return;
            }
          }
          return country2;
        }
      }, {
        key: "determineTheCountryIfNeeded",
        value: function determineTheCountryIfNeeded() {
          if (!this.state.country || this.isCountryCallingCodeAmbiguous()) {
            this.determineTheCountry();
          }
        }
        // Prepends `+CountryCode ` in case of an international phone number
      }, {
        key: "getFullNumber",
        value: function getFullNumber(formattedNationalNumber) {
          var _this2 = this;
          if (this.isInternational()) {
            var prefix = function prefix2(text) {
              return _this2.formatter.getInternationalPrefixBeforeCountryCallingCode(_this2.state, {
                spacing: text ? true : false
              }) + text;
            };
            var callingCode = this.state.callingCode;
            if (!callingCode) {
              return prefix("".concat(this.state.getDigitsWithoutInternationalPrefix()));
            }
            if (!formattedNationalNumber) {
              return prefix(callingCode);
            }
            return prefix("".concat(callingCode, " ").concat(formattedNationalNumber));
          }
          return formattedNationalNumber;
        }
      }, {
        key: "getNonFormattedNationalNumberWithPrefix",
        value: function getNonFormattedNationalNumberWithPrefix() {
          var _this$state = this.state, nationalSignificantNumber = _this$state.nationalSignificantNumber, complexPrefixBeforeNationalSignificantNumber = _this$state.complexPrefixBeforeNationalSignificantNumber, nationalPrefix = _this$state.nationalPrefix;
          var number = nationalSignificantNumber;
          var prefix = complexPrefixBeforeNationalSignificantNumber || nationalPrefix;
          if (prefix) {
            number = prefix + number;
          }
          return number;
        }
      }, {
        key: "getNonFormattedNumber",
        value: function getNonFormattedNumber() {
          var nationalSignificantNumberMatchesInput = this.state.nationalSignificantNumberMatchesInput;
          return this.getFullNumber(nationalSignificantNumberMatchesInput ? this.getNonFormattedNationalNumberWithPrefix() : this.state.getNationalDigits());
        }
      }, {
        key: "getNonFormattedTemplate",
        value: function getNonFormattedTemplate() {
          var number = this.getNonFormattedNumber();
          if (number) {
            return number.replace(/[\+\d]/g, DIGIT_PLACEHOLDER);
          }
        }
      }, {
        key: "isCountryCallingCodeAmbiguous",
        value: function isCountryCallingCodeAmbiguous() {
          var callingCode = this.state.callingCode;
          var countryCodes = this.metadata.getCountryCodesForCallingCode(callingCode);
          return countryCodes && countryCodes.length > 1;
        }
        // Determines the country of the phone number
        // entered so far based on the country phone code
        // and the national phone number.
      }, {
        key: "determineTheCountry",
        value: function determineTheCountry() {
          this.state.setCountry(getCountryByCallingCode(this.isInternational() ? this.state.callingCode : this.defaultCallingCode, this.state.nationalSignificantNumber, this.metadata));
        }
        /**
         * Returns a E.164 phone number value for the user's input.
         *
         * For example, for country `"US"` and input `"(222) 333-4444"`
         * it will return `"+12223334444"`.
         *
         * For international phone number input, it will also auto-correct
         * some minor errors such as using a national prefix when writing
         * an international phone number. For example, if the user inputs
         * `"+44 0 7400 000000"` then it will return an auto-corrected
         * `"+447400000000"` phone number value.
         *
         * Will return `undefined` if no digits have been input,
         * or when inputting a phone number in national format and no
         * default country or default "country calling code" have been set.
         *
         * @return {string} [value]
         */
      }, {
        key: "getNumberValue",
        value: function getNumberValue() {
          var _this$state2 = this.state, digits = _this$state2.digits, callingCode = _this$state2.callingCode, country2 = _this$state2.country, nationalSignificantNumber = _this$state2.nationalSignificantNumber;
          if (!digits) {
            return;
          }
          if (this.isInternational()) {
            if (callingCode) {
              return "+" + callingCode + nationalSignificantNumber;
            } else {
              return "+" + digits;
            }
          } else {
            if (country2 || callingCode) {
              var callingCode_ = country2 ? this.metadata.countryCallingCode() : callingCode;
              return "+" + callingCode_ + nationalSignificantNumber;
            }
          }
        }
        /**
         * Returns an instance of `PhoneNumber` class.
         * Will return `undefined` if no national (significant) number
         * digits have been entered so far, or if no `defaultCountry` has been
         * set and the user enters a phone number not in international format.
         */
      }, {
        key: "getNumber",
        value: function getNumber() {
          var _this$state3 = this.state, nationalSignificantNumber = _this$state3.nationalSignificantNumber, carrierCode = _this$state3.carrierCode, callingCode = _this$state3.callingCode;
          var country2 = this._getCountry();
          if (!nationalSignificantNumber) {
            return;
          }
          if (!country2 && !callingCode) {
            return;
          }
          var phoneNumber = new PhoneNumber(country2 || callingCode, nationalSignificantNumber, this.metadata.metadata);
          if (carrierCode) {
            phoneNumber.carrierCode = carrierCode;
          }
          return phoneNumber;
        }
        /**
         * Returns `true` if the phone number is "possible".
         * Is just a shortcut for `PhoneNumber.isPossible()`.
         * @return {boolean}
         */
      }, {
        key: "isPossible",
        value: function isPossible() {
          var phoneNumber = this.getNumber();
          if (!phoneNumber) {
            return false;
          }
          return phoneNumber.isPossible();
        }
        /**
         * Returns `true` if the phone number is "valid".
         * Is just a shortcut for `PhoneNumber.isValid()`.
         * @return {boolean}
         */
      }, {
        key: "isValid",
        value: function isValid() {
          var phoneNumber = this.getNumber();
          if (!phoneNumber) {
            return false;
          }
          return phoneNumber.isValid();
        }
        /**
         * @deprecated
         * This method is used in `react-phone-number-input/source/input-control.js`
         * in versions before `3.0.16`.
         */
      }, {
        key: "getNationalNumber",
        value: function getNationalNumber() {
          return this.state.nationalSignificantNumber;
        }
        /**
         * Returns the phone number characters entered by the user.
         * @return {string}
         */
      }, {
        key: "getChars",
        value: function getChars() {
          return (this.state.international ? "+" : "") + this.state.digits;
        }
        /**
         * Returns the template for the formatted phone number.
         * @return {string}
         */
      }, {
        key: "getTemplate",
        value: function getTemplate() {
          return this.formatter.getTemplate(this.state) || this.getNonFormattedTemplate() || "";
        }
      }]);
      return AsYouType3;
    }();
  }
});

// node_modules/libphonenumber-js/es6/getCountries.js
var init_getCountries = __esm({
  "node_modules/libphonenumber-js/es6/getCountries.js"() {
    init_metadata();
  }
});

// node_modules/libphonenumber-js/es6/getExampleNumber.js
var init_getExampleNumber = __esm({
  "node_modules/libphonenumber-js/es6/getExampleNumber.js"() {
    init_PhoneNumber();
  }
});

// node_modules/libphonenumber-js/es6/formatIncompletePhoneNumber.js
var init_formatIncompletePhoneNumber = __esm({
  "node_modules/libphonenumber-js/es6/formatIncompletePhoneNumber.js"() {
    init_AsYouType();
  }
});

// node_modules/libphonenumber-js/core/index.js
var init_core = __esm({
  "node_modules/libphonenumber-js/core/index.js"() {
    init_ParseError();
    init_parsePhoneNumberWithError2();
    init_parsePhoneNumber2();
    init_isValidPhoneNumber();
    init_isPossiblePhoneNumber();
    init_validatePhoneNumberLength();
    init_findNumbers();
    init_searchNumbers();
    init_findPhoneNumbersInText();
    init_searchPhoneNumbersInText();
    init_PhoneNumberMatcher();
    init_AsYouType();
    init_AsYouTypeFormatter();
    init_getCountries();
    init_metadata();
    init_getExampleNumber();
    init_formatIncompletePhoneNumber();
    init_parseIncompletePhoneNumber();
    init_parseDigits();
    init_RFC3966();
  }
});

// node_modules/libphonenumber-js/min/exports/parsePhoneNumberWithError.js
var init_parsePhoneNumberWithError3 = __esm({
  "node_modules/libphonenumber-js/min/exports/parsePhoneNumberWithError.js"() {
    init_withMetadataArgument();
    init_core();
  }
});

// node_modules/libphonenumber-js/min/exports/parsePhoneNumber.js
function parsePhoneNumber4() {
  return withMetadataArgument(parsePhoneNumber3, arguments);
}
var init_parsePhoneNumber3 = __esm({
  "node_modules/libphonenumber-js/min/exports/parsePhoneNumber.js"() {
    init_withMetadataArgument();
    init_core();
  }
});

// node_modules/libphonenumber-js/min/exports/isValidPhoneNumber.js
var init_isValidPhoneNumber2 = __esm({
  "node_modules/libphonenumber-js/min/exports/isValidPhoneNumber.js"() {
    init_withMetadataArgument();
    init_core();
  }
});

// node_modules/libphonenumber-js/min/exports/isPossiblePhoneNumber.js
var init_isPossiblePhoneNumber2 = __esm({
  "node_modules/libphonenumber-js/min/exports/isPossiblePhoneNumber.js"() {
    init_withMetadataArgument();
    init_core();
  }
});

// node_modules/libphonenumber-js/min/exports/validatePhoneNumberLength.js
var init_validatePhoneNumberLength2 = __esm({
  "node_modules/libphonenumber-js/min/exports/validatePhoneNumberLength.js"() {
    init_withMetadataArgument();
    init_core();
  }
});

// node_modules/libphonenumber-js/min/exports/findNumbers.js
var init_findNumbers2 = __esm({
  "node_modules/libphonenumber-js/min/exports/findNumbers.js"() {
    init_withMetadataArgument();
    init_core();
  }
});

// node_modules/libphonenumber-js/min/exports/searchNumbers.js
var init_searchNumbers2 = __esm({
  "node_modules/libphonenumber-js/min/exports/searchNumbers.js"() {
    init_withMetadataArgument();
    init_core();
  }
});

// node_modules/libphonenumber-js/min/exports/findPhoneNumbersInText.js
var init_findPhoneNumbersInText2 = __esm({
  "node_modules/libphonenumber-js/min/exports/findPhoneNumbersInText.js"() {
    init_withMetadataArgument();
    init_core();
  }
});

// node_modules/libphonenumber-js/min/exports/searchPhoneNumbersInText.js
var init_searchPhoneNumbersInText2 = __esm({
  "node_modules/libphonenumber-js/min/exports/searchPhoneNumbersInText.js"() {
    init_withMetadataArgument();
    init_core();
  }
});

// node_modules/libphonenumber-js/min/exports/PhoneNumberMatcher.js
function PhoneNumberMatcher2(text, options) {
  return PhoneNumberMatcher.call(this, text, options, metadata_min_json_default);
}
var init_PhoneNumberMatcher2 = __esm({
  "node_modules/libphonenumber-js/min/exports/PhoneNumberMatcher.js"() {
    init_metadata_min_json();
    init_core();
    PhoneNumberMatcher2.prototype = Object.create(PhoneNumberMatcher.prototype, {});
    PhoneNumberMatcher2.prototype.constructor = PhoneNumberMatcher2;
  }
});

// node_modules/libphonenumber-js/min/exports/AsYouType.js
function AsYouType2(country2) {
  return AsYouType.call(this, country2, metadata_min_json_default);
}
var init_AsYouType2 = __esm({
  "node_modules/libphonenumber-js/min/exports/AsYouType.js"() {
    init_metadata_min_json();
    init_core();
    AsYouType2.prototype = Object.create(AsYouType.prototype, {});
    AsYouType2.prototype.constructor = AsYouType2;
  }
});

// node_modules/libphonenumber-js/min/exports/isSupportedCountry.js
var init_isSupportedCountry = __esm({
  "node_modules/libphonenumber-js/min/exports/isSupportedCountry.js"() {
    init_withMetadataArgument();
    init_core();
  }
});

// node_modules/libphonenumber-js/min/exports/getCountries.js
var init_getCountries2 = __esm({
  "node_modules/libphonenumber-js/min/exports/getCountries.js"() {
    init_withMetadataArgument();
    init_core();
  }
});

// node_modules/libphonenumber-js/min/exports/getCountryCallingCode.js
var init_getCountryCallingCode2 = __esm({
  "node_modules/libphonenumber-js/min/exports/getCountryCallingCode.js"() {
    init_withMetadataArgument();
    init_core();
  }
});

// node_modules/libphonenumber-js/min/exports/getExtPrefix.js
var init_getExtPrefix = __esm({
  "node_modules/libphonenumber-js/min/exports/getExtPrefix.js"() {
    init_withMetadataArgument();
    init_core();
  }
});

// node_modules/libphonenumber-js/min/exports/Metadata.js
function Metadata2() {
  return Metadata.call(this, metadata_min_json_default);
}
var init_Metadata = __esm({
  "node_modules/libphonenumber-js/min/exports/Metadata.js"() {
    init_metadata_min_json();
    init_core();
    Metadata2.prototype = Object.create(Metadata.prototype, {});
    Metadata2.prototype.constructor = Metadata2;
  }
});

// node_modules/libphonenumber-js/min/exports/getExampleNumber.js
var init_getExampleNumber2 = __esm({
  "node_modules/libphonenumber-js/min/exports/getExampleNumber.js"() {
    init_withMetadataArgument();
    init_core();
  }
});

// node_modules/libphonenumber-js/min/exports/formatIncompletePhoneNumber.js
var init_formatIncompletePhoneNumber2 = __esm({
  "node_modules/libphonenumber-js/min/exports/formatIncompletePhoneNumber.js"() {
    init_withMetadataArgument();
    init_core();
  }
});

// node_modules/libphonenumber-js/es6/legacy/parse.js
var init_parse2 = __esm({
  "node_modules/libphonenumber-js/es6/legacy/parse.js"() {
    init_parse();
    init_normalizeArguments();
  }
});

// node_modules/libphonenumber-js/index.es6.exports/parse.js
var init_parse3 = __esm({
  "node_modules/libphonenumber-js/index.es6.exports/parse.js"() {
    init_withMetadataArgument();
    init_parse2();
  }
});

// node_modules/libphonenumber-js/es6/legacy/format.js
var init_format2 = __esm({
  "node_modules/libphonenumber-js/es6/legacy/format.js"() {
    init_format();
    init_parse();
  }
});

// node_modules/libphonenumber-js/index.es6.exports/format.js
var init_format3 = __esm({
  "node_modules/libphonenumber-js/index.es6.exports/format.js"() {
    init_withMetadataArgument();
    init_format2();
  }
});

// node_modules/libphonenumber-js/es6/legacy/getNumberType.js
var init_getNumberType2 = __esm({
  "node_modules/libphonenumber-js/es6/legacy/getNumberType.js"() {
    init_isViablePhoneNumber();
    init_getNumberType();
    init_parse();
  }
});

// node_modules/libphonenumber-js/index.es6.exports/getNumberType.js
var init_getNumberType3 = __esm({
  "node_modules/libphonenumber-js/index.es6.exports/getNumberType.js"() {
    init_withMetadataArgument();
    init_getNumberType2();
  }
});

// node_modules/libphonenumber-js/es6/legacy/isPossibleNumber.js
var init_isPossibleNumber = __esm({
  "node_modules/libphonenumber-js/es6/legacy/isPossibleNumber.js"() {
    init_getNumberType2();
    init_isPossible();
  }
});

// node_modules/libphonenumber-js/index.es6.exports/isPossibleNumber.js
var init_isPossibleNumber2 = __esm({
  "node_modules/libphonenumber-js/index.es6.exports/isPossibleNumber.js"() {
    init_withMetadataArgument();
    init_isPossibleNumber();
  }
});

// node_modules/libphonenumber-js/es6/legacy/isValidNumber.js
var init_isValidNumber = __esm({
  "node_modules/libphonenumber-js/es6/legacy/isValidNumber.js"() {
    init_isValid();
    init_getNumberType2();
  }
});

// node_modules/libphonenumber-js/index.es6.exports/isValidNumber.js
var init_isValidNumber2 = __esm({
  "node_modules/libphonenumber-js/index.es6.exports/isValidNumber.js"() {
    init_withMetadataArgument();
    init_isValidNumber();
  }
});

// node_modules/libphonenumber-js/es6/legacy/isValidNumberForRegion_.js
var init_isValidNumberForRegion = __esm({
  "node_modules/libphonenumber-js/es6/legacy/isValidNumberForRegion_.js"() {
    init_isValid();
  }
});

// node_modules/libphonenumber-js/es6/legacy/isValidNumberForRegion.js
var init_isValidNumberForRegion2 = __esm({
  "node_modules/libphonenumber-js/es6/legacy/isValidNumberForRegion.js"() {
    init_isViablePhoneNumber();
    init_parse();
    init_isValidNumberForRegion();
  }
});

// node_modules/libphonenumber-js/index.es6.exports/isValidNumberForRegion.js
var init_isValidNumberForRegion3 = __esm({
  "node_modules/libphonenumber-js/index.es6.exports/isValidNumberForRegion.js"() {
    init_withMetadataArgument();
    init_isValidNumberForRegion2();
  }
});

// node_modules/libphonenumber-js/es6/legacy/findPhoneNumbersInitialImplementation.js
function _classCallCheck13(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties13(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass13(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties13(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties13(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var EXTN_PATTERNS_FOR_PARSING, WHITESPACE_IN_THE_BEGINNING_PATTERN, PUNCTUATION_IN_THE_END_PATTERN, PhoneNumberSearch;
var init_findPhoneNumbersInitialImplementation = __esm({
  "node_modules/libphonenumber-js/es6/legacy/findPhoneNumbersInitialImplementation.js"() {
    init_constants();
    init_parse();
    init_isViablePhoneNumber();
    init_createExtensionPattern();
    init_parsePreCandidate();
    init_isValidPreCandidate();
    init_isValidCandidate();
    EXTN_PATTERNS_FOR_PARSING = createExtensionPattern("parsing");
    WHITESPACE_IN_THE_BEGINNING_PATTERN = new RegExp("^[" + WHITESPACE + "]+");
    PUNCTUATION_IN_THE_END_PATTERN = new RegExp("[" + VALID_PUNCTUATION + "]+$");
    PhoneNumberSearch = function() {
      function PhoneNumberSearch3(text, options, metadata) {
        _classCallCheck13(this, PhoneNumberSearch3);
        this.text = text;
        this.options = options || {};
        this.metadata = metadata;
        this.state = "NOT_READY";
        this.regexp = new RegExp(VALID_PHONE_NUMBER_WITH_EXTENSION, "ig");
      }
      _createClass13(PhoneNumberSearch3, [{
        key: "find",
        value: function find() {
          var matches2 = this.regexp.exec(this.text);
          if (!matches2) {
            return;
          }
          var number = matches2[0];
          var startsAt = matches2.index;
          number = number.replace(WHITESPACE_IN_THE_BEGINNING_PATTERN, "");
          startsAt += matches2[0].length - number.length;
          number = number.replace(PUNCTUATION_IN_THE_END_PATTERN, "");
          number = parsePreCandidate(number);
          var result2 = this.parseCandidate(number, startsAt);
          if (result2) {
            return result2;
          }
          return this.find();
        }
      }, {
        key: "parseCandidate",
        value: function parseCandidate(number, startsAt) {
          if (!isValidPreCandidate(number, startsAt, this.text)) {
            return;
          }
          if (!isValidCandidate(number, startsAt, this.text, this.options.extended ? "POSSIBLE" : "VALID")) {
            return;
          }
          var result2 = parse(number, this.options, this.metadata);
          if (!result2.phone) {
            return;
          }
          result2.startsAt = startsAt;
          result2.endsAt = startsAt + number.length;
          return result2;
        }
      }, {
        key: "hasNext",
        value: function hasNext() {
          if (this.state === "NOT_READY") {
            this.last_match = this.find();
            if (this.last_match) {
              this.state = "READY";
            } else {
              this.state = "DONE";
            }
          }
          return this.state === "READY";
        }
      }, {
        key: "next",
        value: function next() {
          if (!this.hasNext()) {
            throw new Error("No next element");
          }
          var result2 = this.last_match;
          this.last_match = null;
          this.state = "NOT_READY";
          return result2;
        }
      }]);
      return PhoneNumberSearch3;
    }();
  }
});

// node_modules/libphonenumber-js/es6/legacy/findPhoneNumbers.js
var init_findPhoneNumbers = __esm({
  "node_modules/libphonenumber-js/es6/legacy/findPhoneNumbers.js"() {
    init_findPhoneNumbersInitialImplementation();
    init_normalizeArguments();
  }
});

// node_modules/libphonenumber-js/index.es6.exports/findPhoneNumbers.js
var init_findPhoneNumbers2 = __esm({
  "node_modules/libphonenumber-js/index.es6.exports/findPhoneNumbers.js"() {
    init_withMetadataArgument();
    init_findPhoneNumbers();
  }
});

// node_modules/libphonenumber-js/index.es6.exports/searchPhoneNumbers.js
var init_searchPhoneNumbers = __esm({
  "node_modules/libphonenumber-js/index.es6.exports/searchPhoneNumbers.js"() {
    init_withMetadataArgument();
    init_findPhoneNumbers();
  }
});

// node_modules/libphonenumber-js/index.es6.exports/PhoneNumberSearch.js
function PhoneNumberSearch2(text, options) {
  PhoneNumberSearch.call(this, text, options, metadata_min_json_default);
}
var init_PhoneNumberSearch = __esm({
  "node_modules/libphonenumber-js/index.es6.exports/PhoneNumberSearch.js"() {
    init_metadata_min_json();
    init_findPhoneNumbersInitialImplementation();
    PhoneNumberSearch2.prototype = Object.create(PhoneNumberSearch.prototype, {});
    PhoneNumberSearch2.prototype.constructor = PhoneNumberSearch2;
  }
});

// node_modules/libphonenumber-js/index.js
var init_libphonenumber_js = __esm({
  "node_modules/libphonenumber-js/index.js"() {
    init_parsePhoneNumberWithError3();
    init_parsePhoneNumber3();
    init_isValidPhoneNumber2();
    init_isPossiblePhoneNumber2();
    init_validatePhoneNumberLength2();
    init_findNumbers2();
    init_searchNumbers2();
    init_findPhoneNumbersInText2();
    init_searchPhoneNumbersInText2();
    init_PhoneNumberMatcher2();
    init_AsYouType2();
    init_AsYouTypeFormatter();
    init_isSupportedCountry();
    init_getCountries2();
    init_getCountryCallingCode2();
    init_getExtPrefix();
    init_Metadata();
    init_getExampleNumber2();
    init_formatIncompletePhoneNumber2();
    init_core();
    init_parse3();
    init_format3();
    init_getNumberType3();
    init_isPossibleNumber2();
    init_isValidNumber2();
    init_isValidNumberForRegion3();
    init_findPhoneNumbers2();
    init_searchPhoneNumbers();
    init_PhoneNumberSearch();
    init_parseDigits();
    init_parse2();
    init_format2();
    init_isValidNumber();
    init_findPhoneNumbers();
    init_findPhoneNumbers();
    init_findPhoneNumbersInitialImplementation();
    init_getNumberType2();
    init_getCountryCallingCode();
    init_AsYouType();
  }
});

// node_modules/class-validator/esm5/decorator/string/IsPhoneNumber.js
function isPhoneNumber(value, region) {
  try {
    var phoneNum = parsePhoneNumber4(value, region);
    var result2 = phoneNum === null || phoneNum === void 0 ? void 0 : phoneNum.isValid();
    return !!result2;
  } catch (error) {
    return false;
  }
}
function IsPhoneNumber(region, validationOptions) {
  return ValidateBy({
    name: IS_PHONE_NUMBER,
    constraints: [region],
    validator: {
      validate: function(value, args) {
        return isPhoneNumber(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a valid phone number";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_PHONE_NUMBER;
var init_IsPhoneNumber = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsPhoneNumber.js"() {
    init_ValidateBy();
    init_libphonenumber_js();
    IS_PHONE_NUMBER = "isPhoneNumber";
  }
});

// node_modules/class-validator/esm5/decorator/string/IsMilitaryTime.js
function isMilitaryTime(value) {
  var militaryTimeRegex = /^([01]\d|2[0-3]):?([0-5]\d)$/;
  return typeof value === "string" && (0, import_matches2.default)(value, militaryTimeRegex);
}
function IsMilitaryTime(validationOptions) {
  return ValidateBy({
    name: IS_MILITARY_TIME,
    validator: {
      validate: function(value, args) {
        return isMilitaryTime(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a valid representation of military time in the format HH:MM";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_matches2, IS_MILITARY_TIME;
var init_IsMilitaryTime = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsMilitaryTime.js"() {
    init_ValidateBy();
    import_matches2 = __toESM(require_matches());
    IS_MILITARY_TIME = "isMilitaryTime";
  }
});

// node_modules/validator/lib/isHash.js
var require_isHash = __commonJS({
  "node_modules/validator/lib/isHash.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isHash2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var lengths = {
      md5: 32,
      md4: 32,
      sha1: 40,
      sha256: 64,
      sha384: 96,
      sha512: 128,
      ripemd128: 32,
      ripemd160: 40,
      tiger128: 32,
      tiger160: 40,
      tiger192: 48,
      crc32: 8,
      crc32b: 8
    };
    function isHash2(str, algorithm) {
      (0, _assertString.default)(str);
      var hash = new RegExp("^[a-fA-F0-9]{".concat(lengths[algorithm], "}$"));
      return hash.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsHash.js
function isHash(value, algorithm) {
  return typeof value === "string" && (0, import_isHash.default)(value, algorithm);
}
function IsHash(algorithm, validationOptions) {
  return ValidateBy({
    name: IS_HASH,
    constraints: [algorithm],
    validator: {
      validate: function(value, args) {
        return isHash(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a hash of type $constraint1";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isHash, IS_HASH;
var init_IsHash = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsHash.js"() {
    init_ValidateBy();
    import_isHash = __toESM(require_isHash());
    IS_HASH = "isHash";
  }
});

// node_modules/validator/lib/isISSN.js
var require_isISSN = __commonJS({
  "node_modules/validator/lib/isISSN.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isISSN2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var issn = "^\\d{4}-?\\d{3}[\\dX]$";
    function isISSN2(str) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      (0, _assertString.default)(str);
      var testIssn = issn;
      testIssn = options.require_hyphen ? testIssn.replace("?", "") : testIssn;
      testIssn = options.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, "i");
      if (!testIssn.test(str)) {
        return false;
      }
      var digits = str.replace("-", "").toUpperCase();
      var checksum = 0;
      for (var i = 0; i < digits.length; i++) {
        var digit = digits[i];
        checksum += (digit === "X" ? 10 : +digit) * (8 - i);
      }
      return checksum % 11 === 0;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsISSN.js
function isISSN(value, options) {
  return typeof value === "string" && (0, import_isISSN.default)(value, options);
}
function IsISSN(options, validationOptions) {
  return ValidateBy({
    name: IS_ISSN,
    constraints: [options],
    validator: {
      validate: function(value, args) {
        return isISSN(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a ISSN";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isISSN, IS_ISSN;
var init_IsISSN = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsISSN.js"() {
    init_ValidateBy();
    import_isISSN = __toESM(require_isISSN());
    IS_ISSN = "isISSN";
  }
});

// node_modules/class-validator/esm5/decorator/string/IsDateString.js
function isDateString(value, options) {
  return isISO8601(value, options);
}
function IsDateString(options, validationOptions) {
  return ValidateBy({
    name: IS_DATE_STRING,
    constraints: [options],
    validator: {
      validate: function(value, args) {
        return isDateString(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a valid ISO 8601 date string";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_DATE_STRING;
var init_IsDateString = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsDateString.js"() {
    init_ValidateBy();
    init_IsISO8601();
    IS_DATE_STRING = "isDateString";
  }
});

// node_modules/validator/lib/isBoolean.js
var require_isBoolean = __commonJS({
  "node_modules/validator/lib/isBoolean.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBoolean2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var defaultOptions2 = {
      loose: false
    };
    var strictBooleans = ["true", "false", "1", "0"];
    var looseBooleans = [].concat(strictBooleans, ["yes", "no"]);
    function isBoolean2(str) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultOptions2;
      (0, _assertString.default)(str);
      if (options.loose) {
        return looseBooleans.includes(str.toLowerCase());
      }
      return strictBooleans.includes(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsBooleanString.js
function isBooleanString(value) {
  return typeof value === "string" && (0, import_isBoolean.default)(value);
}
function IsBooleanString(validationOptions) {
  return ValidateBy({
    name: IS_BOOLEAN_STRING,
    validator: {
      validate: function(value, args) {
        return isBooleanString(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a boolean string";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isBoolean, IS_BOOLEAN_STRING;
var init_IsBooleanString = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsBooleanString.js"() {
    init_ValidateBy();
    import_isBoolean = __toESM(require_isBoolean());
    IS_BOOLEAN_STRING = "isBooleanString";
  }
});

// node_modules/validator/lib/isNumeric.js
var require_isNumeric = __commonJS({
  "node_modules/validator/lib/isNumeric.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isNumeric;
    var _assertString = _interopRequireDefault(require_assertString());
    var _alpha = require_alpha();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var numericNoSymbols = /^[0-9]+$/;
    function isNumeric(str, options) {
      (0, _assertString.default)(str);
      if (options && options.no_symbols) {
        return numericNoSymbols.test(str);
      }
      return new RegExp("^[+-]?([0-9]*[".concat((options || {}).locale ? _alpha.decimal[options.locale] : ".", "])?[0-9]+$")).test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsNumberString.js
function isNumberString(value, options) {
  return typeof value === "string" && (0, import_isNumeric.default)(value, options);
}
function IsNumberString(options, validationOptions) {
  return ValidateBy({
    name: IS_NUMBER_STRING,
    constraints: [options],
    validator: {
      validate: function(value, args) {
        return isNumberString(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a number string";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isNumeric, IS_NUMBER_STRING;
var init_IsNumberString = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsNumberString.js"() {
    init_ValidateBy();
    import_isNumeric = __toESM(require_isNumeric());
    IS_NUMBER_STRING = "isNumberString";
  }
});

// node_modules/validator/lib/isBase32.js
var require_isBase32 = __commonJS({
  "node_modules/validator/lib/isBase32.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBase322;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var base32 = /^[A-Z2-7]+=*$/;
    var crockfordBase32 = /^[A-HJKMNP-TV-Z0-9]+$/;
    var defaultBase32Options = {
      crockford: false
    };
    function isBase322(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, defaultBase32Options);
      if (options.crockford) {
        return crockfordBase32.test(str);
      }
      var len = str.length;
      if (len % 8 === 0 && base32.test(str)) {
        return true;
      }
      return false;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsBase32.js
function isBase32(value) {
  return typeof value === "string" && (0, import_isBase32.default)(value);
}
function IsBase32(validationOptions) {
  return ValidateBy({
    name: IS_BASE32,
    validator: {
      validate: function(value, args) {
        return isBase32(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be base32 encoded";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isBase32, IS_BASE32;
var init_IsBase32 = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsBase32.js"() {
    init_ValidateBy();
    import_isBase32 = __toESM(require_isBase32());
    IS_BASE32 = "isBase32";
  }
});

// node_modules/validator/lib/isBIC.js
var require_isBIC = __commonJS({
  "node_modules/validator/lib/isBIC.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBIC2;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isISO31661Alpha = require_isISO31661Alpha2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isBICReg = /^[A-Za-z]{6}[A-Za-z0-9]{2}([A-Za-z0-9]{3})?$/;
    function isBIC2(str) {
      (0, _assertString.default)(str);
      var countryCode = str.slice(4, 6).toUpperCase();
      if (!_isISO31661Alpha.CountryCodes.has(countryCode) && countryCode !== "XK") {
        return false;
      }
      return isBICReg.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsBIC.js
function isBIC(value) {
  return typeof value === "string" && (0, import_isBIC.default)(value);
}
function IsBIC(validationOptions) {
  return ValidateBy({
    name: IS_BIC,
    validator: {
      validate: function(value, args) {
        return isBIC(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a BIC or SWIFT code";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isBIC, IS_BIC;
var init_IsBIC = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsBIC.js"() {
    init_ValidateBy();
    import_isBIC = __toESM(require_isBIC());
    IS_BIC = "isBIC";
  }
});

// node_modules/validator/lib/isBtcAddress.js
var require_isBtcAddress = __commonJS({
  "node_modules/validator/lib/isBtcAddress.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBtcAddress2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var bech32 = /^(bc1)[a-z0-9]{25,39}$/;
    var base58 = /^(1|3)[A-HJ-NP-Za-km-z1-9]{25,39}$/;
    function isBtcAddress2(str) {
      (0, _assertString.default)(str);
      return bech32.test(str) || base58.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsBtcAddress.js
function isBtcAddress(value) {
  return typeof value === "string" && (0, import_isBtcAddress.default)(value);
}
function IsBtcAddress(validationOptions) {
  return ValidateBy({
    name: IS_BTC_ADDRESS,
    validator: {
      validate: function(value, args) {
        return isBtcAddress(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a BTC address";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isBtcAddress, IS_BTC_ADDRESS;
var init_IsBtcAddress = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsBtcAddress.js"() {
    init_ValidateBy();
    import_isBtcAddress = __toESM(require_isBtcAddress());
    IS_BTC_ADDRESS = "isBtcAddress";
  }
});

// node_modules/validator/lib/isDataURI.js
var require_isDataURI = __commonJS({
  "node_modules/validator/lib/isDataURI.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isDataURI2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var validMediaType = /^[a-z]+\/[a-z0-9\-\+\._]+$/i;
    var validAttribute = /^[a-z\-]+=[a-z0-9\-]+$/i;
    var validData = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;
    function isDataURI2(str) {
      (0, _assertString.default)(str);
      var data = str.split(",");
      if (data.length < 2) {
        return false;
      }
      var attributes = data.shift().trim().split(";");
      var schemeAndMediaType = attributes.shift();
      if (schemeAndMediaType.slice(0, 5) !== "data:") {
        return false;
      }
      var mediaType = schemeAndMediaType.slice(5);
      if (mediaType !== "" && !validMediaType.test(mediaType)) {
        return false;
      }
      for (var i = 0; i < attributes.length; i++) {
        if (!(i === attributes.length - 1 && attributes[i].toLowerCase() === "base64") && !validAttribute.test(attributes[i])) {
          return false;
        }
      }
      for (var _i = 0; _i < data.length; _i++) {
        if (!validData.test(data[_i])) {
          return false;
        }
      }
      return true;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsDataURI.js
function isDataURI(value) {
  return typeof value === "string" && (0, import_isDataURI.default)(value);
}
function IsDataURI(validationOptions) {
  return ValidateBy({
    name: IS_DATA_URI,
    validator: {
      validate: function(value, args) {
        return isDataURI(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a data uri format";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isDataURI, IS_DATA_URI;
var init_IsDataURI = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsDataURI.js"() {
    init_ValidateBy();
    import_isDataURI = __toESM(require_isDataURI());
    IS_DATA_URI = "isDataURI";
  }
});

// node_modules/validator/lib/isEAN.js
var require_isEAN = __commonJS({
  "node_modules/validator/lib/isEAN.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isEAN2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var LENGTH_EAN_8 = 8;
    var LENGTH_EAN_14 = 14;
    var validEanRegex = /^(\d{8}|\d{13}|\d{14})$/;
    function getPositionWeightThroughLengthAndIndex(length2, index) {
      if (length2 === LENGTH_EAN_8 || length2 === LENGTH_EAN_14) {
        return index % 2 === 0 ? 3 : 1;
      }
      return index % 2 === 0 ? 1 : 3;
    }
    function calculateCheckDigit(ean) {
      var checksum = ean.slice(0, -1).split("").map(function(char, index) {
        return Number(char) * getPositionWeightThroughLengthAndIndex(ean.length, index);
      }).reduce(function(acc, partialSum) {
        return acc + partialSum;
      }, 0);
      var remainder = 10 - checksum % 10;
      return remainder < 10 ? remainder : 0;
    }
    function isEAN2(str) {
      (0, _assertString.default)(str);
      var actualCheckDigit = Number(str.slice(-1));
      return validEanRegex.test(str) && actualCheckDigit === calculateCheckDigit(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsEAN.js
function isEAN(value) {
  return typeof value === "string" && (0, import_isEAN.default)(value);
}
function IsEAN(validationOptions) {
  return ValidateBy({
    name: IS_EAN,
    validator: {
      validate: function(value, args) {
        return isEAN(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be an EAN (European Article Number)";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isEAN, IS_EAN;
var init_IsEAN = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsEAN.js"() {
    init_ValidateBy();
    import_isEAN = __toESM(require_isEAN());
    IS_EAN = "isEAN";
  }
});

// node_modules/validator/lib/isEthereumAddress.js
var require_isEthereumAddress = __commonJS({
  "node_modules/validator/lib/isEthereumAddress.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isEthereumAddress2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var eth = /^(0x)[0-9a-f]{40}$/i;
    function isEthereumAddress2(str) {
      (0, _assertString.default)(str);
      return eth.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsEthereumAddress.js
function isEthereumAddress(value) {
  return typeof value === "string" && (0, import_isEthereumAddress.default)(value);
}
function IsEthereumAddress(validationOptions) {
  return ValidateBy({
    name: IS_ETHEREUM_ADDRESS,
    validator: {
      validate: function(value, args) {
        return isEthereumAddress(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be an Ethereum address";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isEthereumAddress, IS_ETHEREUM_ADDRESS;
var init_IsEthereumAddress = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsEthereumAddress.js"() {
    init_ValidateBy();
    import_isEthereumAddress = __toESM(require_isEthereumAddress());
    IS_ETHEREUM_ADDRESS = "isEthereumAddress";
  }
});

// node_modules/validator/lib/isHSL.js
var require_isHSL = __commonJS({
  "node_modules/validator/lib/isHSL.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isHSL2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hslComma = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(,(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}(,((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?))?\)$/i;
    var hslSpace = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(\s(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}\s?(\/\s((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?)\s?)?\)$/i;
    function isHSL2(str) {
      (0, _assertString.default)(str);
      var strippedStr = str.replace(/\s+/g, " ").replace(/\s?(hsla?\(|\)|,)\s?/ig, "$1");
      if (strippedStr.indexOf(",") !== -1) {
        return hslComma.test(strippedStr);
      }
      return hslSpace.test(strippedStr);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsHSL.js
function isHSL(value) {
  return typeof value === "string" && (0, import_isHSL.default)(value);
}
function IsHSL(validationOptions) {
  return ValidateBy({
    name: IS_HSL,
    validator: {
      validate: function(value, args) {
        return isHSL(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a HSL color";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isHSL, IS_HSL;
var init_IsHSL = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsHSL.js"() {
    init_ValidateBy();
    import_isHSL = __toESM(require_isHSL());
    IS_HSL = "isHSL";
  }
});

// node_modules/validator/lib/isIBAN.js
var require_isIBAN = __commonJS({
  "node_modules/validator/lib/isIBAN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isIBAN2;
    exports.locales = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ibanRegexThroughCountryCode = {
      AD: /^(AD[0-9]{2})\d{8}[A-Z0-9]{12}$/,
      AE: /^(AE[0-9]{2})\d{3}\d{16}$/,
      AL: /^(AL[0-9]{2})\d{8}[A-Z0-9]{16}$/,
      AT: /^(AT[0-9]{2})\d{16}$/,
      AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\d{20}$/,
      BA: /^(BA[0-9]{2})\d{16}$/,
      BE: /^(BE[0-9]{2})\d{12}$/,
      BG: /^(BG[0-9]{2})[A-Z]{4}\d{6}[A-Z0-9]{8}$/,
      BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,
      BR: /^(BR[0-9]{2})\d{23}[A-Z]{1}[A-Z0-9]{1}$/,
      BY: /^(BY[0-9]{2})[A-Z0-9]{4}\d{20}$/,
      CH: /^(CH[0-9]{2})\d{5}[A-Z0-9]{12}$/,
      CR: /^(CR[0-9]{2})\d{18}$/,
      CY: /^(CY[0-9]{2})\d{8}[A-Z0-9]{16}$/,
      CZ: /^(CZ[0-9]{2})\d{20}$/,
      DE: /^(DE[0-9]{2})\d{18}$/,
      DK: /^(DK[0-9]{2})\d{14}$/,
      DO: /^(DO[0-9]{2})[A-Z]{4}\d{20}$/,
      EE: /^(EE[0-9]{2})\d{16}$/,
      EG: /^(EG[0-9]{2})\d{25}$/,
      ES: /^(ES[0-9]{2})\d{20}$/,
      FI: /^(FI[0-9]{2})\d{14}$/,
      FO: /^(FO[0-9]{2})\d{14}$/,
      FR: /^(FR[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
      GB: /^(GB[0-9]{2})[A-Z]{4}\d{14}$/,
      GE: /^(GE[0-9]{2})[A-Z0-9]{2}\d{16}$/,
      GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,
      GL: /^(GL[0-9]{2})\d{14}$/,
      GR: /^(GR[0-9]{2})\d{7}[A-Z0-9]{16}$/,
      GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,
      HR: /^(HR[0-9]{2})\d{17}$/,
      HU: /^(HU[0-9]{2})\d{24}$/,
      IE: /^(IE[0-9]{2})[A-Z0-9]{4}\d{14}$/,
      IL: /^(IL[0-9]{2})\d{19}$/,
      IQ: /^(IQ[0-9]{2})[A-Z]{4}\d{15}$/,
      IR: /^(IR[0-9]{2})0\d{2}0\d{18}$/,
      IS: /^(IS[0-9]{2})\d{22}$/,
      IT: /^(IT[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
      JO: /^(JO[0-9]{2})[A-Z]{4}\d{22}$/,
      KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,
      KZ: /^(KZ[0-9]{2})\d{3}[A-Z0-9]{13}$/,
      LB: /^(LB[0-9]{2})\d{4}[A-Z0-9]{20}$/,
      LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,
      LI: /^(LI[0-9]{2})\d{5}[A-Z0-9]{12}$/,
      LT: /^(LT[0-9]{2})\d{16}$/,
      LU: /^(LU[0-9]{2})\d{3}[A-Z0-9]{13}$/,
      LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,
      MC: /^(MC[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
      MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,
      ME: /^(ME[0-9]{2})\d{18}$/,
      MK: /^(MK[0-9]{2})\d{3}[A-Z0-9]{10}\d{2}$/,
      MR: /^(MR[0-9]{2})\d{23}$/,
      MT: /^(MT[0-9]{2})[A-Z]{4}\d{5}[A-Z0-9]{18}$/,
      MU: /^(MU[0-9]{2})[A-Z]{4}\d{19}[A-Z]{3}$/,
      MZ: /^(MZ[0-9]{2})\d{21}$/,
      NL: /^(NL[0-9]{2})[A-Z]{4}\d{10}$/,
      NO: /^(NO[0-9]{2})\d{11}$/,
      PK: /^(PK[0-9]{2})[A-Z0-9]{4}\d{16}$/,
      PL: /^(PL[0-9]{2})\d{24}$/,
      PS: /^(PS[0-9]{2})[A-Z0-9]{4}\d{21}$/,
      PT: /^(PT[0-9]{2})\d{21}$/,
      QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,
      RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,
      RS: /^(RS[0-9]{2})\d{18}$/,
      SA: /^(SA[0-9]{2})\d{2}[A-Z0-9]{18}$/,
      SC: /^(SC[0-9]{2})[A-Z]{4}\d{20}[A-Z]{3}$/,
      SE: /^(SE[0-9]{2})\d{20}$/,
      SI: /^(SI[0-9]{2})\d{15}$/,
      SK: /^(SK[0-9]{2})\d{20}$/,
      SM: /^(SM[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
      SV: /^(SV[0-9]{2})[A-Z0-9]{4}\d{20}$/,
      TL: /^(TL[0-9]{2})\d{19}$/,
      TN: /^(TN[0-9]{2})\d{20}$/,
      TR: /^(TR[0-9]{2})\d{5}[A-Z0-9]{17}$/,
      UA: /^(UA[0-9]{2})\d{6}[A-Z0-9]{19}$/,
      VA: /^(VA[0-9]{2})\d{18}$/,
      VG: /^(VG[0-9]{2})[A-Z0-9]{4}\d{16}$/,
      XK: /^(XK[0-9]{2})\d{16}$/
    };
    function hasValidIbanFormat(str) {
      var strippedStr = str.replace(/[\s\-]+/gi, "").toUpperCase();
      var isoCountryCode = strippedStr.slice(0, 2).toUpperCase();
      return isoCountryCode in ibanRegexThroughCountryCode && ibanRegexThroughCountryCode[isoCountryCode].test(strippedStr);
    }
    function hasValidIbanChecksum(str) {
      var strippedStr = str.replace(/[^A-Z0-9]+/gi, "").toUpperCase();
      var rearranged = strippedStr.slice(4) + strippedStr.slice(0, 4);
      var alphaCapsReplacedWithDigits = rearranged.replace(/[A-Z]/g, function(char) {
        return char.charCodeAt(0) - 55;
      });
      var remainder = alphaCapsReplacedWithDigits.match(/\d{1,7}/g).reduce(function(acc, value) {
        return Number(acc + value) % 97;
      }, "");
      return remainder === 1;
    }
    function isIBAN2(str) {
      (0, _assertString.default)(str);
      return hasValidIbanFormat(str) && hasValidIbanChecksum(str);
    }
    var locales = Object.keys(ibanRegexThroughCountryCode);
    exports.locales = locales;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsIBAN.js
function isIBAN(value) {
  return typeof value === "string" && (0, import_isIBAN.default)(value);
}
function IsIBAN(validationOptions) {
  return ValidateBy({
    name: IS_IBAN,
    validator: {
      validate: function(value, args) {
        return isIBAN(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be an IBAN";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isIBAN, IS_IBAN;
var init_IsIBAN = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsIBAN.js"() {
    init_ValidateBy();
    import_isIBAN = __toESM(require_isIBAN());
    IS_IBAN = "isIBAN";
  }
});

// node_modules/validator/lib/isIdentityCard.js
var require_isIdentityCard = __commonJS({
  "node_modules/validator/lib/isIdentityCard.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isIdentityCard2;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isInt = _interopRequireDefault(require_isInt());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var validators = {
      PL: function PL(str) {
        (0, _assertString.default)(str);
        var weightOfDigits = {
          1: 1,
          2: 3,
          3: 7,
          4: 9,
          5: 1,
          6: 3,
          7: 7,
          8: 9,
          9: 1,
          10: 3,
          11: 0
        };
        if (str != null && str.length === 11 && (0, _isInt.default)(str, {
          allow_leading_zeroes: true
        })) {
          var digits = str.split("").slice(0, -1);
          var sum = digits.reduce(function(acc, digit, index) {
            return acc + Number(digit) * weightOfDigits[index + 1];
          }, 0);
          var modulo = sum % 10;
          var lastDigit = Number(str.charAt(str.length - 1));
          if (modulo === 0 && lastDigit === 0 || lastDigit === 10 - modulo) {
            return true;
          }
        }
        return false;
      },
      ES: function ES(str) {
        (0, _assertString.default)(str);
        var DNI = /^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/;
        var charsValue = {
          X: 0,
          Y: 1,
          Z: 2
        };
        var controlDigits = ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"];
        var sanitized = str.trim().toUpperCase();
        if (!DNI.test(sanitized)) {
          return false;
        }
        var number = sanitized.slice(0, -1).replace(/[X,Y,Z]/g, function(char) {
          return charsValue[char];
        });
        return sanitized.endsWith(controlDigits[number % 23]);
      },
      FI: function FI(str) {
        (0, _assertString.default)(str);
        if (str.length !== 11) {
          return false;
        }
        if (!str.match(/^\d{6}[\-A\+]\d{3}[0-9ABCDEFHJKLMNPRSTUVWXY]{1}$/)) {
          return false;
        }
        var checkDigits = "0123456789ABCDEFHJKLMNPRSTUVWXY";
        var idAsNumber = parseInt(str.slice(0, 6), 10) * 1e3 + parseInt(str.slice(7, 10), 10);
        var remainder = idAsNumber % 31;
        var checkDigit = checkDigits[remainder];
        return checkDigit === str.slice(10, 11);
      },
      IN: function IN(str) {
        var DNI = /^[1-9]\d{3}\s?\d{4}\s?\d{4}$/;
        var d = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];
        var p = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];
        var sanitized = str.trim();
        if (!DNI.test(sanitized)) {
          return false;
        }
        var c = 0;
        var invertedArray = sanitized.replace(/\s/g, "").split("").map(Number).reverse();
        invertedArray.forEach(function(val, i) {
          c = d[c][p[i % 8][val]];
        });
        return c === 0;
      },
      IR: function IR(str) {
        if (!str.match(/^\d{10}$/))
          return false;
        str = "0000".concat(str).slice(str.length - 6);
        if (parseInt(str.slice(3, 9), 10) === 0)
          return false;
        var lastNumber = parseInt(str.slice(9, 10), 10);
        var sum = 0;
        for (var i = 0; i < 9; i++) {
          sum += parseInt(str.slice(i, i + 1), 10) * (10 - i);
        }
        sum %= 11;
        return sum < 2 && lastNumber === sum || sum >= 2 && lastNumber === 11 - sum;
      },
      IT: function IT(str) {
        if (str.length !== 9)
          return false;
        if (str === "CA00000AA")
          return false;
        return str.search(/C[A-Z][0-9]{5}[A-Z]{2}/i) > -1;
      },
      NO: function NO(str) {
        var sanitized = str.trim();
        if (isNaN(Number(sanitized)))
          return false;
        if (sanitized.length !== 11)
          return false;
        if (sanitized === "00000000000")
          return false;
        var f2 = sanitized.split("").map(Number);
        var k1 = (11 - (3 * f2[0] + 7 * f2[1] + 6 * f2[2] + 1 * f2[3] + 8 * f2[4] + 9 * f2[5] + 4 * f2[6] + 5 * f2[7] + 2 * f2[8]) % 11) % 11;
        var k2 = (11 - (5 * f2[0] + 4 * f2[1] + 3 * f2[2] + 2 * f2[3] + 7 * f2[4] + 6 * f2[5] + 5 * f2[6] + 4 * f2[7] + 3 * f2[8] + 2 * k1) % 11) % 11;
        if (k1 !== f2[9] || k2 !== f2[10])
          return false;
        return true;
      },
      TH: function TH(str) {
        if (!str.match(/^[1-8]\d{12}$/))
          return false;
        var sum = 0;
        for (var i = 0; i < 12; i++) {
          sum += parseInt(str[i], 10) * (13 - i);
        }
        return str[12] === ((11 - sum % 11) % 10).toString();
      },
      LK: function LK(str) {
        var old_nic = /^[1-9]\d{8}[vx]$/i;
        var new_nic = /^[1-9]\d{11}$/i;
        if (str.length === 10 && old_nic.test(str))
          return true;
        else if (str.length === 12 && new_nic.test(str))
          return true;
        return false;
      },
      "he-IL": function heIL(str) {
        var DNI = /^\d{9}$/;
        var sanitized = str.trim();
        if (!DNI.test(sanitized)) {
          return false;
        }
        var id = sanitized;
        var sum = 0, incNum;
        for (var i = 0; i < id.length; i++) {
          incNum = Number(id[i]) * (i % 2 + 1);
          sum += incNum > 9 ? incNum - 9 : incNum;
        }
        return sum % 10 === 0;
      },
      "ar-LY": function arLY(str) {
        var NIN = /^(1|2)\d{11}$/;
        var sanitized = str.trim();
        if (!NIN.test(sanitized)) {
          return false;
        }
        return true;
      },
      "ar-TN": function arTN(str) {
        var DNI = /^\d{8}$/;
        var sanitized = str.trim();
        if (!DNI.test(sanitized)) {
          return false;
        }
        return true;
      },
      "zh-CN": function zhCN(str) {
        var provincesAndCities = [
          "11",
          // 北京
          "12",
          // 天津
          "13",
          // 河北
          "14",
          // 山西
          "15",
          // 内蒙古
          "21",
          // 辽宁
          "22",
          // 吉林
          "23",
          // 黑龙江
          "31",
          // 上海
          "32",
          // 江苏
          "33",
          // 浙江
          "34",
          // 安徽
          "35",
          // 福建
          "36",
          // 江西
          "37",
          // 山东
          "41",
          // 河南
          "42",
          // 湖北
          "43",
          // 湖南
          "44",
          // 广东
          "45",
          // 广西
          "46",
          // 海南
          "50",
          // 重庆
          "51",
          // 四川
          "52",
          // 贵州
          "53",
          // 云南
          "54",
          // 西藏
          "61",
          // 陕西
          "62",
          // 甘肃
          "63",
          // 青海
          "64",
          // 宁夏
          "65",
          // 新疆
          "71",
          // 台湾
          "81",
          // 香港
          "82",
          // 澳门
          "91"
          // 国外
        ];
        var powers = ["7", "9", "10", "5", "8", "4", "2", "1", "6", "3", "7", "9", "10", "5", "8", "4", "2"];
        var parityBit = ["1", "0", "X", "9", "8", "7", "6", "5", "4", "3", "2"];
        var checkAddressCode = function checkAddressCode2(addressCode) {
          return provincesAndCities.includes(addressCode);
        };
        var checkBirthDayCode = function checkBirthDayCode2(birDayCode) {
          var yyyy = parseInt(birDayCode.substring(0, 4), 10);
          var mm = parseInt(birDayCode.substring(4, 6), 10);
          var dd = parseInt(birDayCode.substring(6), 10);
          var xdata = new Date(yyyy, mm - 1, dd);
          if (xdata > /* @__PURE__ */ new Date()) {
            return false;
          } else if (xdata.getFullYear() === yyyy && xdata.getMonth() === mm - 1 && xdata.getDate() === dd) {
            return true;
          }
          return false;
        };
        var getParityBit = function getParityBit2(idCardNo) {
          var id17 = idCardNo.substring(0, 17);
          var power = 0;
          for (var i = 0; i < 17; i++) {
            power += parseInt(id17.charAt(i), 10) * parseInt(powers[i], 10);
          }
          var mod = power % 11;
          return parityBit[mod];
        };
        var checkParityBit = function checkParityBit2(idCardNo) {
          return getParityBit(idCardNo) === idCardNo.charAt(17).toUpperCase();
        };
        var check15IdCardNo = function check15IdCardNo2(idCardNo) {
          var check = /^[1-9]\d{7}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}$/.test(idCardNo);
          if (!check)
            return false;
          var addressCode = idCardNo.substring(0, 2);
          check = checkAddressCode(addressCode);
          if (!check)
            return false;
          var birDayCode = "19".concat(idCardNo.substring(6, 12));
          check = checkBirthDayCode(birDayCode);
          if (!check)
            return false;
          return true;
        };
        var check18IdCardNo = function check18IdCardNo2(idCardNo) {
          var check = /^[1-9]\d{5}[1-9]\d{3}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}(\d|x|X)$/.test(idCardNo);
          if (!check)
            return false;
          var addressCode = idCardNo.substring(0, 2);
          check = checkAddressCode(addressCode);
          if (!check)
            return false;
          var birDayCode = idCardNo.substring(6, 14);
          check = checkBirthDayCode(birDayCode);
          if (!check)
            return false;
          return checkParityBit(idCardNo);
        };
        var checkIdCardNo = function checkIdCardNo2(idCardNo) {
          var check = /^\d{15}|(\d{17}(\d|x|X))$/.test(idCardNo);
          if (!check)
            return false;
          if (idCardNo.length === 15) {
            return check15IdCardNo(idCardNo);
          }
          return check18IdCardNo(idCardNo);
        };
        return checkIdCardNo(str);
      },
      "zh-HK": function zhHK(str) {
        str = str.trim();
        var regexHKID = /^[A-Z]{1,2}[0-9]{6}((\([0-9A]\))|(\[[0-9A]\])|([0-9A]))$/;
        var regexIsDigit = /^[0-9]$/;
        str = str.toUpperCase();
        if (!regexHKID.test(str))
          return false;
        str = str.replace(/\[|\]|\(|\)/g, "");
        if (str.length === 8)
          str = "3".concat(str);
        var checkSumVal = 0;
        for (var i = 0; i <= 7; i++) {
          var convertedChar = void 0;
          if (!regexIsDigit.test(str[i]))
            convertedChar = (str[i].charCodeAt(0) - 55) % 11;
          else
            convertedChar = str[i];
          checkSumVal += convertedChar * (9 - i);
        }
        checkSumVal %= 11;
        var checkSumConverted;
        if (checkSumVal === 0)
          checkSumConverted = "0";
        else if (checkSumVal === 1)
          checkSumConverted = "A";
        else
          checkSumConverted = String(11 - checkSumVal);
        if (checkSumConverted === str[str.length - 1])
          return true;
        return false;
      },
      "zh-TW": function zhTW(str) {
        var ALPHABET_CODES = {
          A: 10,
          B: 11,
          C: 12,
          D: 13,
          E: 14,
          F: 15,
          G: 16,
          H: 17,
          I: 34,
          J: 18,
          K: 19,
          L: 20,
          M: 21,
          N: 22,
          O: 35,
          P: 23,
          Q: 24,
          R: 25,
          S: 26,
          T: 27,
          U: 28,
          V: 29,
          W: 32,
          X: 30,
          Y: 31,
          Z: 33
        };
        var sanitized = str.trim().toUpperCase();
        if (!/^[A-Z][0-9]{9}$/.test(sanitized))
          return false;
        return Array.from(sanitized).reduce(function(sum, number, index) {
          if (index === 0) {
            var code = ALPHABET_CODES[number];
            return code % 10 * 9 + Math.floor(code / 10);
          }
          if (index === 9) {
            return (10 - sum % 10 - Number(number)) % 10 === 0;
          }
          return sum + Number(number) * (9 - index);
        }, 0);
      }
    };
    function isIdentityCard2(str, locale) {
      (0, _assertString.default)(str);
      if (locale in validators) {
        return validators[locale](str);
      } else if (locale === "any") {
        for (var key in validators) {
          if (validators.hasOwnProperty(key)) {
            var validator = validators[key];
            if (validator(str)) {
              return true;
            }
          }
        }
        return false;
      }
      throw new Error("Invalid locale '".concat(locale, "'"));
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsIdentityCard.js
function isIdentityCard(value, locale) {
  return typeof value === "string" && (0, import_isIdentityCard.default)(value, locale);
}
function IsIdentityCard(locale, validationOptions) {
  return ValidateBy({
    name: IS_IDENTITY_CARD,
    constraints: [locale],
    validator: {
      validate: function(value, args) {
        return isIdentityCard(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a identity card number";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isIdentityCard, IS_IDENTITY_CARD;
var init_IsIdentityCard = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsIdentityCard.js"() {
    init_ValidateBy();
    import_isIdentityCard = __toESM(require_isIdentityCard());
    IS_IDENTITY_CARD = "isIdentityCard";
  }
});

// node_modules/validator/lib/isISRC.js
var require_isISRC = __commonJS({
  "node_modules/validator/lib/isISRC.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isISRC2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isrc = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
    function isISRC2(str) {
      (0, _assertString.default)(str);
      return isrc.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsISRC.js
function isISRC(value) {
  return typeof value === "string" && (0, import_isISRC.default)(value);
}
function IsISRC(validationOptions) {
  return ValidateBy({
    name: IS_ISRC,
    validator: {
      validate: function(value, args) {
        return isISRC(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be an ISRC";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isISRC, IS_ISRC;
var init_IsISRC = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsISRC.js"() {
    init_ValidateBy();
    import_isISRC = __toESM(require_isISRC());
    IS_ISRC = "isISRC";
  }
});

// node_modules/validator/lib/isLocale.js
var require_isLocale = __commonJS({
  "node_modules/validator/lib/isLocale.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isLocale2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var localeReg = /^[A-Za-z]{2,4}([_-]([A-Za-z]{4}|[\d]{3}))?([_-]([A-Za-z]{2}|[\d]{3}))?$/;
    function isLocale2(str) {
      (0, _assertString.default)(str);
      if (str === "en_US_POSIX" || str === "ca_ES_VALENCIA") {
        return true;
      }
      return localeReg.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsLocale.js
function isLocale(value) {
  return typeof value === "string" && (0, import_isLocale.default)(value);
}
function IsLocale(validationOptions) {
  return ValidateBy({
    name: IS_LOCALE,
    validator: {
      validate: function(value, args) {
        return isLocale(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be locale";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isLocale, IS_LOCALE;
var init_IsLocale = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsLocale.js"() {
    init_ValidateBy();
    import_isLocale = __toESM(require_isLocale());
    IS_LOCALE = "isLocale";
  }
});

// node_modules/validator/lib/isMagnetURI.js
var require_isMagnetURI = __commonJS({
  "node_modules/validator/lib/isMagnetURI.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isMagnetURI2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var magnetURIComponent = /(?:^magnet:\?|[^?&]&)xt(?:\.1)?=urn:(?:(?:aich|bitprint|btih|ed2k|ed2khash|kzhash|md5|sha1|tree:tiger):[a-z0-9]{32}(?:[a-z0-9]{8})?|btmh:1220[a-z0-9]{64})(?:$|&)/i;
    function isMagnetURI2(url) {
      (0, _assertString.default)(url);
      if (url.indexOf("magnet:?") !== 0) {
        return false;
      }
      return magnetURIComponent.test(url);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsMagnetURI.js
function isMagnetURI(value) {
  return typeof value === "string" && (0, import_isMagnetURI.default)(value);
}
function IsMagnetURI(validationOptions) {
  return ValidateBy({
    name: IS_MAGNET_URI,
    validator: {
      validate: function(value, args) {
        return isMagnetURI(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be magnet uri format";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isMagnetURI, IS_MAGNET_URI;
var init_IsMagnetURI = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsMagnetURI.js"() {
    init_ValidateBy();
    import_isMagnetURI = __toESM(require_isMagnetURI());
    IS_MAGNET_URI = "isMagnetURI";
  }
});

// node_modules/validator/lib/isMimeType.js
var require_isMimeType = __commonJS({
  "node_modules/validator/lib/isMimeType.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isMimeType2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var mimeTypeSimple = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+_]{1,100}$/i;
    var mimeTypeText = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i;
    var mimeTypeMultipart = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i;
    function isMimeType2(str) {
      (0, _assertString.default)(str);
      return mimeTypeSimple.test(str) || mimeTypeText.test(str) || mimeTypeMultipart.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsMimeType.js
function isMimeType(value) {
  return typeof value === "string" && (0, import_isMimeType.default)(value);
}
function IsMimeType(validationOptions) {
  return ValidateBy({
    name: IS_MIME_TYPE,
    validator: {
      validate: function(value, args) {
        return isMimeType(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be MIME type format";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isMimeType, IS_MIME_TYPE;
var init_IsMimeType = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsMimeType.js"() {
    init_ValidateBy();
    import_isMimeType = __toESM(require_isMimeType());
    IS_MIME_TYPE = "isMimeType";
  }
});

// node_modules/validator/lib/isOctal.js
var require_isOctal = __commonJS({
  "node_modules/validator/lib/isOctal.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isOctal2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var octal = /^(0o)?[0-7]+$/i;
    function isOctal2(str) {
      (0, _assertString.default)(str);
      return octal.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsOctal.js
function isOctal(value) {
  return typeof value === "string" && (0, import_isOctal.default)(value);
}
function IsOctal(validationOptions) {
  return ValidateBy({
    name: IS_OCTAL,
    validator: {
      validate: function(value, args) {
        return isOctal(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be valid octal number";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isOctal, IS_OCTAL;
var init_IsOctal = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsOctal.js"() {
    init_ValidateBy();
    import_isOctal = __toESM(require_isOctal());
    IS_OCTAL = "isOctal";
  }
});

// node_modules/validator/lib/isPassportNumber.js
var require_isPassportNumber = __commonJS({
  "node_modules/validator/lib/isPassportNumber.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isPassportNumber2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var passportRegexByCountryCode = {
      AM: /^[A-Z]{2}\d{7}$/,
      // ARMENIA
      AR: /^[A-Z]{3}\d{6}$/,
      // ARGENTINA
      AT: /^[A-Z]\d{7}$/,
      // AUSTRIA
      AU: /^[A-Z]\d{7}$/,
      // AUSTRALIA
      AZ: /^[A-Z]{2,3}\d{7,8}$/,
      // AZERBAIJAN
      BE: /^[A-Z]{2}\d{6}$/,
      // BELGIUM
      BG: /^\d{9}$/,
      // BULGARIA
      BR: /^[A-Z]{2}\d{6}$/,
      // BRAZIL
      BY: /^[A-Z]{2}\d{7}$/,
      // BELARUS
      CA: /^[A-Z]{2}\d{6}$/,
      // CANADA
      CH: /^[A-Z]\d{7}$/,
      // SWITZERLAND
      CN: /^G\d{8}$|^E(?![IO])[A-Z0-9]\d{7}$/,
      // CHINA [G=Ordinary, E=Electronic] followed by 8-digits, or E followed by any UPPERCASE letter (except I and O) followed by 7 digits
      CY: /^[A-Z](\d{6}|\d{8})$/,
      // CYPRUS
      CZ: /^\d{8}$/,
      // CZECH REPUBLIC
      DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/,
      // GERMANY
      DK: /^\d{9}$/,
      // DENMARK
      DZ: /^\d{9}$/,
      // ALGERIA
      EE: /^([A-Z]\d{7}|[A-Z]{2}\d{7})$/,
      // ESTONIA (K followed by 7-digits), e-passports have 2 UPPERCASE followed by 7 digits
      ES: /^[A-Z0-9]{2}([A-Z0-9]?)\d{6}$/,
      // SPAIN
      FI: /^[A-Z]{2}\d{7}$/,
      // FINLAND
      FR: /^\d{2}[A-Z]{2}\d{5}$/,
      // FRANCE
      GB: /^\d{9}$/,
      // UNITED KINGDOM
      GR: /^[A-Z]{2}\d{7}$/,
      // GREECE
      HR: /^\d{9}$/,
      // CROATIA
      HU: /^[A-Z]{2}(\d{6}|\d{7})$/,
      // HUNGARY
      IE: /^[A-Z0-9]{2}\d{7}$/,
      // IRELAND
      IN: /^[A-Z]{1}-?\d{7}$/,
      // INDIA
      ID: /^[A-C]\d{7}$/,
      // INDONESIA
      IR: /^[A-Z]\d{8}$/,
      // IRAN
      IS: /^(A)\d{7}$/,
      // ICELAND
      IT: /^[A-Z0-9]{2}\d{7}$/,
      // ITALY
      JM: /^[Aa]\d{7}$/,
      // JAMAICA
      JP: /^[A-Z]{2}\d{7}$/,
      // JAPAN
      KR: /^[MS]\d{8}$/,
      // SOUTH KOREA, REPUBLIC OF KOREA, [S=PS Passports, M=PM Passports]
      KZ: /^[a-zA-Z]\d{7}$/,
      // KAZAKHSTAN
      LI: /^[a-zA-Z]\d{5}$/,
      // LIECHTENSTEIN
      LT: /^[A-Z0-9]{8}$/,
      // LITHUANIA
      LU: /^[A-Z0-9]{8}$/,
      // LUXEMBURG
      LV: /^[A-Z0-9]{2}\d{7}$/,
      // LATVIA
      LY: /^[A-Z0-9]{8}$/,
      // LIBYA
      MT: /^\d{7}$/,
      // MALTA
      MZ: /^([A-Z]{2}\d{7})|(\d{2}[A-Z]{2}\d{5})$/,
      // MOZAMBIQUE
      MY: /^[AHK]\d{8}$/,
      // MALAYSIA
      MX: /^\d{10,11}$/,
      // MEXICO
      NL: /^[A-Z]{2}[A-Z0-9]{6}\d$/,
      // NETHERLANDS
      NZ: /^([Ll]([Aa]|[Dd]|[Ff]|[Hh])|[Ee]([Aa]|[Pp])|[Nn])\d{6}$/,
      // NEW ZEALAND
      PH: /^([A-Z](\d{6}|\d{7}[A-Z]))|([A-Z]{2}(\d{6}|\d{7}))$/,
      // PHILIPPINES
      PK: /^[A-Z]{2}\d{7}$/,
      // PAKISTAN
      PL: /^[A-Z]{2}\d{7}$/,
      // POLAND
      PT: /^[A-Z]\d{6}$/,
      // PORTUGAL
      RO: /^\d{8,9}$/,
      // ROMANIA
      RU: /^\d{9}$/,
      // RUSSIAN FEDERATION
      SE: /^\d{8}$/,
      // SWEDEN
      SL: /^(P)[A-Z]\d{7}$/,
      // SLOVENIA
      SK: /^[0-9A-Z]\d{7}$/,
      // SLOVAKIA
      TH: /^[A-Z]{1,2}\d{6,7}$/,
      // THAILAND
      TR: /^[A-Z]\d{8}$/,
      // TURKEY
      UA: /^[A-Z]{2}\d{6}$/,
      // UKRAINE
      US: /^\d{9}$/
      // UNITED STATES
    };
    function isPassportNumber2(str, countryCode) {
      (0, _assertString.default)(str);
      var normalizedStr = str.replace(/\s/g, "").toUpperCase();
      return countryCode.toUpperCase() in passportRegexByCountryCode && passportRegexByCountryCode[countryCode].test(normalizedStr);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsPassportNumber.js
function isPassportNumber(value, countryCode) {
  return typeof value === "string" && (0, import_isPassportNumber.default)(value, countryCode);
}
function IsPassportNumber(countryCode, validationOptions) {
  return ValidateBy({
    name: IS_PASSPORT_NUMBER,
    constraints: [countryCode],
    validator: {
      validate: function(value, args) {
        return isPassportNumber(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be valid passport number";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isPassportNumber, IS_PASSPORT_NUMBER;
var init_IsPassportNumber = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsPassportNumber.js"() {
    init_ValidateBy();
    import_isPassportNumber = __toESM(require_isPassportNumber());
    IS_PASSPORT_NUMBER = "isPassportNumber";
  }
});

// node_modules/validator/lib/isPostalCode.js
var require_isPostalCode = __commonJS({
  "node_modules/validator/lib/isPostalCode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isPostalCode2;
    exports.locales = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var threeDigit = /^\d{3}$/;
    var fourDigit = /^\d{4}$/;
    var fiveDigit = /^\d{5}$/;
    var sixDigit = /^\d{6}$/;
    var patterns = {
      AD: /^AD\d{3}$/,
      AT: fourDigit,
      AU: fourDigit,
      AZ: /^AZ\d{4}$/,
      BA: /^([7-8]\d{4}$)/,
      BE: fourDigit,
      BG: fourDigit,
      BR: /^\d{5}-\d{3}$/,
      BY: /^2[1-4]\d{4}$/,
      CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
      CH: fourDigit,
      CN: /^(0[1-7]|1[012356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[1-5]|8[1345]|9[09])\d{4}$/,
      CZ: /^\d{3}\s?\d{2}$/,
      DE: fiveDigit,
      DK: fourDigit,
      DO: fiveDigit,
      DZ: fiveDigit,
      EE: fiveDigit,
      ES: /^(5[0-2]{1}|[0-4]{1}\d{1})\d{3}$/,
      FI: fiveDigit,
      FR: /^\d{2}\s?\d{3}$/,
      GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
      GR: /^\d{3}\s?\d{2}$/,
      HR: /^([1-5]\d{4}$)/,
      HT: /^HT\d{4}$/,
      HU: fourDigit,
      ID: fiveDigit,
      IE: /^(?!.*(?:o))[A-Za-z]\d[\dw]\s\w{4}$/i,
      IL: /^(\d{5}|\d{7})$/,
      IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/,
      IR: /^(?!(\d)\1{3})[13-9]{4}[1346-9][013-9]{5}$/,
      IS: threeDigit,
      IT: fiveDigit,
      JP: /^\d{3}\-\d{4}$/,
      KE: fiveDigit,
      KR: /^(\d{5}|\d{6})$/,
      LI: /^(948[5-9]|949[0-7])$/,
      LT: /^LT\-\d{5}$/,
      LU: fourDigit,
      LV: /^LV\-\d{4}$/,
      LK: fiveDigit,
      MG: threeDigit,
      MX: fiveDigit,
      MT: /^[A-Za-z]{3}\s{0,1}\d{4}$/,
      MY: fiveDigit,
      NL: /^\d{4}\s?[a-z]{2}$/i,
      NO: fourDigit,
      NP: /^(10|21|22|32|33|34|44|45|56|57)\d{3}$|^(977)$/i,
      NZ: fourDigit,
      PL: /^\d{2}\-\d{3}$/,
      PR: /^00[679]\d{2}([ -]\d{4})?$/,
      PT: /^\d{4}\-\d{3}?$/,
      RO: sixDigit,
      RU: sixDigit,
      SA: fiveDigit,
      SE: /^[1-9]\d{2}\s?\d{2}$/,
      SG: sixDigit,
      SI: fourDigit,
      SK: /^\d{3}\s?\d{2}$/,
      TH: fiveDigit,
      TN: fourDigit,
      TW: /^\d{3}(\d{2})?$/,
      UA: fiveDigit,
      US: /^\d{5}(-\d{4})?$/,
      ZA: fourDigit,
      ZM: fiveDigit
    };
    var locales = Object.keys(patterns);
    exports.locales = locales;
    function isPostalCode2(str, locale) {
      (0, _assertString.default)(str);
      if (locale in patterns) {
        return patterns[locale].test(str);
      } else if (locale === "any") {
        for (var key in patterns) {
          if (patterns.hasOwnProperty(key)) {
            var pattern = patterns[key];
            if (pattern.test(str)) {
              return true;
            }
          }
        }
        return false;
      }
      throw new Error("Invalid locale '".concat(locale, "'"));
    }
  }
});

// node_modules/class-validator/esm5/decorator/string/IsPostalCode.js
function isPostalCode(value, locale) {
  return typeof value === "string" && (0, import_isPostalCode.default)(value, locale);
}
function IsPostalCode(locale, validationOptions) {
  return ValidateBy({
    name: IS_POSTAL_CODE,
    constraints: [locale],
    validator: {
      validate: function(value, args) {
        return isPostalCode(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a postal code";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isPostalCode, IS_POSTAL_CODE;
var init_IsPostalCode = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsPostalCode.js"() {
    init_ValidateBy();
    import_isPostalCode = __toESM(require_isPostalCode());
    IS_POSTAL_CODE = "isPostalCode";
  }
});

// node_modules/validator/lib/isRFC3339.js
var require_isRFC3339 = __commonJS({
  "node_modules/validator/lib/isRFC3339.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isRFC33392;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var dateFullYear = /[0-9]{4}/;
    var dateMonth = /(0[1-9]|1[0-2])/;
    var dateMDay = /([12]\d|0[1-9]|3[01])/;
    var timeHour = /([01][0-9]|2[0-3])/;
    var timeMinute = /[0-5][0-9]/;
    var timeSecond = /([0-5][0-9]|60)/;
    var timeSecFrac = /(\.[0-9]+)?/;
    var timeNumOffset = new RegExp("[-+]".concat(timeHour.source, ":").concat(timeMinute.source));
    var timeOffset = new RegExp("([zZ]|".concat(timeNumOffset.source, ")"));
    var partialTime = new RegExp("".concat(timeHour.source, ":").concat(timeMinute.source, ":").concat(timeSecond.source).concat(timeSecFrac.source));
    var fullDate = new RegExp("".concat(dateFullYear.source, "-").concat(dateMonth.source, "-").concat(dateMDay.source));
    var fullTime = new RegExp("".concat(partialTime.source).concat(timeOffset.source));
    var rfc3339 = new RegExp("^".concat(fullDate.source, "[ tT]").concat(fullTime.source, "$"));
    function isRFC33392(str) {
      (0, _assertString.default)(str);
      return rfc3339.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsRFC3339.js
function isRFC3339(value) {
  return typeof value === "string" && (0, import_isRFC3339.default)(value);
}
function IsRFC3339(validationOptions) {
  return ValidateBy({
    name: IS_RFC_3339,
    validator: {
      validate: function(value, args) {
        return isRFC3339(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be RFC 3339 date";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isRFC3339, IS_RFC_3339;
var init_IsRFC3339 = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsRFC3339.js"() {
    init_ValidateBy();
    import_isRFC3339 = __toESM(require_isRFC3339());
    IS_RFC_3339 = "isRFC3339";
  }
});

// node_modules/validator/lib/isRgbColor.js
var require_isRgbColor = __commonJS({
  "node_modules/validator/lib/isRgbColor.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isRgbColor2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var rgbColor = /^rgb\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\)$/;
    var rgbaColor = /^rgba\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
    var rgbColorPercent = /^rgb\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\)$/;
    var rgbaColorPercent = /^rgba\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
    function isRgbColor2(str) {
      var includePercentValues = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      (0, _assertString.default)(str);
      if (!includePercentValues) {
        return rgbColor.test(str) || rgbaColor.test(str);
      }
      return rgbColor.test(str) || rgbaColor.test(str) || rgbColorPercent.test(str) || rgbaColorPercent.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsRgbColor.js
function isRgbColor(value, includePercentValues) {
  return typeof value === "string" && (0, import_isRgbColor.default)(value, includePercentValues);
}
function IsRgbColor(includePercentValues, validationOptions) {
  return ValidateBy({
    name: IS_RGB_COLOR,
    constraints: [includePercentValues],
    validator: {
      validate: function(value, args) {
        return isRgbColor(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be RGB color";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isRgbColor, IS_RGB_COLOR;
var init_IsRgbColor = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsRgbColor.js"() {
    init_ValidateBy();
    import_isRgbColor = __toESM(require_isRgbColor());
    IS_RGB_COLOR = "isRgbColor";
  }
});

// node_modules/validator/lib/util/multilineRegex.js
var require_multilineRegex = __commonJS({
  "node_modules/validator/lib/util/multilineRegex.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = multilineRegexp;
    function multilineRegexp(parts, flags) {
      var regexpAsStringLiteral = parts.join("");
      return new RegExp(regexpAsStringLiteral, flags);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isSemVer.js
var require_isSemVer = __commonJS({
  "node_modules/validator/lib/isSemVer.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isSemVer2;
    var _assertString = _interopRequireDefault(require_assertString());
    var _multilineRegex = _interopRequireDefault(require_multilineRegex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var semanticVersioningRegex = (0, _multilineRegex.default)(["^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)", "(?:-((?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*))*))", "?(?:\\+([0-9a-z-]+(?:\\.[0-9a-z-]+)*))?$"], "i");
    function isSemVer2(str) {
      (0, _assertString.default)(str);
      return semanticVersioningRegex.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/class-validator/esm5/decorator/string/IsSemVer.js
function isSemVer(value) {
  return typeof value === "string" && (0, import_isSemVer.default)(value);
}
function IsSemVer(validationOptions) {
  return ValidateBy({
    name: IS_SEM_VER,
    validator: {
      validate: function(value, args) {
        return isSemVer(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a Semantic Versioning Specification";
      }, validationOptions)
    }
  }, validationOptions);
}
var import_isSemVer, IS_SEM_VER;
var init_IsSemVer = __esm({
  "node_modules/class-validator/esm5/decorator/string/IsSemVer.js"() {
    init_ValidateBy();
    import_isSemVer = __toESM(require_isSemVer());
    IS_SEM_VER = "isSemVer";
  }
});

// node_modules/class-validator/esm5/decorator/typechecker/IsBoolean.js
function isBoolean(value) {
  return value instanceof Boolean || typeof value === "boolean";
}
function IsBoolean(validationOptions) {
  return ValidateBy({
    name: IS_BOOLEAN,
    validator: {
      validate: function(value, args) {
        return isBoolean(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a boolean value";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_BOOLEAN;
var init_IsBoolean = __esm({
  "node_modules/class-validator/esm5/decorator/typechecker/IsBoolean.js"() {
    init_ValidateBy();
    IS_BOOLEAN = "isBoolean";
  }
});

// node_modules/class-validator/esm5/decorator/typechecker/IsDate.js
function isDate(value) {
  return value instanceof Date && !isNaN(value.getTime());
}
function IsDate(validationOptions) {
  return ValidateBy({
    name: IS_DATE,
    validator: {
      validate: function(value, args) {
        return isDate(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a Date instance";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_DATE;
var init_IsDate = __esm({
  "node_modules/class-validator/esm5/decorator/typechecker/IsDate.js"() {
    init_ValidateBy();
    IS_DATE = "isDate";
  }
});

// node_modules/class-validator/esm5/decorator/typechecker/IsNumber.js
function isNumber(value, options) {
  if (options === void 0) {
    options = {};
  }
  if (typeof value !== "number") {
    return false;
  }
  if (value === Infinity || value === -Infinity) {
    return options.allowInfinity;
  }
  if (Number.isNaN(value)) {
    return options.allowNaN;
  }
  if (options.maxDecimalPlaces !== void 0) {
    var decimalPlaces = 0;
    if (value % 1 !== 0) {
      decimalPlaces = value.toString().split(".")[1].length;
    }
    if (decimalPlaces > options.maxDecimalPlaces) {
      return false;
    }
  }
  return Number.isFinite(value);
}
function IsNumber(options, validationOptions) {
  if (options === void 0) {
    options = {};
  }
  return ValidateBy({
    name: IS_NUMBER,
    constraints: [options],
    validator: {
      validate: function(value, args) {
        return isNumber(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a number conforming to the specified constraints";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_NUMBER;
var init_IsNumber = __esm({
  "node_modules/class-validator/esm5/decorator/typechecker/IsNumber.js"() {
    init_ValidateBy();
    IS_NUMBER = "isNumber";
  }
});

// node_modules/class-validator/esm5/decorator/typechecker/IsEnum.js
function isEnum(value, entity) {
  var enumValues = Object.keys(entity).map(function(k) {
    return entity[k];
  });
  return enumValues.indexOf(value) >= 0;
}
function IsEnum(entity, validationOptions) {
  return ValidateBy({
    name: IS_ENUM,
    constraints: [entity],
    validator: {
      validate: function(value, args) {
        return isEnum(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a valid enum value";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_ENUM;
var init_IsEnum = __esm({
  "node_modules/class-validator/esm5/decorator/typechecker/IsEnum.js"() {
    init_ValidateBy();
    IS_ENUM = "isEnum";
  }
});

// node_modules/class-validator/esm5/decorator/typechecker/IsInt.js
function isInt(val) {
  return typeof val === "number" && Number.isInteger(val);
}
function IsInt(validationOptions) {
  return ValidateBy({
    name: IS_INT,
    validator: {
      validate: function(value, args) {
        return isInt(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be an integer number";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_INT;
var init_IsInt = __esm({
  "node_modules/class-validator/esm5/decorator/typechecker/IsInt.js"() {
    init_ValidateBy();
    IS_INT = "isInt";
  }
});

// node_modules/class-validator/esm5/decorator/typechecker/IsString.js
function isString(value) {
  return value instanceof String || typeof value === "string";
}
function IsString(validationOptions) {
  return ValidateBy({
    name: IS_STRING,
    validator: {
      validate: function(value, args) {
        return isString(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a string";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_STRING;
var init_IsString = __esm({
  "node_modules/class-validator/esm5/decorator/typechecker/IsString.js"() {
    init_ValidateBy();
    IS_STRING = "isString";
  }
});

// node_modules/class-validator/esm5/decorator/typechecker/IsArray.js
function isArray(value) {
  return value instanceof Array;
}
function IsArray(validationOptions) {
  return ValidateBy({
    name: IS_ARRAY,
    validator: {
      validate: function(value, args) {
        return isArray(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be an array";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_ARRAY;
var init_IsArray = __esm({
  "node_modules/class-validator/esm5/decorator/typechecker/IsArray.js"() {
    init_ValidateBy();
    IS_ARRAY = "isArray";
  }
});

// node_modules/class-validator/esm5/decorator/typechecker/IsObject.js
function isObject3(value) {
  return value != null && (typeof value === "object" || typeof value === "function") && !Array.isArray(value);
}
function IsObject(validationOptions) {
  return ValidateBy({
    name: IS_OBJECT,
    validator: {
      validate: function(value, args) {
        return isObject3(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be an object";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_OBJECT;
var init_IsObject = __esm({
  "node_modules/class-validator/esm5/decorator/typechecker/IsObject.js"() {
    init_ValidateBy();
    IS_OBJECT = "isObject";
  }
});

// node_modules/class-validator/esm5/decorator/array/ArrayContains.js
function arrayContains(array, values) {
  if (!(array instanceof Array))
    return false;
  return values.every(function(value) {
    return array.indexOf(value) !== -1;
  });
}
function ArrayContains(values, validationOptions) {
  return ValidateBy({
    name: ARRAY_CONTAINS,
    constraints: [values],
    validator: {
      validate: function(value, args) {
        return arrayContains(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must contain $constraint1 values";
      }, validationOptions)
    }
  }, validationOptions);
}
var ARRAY_CONTAINS;
var init_ArrayContains = __esm({
  "node_modules/class-validator/esm5/decorator/array/ArrayContains.js"() {
    init_ValidateBy();
    ARRAY_CONTAINS = "arrayContains";
  }
});

// node_modules/class-validator/esm5/decorator/array/ArrayNotContains.js
function arrayNotContains(array, values) {
  if (!(array instanceof Array))
    return false;
  return values.every(function(value) {
    return array.indexOf(value) === -1;
  });
}
function ArrayNotContains(values, validationOptions) {
  return ValidateBy({
    name: ARRAY_NOT_CONTAINS,
    constraints: [values],
    validator: {
      validate: function(value, args) {
        return arrayNotContains(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property should not contain $constraint1 values";
      }, validationOptions)
    }
  }, validationOptions);
}
var ARRAY_NOT_CONTAINS;
var init_ArrayNotContains = __esm({
  "node_modules/class-validator/esm5/decorator/array/ArrayNotContains.js"() {
    init_ValidateBy();
    ARRAY_NOT_CONTAINS = "arrayNotContains";
  }
});

// node_modules/class-validator/esm5/decorator/array/ArrayNotEmpty.js
function arrayNotEmpty(array) {
  return array instanceof Array && array.length > 0;
}
function ArrayNotEmpty(validationOptions) {
  return ValidateBy({
    name: ARRAY_NOT_EMPTY,
    validator: {
      validate: function(value, args) {
        return arrayNotEmpty(value);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property should not be empty";
      }, validationOptions)
    }
  }, validationOptions);
}
var ARRAY_NOT_EMPTY;
var init_ArrayNotEmpty = __esm({
  "node_modules/class-validator/esm5/decorator/array/ArrayNotEmpty.js"() {
    init_ValidateBy();
    ARRAY_NOT_EMPTY = "arrayNotEmpty";
  }
});

// node_modules/class-validator/esm5/decorator/array/ArrayMinSize.js
function arrayMinSize(array, min2) {
  return array instanceof Array && array.length >= min2;
}
function ArrayMinSize(min2, validationOptions) {
  return ValidateBy({
    name: ARRAY_MIN_SIZE,
    constraints: [min2],
    validator: {
      validate: function(value, args) {
        return arrayMinSize(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must contain at least $constraint1 elements";
      }, validationOptions)
    }
  }, validationOptions);
}
var ARRAY_MIN_SIZE;
var init_ArrayMinSize = __esm({
  "node_modules/class-validator/esm5/decorator/array/ArrayMinSize.js"() {
    init_ValidateBy();
    ARRAY_MIN_SIZE = "arrayMinSize";
  }
});

// node_modules/class-validator/esm5/decorator/array/ArrayMaxSize.js
function arrayMaxSize(array, max2) {
  return array instanceof Array && array.length <= max2;
}
function ArrayMaxSize(max2, validationOptions) {
  return ValidateBy({
    name: ARRAY_MAX_SIZE,
    constraints: [max2],
    validator: {
      validate: function(value, args) {
        return arrayMaxSize(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must contain not more than $constraint1 elements";
      }, validationOptions)
    }
  }, validationOptions);
}
var ARRAY_MAX_SIZE;
var init_ArrayMaxSize = __esm({
  "node_modules/class-validator/esm5/decorator/array/ArrayMaxSize.js"() {
    init_ValidateBy();
    ARRAY_MAX_SIZE = "arrayMaxSize";
  }
});

// node_modules/class-validator/esm5/decorator/array/ArrayUnique.js
function arrayUnique(array, identifier) {
  if (!(array instanceof Array))
    return false;
  if (identifier) {
    array = array.map(function(o) {
      return o != null ? identifier(o) : o;
    });
  }
  var uniqueItems = array.filter(function(a, b, c) {
    return c.indexOf(a) === b;
  });
  return array.length === uniqueItems.length;
}
function ArrayUnique(identifierOrOptions, validationOptions) {
  var identifier = typeof identifierOrOptions === "function" ? identifierOrOptions : void 0;
  var options = typeof identifierOrOptions !== "function" ? identifierOrOptions : validationOptions;
  return ValidateBy({
    name: ARRAY_UNIQUE,
    validator: {
      validate: function(value, args) {
        return arrayUnique(value, identifier);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "All $property's elements must be unique";
      }, options)
    }
  }, options);
}
var ARRAY_UNIQUE;
var init_ArrayUnique = __esm({
  "node_modules/class-validator/esm5/decorator/array/ArrayUnique.js"() {
    init_ValidateBy();
    ARRAY_UNIQUE = "arrayUnique";
  }
});

// node_modules/class-validator/esm5/decorator/object/IsNotEmptyObject.js
function isNotEmptyObject(value, options) {
  if (!isObject3(value)) {
    return false;
  }
  if ((options === null || options === void 0 ? void 0 : options.nullable) === true) {
    return !Object.values(value).every(function(propertyValue) {
      return propertyValue === null || propertyValue === void 0;
    });
  }
  for (var key in value) {
    if (value.hasOwnProperty(key)) {
      return true;
    }
  }
  return false;
}
function IsNotEmptyObject(options, validationOptions) {
  return ValidateBy({
    name: IS_NOT_EMPTY_OBJECT,
    constraints: [options],
    validator: {
      validate: function(value, args) {
        return isNotEmptyObject(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix) {
        return eachPrefix + "$property must be a non-empty object";
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_NOT_EMPTY_OBJECT;
var init_IsNotEmptyObject = __esm({
  "node_modules/class-validator/esm5/decorator/object/IsNotEmptyObject.js"() {
    init_ValidateBy();
    init_IsObject();
    IS_NOT_EMPTY_OBJECT = "isNotEmptyObject";
  }
});

// node_modules/class-validator/esm5/decorator/object/IsInstance.js
function isInstance(object, targetTypeConstructor) {
  return targetTypeConstructor && typeof targetTypeConstructor === "function" && object instanceof targetTypeConstructor;
}
function IsInstance(targetType, validationOptions) {
  return ValidateBy({
    name: IS_INSTANCE,
    constraints: [targetType],
    validator: {
      validate: function(value, args) {
        return isInstance(value, args.constraints[0]);
      },
      defaultMessage: buildMessage(function(eachPrefix, args) {
        if (args.constraints[0]) {
          return eachPrefix + ("$property must be an instance of " + args.constraints[0].name);
        } else {
          return eachPrefix + (IS_INSTANCE + " decorator expects and object as value, but got falsy value.");
        }
      }, validationOptions)
    }
  }, validationOptions);
}
var IS_INSTANCE;
var init_IsInstance = __esm({
  "node_modules/class-validator/esm5/decorator/object/IsInstance.js"() {
    init_ValidateBy();
    IS_INSTANCE = "isInstance";
  }
});

// node_modules/class-validator/esm5/decorator/decorators.js
var init_decorators2 = __esm({
  "node_modules/class-validator/esm5/decorator/decorators.js"() {
    init_Allow();
    init_IsDefined();
    init_IsOptional();
    init_Validate();
    init_ValidateBy();
    init_ValidateIf();
    init_ValidateNested();
    init_ValidatePromise();
    init_IsLatLong();
    init_IsLatitude();
    init_IsLongitude();
    init_Equals();
    init_NotEquals();
    init_IsEmpty();
    init_IsNotEmpty();
    init_IsIn();
    init_IsNotIn();
    init_IsDivisibleBy();
    init_IsPositive();
    init_IsNegative();
    init_Max();
    init_Min();
    init_MinDate();
    init_MaxDate();
    init_Contains();
    init_NotContains();
    init_IsAlpha();
    init_IsAlphanumeric();
    init_IsDecimal();
    init_IsAscii();
    init_IsBase64();
    init_IsByteLength();
    init_IsCreditCard();
    init_IsCurrency();
    init_IsEmail();
    init_IsFQDN();
    init_IsFullWidth();
    init_IsHalfWidth();
    init_IsVariableWidth();
    init_IsHexColor();
    init_IsHexadecimal();
    init_IsMacAddress();
    init_IsIP();
    init_IsPort();
    init_IsISBN();
    init_IsISIN();
    init_IsISO8601();
    init_IsJSON();
    init_IsJWT();
    init_IsLowercase();
    init_IsMobilePhone();
    init_IsISO31661Alpha2();
    init_IsISO31661Alpha3();
    init_IsMongoId();
    init_IsMultibyte();
    init_IsSurrogatePair();
    init_IsUrl();
    init_IsUUID();
    init_IsFirebasePushId();
    init_IsUppercase();
    init_Length();
    init_MaxLength();
    init_MinLength();
    init_Matches();
    init_IsPhoneNumber();
    init_IsMilitaryTime();
    init_IsHash();
    init_IsISSN();
    init_IsDateString();
    init_IsBooleanString();
    init_IsNumberString();
    init_IsBase32();
    init_IsBIC();
    init_IsBtcAddress();
    init_IsDataURI();
    init_IsEAN();
    init_IsEthereumAddress();
    init_IsHSL();
    init_IsIBAN();
    init_IsIdentityCard();
    init_IsISRC();
    init_IsLocale();
    init_IsMagnetURI();
    init_IsMimeType();
    init_IsOctal();
    init_IsPassportNumber();
    init_IsPostalCode();
    init_IsRFC3339();
    init_IsRgbColor();
    init_IsSemVer();
    init_IsBoolean();
    init_IsDate();
    init_IsNumber();
    init_IsEnum();
    init_IsInt();
    init_IsString();
    init_IsArray();
    init_IsObject();
    init_ArrayContains();
    init_ArrayNotContains();
    init_ArrayNotEmpty();
    init_ArrayMinSize();
    init_ArrayMaxSize();
    init_ArrayUnique();
    init_IsNotEmptyObject();
    init_IsInstance();
  }
});

// node_modules/class-validator/esm5/validation/ValidatorConstraintInterface.js
var init_ValidatorConstraintInterface = __esm({
  "node_modules/class-validator/esm5/validation/ValidatorConstraintInterface.js"() {
  }
});

// node_modules/class-validator/esm5/validation/ValidatorOptions.js
var init_ValidatorOptions = __esm({
  "node_modules/class-validator/esm5/validation/ValidatorOptions.js"() {
  }
});

// node_modules/class-validator/esm5/validation/ValidationArguments.js
var init_ValidationArguments = __esm({
  "node_modules/class-validator/esm5/validation/ValidationArguments.js"() {
  }
});

// node_modules/class-validator/esm5/validation-schema/ValidationSchema.js
var init_ValidationSchema = __esm({
  "node_modules/class-validator/esm5/validation-schema/ValidationSchema.js"() {
  }
});

// node_modules/class-validator/esm5/index.js
var esm5_exports2 = {};
__export(esm5_exports2, {
  ARRAY_CONTAINS: () => ARRAY_CONTAINS,
  ARRAY_MAX_SIZE: () => ARRAY_MAX_SIZE,
  ARRAY_MIN_SIZE: () => ARRAY_MIN_SIZE,
  ARRAY_NOT_CONTAINS: () => ARRAY_NOT_CONTAINS,
  ARRAY_NOT_EMPTY: () => ARRAY_NOT_EMPTY,
  ARRAY_UNIQUE: () => ARRAY_UNIQUE,
  Allow: () => Allow,
  ArrayContains: () => ArrayContains,
  ArrayMaxSize: () => ArrayMaxSize,
  ArrayMinSize: () => ArrayMinSize,
  ArrayNotContains: () => ArrayNotContains,
  ArrayNotEmpty: () => ArrayNotEmpty,
  ArrayUnique: () => ArrayUnique,
  CONTAINS: () => CONTAINS,
  Contains: () => Contains,
  EQUALS: () => EQUALS,
  Equals: () => Equals,
  IS_ALPHA: () => IS_ALPHA,
  IS_ALPHANUMERIC: () => IS_ALPHANUMERIC,
  IS_ARRAY: () => IS_ARRAY,
  IS_ASCII: () => IS_ASCII,
  IS_BASE32: () => IS_BASE32,
  IS_BASE64: () => IS_BASE64,
  IS_BIC: () => IS_BIC,
  IS_BOOLEAN: () => IS_BOOLEAN,
  IS_BOOLEAN_STRING: () => IS_BOOLEAN_STRING,
  IS_BTC_ADDRESS: () => IS_BTC_ADDRESS,
  IS_BYTE_LENGTH: () => IS_BYTE_LENGTH,
  IS_CREDIT_CARD: () => IS_CREDIT_CARD,
  IS_CURRENCY: () => IS_CURRENCY,
  IS_DATA_URI: () => IS_DATA_URI,
  IS_DATE: () => IS_DATE,
  IS_DATE_STRING: () => IS_DATE_STRING,
  IS_DECIMAL: () => IS_DECIMAL,
  IS_DEFINED: () => IS_DEFINED,
  IS_DIVISIBLE_BY: () => IS_DIVISIBLE_BY,
  IS_EAN: () => IS_EAN,
  IS_EMAIL: () => IS_EMAIL,
  IS_EMPTY: () => IS_EMPTY,
  IS_ENUM: () => IS_ENUM,
  IS_ETHEREUM_ADDRESS: () => IS_ETHEREUM_ADDRESS,
  IS_FIREBASE_PUSH_ID: () => IS_FIREBASE_PUSH_ID,
  IS_FQDN: () => IS_FQDN,
  IS_FULL_WIDTH: () => IS_FULL_WIDTH,
  IS_HALF_WIDTH: () => IS_HALF_WIDTH,
  IS_HASH: () => IS_HASH,
  IS_HEXADECIMAL: () => IS_HEXADECIMAL,
  IS_HEX_COLOR: () => IS_HEX_COLOR,
  IS_HSL: () => IS_HSL,
  IS_IBAN: () => IS_IBAN,
  IS_IDENTITY_CARD: () => IS_IDENTITY_CARD,
  IS_IN: () => IS_IN,
  IS_INSTANCE: () => IS_INSTANCE,
  IS_INT: () => IS_INT,
  IS_IP: () => IS_IP,
  IS_ISBN: () => IS_ISBN,
  IS_ISIN: () => IS_ISIN,
  IS_ISO31661_ALPHA_2: () => IS_ISO31661_ALPHA_2,
  IS_ISO31661_ALPHA_3: () => IS_ISO31661_ALPHA_3,
  IS_ISO8601: () => IS_ISO8601,
  IS_ISRC: () => IS_ISRC,
  IS_ISSN: () => IS_ISSN,
  IS_JSON: () => IS_JSON,
  IS_JWT: () => IS_JWT,
  IS_LATITUDE: () => IS_LATITUDE,
  IS_LATLONG: () => IS_LATLONG,
  IS_LENGTH: () => IS_LENGTH,
  IS_LOCALE: () => IS_LOCALE,
  IS_LONGITUDE: () => IS_LONGITUDE,
  IS_LOWERCASE: () => IS_LOWERCASE,
  IS_MAC_ADDRESS: () => IS_MAC_ADDRESS,
  IS_MAGNET_URI: () => IS_MAGNET_URI,
  IS_MILITARY_TIME: () => IS_MILITARY_TIME,
  IS_MIME_TYPE: () => IS_MIME_TYPE,
  IS_MOBILE_PHONE: () => IS_MOBILE_PHONE,
  IS_MONGO_ID: () => IS_MONGO_ID,
  IS_MULTIBYTE: () => IS_MULTIBYTE,
  IS_NEGATIVE: () => IS_NEGATIVE,
  IS_NOT_EMPTY: () => IS_NOT_EMPTY,
  IS_NOT_EMPTY_OBJECT: () => IS_NOT_EMPTY_OBJECT,
  IS_NOT_IN: () => IS_NOT_IN,
  IS_NUMBER: () => IS_NUMBER,
  IS_NUMBER_STRING: () => IS_NUMBER_STRING,
  IS_OBJECT: () => IS_OBJECT,
  IS_OCTAL: () => IS_OCTAL,
  IS_PASSPORT_NUMBER: () => IS_PASSPORT_NUMBER,
  IS_PHONE_NUMBER: () => IS_PHONE_NUMBER,
  IS_PORT: () => IS_PORT,
  IS_POSITIVE: () => IS_POSITIVE,
  IS_POSTAL_CODE: () => IS_POSTAL_CODE,
  IS_RFC_3339: () => IS_RFC_3339,
  IS_RGB_COLOR: () => IS_RGB_COLOR,
  IS_SEM_VER: () => IS_SEM_VER,
  IS_STRING: () => IS_STRING,
  IS_SURROGATE_PAIR: () => IS_SURROGATE_PAIR,
  IS_UPPERCASE: () => IS_UPPERCASE,
  IS_URL: () => IS_URL,
  IS_UUID: () => IS_UUID,
  IS_VARIABLE_WIDTH: () => IS_VARIABLE_WIDTH,
  IsAlpha: () => IsAlpha,
  IsAlphanumeric: () => IsAlphanumeric,
  IsArray: () => IsArray,
  IsAscii: () => IsAscii,
  IsBIC: () => IsBIC,
  IsBase32: () => IsBase32,
  IsBase64: () => IsBase64,
  IsBoolean: () => IsBoolean,
  IsBooleanString: () => IsBooleanString,
  IsBtcAddress: () => IsBtcAddress,
  IsByteLength: () => IsByteLength,
  IsCreditCard: () => IsCreditCard,
  IsCurrency: () => IsCurrency,
  IsDataURI: () => IsDataURI,
  IsDate: () => IsDate,
  IsDateString: () => IsDateString,
  IsDecimal: () => IsDecimal,
  IsDefined: () => IsDefined,
  IsDivisibleBy: () => IsDivisibleBy,
  IsEAN: () => IsEAN,
  IsEmail: () => IsEmail,
  IsEmpty: () => IsEmpty,
  IsEnum: () => IsEnum,
  IsEthereumAddress: () => IsEthereumAddress,
  IsFQDN: () => IsFQDN,
  IsFirebasePushId: () => IsFirebasePushId,
  IsFullWidth: () => IsFullWidth,
  IsHSL: () => IsHSL,
  IsHalfWidth: () => IsHalfWidth,
  IsHash: () => IsHash,
  IsHexColor: () => IsHexColor,
  IsHexadecimal: () => IsHexadecimal,
  IsIBAN: () => IsIBAN,
  IsIP: () => IsIP,
  IsISBN: () => IsISBN,
  IsISIN: () => IsISIN,
  IsISO31661Alpha2: () => IsISO31661Alpha2,
  IsISO31661Alpha3: () => IsISO31661Alpha3,
  IsISO8601: () => IsISO8601,
  IsISRC: () => IsISRC,
  IsISSN: () => IsISSN,
  IsIdentityCard: () => IsIdentityCard,
  IsIn: () => IsIn,
  IsInstance: () => IsInstance,
  IsInt: () => IsInt,
  IsJSON: () => IsJSON,
  IsJWT: () => IsJWT,
  IsLatLong: () => IsLatLong,
  IsLatitude: () => IsLatitude,
  IsLocale: () => IsLocale,
  IsLongitude: () => IsLongitude,
  IsLowercase: () => IsLowercase,
  IsMACAddress: () => IsMACAddress,
  IsMagnetURI: () => IsMagnetURI,
  IsMilitaryTime: () => IsMilitaryTime,
  IsMimeType: () => IsMimeType,
  IsMobilePhone: () => IsMobilePhone,
  IsMongoId: () => IsMongoId,
  IsMultibyte: () => IsMultibyte,
  IsNegative: () => IsNegative,
  IsNotEmpty: () => IsNotEmpty,
  IsNotEmptyObject: () => IsNotEmptyObject,
  IsNotIn: () => IsNotIn,
  IsNumber: () => IsNumber,
  IsNumberString: () => IsNumberString,
  IsObject: () => IsObject,
  IsOctal: () => IsOctal,
  IsOptional: () => IsOptional,
  IsPassportNumber: () => IsPassportNumber,
  IsPhoneNumber: () => IsPhoneNumber,
  IsPort: () => IsPort,
  IsPositive: () => IsPositive,
  IsPostalCode: () => IsPostalCode,
  IsRFC3339: () => IsRFC3339,
  IsRgbColor: () => IsRgbColor,
  IsSemVer: () => IsSemVer,
  IsString: () => IsString,
  IsSurrogatePair: () => IsSurrogatePair,
  IsUUID: () => IsUUID,
  IsUppercase: () => IsUppercase,
  IsUrl: () => IsUrl,
  IsVariableWidth: () => IsVariableWidth,
  Length: () => Length,
  MATCHES: () => MATCHES,
  MAX: () => MAX,
  MAX_DATE: () => MAX_DATE,
  MAX_LENGTH: () => MAX_LENGTH,
  MIN: () => MIN,
  MIN_DATE: () => MIN_DATE,
  MIN_LENGTH: () => MIN_LENGTH,
  Matches: () => Matches,
  Max: () => Max,
  MaxDate: () => MaxDate,
  MaxLength: () => MaxLength,
  MetadataStorage: () => MetadataStorage2,
  Min: () => Min,
  MinDate: () => MinDate,
  MinLength: () => MinLength,
  NOT_CONTAINS: () => NOT_CONTAINS,
  NOT_EQUALS: () => NOT_EQUALS,
  NotContains: () => NotContains,
  NotEquals: () => NotEquals,
  Validate: () => Validate,
  ValidateBy: () => ValidateBy,
  ValidateIf: () => ValidateIf,
  ValidateNested: () => ValidateNested,
  ValidatePromise: () => ValidatePromise,
  ValidationError: () => ValidationError,
  ValidationTypes: () => ValidationTypes,
  Validator: () => Validator,
  ValidatorConstraint: () => ValidatorConstraint,
  arrayContains: () => arrayContains,
  arrayMaxSize: () => arrayMaxSize,
  arrayMinSize: () => arrayMinSize,
  arrayNotContains: () => arrayNotContains,
  arrayNotEmpty: () => arrayNotEmpty,
  arrayUnique: () => arrayUnique,
  buildMessage: () => buildMessage,
  contains: () => contains,
  equals: () => equals,
  getFromContainer: () => getFromContainer,
  getMetadataStorage: () => getMetadataStorage,
  isAlpha: () => isAlpha,
  isAlphanumeric: () => isAlphanumeric,
  isArray: () => isArray,
  isAscii: () => isAscii,
  isBIC: () => isBIC,
  isBase32: () => isBase32,
  isBase64: () => isBase64,
  isBoolean: () => isBoolean,
  isBooleanString: () => isBooleanString,
  isBtcAddress: () => isBtcAddress,
  isByteLength: () => isByteLength,
  isCreditCard: () => isCreditCard,
  isCurrency: () => isCurrency,
  isDataURI: () => isDataURI,
  isDate: () => isDate,
  isDateString: () => isDateString,
  isDecimal: () => isDecimal,
  isDefined: () => isDefined,
  isDivisibleBy: () => isDivisibleBy,
  isEAN: () => isEAN,
  isEmail: () => isEmail,
  isEmpty: () => isEmpty,
  isEnum: () => isEnum,
  isEthereumAddress: () => isEthereumAddress,
  isFQDN: () => isFQDN,
  isFirebasePushId: () => isFirebasePushId,
  isFullWidth: () => isFullWidth,
  isHSL: () => isHSL,
  isHalfWidth: () => isHalfWidth,
  isHash: () => isHash,
  isHexColor: () => isHexColor,
  isHexadecimal: () => isHexadecimal,
  isIBAN: () => isIBAN,
  isIP: () => isIP,
  isISBN: () => isISBN,
  isISIN: () => isISIN,
  isISO31661Alpha2: () => isISO31661Alpha2,
  isISO31661Alpha3: () => isISO31661Alpha3,
  isISO8601: () => isISO8601,
  isISRC: () => isISRC,
  isISSN: () => isISSN,
  isIdentityCard: () => isIdentityCard,
  isIn: () => isIn,
  isInstance: () => isInstance,
  isInt: () => isInt,
  isJSON: () => isJSON,
  isJWT: () => isJWT,
  isLatLong: () => isLatLong,
  isLatitude: () => isLatitude,
  isLocale: () => isLocale,
  isLongitude: () => isLongitude,
  isLowercase: () => isLowercase,
  isMACAddress: () => isMACAddress,
  isMagnetURI: () => isMagnetURI,
  isMilitaryTime: () => isMilitaryTime,
  isMimeType: () => isMimeType,
  isMobilePhone: () => isMobilePhone,
  isMongoId: () => isMongoId,
  isMultibyte: () => isMultibyte,
  isNegative: () => isNegative,
  isNotEmpty: () => isNotEmpty,
  isNotEmptyObject: () => isNotEmptyObject,
  isNotIn: () => isNotIn,
  isNumber: () => isNumber,
  isNumberString: () => isNumberString,
  isObject: () => isObject3,
  isOctal: () => isOctal,
  isPassportNumber: () => isPassportNumber,
  isPhoneNumber: () => isPhoneNumber,
  isPort: () => isPort,
  isPositive: () => isPositive,
  isPostalCode: () => isPostalCode,
  isRFC3339: () => isRFC3339,
  isRgbColor: () => isRgbColor,
  isSemVer: () => isSemVer,
  isString: () => isString,
  isSurrogatePair: () => isSurrogatePair,
  isURL: () => isURL,
  isUUID: () => isUUID,
  isUppercase: () => isUppercase,
  isValidationOptions: () => isValidationOptions,
  isVariableWidth: () => isVariableWidth,
  length: () => length,
  matches: () => matches,
  max: () => max,
  maxDate: () => maxDate,
  maxLength: () => maxLength,
  min: () => min,
  minDate: () => minDate,
  minLength: () => minLength,
  notContains: () => notContains,
  notEquals: () => notEquals,
  registerDecorator: () => registerDecorator,
  registerSchema: () => registerSchema,
  useContainer: () => useContainer,
  validate: () => validate,
  validateOrReject: () => validateOrReject,
  validateSync: () => validateSync
});
function validate(schemaNameOrObject, objectOrValidationOptions, maybeValidatorOptions) {
  if (typeof schemaNameOrObject === "string") {
    return getFromContainer(Validator).validate(schemaNameOrObject, objectOrValidationOptions, maybeValidatorOptions);
  } else {
    return getFromContainer(Validator).validate(schemaNameOrObject, objectOrValidationOptions);
  }
}
function validateOrReject(schemaNameOrObject, objectOrValidationOptions, maybeValidatorOptions) {
  if (typeof schemaNameOrObject === "string") {
    return getFromContainer(Validator).validateOrReject(schemaNameOrObject, objectOrValidationOptions, maybeValidatorOptions);
  } else {
    return getFromContainer(Validator).validateOrReject(schemaNameOrObject, objectOrValidationOptions);
  }
}
function validateSync(schemaNameOrObject, objectOrValidationOptions, maybeValidatorOptions) {
  if (typeof schemaNameOrObject === "string") {
    return getFromContainer(Validator).validateSync(schemaNameOrObject, objectOrValidationOptions, maybeValidatorOptions);
  } else {
    return getFromContainer(Validator).validateSync(schemaNameOrObject, objectOrValidationOptions);
  }
}
function registerSchema(schema) {
  getMetadataStorage().addValidationSchema(schema);
}
var init_esm52 = __esm({
  "node_modules/class-validator/esm5/index.js"() {
    init_MetadataStorage2();
    init_Validator();
    init_container();
    init_container();
    init_decorators2();
    init_ValidationOptions();
    init_ValidatorConstraintInterface();
    init_ValidationError();
    init_ValidatorOptions();
    init_ValidationArguments();
    init_ValidationTypes();
    init_Validator();
    init_ValidationSchema();
    init_register_decorator();
    init_MetadataStorage2();
  }
});

// node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "node_modules/strict-uri-encode/index.js"(exports, module) {
    "use strict";
    module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x) => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "node_modules/decode-uri-component/index.js"(exports, module) {
    "use strict";
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return [decodeURIComponent(components.join(""))];
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher) || [];
        for (var i = 1; i < tokens.length; i++) {
          input = decodeComponents(tokens, i).join("");
          tokens = input.match(singleMatcher) || [];
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "��",
        "%FF%FE": "��"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result2 = decode(match[0]);
          if (result2 !== match[0]) {
            replaceMap[match[0]] = result2;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "�";
      var entries = Object.keys(replaceMap);
      for (var i = 0; i < entries.length; i++) {
        var key = entries[i];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }
    module.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
  "node_modules/split-on-first/index.js"(exports, module) {
    "use strict";
    module.exports = (string, separator) => {
      if (!(typeof string === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string];
      }
      const separatorIndex = string.indexOf(separator);
      if (separatorIndex === -1) {
        return [string];
      }
      return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
      ];
    };
  }
});

// node_modules/filter-obj/index.js
var require_filter_obj = __commonJS({
  "node_modules/filter-obj/index.js"(exports, module) {
    "use strict";
    module.exports = function(obj, predicate) {
      var ret = {};
      var keys = Object.keys(obj);
      var isArr = Array.isArray(predicate);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var val = obj[key];
        if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
          ret[key] = val;
        }
      }
      return ret;
    };
  }
});

// node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/query-string/index.js"(exports) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result2, value) => {
            const index = result2.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result2;
            }
            if (value === null) {
              return [...result2, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result2,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result2, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result2;
            }
            if (value === null) {
              return [...result2, [encode(key, options), "[]"].join("")];
            }
            return [...result2, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result2, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result2;
            }
            if (value === null) {
              return [...result2, [encode(key, options), ":list="].join("")];
            }
            return [...result2, [encode(key, options), ":list=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result2, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result2;
            }
            value = value === null ? "" : value;
            if (result2.length === 0) {
              return [[encode(key, options), keyValueSep, encode(value, options)].join("")];
            }
            return [[result2, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result2, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result2;
            }
            if (value === null) {
              return [...result2, encode(key, options)];
            }
            return [...result2, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result2;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result2 = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result2) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result2[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result2 = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result2) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result2 = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result2) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray2 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray2 && decode(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode(value, options) : value;
            const newValue = isArray2 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray2 = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray2) {
              accumulator[key] = value ? decode(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse4(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k of Object.keys(value)) {
            value[k] = parseValue(value[k], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result2, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result2[key] = keysSorter(value);
        } else {
          result2[key] = value;
        }
        return result2;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse4;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x) => x.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse4(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/@aries-framework/core/build/decorators/ack/AckDecorator.js
var require_AckDecorator = __commonJS({
  "node_modules/@aries-framework/core/build/decorators/ack/AckDecorator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AckDecorator = exports.AckValues = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AckValues;
    (function(AckValues2) {
      AckValues2["Receipt"] = "RECEIPT";
      AckValues2["Outcome"] = "OUTCOME";
    })(AckValues = exports.AckValues || (exports.AckValues = {}));
    var AckDecorator = class {
      constructor(options) {
        this.on = [AckValues.Receipt];
        if (options) {
          this.on = options.on;
        }
      }
    };
    __decorate([
      (0, class_validator_1.IsEnum)(AckValues, { each: true }),
      (0, class_validator_1.IsArray)(),
      __metadata("design:type", Array)
    ], AckDecorator.prototype, "on", void 0);
    exports.AckDecorator = AckDecorator;
  }
});

// node_modules/@aries-framework/core/build/decorators/ack/AckDecoratorExtension.js
var require_AckDecoratorExtension = __commonJS({
  "node_modules/@aries-framework/core/build/decorators/ack/AckDecoratorExtension.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AckDecorated = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AckDecorator_1 = require_AckDecorator();
    function AckDecorated(Base) {
      class AckDecoratorExtension extends Base {
        setPleaseAck(on = [AckDecorator_1.AckValues.Receipt]) {
          this.pleaseAck = new AckDecorator_1.AckDecorator({ on });
        }
        getPleaseAck() {
          return this.pleaseAck;
        }
        requiresAck() {
          return this.pleaseAck !== void 0;
        }
      }
      __decorate([
        (0, class_transformer_1.Expose)({ name: "~please_ack" }),
        (0, class_transformer_1.Type)(() => AckDecorator_1.AckDecorator),
        (0, class_validator_1.ValidateNested)(),
        (0, class_validator_1.IsInstance)(AckDecorator_1.AckDecorator),
        (0, class_validator_1.IsOptional)(),
        __metadata("design:type", AckDecorator_1.AckDecorator)
      ], AckDecoratorExtension.prototype, "pleaseAck", void 0);
      return AckDecoratorExtension;
    }
    exports.AckDecorated = AckDecorated;
  }
});

// node_modules/@aries-framework/core/build/utils/base64.js
var require_base64 = __commonJS({
  "node_modules/@aries-framework/core/build/utils/base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.base64ToBase64URL = void 0;
    function base64ToBase64URL(base64) {
      return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
    }
    exports.base64ToBase64URL = base64ToBase64URL;
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length2) {
      if (length2 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length2);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length2) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length2);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length2) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance2(value, ArrayBuffer) || value && isInstance2(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length2);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance2(value, SharedArrayBuffer) || value && isInstance2(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length2);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length2);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length2) {
      return from(value, encodingOrOffset, length2);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length2 = byteLength(string, encoding) | 0;
      let buf = createBuffer(length2);
      const actual = buf.write(string, encoding);
      if (actual !== length2) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length2 = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length2);
      for (let i = 0; i < length2; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance2(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length2) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length2 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length2 === void 0) {
        buf = new Uint8Array(array);
      } else if (length2 === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length2);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length2) {
      if (length2 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length2 | 0;
    }
    function SlowBuffer(length2) {
      if (+length2 != length2) {
        length2 = 0;
      }
      return Buffer2.alloc(+length2);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance2(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance2(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length2) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length2 === void 0) {
        length2 = 0;
        for (i = 0; i < list.length; ++i) {
          length2 += list[i].length;
        }
      }
      const buffer = Buffer2.allocUnsafe(length2);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance2(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer2.isBuffer(buf))
              buf = Buffer2.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance2(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length2 = this.length;
      if (length2 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length2);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals2(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max2 = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max2)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance2(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length2) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length2) {
        length2 = remaining;
      } else {
        length2 = Number(length2);
        if (length2 > remaining) {
          length2 = remaining;
        }
      }
      const strLen = string.length;
      if (length2 > strLen / 2) {
        length2 = strLen / 2;
      }
      let i;
      for (i = 0; i < length2; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length2) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length2);
    }
    function asciiWrite(buf, string, offset, length2) {
      return blitBuffer(asciiToBytes(string), buf, offset, length2);
    }
    function base64Write(buf, string, offset, length2) {
      return blitBuffer(base64ToBytes(string), buf, offset, length2);
    }
    function ucs2Write(buf, string, offset, length2) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length2);
    }
    Buffer2.prototype.write = function write(string, offset, length2, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length2 = this.length;
        offset = 0;
      } else if (length2 === void 0 && typeof offset === "string") {
        encoding = offset;
        length2 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length2)) {
          length2 = length2 >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length2;
          length2 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length2 === void 0 || length2 > remaining)
        length2 = remaining;
      if (string.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length2);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length2);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length2);
          case "base64":
            return base64Write(this, string, offset, length2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length2);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length2) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length2)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max2, min2) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max2 || value < min2)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min2, max2) {
      checkIntBI(value, min2, max2, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min2, max2) {
      checkIntBI(value, min2, max2, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit2 = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit2 - 1, -limit2);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit2 = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit2 - 1, -limit2);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max2, min2) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min2, max2, buf, offset, byteLength2) {
      if (value > max2 || value < min2) {
        const n = typeof min2 === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min2 === 0 || min2 === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min2}${n} and <= ${max2}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length2, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length2 < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length2}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length2 = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length2; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length2) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length2) {
      let i;
      for (i = 0; i < length2; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance2(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/@aries-framework/core/build/utils/buffer.js
var require_buffer2 = __commonJS({
  "node_modules/@aries-framework/core/build/utils/buffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Buffer = void 0;
    var buffer_1 = require_buffer();
    Object.defineProperty(exports, "Buffer", { enumerable: true, get: function() {
      return buffer_1.Buffer;
    } });
  }
});

// node_modules/@aries-framework/core/build/utils/JsonEncoder.js
var require_JsonEncoder = __commonJS({
  "node_modules/@aries-framework/core/build/utils/JsonEncoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonEncoder = void 0;
    var base64_1 = require_base64();
    var buffer_1 = require_buffer2();
    var JsonEncoder = class {
      /**
       * Encode json object into base64 string.
       *
       * @param json the json object to encode into base64 string
       */
      static toBase64(json) {
        return JsonEncoder.toBuffer(json).toString("base64");
      }
      /**
       * Encode json object into base64url string.
       *
       * @param json the json object to encode into base64url string
       */
      static toBase64URL(json) {
        return (0, base64_1.base64ToBase64URL)(JsonEncoder.toBase64(json));
      }
      /**
       * Decode base64 string into json object. Also supports base64url
       *
       * @param base64 the base64 or base64url string to decode into json
       */
      static fromBase64(base64) {
        return JsonEncoder.fromBuffer(buffer_1.Buffer.from(base64, "base64"));
      }
      /**
       * Encode json object into string
       *
       * @param json the json object to encode into string
       */
      static toString(json) {
        return JSON.stringify(json);
      }
      /**
       * Decode string into json object
       *
       * @param string the string to decode into json
       */
      static fromString(string) {
        return JSON.parse(string);
      }
      /**
       * Encode json object into buffer
       *
       * @param json the json object to encode into buffer format
       */
      static toBuffer(json) {
        return buffer_1.Buffer.from(JsonEncoder.toString(json));
      }
      /**
       * Decode buffer into json object
       *
       * @param buffer the buffer to decode into json
       */
      static fromBuffer(buffer) {
        return JsonEncoder.fromString(buffer_1.Buffer.from(buffer).toString("utf-8"));
      }
    };
    exports.JsonEncoder = JsonEncoder;
  }
});

// node_modules/uuid/dist/esm-browser/rng.js
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var getRandomValues, rnds8;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-browser/rng.js"() {
    rnds8 = new Uint8Array(16);
  }
});

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/uuid/dist/esm-browser/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/uuid/dist/esm-browser/validate.js
function validate2(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/uuid/dist/esm-browser/validate.js"() {
    init_regex();
    validate_default = validate2;
  }
});

// node_modules/uuid/dist/esm-browser/stringify.js
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, i, stringify_default;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-browser/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/uuid/dist/esm-browser/v1.js
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || stringify_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-browser/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-browser/parse.js
function parse3(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse4 = __esm({
  "node_modules/uuid/dist/esm-browser/parse.js"() {
    init_validate();
    parse_default = parse3;
  }
});

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
function v35_default(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS, URL2;
var init_v35 = __esm({
  "node_modules/uuid/dist/esm-browser/v35.js"() {
    init_stringify();
    init_parse4();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default;
var init_md5 = __esm({
  "node_modules/uuid/dist/esm-browser/md5.js"() {
    md5_default = md5;
  }
});

// node_modules/uuid/dist/esm-browser/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/uuid/dist/esm-browser/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-browser/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default;
var init_sha1 = __esm({
  "node_modules/uuid/dist/esm-browser/sha1.js"() {
    sha1_default = sha1;
  }
});

// node_modules/uuid/dist/esm-browser/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/uuid/dist/esm-browser/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/uuid/dist/esm-browser/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/uuid/dist/esm-browser/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/uuid/dist/esm-browser/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/uuid/dist/esm-browser/version.js"() {
    init_validate();
    version_default = version;
  }
});

// node_modules/uuid/dist/esm-browser/index.js
var esm_browser_exports = {};
__export(esm_browser_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_browser = __esm({
  "node_modules/uuid/dist/esm-browser/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse4();
  }
});

// node_modules/@aries-framework/core/build/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/@aries-framework/core/build/utils/uuid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uuid = void 0;
    var uuid_1 = (init_esm_browser(), __toCommonJS(esm_browser_exports));
    function uuid() {
      return (0, uuid_1.v4)();
    }
    exports.uuid = uuid;
  }
});

// node_modules/@aries-framework/core/build/decorators/attachment/Attachment.js
var require_Attachment = __commonJS({
  "node_modules/@aries-framework/core/build/decorators/attachment/Attachment.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Attachment = exports.AttachmentData = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var error_1 = require_error();
    var JsonEncoder_1 = require_JsonEncoder();
    var uuid_1 = require_uuid();
    var AttachmentData = class {
      constructor(options) {
        if (options) {
          this.base64 = options.base64;
          this.json = options.json;
          this.links = options.links;
          this.jws = options.jws;
          this.sha256 = options.sha256;
        }
      }
    };
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsBase64)(),
      __metadata("design:type", String)
    ], AttachmentData.prototype, "base64", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Object)
    ], AttachmentData.prototype, "json", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)({ each: true }),
      __metadata("design:type", Array)
    ], AttachmentData.prototype, "links", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Object)
    ], AttachmentData.prototype, "jws", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsHash)("sha256"),
      __metadata("design:type", String)
    ], AttachmentData.prototype, "sha256", void 0);
    exports.AttachmentData = AttachmentData;
    var Attachment = class {
      constructor(options) {
        var _a;
        if (options) {
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.description = options.description;
          this.filename = options.filename;
          this.mimeType = options.mimeType;
          this.lastmodTime = options.lastmodTime;
          this.byteCount = options.byteCount;
          this.data = options.data;
        }
      }
      /*
       * Helper function returning JSON representation of attachment data (if present). Tries to obtain the data from .base64 or .json, throws an error otherwise
       */
      getDataAsJson() {
        if (typeof this.data.base64 === "string") {
          return JsonEncoder_1.JsonEncoder.fromBase64(this.data.base64);
        } else if (this.data.json) {
          return this.data.json;
        } else {
          throw new error_1.AriesFrameworkError("No attachment data found in `json` or `base64` data fields.");
        }
      }
      addJws(jws) {
        if (!this.data.jws) {
          this.data.jws = jws;
        } else if ("signatures" in this.data.jws) {
          this.data.jws.signatures.push(jws);
        } else {
          this.data.jws = {
            signatures: [this.data.jws, jws]
          };
        }
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "@id" }),
      __metadata("design:type", String)
    ], Attachment.prototype, "id", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], Attachment.prototype, "description", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], Attachment.prototype, "filename", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "mime-type" }),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsMimeType)(),
      __metadata("design:type", String)
    ], Attachment.prototype, "mimeType", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "lastmod_time" }),
      (0, class_transformer_1.Type)(() => Date),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsDate)(),
      __metadata(
        "design:type",
        Date
        /**
         * Optional, and mostly relevant when content is included by reference instead of by value. Lets the receiver guess how expensive it will be, in time, bandwidth, and storage, to fully fetch the attachment.
         */
      )
    ], Attachment.prototype, "lastmodTime", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "byte_count" }),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsInt)(),
      __metadata("design:type", Number)
    ], Attachment.prototype, "byteCount", void 0);
    __decorate([
      (0, class_transformer_1.Type)(() => AttachmentData),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsInstance)(AttachmentData),
      __metadata(
        "design:type",
        AttachmentData
        /*
         * Helper function returning JSON representation of attachment data (if present). Tries to obtain the data from .base64 or .json, throws an error otherwise
         */
      )
    ], Attachment.prototype, "data", void 0);
    exports.Attachment = Attachment;
  }
});

// node_modules/@aries-framework/core/build/decorators/attachment/AttachmentExtension.js
var require_AttachmentExtension = __commonJS({
  "node_modules/@aries-framework/core/build/decorators/attachment/AttachmentExtension.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AttachmentDecorated = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var Attachment_1 = require_Attachment();
    function AttachmentDecorated(Base) {
      class AttachmentDecoratorExtension extends Base {
        getAppendedAttachmentById(id) {
          var _a;
          return (_a = this.appendedAttachments) === null || _a === void 0 ? void 0 : _a.find((attachment) => attachment.id === id);
        }
        addAppendedAttachment(attachment) {
          if (this.appendedAttachments) {
            this.appendedAttachments.push(attachment);
          } else {
            this.appendedAttachments = [attachment];
          }
        }
      }
      __decorate([
        (0, class_transformer_1.Expose)({ name: "~attach" }),
        (0, class_transformer_1.Type)(() => Attachment_1.Attachment),
        (0, class_validator_1.ValidateNested)(),
        (0, class_validator_1.IsInstance)(Attachment_1.Attachment, { each: true }),
        (0, class_validator_1.IsOptional)(),
        __metadata("design:type", Array)
      ], AttachmentDecoratorExtension.prototype, "appendedAttachments", void 0);
      return AttachmentDecoratorExtension;
    }
    exports.AttachmentDecorated = AttachmentDecorated;
  }
});

// node_modules/@aries-framework/core/build/decorators/l10n/L10nDecorator.js
var require_L10nDecorator = __commonJS({
  "node_modules/@aries-framework/core/build/decorators/l10n/L10nDecorator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.L10nDecorator = void 0;
    var L10nDecorator = class {
      constructor(partial) {
        this.locale = partial === null || partial === void 0 ? void 0 : partial.locale;
      }
    };
    exports.L10nDecorator = L10nDecorator;
  }
});

// node_modules/@aries-framework/core/build/decorators/l10n/L10nDecoratorExtension.js
var require_L10nDecoratorExtension = __commonJS({
  "node_modules/@aries-framework/core/build/decorators/l10n/L10nDecoratorExtension.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.L10nDecorated = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var L10nDecorator_1 = require_L10nDecorator();
    function L10nDecorated(Base) {
      class L10nDecoratorExtension extends Base {
        addLocale(locale) {
          this.l10n = new L10nDecorator_1.L10nDecorator({
            locale
          });
        }
        getLocale() {
          var _a;
          if ((_a = this.l10n) === null || _a === void 0 ? void 0 : _a.locale)
            return this.l10n.locale;
          return void 0;
        }
      }
      __decorate([
        (0, class_transformer_1.Expose)({ name: "~l10n" }),
        (0, class_transformer_1.Type)(() => L10nDecorator_1.L10nDecorator),
        (0, class_validator_1.ValidateNested)(),
        (0, class_validator_1.IsOptional)(),
        (0, class_validator_1.IsInstance)(L10nDecorator_1.L10nDecorator),
        __metadata("design:type", L10nDecorator_1.L10nDecorator)
      ], L10nDecoratorExtension.prototype, "l10n", void 0);
      return L10nDecoratorExtension;
    }
    exports.L10nDecorated = L10nDecorated;
  }
});

// node_modules/@aries-framework/core/build/crypto/KeyType.js
var require_KeyType = __commonJS({
  "node_modules/@aries-framework/core/build/crypto/KeyType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyType = void 0;
    var KeyType;
    (function(KeyType2) {
      KeyType2["Ed25519"] = "ed25519";
      KeyType2["Bls12381g1g2"] = "bls12381g1g2";
      KeyType2["Bls12381g1"] = "bls12381g1";
      KeyType2["Bls12381g2"] = "bls12381g2";
      KeyType2["X25519"] = "x25519";
    })(KeyType = exports.KeyType || (exports.KeyType = {}));
  }
});

// node_modules/@multiformats/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/@multiformats/base-x/src/index.js"(exports, module) {
    "use strict";
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          pbegin++;
        }
        var it2 = size - length2;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size - length2;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode
      };
    }
    module.exports = base;
  }
});

// node_modules/@aries-framework/core/build/utils/base58.js
var require_base58 = __commonJS({
  "node_modules/@aries-framework/core/build/utils/base58.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeToBase58 = exports.decodeFromBase58 = void 0;
    var base_x_1 = __importDefault(require_src());
    var BASE58_ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    var base58Converter = (0, base_x_1.default)(BASE58_ALPHABET);
    function decodeFromBase58(base58) {
      return base58Converter.decode(base58);
    }
    exports.decodeFromBase58 = decodeFromBase58;
    function encodeToBase58(buffer) {
      return base58Converter.encode(buffer);
    }
    exports.encodeToBase58 = encodeToBase58;
  }
});

// node_modules/@aries-framework/core/build/utils/TypedArrayEncoder.js
var require_TypedArrayEncoder = __commonJS({
  "node_modules/@aries-framework/core/build/utils/TypedArrayEncoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypedArrayEncoder = void 0;
    var base58_1 = require_base58();
    var base64_1 = require_base64();
    var buffer_1 = require_buffer2();
    var TypedArrayEncoder = class {
      /**
       * Encode buffer into base64 string.
       *
       * @param buffer the buffer to encode into base64 string
       */
      static toBase64(buffer) {
        return buffer_1.Buffer.from(buffer).toString("base64");
      }
      /**
       * Encode buffer into base64url string.
       *
       * @param buffer the buffer to encode into base64url string
       */
      static toBase64URL(buffer) {
        return (0, base64_1.base64ToBase64URL)(TypedArrayEncoder.toBase64(buffer));
      }
      /**
       * Encode buffer into base58 string.
       *
       * @param buffer the buffer to encode into base58 string
       */
      static toBase58(buffer) {
        return (0, base58_1.encodeToBase58)(buffer);
      }
      /**
       * Decode base64 string into buffer. Also supports base64url
       *
       * @param base64 the base64 or base64url string to decode into buffer format
       */
      static fromBase64(base64) {
        return buffer_1.Buffer.from(base64, "base64");
      }
      /**
       * Decode base58 string into buffer
       *
       * @param base58 the base58 string to decode into buffer format
       */
      static fromBase58(base58) {
        return buffer_1.Buffer.from((0, base58_1.decodeFromBase58)(base58));
      }
      /**
       * Decode string into buffer.
       *
       * @param str the string to decode into buffer format
       */
      static fromString(str) {
        return buffer_1.Buffer.from(str);
      }
      static toUtf8String(buffer) {
        return buffer_1.Buffer.from(buffer).toString();
      }
      /**
       * Check whether an array is byte, or typed, array
       *
       * @param array unknown The array that has to be checked
       *
       * @returns A boolean if the array is a byte array
       */
      static isTypedArray(array) {
        return "BYTES_PER_ELEMENT" in array;
      }
    };
    exports.TypedArrayEncoder = TypedArrayEncoder;
  }
});

// node_modules/@aries-framework/core/build/error/ValidationErrorUtils.js
var require_ValidationErrorUtils = __commonJS({
  "node_modules/@aries-framework/core/build/error/ValidationErrorUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidationErrorArray = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    function isValidationErrorArray(e) {
      if (Array.isArray(e)) {
        const isErrorArray = e.length > 0 && e.every((err) => err instanceof class_validator_1.ValidationError);
        return isErrorArray;
      }
      return false;
    }
    exports.isValidationErrorArray = isValidationErrorArray;
  }
});

// node_modules/@aries-framework/core/build/utils/MessageValidator.js
var require_MessageValidator = __commonJS({
  "node_modules/@aries-framework/core/build/utils/MessageValidator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageValidator = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var error_1 = require_error();
    var ValidationErrorUtils_1 = require_ValidationErrorUtils();
    var MessageValidator = class {
      /**
       *
       * @param classInstance the class instance to validate
       * @returns void
       * @throws array of validation errors {@link ValidationError}
       */
      // eslint-disable-next-line @typescript-eslint/ban-types
      static validateSync(classInstance) {
        const errors = (0, class_validator_1.validateSync)(classInstance);
        if ((0, ValidationErrorUtils_1.isValidationErrorArray)(errors)) {
          throw new error_1.ClassValidationError("Failed to validate class.", {
            classType: classInstance.constructor.name,
            validationErrors: errors
          });
        } else if (errors.length !== 0) {
          throw new error_1.ClassValidationError("An unknown validation error occurred.", {
            classType: Object.prototype.constructor(classInstance).name
          });
        }
      }
    };
    exports.MessageValidator = MessageValidator;
  }
});

// node_modules/@aries-framework/core/build/utils/JsonTransformer.js
var require_JsonTransformer = __commonJS({
  "node_modules/@aries-framework/core/build/utils/JsonTransformer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonTransformer = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var ClassValidationError_1 = require_ClassValidationError();
    var MessageValidator_1 = require_MessageValidator();
    var JsonTransformer = class {
      static toJSON(classInstance) {
        return (0, class_transformer_1.instanceToPlain)(classInstance, {
          exposeDefaultValues: true
        });
      }
      static fromJSON(json, cls, { validate: validate3 = true } = {}) {
        const instance2 = (0, class_transformer_1.plainToInstance)(cls, json, { exposeDefaultValues: true });
        if (!validate3)
          return instance2;
        if (!instance2) {
          throw new ClassValidationError_1.ClassValidationError("Cannot validate instance of ", { classType: Object.getPrototypeOf(cls).name });
        }
        MessageValidator_1.MessageValidator.validateSync(instance2);
        return instance2;
      }
      static clone(classInstance) {
        return (0, class_transformer_1.instanceToInstance)(classInstance, {
          exposeDefaultValues: true,
          enableCircularCheck: true,
          enableImplicitConversion: true,
          ignoreDecorators: true
        });
      }
      static serialize(classInstance) {
        return JSON.stringify(this.toJSON(classInstance));
      }
      static deserialize(jsonString, cls, { validate: validate3 = true } = {}) {
        return this.fromJSON(JSON.parse(jsonString), cls, { validate: validate3 });
      }
    };
    exports.JsonTransformer = JsonTransformer;
  }
});

// node_modules/@aries-framework/core/build/utils/MultiBaseEncoder.js
var require_MultiBaseEncoder = __commonJS({
  "node_modules/@aries-framework/core/build/utils/MultiBaseEncoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultiBaseEncoder = void 0;
    var base58_1 = require_base58();
    var multibaseEncodingMap = {
      base58btc: (data) => `z${(0, base58_1.encodeToBase58)(data)}`
    };
    var multibaseDecodingMap = {
      z: (data) => ({ data: (0, base58_1.decodeFromBase58)(data.substring(1)), baseName: "base58btc" })
    };
    var MultiBaseEncoder = class {
      /**
       *
       * Encodes a buffer into a multibase
       *
       * @param buffer the buffer that has to be encoded
       * @param baseName the encoding algorithm
       */
      static encode(buffer, baseName) {
        const encode = multibaseEncodingMap[baseName];
        if (!encode) {
          throw new Error(`Unsupported encoding '${baseName}'`);
        }
        return encode(buffer);
      }
      /**
       *
       * Decodes a multibase into a Uint8Array
       *
       * @param data the multibase that has to be decoded
       *
       * @returns decoded data and the multi base name
       */
      static decode(data) {
        const prefix = data[0];
        const decode = multibaseDecodingMap[prefix];
        if (!decode) {
          throw new Error(`No decoder found for multibase prefix '${prefix}'`);
        }
        return decode(data);
      }
      static isValid(data) {
        try {
          MultiBaseEncoder.decode(data);
          return true;
        } catch (error) {
          return false;
        }
      }
    };
    exports.MultiBaseEncoder = MultiBaseEncoder;
  }
});

// node_modules/@stablelib/int/lib/int.js
var require_int = __commonJS({
  "node_modules/@stablelib/int/lib/int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function imulShim(a, b) {
      var ah = a >>> 16 & 65535, al = a & 65535;
      var bh = b >>> 16 & 65535, bl = b & 65535;
      return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    }
    exports.mul = Math.imul || imulShim;
    function add(a, b) {
      return a + b | 0;
    }
    exports.add = add;
    function sub(a, b) {
      return a - b | 0;
    }
    exports.sub = sub;
    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    exports.rotl = rotl;
    function rotr(x, n) {
      return x << 32 - n | x >>> n;
    }
    exports.rotr = rotr;
    function isIntegerShim(n) {
      return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
    }
    exports.isInteger = Number.isInteger || isIntegerShim;
    exports.MAX_SAFE_INTEGER = 9007199254740991;
    exports.isSafeInteger = function(n) {
      return exports.isInteger(n) && (n >= -exports.MAX_SAFE_INTEGER && n <= exports.MAX_SAFE_INTEGER);
    };
  }
});

// node_modules/@stablelib/binary/lib/binary.js
var require_binary = __commonJS({
  "node_modules/@stablelib/binary/lib/binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var int_1 = require_int();
    function readInt16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
    }
    exports.readInt16BE = readInt16BE;
    function readUint16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
    }
    exports.readUint16BE = readUint16BE;
    function readInt16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
    }
    exports.readInt16LE = readInt16LE;
    function readUint16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports.readUint16LE = readUint16LE;
    function writeUint16BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 8;
      out[offset + 1] = value >>> 0;
      return out;
    }
    exports.writeUint16BE = writeUint16BE;
    exports.writeInt16BE = writeUint16BE;
    function writeUint16LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      return out;
    }
    exports.writeUint16LE = writeUint16LE;
    exports.writeInt16LE = writeUint16LE;
    function readInt32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
    }
    exports.readInt32BE = readInt32BE;
    function readUint32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
    }
    exports.readUint32BE = readUint32BE;
    function readInt32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
    }
    exports.readInt32LE = readInt32LE;
    function readUint32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports.readUint32LE = readUint32LE;
    function writeUint32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 24;
      out[offset + 1] = value >>> 16;
      out[offset + 2] = value >>> 8;
      out[offset + 3] = value >>> 0;
      return out;
    }
    exports.writeUint32BE = writeUint32BE;
    exports.writeInt32BE = writeUint32BE;
    function writeUint32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      out[offset + 2] = value >>> 16;
      out[offset + 3] = value >>> 24;
      return out;
    }
    exports.writeUint32LE = writeUint32LE;
    exports.writeInt32LE = writeUint32LE;
    function readInt64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readInt32BE(array, offset);
      var lo = readInt32BE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports.readInt64BE = readInt64BE;
    function readUint64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readUint32BE(array, offset);
      var lo = readUint32BE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports.readUint64BE = readUint64BE;
    function readInt64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readInt32LE(array, offset);
      var hi = readInt32LE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports.readInt64LE = readInt64LE;
    function readUint64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readUint32LE(array, offset);
      var hi = readUint32LE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports.readUint64LE = readUint64LE;
    function writeUint64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32BE(value / 4294967296 >>> 0, out, offset);
      writeUint32BE(value >>> 0, out, offset + 4);
      return out;
    }
    exports.writeUint64BE = writeUint64BE;
    exports.writeInt64BE = writeUint64BE;
    function writeUint64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32LE(value >>> 0, out, offset);
      writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
      return out;
    }
    exports.writeUint64LE = writeUint64LE;
    exports.writeInt64LE = writeUint64LE;
    function readUintBE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
      }
      var result2 = 0;
      var mul = 1;
      for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        result2 += array[i] * mul;
        mul *= 256;
      }
      return result2;
    }
    exports.readUintBE = readUintBE;
    function readUintLE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
      }
      var result2 = 0;
      var mul = 1;
      for (var i = offset; i < offset + bitLength / 8; i++) {
        result2 += array[i] * mul;
        mul *= 256;
      }
      return result2;
    }
    exports.readUintLE = readUintLE;
    function writeUintBE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintBE value must be an integer");
      }
      var div = 1;
      for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        out[i] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports.writeUintBE = writeUintBE;
    function writeUintLE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintLE value must be an integer");
      }
      var div = 1;
      for (var i = offset; i < offset + bitLength / 8; i++) {
        out[i] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports.writeUintLE = writeUintLE;
    function readFloat32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset);
    }
    exports.readFloat32BE = readFloat32BE;
    function readFloat32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset, true);
    }
    exports.readFloat32LE = readFloat32LE;
    function readFloat64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset);
    }
    exports.readFloat64BE = readFloat64BE;
    function readFloat64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset, true);
    }
    exports.readFloat64LE = readFloat64LE;
    function writeFloat32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value);
      return out;
    }
    exports.writeFloat32BE = writeFloat32BE;
    function writeFloat32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value, true);
      return out;
    }
    exports.writeFloat32LE = writeFloat32LE;
    function writeFloat64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value);
      return out;
    }
    exports.writeFloat64BE = writeFloat64BE;
    function writeFloat64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value, true);
      return out;
    }
    exports.writeFloat64LE = writeFloat64LE;
  }
});

// node_modules/@stablelib/wipe/lib/wipe.js
var require_wipe = __commonJS({
  "node_modules/@stablelib/wipe/lib/wipe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function wipe(array) {
      for (var i = 0; i < array.length; i++) {
        array[i] = 0;
      }
      return array;
    }
    exports.wipe = wipe;
  }
});

// node_modules/@stablelib/sha256/lib/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@stablelib/sha256/lib/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 32;
    exports.BLOCK_SIZE = 64;
    var SHA256 = (
      /** @class */
      function() {
        function SHA2562() {
          this.digestLength = exports.DIGEST_LENGTH;
          this.blockSize = exports.BLOCK_SIZE;
          this._state = new Int32Array(8);
          this._temp = new Int32Array(64);
          this._buffer = new Uint8Array(128);
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          this.reset();
        }
        SHA2562.prototype._initState = function() {
          this._state[0] = 1779033703;
          this._state[1] = 3144134277;
          this._state[2] = 1013904242;
          this._state[3] = 2773480762;
          this._state[4] = 1359893119;
          this._state[5] = 2600822924;
          this._state[6] = 528734635;
          this._state[7] = 1541459225;
        };
        SHA2562.prototype.reset = function() {
          this._initState();
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          return this;
        };
        SHA2562.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._temp);
          this.reset();
        };
        SHA2562.prototype.update = function(data, dataLength) {
          if (dataLength === void 0) {
            dataLength = data.length;
          }
          if (this._finished) {
            throw new Error("SHA256: can't update because hash was finished.");
          }
          var dataPos = 0;
          this._bytesHashed += dataLength;
          if (this._bufferLength > 0) {
            while (this._bufferLength < this.blockSize && dataLength > 0) {
              this._buffer[this._bufferLength++] = data[dataPos++];
              dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
              hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
              this._bufferLength = 0;
            }
          }
          if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
            dataLength %= this.blockSize;
          }
          while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          return this;
        };
        SHA2562.prototype.finish = function(out) {
          if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = bytesHashed / 536870912 | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = bytesHashed % 64 < 56 ? 64 : 128;
            this._buffer[left] = 128;
            for (var i = left + 1; i < padLength - 8; i++) {
              this._buffer[i] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
            this._finished = true;
          }
          for (var i = 0; i < this.digestLength / 4; i++) {
            binary_1.writeUint32BE(this._state[i], out, i * 4);
          }
          return this;
        };
        SHA2562.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        SHA2562.prototype.saveState = function() {
          if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
          }
          return {
            state: new Int32Array(this._state),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          };
        };
        SHA2562.prototype.restoreState = function(savedState) {
          this._state.set(savedState.state);
          this._bufferLength = savedState.bufferLength;
          if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
          }
          this._bytesHashed = savedState.bytesHashed;
          this._finished = false;
          return this;
        };
        SHA2562.prototype.cleanSavedState = function(savedState) {
          wipe_1.wipe(savedState.state);
          if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
          }
          savedState.bufferLength = 0;
          savedState.bytesHashed = 0;
        };
        return SHA2562;
      }()
    );
    exports.SHA256 = SHA256;
    var K = new Int32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    function hashBlocks(w, v, p, pos, len) {
      while (len >= 64) {
        var a = v[0];
        var b = v[1];
        var c = v[2];
        var d = v[3];
        var e = v[4];
        var f2 = v[5];
        var g = v[6];
        var h = v[7];
        for (var i = 0; i < 16; i++) {
          var j = pos + i * 4;
          w[i] = binary_1.readUint32BE(p, j);
        }
        for (var i = 16; i < 64; i++) {
          var u = w[i - 2];
          var t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
          u = w[i - 15];
          var t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
          w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
        }
        for (var i = 0; i < 64; i++) {
          var t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f2 ^ ~e & g) | 0) + (h + (K[i] + w[i] | 0) | 0) | 0;
          var t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
          h = g;
          g = f2;
          f2 = e;
          e = d + t1 | 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 | 0;
        }
        v[0] += a;
        v[1] += b;
        v[2] += c;
        v[3] += d;
        v[4] += e;
        v[5] += f2;
        v[6] += g;
        v[7] += h;
        pos += 64;
        len -= 64;
      }
      return pos;
    }
    function hash(data) {
      var h = new SHA256();
      h.update(data);
      var digest = h.digest();
      h.clean();
      return digest;
    }
    exports.hash = hash;
  }
});

// node_modules/@aries-framework/core/build/utils/Hasher.js
var require_Hasher = __commonJS({
  "node_modules/@aries-framework/core/build/utils/Hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hasher = void 0;
    var sha256_1 = require_sha256();
    var hashingMap = {
      "sha2-256": (data) => (0, sha256_1.hash)(data)
    };
    var Hasher = class {
      static hash(data, hashName) {
        const hashFn = hashingMap[hashName];
        if (!hashFn) {
          throw new Error(`Unsupported hash name '${hashName}'`);
        }
        return hashFn(data);
      }
    };
    exports.Hasher = Hasher;
  }
});

// node_modules/varint/encode.js
var require_encode = __commonJS({
  "node_modules/varint/encode.js"(exports, module) {
    module.exports = encode;
    var MSB = 128;
    var REST = 127;
    var MSBALL = ~REST;
    var INT = Math.pow(2, 31);
    function encode(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT) {
        out[offset++] = num & 255 | MSB;
        num /= 128;
      }
      while (num & MSBALL) {
        out[offset++] = num & 255 | MSB;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/varint/decode.js
var require_decode = __commonJS({
  "node_modules/varint/decode.js"(exports, module) {
    module.exports = read;
    var MSB = 128;
    var REST = 127;
    function read(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l || shift > 49) {
          read.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB);
      read.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/varint/length.js
var require_length = __commonJS({
  "node_modules/varint/length.js"(exports, module) {
    var N1 = Math.pow(2, 7);
    var N2 = Math.pow(2, 14);
    var N3 = Math.pow(2, 21);
    var N4 = Math.pow(2, 28);
    var N5 = Math.pow(2, 35);
    var N6 = Math.pow(2, 42);
    var N7 = Math.pow(2, 49);
    var N8 = Math.pow(2, 56);
    var N9 = Math.pow(2, 63);
    module.exports = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
  }
});

// node_modules/varint/index.js
var require_varint = __commonJS({
  "node_modules/varint/index.js"(exports, module) {
    module.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// node_modules/@aries-framework/core/build/utils/VarintEncoder.js
var require_VarintEncoder = __commonJS({
  "node_modules/@aries-framework/core/build/utils/VarintEncoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VarintEncoder = void 0;
    var varint_1 = require_varint();
    var buffer_1 = require_buffer2();
    var VarintEncoder = class {
      static decode(data) {
        const code = (0, varint_1.decode)(data);
        return [code, varint_1.decode.bytes];
      }
      static encode(int) {
        const target = new buffer_1.Buffer(VarintEncoder.encodingLength(int));
        (0, varint_1.encode)(int, target);
        return target;
      }
      static encodingLength(int) {
        return (0, varint_1.encodingLength)(int);
      }
    };
    exports.VarintEncoder = VarintEncoder;
  }
});

// node_modules/@aries-framework/core/build/utils/MultiHashEncoder.js
var require_MultiHashEncoder = __commonJS({
  "node_modules/@aries-framework/core/build/utils/MultiHashEncoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultiHashEncoder = void 0;
    var Hasher_1 = require_Hasher();
    var VarintEncoder_1 = require_VarintEncoder();
    var buffer_1 = require_buffer2();
    var multiHashNameMap = {
      "sha2-256": 18
    };
    var multiHashCodeMap = Object.entries(multiHashNameMap).reduce((map, [hashName, hashCode]) => Object.assign(Object.assign({}, map), { [hashCode]: hashName }), {});
    var MultiHashEncoder = class {
      /**
       *
       * Encodes a buffer into a hash
       *
       * @param buffer the buffer that has to be encoded
       * @param hashName the hashing algorithm, 'sha2-256'
       *
       * @returns a multihash
       */
      static encode(data, hashName) {
        const hash = Hasher_1.Hasher.hash(data, hashName);
        const hashCode = multiHashNameMap[hashName];
        const hashPrefix = VarintEncoder_1.VarintEncoder.encode(hashCode);
        const hashLengthPrefix = VarintEncoder_1.VarintEncoder.encode(hash.length);
        return buffer_1.Buffer.concat([hashPrefix, hashLengthPrefix, hash]);
      }
      /**
       *
       * Decodes the multihash
       *
       * @param data the multihash that has to be decoded
       *
       * @returns object with the data and the hashing algorithm
       */
      static decode(data) {
        const [hashPrefix, hashPrefixByteLength] = VarintEncoder_1.VarintEncoder.decode(data);
        const withoutHashPrefix = data.slice(hashPrefixByteLength);
        const [, lengthPrefixByteLength] = VarintEncoder_1.VarintEncoder.decode(withoutHashPrefix);
        const withoutLengthPrefix = withoutHashPrefix.slice(lengthPrefixByteLength);
        const hashName = multiHashCodeMap[hashPrefix];
        if (!hashName) {
          throw new Error(`Unsupported hash code 0x${hashPrefix.toString(16)}`);
        }
        return {
          data: buffer_1.Buffer.from(withoutLengthPrefix),
          hashName: multiHashCodeMap[hashPrefix]
        };
      }
      /**
       *
       * Validates if it is a valid mulithash
       *
       * @param data the multihash that needs to be validated
       *
       * @returns a boolean whether the multihash is valid
       */
      static isValid(data) {
        try {
          MultiHashEncoder.decode(data);
          return true;
        } catch (e) {
          return false;
        }
      }
    };
    exports.MultiHashEncoder = MultiHashEncoder;
  }
});

// node_modules/@aries-framework/core/build/utils/JWE.js
var require_JWE = __commonJS({
  "node_modules/@aries-framework/core/build/utils/JWE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidJweStructure = void 0;
    function isValidJweStructure(message) {
      return Boolean(message && typeof message === "object" && message !== null && typeof message.protected === "string" && message.iv && message.ciphertext && message.tag);
    }
    exports.isValidJweStructure = isValidJweStructure;
  }
});

// node_modules/@aries-framework/core/build/utils/regex.js
var require_regex = __commonJS({
  "node_modules/@aries-framework/core/build/utils/regex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.indyDidRegex = exports.credDefIdRegex = exports.schemaVersionRegex = exports.schemaIdRegex = void 0;
    exports.schemaIdRegex = /^[a-zA-Z0-9]{21,22}:2:.+:[0-9.]+$/;
    exports.schemaVersionRegex = /^(\d+\.)?(\d+\.)?(\*|\d+)$/;
    exports.credDefIdRegex = /^([a-zA-Z0-9]{21,22}):3:CL:(([1-9][0-9]*)|([a-zA-Z0-9]{21,22}:2:.+:[0-9.]+)):(.+)?$/;
    exports.indyDidRegex = /^(did:sov:)?[a-zA-Z0-9]{21,22}$/;
  }
});

// node_modules/@aries-framework/core/build/utils/indyProofRequest.js
var require_indyProofRequest = __commonJS({
  "node_modules/@aries-framework/core/build/utils/indyProofRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkProofRequestForDuplicates = void 0;
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    function attributeNamesToArray(proofRequest) {
      return Array.from(proofRequest.requestedAttributes.values()).reduce((names, a) => [...names, ...a.name ? [a.name] : a.names ? a.names : []], []);
    }
    function predicateNamesToArray(proofRequest) {
      return Array.from(new Set(Array.from(proofRequest.requestedPredicates.values()).map((a) => a.name)));
    }
    function assertNoDuplicates(predicates, attributeNames) {
      const duplicates = predicates.filter((item) => attributeNames.indexOf(item) !== -1);
      if (duplicates.length > 0) {
        throw new AriesFrameworkError_1.AriesFrameworkError(`The proof request contains duplicate predicates and attributes: ${duplicates.toString()}`);
      }
    }
    function checkProofRequestForDuplicates(proofRequest) {
      const attributes = attributeNamesToArray(proofRequest);
      const predicates = predicateNamesToArray(proofRequest);
      assertNoDuplicates(predicates, attributes);
    }
    exports.checkProofRequestForDuplicates = checkProofRequestForDuplicates;
  }
});

// node_modules/@aries-framework/core/build/utils/validators.js
var require_validators = __commonJS({
  "node_modules/@aries-framework/core/build/utils/validators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsUri = exports.UriValidator = exports.isStringArray = exports.IsInstanceOrArrayOfInstances = exports.IsStringOrInstance = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    function IsStringOrInstance(targetType, validationOptions) {
      return (0, class_validator_1.ValidateBy)({
        name: "IsStringOrInstance",
        constraints: [targetType],
        validator: {
          validate: (value, args) => (0, class_validator_1.isString)(value) || (0, class_validator_1.isInstance)(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, class_validator_1.buildMessage)((eachPrefix, args) => {
            if (args === null || args === void 0 ? void 0 : args.constraints[0]) {
              return eachPrefix + `$property must be of type string or instance of ${args.constraints[0].name}`;
            } else {
              return eachPrefix + `IsStringOrInstance decorator expects an object as value, but got falsy value.`;
            }
          }, validationOptions)
        }
      }, validationOptions);
    }
    exports.IsStringOrInstance = IsStringOrInstance;
    function IsInstanceOrArrayOfInstances(validationOptions) {
      return (0, class_validator_1.ValidateBy)({
        name: "isInstanceOrArrayOfInstances",
        validator: {
          validate: (value) => {
            if (Array.isArray(value)) {
              value.forEach((item) => {
                if (!(0, class_validator_1.isInstance)(item, validationOptions.classType)) {
                  return false;
                }
              });
              return true;
            }
            return (0, class_validator_1.isInstance)(value, validationOptions.classType);
          },
          defaultMessage: (0, class_validator_1.buildMessage)((eachPrefix) => eachPrefix + `$property must be a string or instance of ${validationOptions.classType.name}`, validationOptions)
        }
      }, validationOptions);
    }
    exports.IsInstanceOrArrayOfInstances = IsInstanceOrArrayOfInstances;
    function isStringArray(value) {
      return Array.isArray(value) && value.every((v) => typeof v === "string");
    }
    exports.isStringArray = isStringArray;
    exports.UriValidator = /\w+:(\/?\/?)[^\s]+/;
    function IsUri(validationOptions) {
      return (0, class_validator_1.ValidateBy)({
        name: "isUri",
        validator: {
          validate: (value) => {
            return exports.UriValidator.test(value);
          },
          defaultMessage: (0, class_validator_1.buildMessage)((eachPrefix) => eachPrefix + `$property must be a string that matches regex: ${exports.UriValidator.source}`, validationOptions)
        }
      }, validationOptions);
    }
    exports.IsUri = IsUri;
  }
});

// node_modules/@aries-framework/core/build/utils/type.js
var require_type = __commonJS({
  "node_modules/@aries-framework/core/build/utils/type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isJsonObject = exports.isBoolean = exports.isNumber = exports.isString = void 0;
    var isString2 = (value) => typeof value === "string";
    exports.isString = isString2;
    var isNumber2 = (value) => typeof value === "number";
    exports.isNumber = isNumber2;
    var isBoolean2 = (value) => typeof value === "boolean";
    exports.isBoolean = isBoolean2;
    var isJsonObject = (value) => {
      return value !== void 0 && typeof value === "object" && value !== null && !Array.isArray(value);
    };
    exports.isJsonObject = isJsonObject;
  }
});

// node_modules/@aries-framework/core/build/utils/indyIdentifiers.js
var require_indyIdentifiers = __commonJS({
  "node_modules/@aries-framework/core/build/utils/indyIdentifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLegacyCredentialDefinitionId = exports.getLegacySchemaId = exports.getQualifiedIndySchemaId = exports.getQualifiedIndyCredentialDefinitionId = exports.isQualifiedIndyIdentifier = void 0;
    function isQualifiedIndyIdentifier(identifier) {
      if (!identifier || identifier === "")
        return false;
      return identifier.startsWith("did:indy:");
    }
    exports.isQualifiedIndyIdentifier = isQualifiedIndyIdentifier;
    function getQualifiedIndyCredentialDefinitionId(indyNamespace, unqualifiedCredentialDefinitionId) {
      if (isQualifiedIndyIdentifier(unqualifiedCredentialDefinitionId))
        return unqualifiedCredentialDefinitionId;
      const [did, , , seqNo, tag] = unqualifiedCredentialDefinitionId.split(":");
      return `did:indy:${indyNamespace}:${did}/anoncreds/v0/CLAIM_DEF/${seqNo}/${tag}`;
    }
    exports.getQualifiedIndyCredentialDefinitionId = getQualifiedIndyCredentialDefinitionId;
    function getQualifiedIndySchemaId(indyNamespace, schemaId) {
      if (isQualifiedIndyIdentifier(schemaId))
        return schemaId;
      const [did, , schemaName, schemaVersion] = schemaId.split(":");
      return `did:indy:${indyNamespace}:${did}/anoncreds/v0/SCHEMA/${schemaName}/${schemaVersion}`;
    }
    exports.getQualifiedIndySchemaId = getQualifiedIndySchemaId;
    function getLegacySchemaId(unqualifiedDid, name, version2) {
      return `${unqualifiedDid}:2:${name}:${version2}`;
    }
    exports.getLegacySchemaId = getLegacySchemaId;
    function getLegacyCredentialDefinitionId(unqualifiedDid, seqNo, tag) {
      return `${unqualifiedDid}:3:CL:${seqNo}:${tag}`;
    }
    exports.getLegacyCredentialDefinitionId = getLegacyCredentialDefinitionId;
  }
});

// node_modules/@aries-framework/core/build/utils/objectEquality.js
var require_objectEquality = __commonJS({
  "node_modules/@aries-framework/core/build/utils/objectEquality.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.areObjectsEqual = void 0;
    function areObjectsEqual(a, b) {
      if (typeof a == "object" && a != null && typeof b == "object" && b != null) {
        if (Object.keys(a).length !== Object.keys(b).length)
          return false;
        for (const key in a) {
          if (!(key in b) || !areObjectsEqual(a[key], b[key])) {
            return false;
          }
        }
        for (const key in b) {
          if (!(key in a) || !areObjectsEqual(b[key], a[key])) {
            return false;
          }
        }
        return true;
      } else {
        return a === b;
      }
    }
    exports.areObjectsEqual = areObjectsEqual;
  }
});

// node_modules/@aries-framework/core/build/utils/deepEquality.js
var require_deepEquality = __commonJS({
  "node_modules/@aries-framework/core/build/utils/deepEquality.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deepEquality = void 0;
    var objectEquality_1 = require_objectEquality();
    function deepEquality(x, y) {
      const isXSimpleEqualY = simpleEqual(x, y);
      if (isXSimpleEqualY !== void 0)
        return isXSimpleEqualY;
      if (!(x instanceof Map) || !(y instanceof Map))
        return (0, objectEquality_1.areObjectsEqual)(x, y);
      const xMap = x;
      const yMap = y;
      const xKeys = Array.from(xMap.keys());
      const yKeys = Array.from(yMap.keys());
      if (!equalsIgnoreOrder(xKeys, yKeys))
        return false;
      return Array.from(xMap.entries()).every(([key, xVal]) => deepEquality(xVal, yMap.get(key)));
    }
    exports.deepEquality = deepEquality;
    function equalsIgnoreOrder(a, b) {
      if (a.length !== b.length)
        return false;
      return a.every((k) => b.includes(k));
    }
    function simpleEqual(x, y) {
      if (x === y)
        return true;
      if ((x === null || x === void 0) && (y === null || y === void 0))
        return x === y;
      if (x.constructor !== y.constructor)
        return false;
      if (x instanceof Function)
        return x === y;
      if (x instanceof RegExp)
        return x === y;
      if (x.valueOf && y.valueOf && x.valueOf() === y.valueOf())
        return true;
      if (x instanceof Date || y instanceof Date)
        return false;
    }
  }
});

// node_modules/@aries-framework/core/build/utils/index.js
var require_utils = __commonJS({
  "node_modules/@aries-framework/core/build/utils/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_TypedArrayEncoder(), exports);
    __exportStar(require_JsonEncoder(), exports);
    __exportStar(require_JsonTransformer(), exports);
    __exportStar(require_MultiBaseEncoder(), exports);
    __exportStar(require_buffer2(), exports);
    __exportStar(require_MultiHashEncoder(), exports);
    __exportStar(require_JWE(), exports);
    __exportStar(require_regex(), exports);
    __exportStar(require_indyProofRequest(), exports);
    __exportStar(require_VarintEncoder(), exports);
    __exportStar(require_Hasher(), exports);
    __exportStar(require_validators(), exports);
    __exportStar(require_type(), exports);
    __exportStar(require_indyIdentifiers(), exports);
    __exportStar(require_deepEquality(), exports);
    __exportStar(require_objectEquality(), exports);
  }
});

// node_modules/@aries-framework/core/build/crypto/multiCodecKey.js
var require_multiCodecKey = __commonJS({
  "node_modules/@aries-framework/core/build/crypto/multiCodecKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMultiCodecPrefixByKeytype = exports.getKeyTypeByMultiCodecPrefix = void 0;
    var KeyType_1 = require_KeyType();
    var multiCodecPrefixMap = {
      234: KeyType_1.KeyType.Bls12381g1,
      235: KeyType_1.KeyType.Bls12381g2,
      236: KeyType_1.KeyType.X25519,
      237: KeyType_1.KeyType.Ed25519,
      238: KeyType_1.KeyType.Bls12381g1g2
    };
    function getKeyTypeByMultiCodecPrefix(multiCodecPrefix) {
      const keyType = multiCodecPrefixMap[multiCodecPrefix];
      if (!keyType) {
        throw new Error(`Unsupported key type from multicodec code '${multiCodecPrefix}'`);
      }
      return keyType;
    }
    exports.getKeyTypeByMultiCodecPrefix = getKeyTypeByMultiCodecPrefix;
    function getMultiCodecPrefixByKeytype(keyType) {
      const codes = Object.keys(multiCodecPrefixMap);
      const code = codes.find((key) => multiCodecPrefixMap[key] === keyType);
      if (!code) {
        throw new Error(`Could not find multicodec prefix for key type '${keyType}'`);
      }
      return Number(code);
    }
    exports.getMultiCodecPrefixByKeytype = getMultiCodecPrefixByKeytype;
  }
});

// node_modules/@aries-framework/core/build/crypto/Key.js
var require_Key = __commonJS({
  "node_modules/@aries-framework/core/build/crypto/Key.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Key = void 0;
    var utils_1 = require_utils();
    var multiCodecKey_1 = require_multiCodecKey();
    var Key = class {
      constructor(publicKey, keyType) {
        this.publicKey = utils_1.Buffer.from(publicKey);
        this.keyType = keyType;
      }
      static fromPublicKey(publicKey, keyType) {
        return new Key(utils_1.Buffer.from(publicKey), keyType);
      }
      static fromPublicKeyBase58(publicKey, keyType) {
        const publicKeyBytes = utils_1.TypedArrayEncoder.fromBase58(publicKey);
        return Key.fromPublicKey(publicKeyBytes, keyType);
      }
      static fromFingerprint(fingerprint) {
        const { data } = utils_1.MultiBaseEncoder.decode(fingerprint);
        const [code, byteLength] = utils_1.VarintEncoder.decode(data);
        const publicKey = utils_1.Buffer.from(data.slice(byteLength));
        const keyType = (0, multiCodecKey_1.getKeyTypeByMultiCodecPrefix)(code);
        return new Key(publicKey, keyType);
      }
      get prefixedPublicKey() {
        const multiCodecPrefix = (0, multiCodecKey_1.getMultiCodecPrefixByKeytype)(this.keyType);
        const prefixBytes = utils_1.VarintEncoder.encode(multiCodecPrefix);
        return utils_1.Buffer.concat([prefixBytes, this.publicKey]);
      }
      get fingerprint() {
        return `z${utils_1.TypedArrayEncoder.toBase58(this.prefixedPublicKey)}`;
      }
      get publicKeyBase58() {
        return utils_1.TypedArrayEncoder.toBase58(this.publicKey);
      }
    };
    exports.Key = Key;
  }
});

// node_modules/@aries-framework/core/build/crypto/signing-provider/SigningProvider.js
var require_SigningProvider = __commonJS({
  "node_modules/@aries-framework/core/build/crypto/signing-provider/SigningProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/tsyringe/dist/esm5/types/lifecycle.js
var Lifecycle, lifecycle_default;
var init_lifecycle = __esm({
  "node_modules/tsyringe/dist/esm5/types/lifecycle.js"() {
    (function(Lifecycle2) {
      Lifecycle2[Lifecycle2["Transient"] = 0] = "Transient";
      Lifecycle2[Lifecycle2["Singleton"] = 1] = "Singleton";
      Lifecycle2[Lifecycle2["ResolutionScoped"] = 2] = "ResolutionScoped";
      Lifecycle2[Lifecycle2["ContainerScoped"] = 3] = "ContainerScoped";
    })(Lifecycle || (Lifecycle = {}));
    lifecycle_default = Lifecycle;
  }
});

// node_modules/tsyringe/dist/esm5/types/index.js
var init_types = __esm({
  "node_modules/tsyringe/dist/esm5/types/index.js"() {
    init_lifecycle();
  }
});

// node_modules/tsyringe/node_modules/tslib/tslib.es6.js
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter2(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator2(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f2 = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values2(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
var extendStatics;
var init_tslib_es6 = __esm({
  "node_modules/tsyringe/node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
  }
});

// node_modules/tsyringe/dist/esm5/reflection-helpers.js
function getParamInfo(target) {
  var params = Reflect.getMetadata("design:paramtypes", target) || [];
  var injectionTokens = Reflect.getOwnMetadata(INJECTION_TOKEN_METADATA_KEY, target) || {};
  Object.keys(injectionTokens).forEach(function(key) {
    params[+key] = injectionTokens[key];
  });
  return params;
}
function defineInjectionTokenMetadata(data, transform) {
  return function(target, _propertyKey, parameterIndex) {
    var descriptors = Reflect.getOwnMetadata(INJECTION_TOKEN_METADATA_KEY, target) || {};
    descriptors[parameterIndex] = transform ? {
      token: data,
      transform: transform.transformToken,
      transformArgs: transform.args || []
    } : data;
    Reflect.defineMetadata(INJECTION_TOKEN_METADATA_KEY, descriptors, target);
  };
}
var INJECTION_TOKEN_METADATA_KEY;
var init_reflection_helpers = __esm({
  "node_modules/tsyringe/dist/esm5/reflection-helpers.js"() {
    INJECTION_TOKEN_METADATA_KEY = "injectionTokens";
  }
});

// node_modules/tsyringe/dist/esm5/providers/class-provider.js
function isClassProvider(provider) {
  return !!provider.useClass;
}
var init_class_provider = __esm({
  "node_modules/tsyringe/dist/esm5/providers/class-provider.js"() {
  }
});

// node_modules/tsyringe/dist/esm5/providers/factory-provider.js
function isFactoryProvider(provider) {
  return !!provider.useFactory;
}
var init_factory_provider = __esm({
  "node_modules/tsyringe/dist/esm5/providers/factory-provider.js"() {
  }
});

// node_modules/tsyringe/dist/esm5/lazy-helpers.js
function delay(wrappedConstructor) {
  if (typeof wrappedConstructor === "undefined") {
    throw new Error("Attempt to `delay` undefined. Constructor must be wrapped in a callback");
  }
  return new DelayedConstructor(wrappedConstructor);
}
var DelayedConstructor;
var init_lazy_helpers = __esm({
  "node_modules/tsyringe/dist/esm5/lazy-helpers.js"() {
    init_tslib_es6();
    DelayedConstructor = function() {
      function DelayedConstructor2(wrap) {
        this.wrap = wrap;
        this.reflectMethods = [
          "get",
          "getPrototypeOf",
          "setPrototypeOf",
          "getOwnPropertyDescriptor",
          "defineProperty",
          "has",
          "set",
          "deleteProperty",
          "apply",
          "construct",
          "ownKeys"
        ];
      }
      DelayedConstructor2.prototype.createProxy = function(createObject) {
        var _this = this;
        var target = {};
        var init = false;
        var value;
        var delayedObject = function() {
          if (!init) {
            value = createObject(_this.wrap());
            init = true;
          }
          return value;
        };
        return new Proxy(target, this.createHandler(delayedObject));
      };
      DelayedConstructor2.prototype.createHandler = function(delayedObject) {
        var handler = {};
        var install = function(name) {
          handler[name] = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            args[0] = delayedObject();
            var method = Reflect[name];
            return method.apply(void 0, __spread(args));
          };
        };
        this.reflectMethods.forEach(install);
        return handler;
      };
      return DelayedConstructor2;
    }();
  }
});

// node_modules/tsyringe/dist/esm5/providers/injection-token.js
function isNormalToken(token) {
  return typeof token === "string" || typeof token === "symbol";
}
function isTokenDescriptor(descriptor) {
  return typeof descriptor === "object" && "token" in descriptor && "multiple" in descriptor;
}
function isTransformDescriptor(descriptor) {
  return typeof descriptor === "object" && "token" in descriptor && "transform" in descriptor;
}
function isConstructorToken(token) {
  return typeof token === "function" || token instanceof DelayedConstructor;
}
var init_injection_token = __esm({
  "node_modules/tsyringe/dist/esm5/providers/injection-token.js"() {
    init_lazy_helpers();
  }
});

// node_modules/tsyringe/dist/esm5/providers/token-provider.js
function isTokenProvider(provider) {
  return !!provider.useToken;
}
var init_token_provider = __esm({
  "node_modules/tsyringe/dist/esm5/providers/token-provider.js"() {
  }
});

// node_modules/tsyringe/dist/esm5/providers/value-provider.js
function isValueProvider(provider) {
  return provider.useValue != void 0;
}
var init_value_provider = __esm({
  "node_modules/tsyringe/dist/esm5/providers/value-provider.js"() {
  }
});

// node_modules/tsyringe/dist/esm5/providers/index.js
var init_providers = __esm({
  "node_modules/tsyringe/dist/esm5/providers/index.js"() {
    init_class_provider();
    init_factory_provider();
    init_injection_token();
    init_token_provider();
    init_value_provider();
  }
});

// node_modules/tsyringe/dist/esm5/providers/provider.js
function isProvider(provider) {
  return isClassProvider(provider) || isValueProvider(provider) || isTokenProvider(provider) || isFactoryProvider(provider);
}
var init_provider = __esm({
  "node_modules/tsyringe/dist/esm5/providers/provider.js"() {
    init_class_provider();
    init_value_provider();
    init_token_provider();
    init_factory_provider();
  }
});

// node_modules/tsyringe/dist/esm5/registry-base.js
var RegistryBase, registry_base_default;
var init_registry_base = __esm({
  "node_modules/tsyringe/dist/esm5/registry-base.js"() {
    RegistryBase = function() {
      function RegistryBase2() {
        this._registryMap = /* @__PURE__ */ new Map();
      }
      RegistryBase2.prototype.entries = function() {
        return this._registryMap.entries();
      };
      RegistryBase2.prototype.getAll = function(key) {
        this.ensure(key);
        return this._registryMap.get(key);
      };
      RegistryBase2.prototype.get = function(key) {
        this.ensure(key);
        var value = this._registryMap.get(key);
        return value[value.length - 1] || null;
      };
      RegistryBase2.prototype.set = function(key, value) {
        this.ensure(key);
        this._registryMap.get(key).push(value);
      };
      RegistryBase2.prototype.setAll = function(key, value) {
        this._registryMap.set(key, value);
      };
      RegistryBase2.prototype.has = function(key) {
        this.ensure(key);
        return this._registryMap.get(key).length > 0;
      };
      RegistryBase2.prototype.clear = function() {
        this._registryMap.clear();
      };
      RegistryBase2.prototype.ensure = function(key) {
        if (!this._registryMap.has(key)) {
          this._registryMap.set(key, []);
        }
      };
      return RegistryBase2;
    }();
    registry_base_default = RegistryBase;
  }
});

// node_modules/tsyringe/dist/esm5/registry.js
var Registry, registry_default;
var init_registry = __esm({
  "node_modules/tsyringe/dist/esm5/registry.js"() {
    init_tslib_es6();
    init_registry_base();
    Registry = function(_super) {
      __extends(Registry2, _super);
      function Registry2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return Registry2;
    }(registry_base_default);
    registry_default = Registry;
  }
});

// node_modules/tsyringe/dist/esm5/resolution-context.js
var ResolutionContext, resolution_context_default;
var init_resolution_context = __esm({
  "node_modules/tsyringe/dist/esm5/resolution-context.js"() {
    ResolutionContext = function() {
      function ResolutionContext2() {
        this.scopedResolutions = /* @__PURE__ */ new Map();
      }
      return ResolutionContext2;
    }();
    resolution_context_default = ResolutionContext;
  }
});

// node_modules/tsyringe/dist/esm5/error-helpers.js
function formatDependency(params, idx) {
  if (params === null) {
    return "at position #" + idx;
  }
  var argName = params.split(",")[idx].trim();
  return '"' + argName + '" at position #' + idx;
}
function composeErrorMessage(msg, e, indent) {
  if (indent === void 0) {
    indent = "    ";
  }
  return __spread([msg], e.message.split("\n").map(function(l) {
    return indent + l;
  })).join("\n");
}
function formatErrorCtor(ctor, paramIdx, error) {
  var _a = __read(ctor.toString().match(/constructor\(([\w, ]+)\)/) || [], 2), _b = _a[1], params = _b === void 0 ? null : _b;
  var dep = formatDependency(params, paramIdx);
  return composeErrorMessage("Cannot inject the dependency " + dep + ' of "' + ctor.name + '" constructor. Reason:', error);
}
var init_error_helpers = __esm({
  "node_modules/tsyringe/dist/esm5/error-helpers.js"() {
    init_tslib_es6();
  }
});

// node_modules/tsyringe/dist/esm5/types/disposable.js
function isDisposable(value) {
  if (typeof value.dispose !== "function")
    return false;
  var disposeFun = value.dispose;
  if (disposeFun.length > 0) {
    return false;
  }
  return true;
}
var init_disposable = __esm({
  "node_modules/tsyringe/dist/esm5/types/disposable.js"() {
  }
});

// node_modules/tsyringe/dist/esm5/interceptors.js
var PreResolutionInterceptors, PostResolutionInterceptors, Interceptors, interceptors_default;
var init_interceptors = __esm({
  "node_modules/tsyringe/dist/esm5/interceptors.js"() {
    init_tslib_es6();
    init_registry_base();
    PreResolutionInterceptors = function(_super) {
      __extends(PreResolutionInterceptors2, _super);
      function PreResolutionInterceptors2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return PreResolutionInterceptors2;
    }(registry_base_default);
    PostResolutionInterceptors = function(_super) {
      __extends(PostResolutionInterceptors2, _super);
      function PostResolutionInterceptors2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return PostResolutionInterceptors2;
    }(registry_base_default);
    Interceptors = function() {
      function Interceptors2() {
        this.preResolution = new PreResolutionInterceptors();
        this.postResolution = new PostResolutionInterceptors();
      }
      return Interceptors2;
    }();
    interceptors_default = Interceptors;
  }
});

// node_modules/tsyringe/dist/esm5/dependency-container.js
var typeInfo, InternalDependencyContainer, instance;
var init_dependency_container = __esm({
  "node_modules/tsyringe/dist/esm5/dependency-container.js"() {
    init_tslib_es6();
    init_providers();
    init_provider();
    init_injection_token();
    init_registry();
    init_lifecycle();
    init_resolution_context();
    init_error_helpers();
    init_lazy_helpers();
    init_disposable();
    init_interceptors();
    typeInfo = /* @__PURE__ */ new Map();
    InternalDependencyContainer = function() {
      function InternalDependencyContainer2(parent) {
        this.parent = parent;
        this._registry = new registry_default();
        this.interceptors = new interceptors_default();
        this.disposed = false;
        this.disposables = /* @__PURE__ */ new Set();
      }
      InternalDependencyContainer2.prototype.register = function(token, providerOrConstructor, options) {
        if (options === void 0) {
          options = { lifecycle: lifecycle_default.Transient };
        }
        this.ensureNotDisposed();
        var provider;
        if (!isProvider(providerOrConstructor)) {
          provider = { useClass: providerOrConstructor };
        } else {
          provider = providerOrConstructor;
        }
        if (isTokenProvider(provider)) {
          var path = [token];
          var tokenProvider = provider;
          while (tokenProvider != null) {
            var currentToken = tokenProvider.useToken;
            if (path.includes(currentToken)) {
              throw new Error("Token registration cycle detected! " + __spread(path, [currentToken]).join(" -> "));
            }
            path.push(currentToken);
            var registration = this._registry.get(currentToken);
            if (registration && isTokenProvider(registration.provider)) {
              tokenProvider = registration.provider;
            } else {
              tokenProvider = null;
            }
          }
        }
        if (options.lifecycle === lifecycle_default.Singleton || options.lifecycle == lifecycle_default.ContainerScoped || options.lifecycle == lifecycle_default.ResolutionScoped) {
          if (isValueProvider(provider) || isFactoryProvider(provider)) {
            throw new Error('Cannot use lifecycle "' + lifecycle_default[options.lifecycle] + '" with ValueProviders or FactoryProviders');
          }
        }
        this._registry.set(token, { provider, options });
        return this;
      };
      InternalDependencyContainer2.prototype.registerType = function(from, to) {
        this.ensureNotDisposed();
        if (isNormalToken(to)) {
          return this.register(from, {
            useToken: to
          });
        }
        return this.register(from, {
          useClass: to
        });
      };
      InternalDependencyContainer2.prototype.registerInstance = function(token, instance2) {
        this.ensureNotDisposed();
        return this.register(token, {
          useValue: instance2
        });
      };
      InternalDependencyContainer2.prototype.registerSingleton = function(from, to) {
        this.ensureNotDisposed();
        if (isNormalToken(from)) {
          if (isNormalToken(to)) {
            return this.register(from, {
              useToken: to
            }, { lifecycle: lifecycle_default.Singleton });
          } else if (to) {
            return this.register(from, {
              useClass: to
            }, { lifecycle: lifecycle_default.Singleton });
          }
          throw new Error('Cannot register a type name as a singleton without a "to" token');
        }
        var useClass = from;
        if (to && !isNormalToken(to)) {
          useClass = to;
        }
        return this.register(from, {
          useClass
        }, { lifecycle: lifecycle_default.Singleton });
      };
      InternalDependencyContainer2.prototype.resolve = function(token, context2) {
        if (context2 === void 0) {
          context2 = new resolution_context_default();
        }
        this.ensureNotDisposed();
        var registration = this.getRegistration(token);
        if (!registration && isNormalToken(token)) {
          throw new Error('Attempted to resolve unregistered dependency token: "' + token.toString() + '"');
        }
        this.executePreResolutionInterceptor(token, "Single");
        if (registration) {
          var result2 = this.resolveRegistration(registration, context2);
          this.executePostResolutionInterceptor(token, result2, "Single");
          return result2;
        }
        if (isConstructorToken(token)) {
          var result2 = this.construct(token, context2);
          this.executePostResolutionInterceptor(token, result2, "Single");
          return result2;
        }
        throw new Error("Attempted to construct an undefined constructor. Could mean a circular dependency problem. Try using `delay` function.");
      };
      InternalDependencyContainer2.prototype.executePreResolutionInterceptor = function(token, resolutionType) {
        var e_1, _a;
        if (this.interceptors.preResolution.has(token)) {
          var remainingInterceptors = [];
          try {
            for (var _b = __values2(this.interceptors.preResolution.getAll(token)), _c = _b.next(); !_c.done; _c = _b.next()) {
              var interceptor = _c.value;
              if (interceptor.options.frequency != "Once") {
                remainingInterceptors.push(interceptor);
              }
              interceptor.callback(token, resolutionType);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          this.interceptors.preResolution.setAll(token, remainingInterceptors);
        }
      };
      InternalDependencyContainer2.prototype.executePostResolutionInterceptor = function(token, result2, resolutionType) {
        var e_2, _a;
        if (this.interceptors.postResolution.has(token)) {
          var remainingInterceptors = [];
          try {
            for (var _b = __values2(this.interceptors.postResolution.getAll(token)), _c = _b.next(); !_c.done; _c = _b.next()) {
              var interceptor = _c.value;
              if (interceptor.options.frequency != "Once") {
                remainingInterceptors.push(interceptor);
              }
              interceptor.callback(token, result2, resolutionType);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
          this.interceptors.postResolution.setAll(token, remainingInterceptors);
        }
      };
      InternalDependencyContainer2.prototype.resolveRegistration = function(registration, context2) {
        this.ensureNotDisposed();
        if (registration.options.lifecycle === lifecycle_default.ResolutionScoped && context2.scopedResolutions.has(registration)) {
          return context2.scopedResolutions.get(registration);
        }
        var isSingleton = registration.options.lifecycle === lifecycle_default.Singleton;
        var isContainerScoped = registration.options.lifecycle === lifecycle_default.ContainerScoped;
        var returnInstance = isSingleton || isContainerScoped;
        var resolved;
        if (isValueProvider(registration.provider)) {
          resolved = registration.provider.useValue;
        } else if (isTokenProvider(registration.provider)) {
          resolved = returnInstance ? registration.instance || (registration.instance = this.resolve(registration.provider.useToken, context2)) : this.resolve(registration.provider.useToken, context2);
        } else if (isClassProvider(registration.provider)) {
          resolved = returnInstance ? registration.instance || (registration.instance = this.construct(registration.provider.useClass, context2)) : this.construct(registration.provider.useClass, context2);
        } else if (isFactoryProvider(registration.provider)) {
          resolved = registration.provider.useFactory(this);
        } else {
          resolved = this.construct(registration.provider, context2);
        }
        if (registration.options.lifecycle === lifecycle_default.ResolutionScoped) {
          context2.scopedResolutions.set(registration, resolved);
        }
        return resolved;
      };
      InternalDependencyContainer2.prototype.resolveAll = function(token, context2) {
        var _this = this;
        if (context2 === void 0) {
          context2 = new resolution_context_default();
        }
        this.ensureNotDisposed();
        var registrations = this.getAllRegistrations(token);
        if (!registrations && isNormalToken(token)) {
          throw new Error('Attempted to resolve unregistered dependency token: "' + token.toString() + '"');
        }
        this.executePreResolutionInterceptor(token, "All");
        if (registrations) {
          var result_1 = registrations.map(function(item) {
            return _this.resolveRegistration(item, context2);
          });
          this.executePostResolutionInterceptor(token, result_1, "All");
          return result_1;
        }
        var result2 = [this.construct(token, context2)];
        this.executePostResolutionInterceptor(token, result2, "All");
        return result2;
      };
      InternalDependencyContainer2.prototype.isRegistered = function(token, recursive) {
        if (recursive === void 0) {
          recursive = false;
        }
        this.ensureNotDisposed();
        return this._registry.has(token) || recursive && (this.parent || false) && this.parent.isRegistered(token, true);
      };
      InternalDependencyContainer2.prototype.reset = function() {
        this.ensureNotDisposed();
        this._registry.clear();
        this.interceptors.preResolution.clear();
        this.interceptors.postResolution.clear();
      };
      InternalDependencyContainer2.prototype.clearInstances = function() {
        var e_3, _a;
        this.ensureNotDisposed();
        try {
          for (var _b = __values2(this._registry.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read(_c.value, 2), token = _d[0], registrations = _d[1];
            this._registry.setAll(token, registrations.filter(function(registration) {
              return !isValueProvider(registration.provider);
            }).map(function(registration) {
              registration.instance = void 0;
              return registration;
            }));
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
      };
      InternalDependencyContainer2.prototype.createChildContainer = function() {
        var e_4, _a;
        this.ensureNotDisposed();
        var childContainer = new InternalDependencyContainer2(this);
        try {
          for (var _b = __values2(this._registry.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read(_c.value, 2), token = _d[0], registrations = _d[1];
            if (registrations.some(function(_a2) {
              var options = _a2.options;
              return options.lifecycle === lifecycle_default.ContainerScoped;
            })) {
              childContainer._registry.setAll(token, registrations.map(function(registration) {
                if (registration.options.lifecycle === lifecycle_default.ContainerScoped) {
                  return {
                    provider: registration.provider,
                    options: registration.options
                  };
                }
                return registration;
              }));
            }
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
        return childContainer;
      };
      InternalDependencyContainer2.prototype.beforeResolution = function(token, callback, options) {
        if (options === void 0) {
          options = { frequency: "Always" };
        }
        this.interceptors.preResolution.set(token, {
          callback,
          options
        });
      };
      InternalDependencyContainer2.prototype.afterResolution = function(token, callback, options) {
        if (options === void 0) {
          options = { frequency: "Always" };
        }
        this.interceptors.postResolution.set(token, {
          callback,
          options
        });
      };
      InternalDependencyContainer2.prototype.dispose = function() {
        return __awaiter2(this, void 0, void 0, function() {
          var promises;
          return __generator2(this, function(_a) {
            switch (_a.label) {
              case 0:
                this.disposed = true;
                promises = [];
                this.disposables.forEach(function(disposable) {
                  var maybePromise = disposable.dispose();
                  if (maybePromise) {
                    promises.push(maybePromise);
                  }
                });
                return [4, Promise.all(promises)];
              case 1:
                _a.sent();
                return [2];
            }
          });
        });
      };
      InternalDependencyContainer2.prototype.getRegistration = function(token) {
        if (this.isRegistered(token)) {
          return this._registry.get(token);
        }
        if (this.parent) {
          return this.parent.getRegistration(token);
        }
        return null;
      };
      InternalDependencyContainer2.prototype.getAllRegistrations = function(token) {
        if (this.isRegistered(token)) {
          return this._registry.getAll(token);
        }
        if (this.parent) {
          return this.parent.getAllRegistrations(token);
        }
        return null;
      };
      InternalDependencyContainer2.prototype.construct = function(ctor, context2) {
        var _this = this;
        if (ctor instanceof DelayedConstructor) {
          return ctor.createProxy(function(target) {
            return _this.resolve(target, context2);
          });
        }
        var instance2 = function() {
          var paramInfo = typeInfo.get(ctor);
          if (!paramInfo || paramInfo.length === 0) {
            if (ctor.length === 0) {
              return new ctor();
            } else {
              throw new Error('TypeInfo not known for "' + ctor.name + '"');
            }
          }
          var params = paramInfo.map(_this.resolveParams(context2, ctor));
          return new (ctor.bind.apply(ctor, __spread([void 0], params)))();
        }();
        if (isDisposable(instance2)) {
          this.disposables.add(instance2);
        }
        return instance2;
      };
      InternalDependencyContainer2.prototype.resolveParams = function(context2, ctor) {
        var _this = this;
        return function(param, idx) {
          var _a, _b, _c;
          try {
            if (isTokenDescriptor(param)) {
              if (isTransformDescriptor(param)) {
                return param.multiple ? (_a = _this.resolve(param.transform)).transform.apply(_a, __spread([_this.resolveAll(param.token)], param.transformArgs)) : (_b = _this.resolve(param.transform)).transform.apply(_b, __spread([_this.resolve(param.token, context2)], param.transformArgs));
              } else {
                return param.multiple ? _this.resolveAll(param.token) : _this.resolve(param.token, context2);
              }
            } else if (isTransformDescriptor(param)) {
              return (_c = _this.resolve(param.transform, context2)).transform.apply(_c, __spread([_this.resolve(param.token, context2)], param.transformArgs));
            }
            return _this.resolve(param, context2);
          } catch (e) {
            throw new Error(formatErrorCtor(ctor, idx, e));
          }
        };
      };
      InternalDependencyContainer2.prototype.ensureNotDisposed = function() {
        if (this.disposed) {
          throw new Error("This container has been disposed, you cannot interact with a disposed container");
        }
      };
      return InternalDependencyContainer2;
    }();
    instance = new InternalDependencyContainer();
  }
});

// node_modules/tsyringe/dist/esm5/decorators/auto-injectable.js
function autoInjectable() {
  return function(target) {
    var paramInfo = getParamInfo(target);
    return function(_super) {
      __extends(class_1, _super);
      function class_1() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return _super.apply(this, __spread(args.concat(paramInfo.slice(args.length).map(function(type, index) {
          var _a, _b, _c;
          try {
            if (isTokenDescriptor(type)) {
              if (isTransformDescriptor(type)) {
                return type.multiple ? (_a = instance.resolve(type.transform)).transform.apply(_a, __spread([instance.resolveAll(type.token)], type.transformArgs)) : (_b = instance.resolve(type.transform)).transform.apply(_b, __spread([instance.resolve(type.token)], type.transformArgs));
              } else {
                return type.multiple ? instance.resolveAll(type.token) : instance.resolve(type.token);
              }
            } else if (isTransformDescriptor(type)) {
              return (_c = instance.resolve(type.transform)).transform.apply(_c, __spread([instance.resolve(type.token)], type.transformArgs));
            }
            return instance.resolve(type);
          } catch (e) {
            var argIndex = index + args.length;
            throw new Error(formatErrorCtor(target, argIndex, e));
          }
        })))) || this;
      }
      return class_1;
    }(target);
  };
}
var auto_injectable_default;
var init_auto_injectable = __esm({
  "node_modules/tsyringe/dist/esm5/decorators/auto-injectable.js"() {
    init_tslib_es6();
    init_reflection_helpers();
    init_dependency_container();
    init_injection_token();
    init_error_helpers();
    auto_injectable_default = autoInjectable;
  }
});

// node_modules/tsyringe/dist/esm5/decorators/inject.js
function inject(token) {
  return defineInjectionTokenMetadata(token);
}
var inject_default;
var init_inject = __esm({
  "node_modules/tsyringe/dist/esm5/decorators/inject.js"() {
    init_reflection_helpers();
    inject_default = inject;
  }
});

// node_modules/tsyringe/dist/esm5/decorators/injectable.js
function injectable() {
  return function(target) {
    typeInfo.set(target, getParamInfo(target));
  };
}
var injectable_default;
var init_injectable = __esm({
  "node_modules/tsyringe/dist/esm5/decorators/injectable.js"() {
    init_reflection_helpers();
    init_dependency_container();
    injectable_default = injectable;
  }
});

// node_modules/tsyringe/dist/esm5/decorators/registry.js
function registry(registrations) {
  if (registrations === void 0) {
    registrations = [];
  }
  return function(target) {
    registrations.forEach(function(_a) {
      var token = _a.token, options = _a.options, provider = __rest(_a, ["token", "options"]);
      return instance.register(token, provider, options);
    });
    return target;
  };
}
var registry_default2;
var init_registry2 = __esm({
  "node_modules/tsyringe/dist/esm5/decorators/registry.js"() {
    init_tslib_es6();
    init_dependency_container();
    registry_default2 = registry;
  }
});

// node_modules/tsyringe/dist/esm5/decorators/singleton.js
function singleton() {
  return function(target) {
    injectable_default()(target);
    instance.registerSingleton(target);
  };
}
var singleton_default;
var init_singleton = __esm({
  "node_modules/tsyringe/dist/esm5/decorators/singleton.js"() {
    init_injectable();
    init_dependency_container();
    singleton_default = singleton;
  }
});

// node_modules/tsyringe/dist/esm5/decorators/inject-all.js
function injectAll(token) {
  var data = { token, multiple: true };
  return defineInjectionTokenMetadata(data);
}
var inject_all_default;
var init_inject_all = __esm({
  "node_modules/tsyringe/dist/esm5/decorators/inject-all.js"() {
    init_reflection_helpers();
    inject_all_default = injectAll;
  }
});

// node_modules/tsyringe/dist/esm5/decorators/inject-all-with-transform.js
function injectAllWithTransform(token, transformer) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  var data = {
    token,
    multiple: true,
    transform: transformer,
    transformArgs: args
  };
  return defineInjectionTokenMetadata(data);
}
var inject_all_with_transform_default;
var init_inject_all_with_transform = __esm({
  "node_modules/tsyringe/dist/esm5/decorators/inject-all-with-transform.js"() {
    init_reflection_helpers();
    inject_all_with_transform_default = injectAllWithTransform;
  }
});

// node_modules/tsyringe/dist/esm5/decorators/inject-with-transform.js
function injectWithTransform(token, transformer) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  return defineInjectionTokenMetadata(token, {
    transformToken: transformer,
    args
  });
}
var inject_with_transform_default;
var init_inject_with_transform = __esm({
  "node_modules/tsyringe/dist/esm5/decorators/inject-with-transform.js"() {
    init_reflection_helpers();
    inject_with_transform_default = injectWithTransform;
  }
});

// node_modules/tsyringe/dist/esm5/decorators/scoped.js
function scoped(lifecycle, token) {
  return function(target) {
    injectable_default()(target);
    instance.register(token || target, target, {
      lifecycle
    });
  };
}
var init_scoped = __esm({
  "node_modules/tsyringe/dist/esm5/decorators/scoped.js"() {
    init_injectable();
    init_dependency_container();
  }
});

// node_modules/tsyringe/dist/esm5/decorators/index.js
var init_decorators3 = __esm({
  "node_modules/tsyringe/dist/esm5/decorators/index.js"() {
    init_auto_injectable();
    init_inject();
    init_injectable();
    init_registry2();
    init_singleton();
    init_inject_all();
    init_inject_all_with_transform();
    init_inject_with_transform();
    init_scoped();
  }
});

// node_modules/tsyringe/dist/esm5/factories/instance-caching-factory.js
function instanceCachingFactory(factoryFunc) {
  var instance2;
  return function(dependencyContainer) {
    if (instance2 == void 0) {
      instance2 = factoryFunc(dependencyContainer);
    }
    return instance2;
  };
}
var init_instance_caching_factory = __esm({
  "node_modules/tsyringe/dist/esm5/factories/instance-caching-factory.js"() {
  }
});

// node_modules/tsyringe/dist/esm5/factories/instance-per-container-caching-factory.js
function instancePerContainerCachingFactory(factoryFunc) {
  var cache = /* @__PURE__ */ new WeakMap();
  return function(dependencyContainer) {
    var instance2 = cache.get(dependencyContainer);
    if (instance2 == void 0) {
      instance2 = factoryFunc(dependencyContainer);
      cache.set(dependencyContainer, instance2);
    }
    return instance2;
  };
}
var init_instance_per_container_caching_factory = __esm({
  "node_modules/tsyringe/dist/esm5/factories/instance-per-container-caching-factory.js"() {
  }
});

// node_modules/tsyringe/dist/esm5/factories/predicate-aware-class-factory.js
function predicateAwareClassFactory(predicate, trueConstructor, falseConstructor, useCaching) {
  if (useCaching === void 0) {
    useCaching = true;
  }
  var instance2;
  var previousPredicate;
  return function(dependencyContainer) {
    var currentPredicate = predicate(dependencyContainer);
    if (!useCaching || previousPredicate !== currentPredicate) {
      if (previousPredicate = currentPredicate) {
        instance2 = dependencyContainer.resolve(trueConstructor);
      } else {
        instance2 = dependencyContainer.resolve(falseConstructor);
      }
    }
    return instance2;
  };
}
var init_predicate_aware_class_factory = __esm({
  "node_modules/tsyringe/dist/esm5/factories/predicate-aware-class-factory.js"() {
  }
});

// node_modules/tsyringe/dist/esm5/factories/index.js
var init_factories = __esm({
  "node_modules/tsyringe/dist/esm5/factories/index.js"() {
    init_instance_caching_factory();
    init_instance_per_container_caching_factory();
    init_predicate_aware_class_factory();
  }
});

// node_modules/tsyringe/dist/esm5/index.js
var esm5_exports3 = {};
__export(esm5_exports3, {
  Lifecycle: () => lifecycle_default,
  autoInjectable: () => auto_injectable_default,
  container: () => instance,
  delay: () => delay,
  inject: () => inject_default,
  injectAll: () => inject_all_default,
  injectAllWithTransform: () => inject_all_with_transform_default,
  injectWithTransform: () => inject_with_transform_default,
  injectable: () => injectable_default,
  instanceCachingFactory: () => instanceCachingFactory,
  instancePerContainerCachingFactory: () => instancePerContainerCachingFactory,
  isClassProvider: () => isClassProvider,
  isFactoryProvider: () => isFactoryProvider,
  isNormalToken: () => isNormalToken,
  isTokenProvider: () => isTokenProvider,
  isValueProvider: () => isValueProvider,
  predicateAwareClassFactory: () => predicateAwareClassFactory,
  registry: () => registry_default2,
  scoped: () => scoped,
  singleton: () => singleton_default
});
var init_esm53 = __esm({
  "node_modules/tsyringe/dist/esm5/index.js"() {
    init_types();
    init_decorators3();
    init_factories();
    init_providers();
    init_lazy_helpers();
    init_dependency_container();
    if (typeof Reflect === "undefined" || !Reflect.getMetadata) {
      throw new Error(`tsyringe requires a reflect polyfill. Please add 'import "reflect-metadata"' to the top of your entry point.`);
    }
  }
});

// node_modules/@aries-framework/core/build/agent/FeatureRegistry.js
var require_FeatureRegistry = __commonJS({
  "node_modules/@aries-framework/core/build/agent/FeatureRegistry.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FeatureRegistry = void 0;
    var tsyringe_1 = (init_esm53(), __toCommonJS(esm5_exports3));
    var FeatureRegistry = class FeatureRegistry {
      constructor() {
        this.features = [];
      }
      /**
       * Register a single or set of Features on the registry
       *
       * @param features set of {Feature} objects or any inherited class
       */
      register(...features) {
        for (const feature of features) {
          const index = this.features.findIndex((item) => item.type === feature.type && item.id === feature.id);
          if (index > -1) {
            this.features[index] = this.features[index].combine(feature);
          } else {
            this.features.push(feature);
          }
        }
      }
      /**
       * Perform a set of queries in the registry, supporting wildcards (*) as
       * expressed in Aries RFC 0557.
       *
       * @see https://github.com/hyperledger/aries-rfcs/blob/560ffd23361f16a01e34ccb7dcc908ec28c5ddb1/features/0557-discover-features-v2/README.md
       *
       * @param queries set of {FeatureQuery} objects to query features
       * @returns array containing all matching features (can be empty)
       */
      query(...queries) {
        const output = [];
        for (const query of queries) {
          const items = this.features.filter((item) => item.type === query.featureType);
          if (query.match === "*") {
            output.push(...items);
          } else if (query.match.endsWith("*")) {
            const match = query.match.slice(0, -1);
            output.push(...items.filter((m) => m.id.startsWith(match)));
          } else {
            output.push(...items.filter((m) => m.id === query.match));
          }
        }
        return output;
      }
    };
    FeatureRegistry = __decorate([
      (0, tsyringe_1.injectable)()
    ], FeatureRegistry);
    exports.FeatureRegistry = FeatureRegistry;
  }
});

// node_modules/@aries-framework/core/build/utils/string.js
var require_string = __commonJS({
  "node_modules/@aries-framework/core/build/utils/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rightSplit = void 0;
    function rightSplit(string, sep, limit2) {
      const split = string.split(sep);
      return limit2 ? [split.slice(0, -limit2).join(sep)].concat(split.slice(-limit2)) : split;
    }
    exports.rightSplit = rightSplit;
  }
});

// node_modules/@aries-framework/core/build/utils/version.js
var require_version = __commonJS({
  "node_modules/@aries-framework/core/build/utils/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isFirstVersionEqualToSecond = exports.isFirstVersionHigherThanSecond = exports.parseVersionString = void 0;
    function parseVersionString(version2) {
      const [major, minor, patch] = version2.split(".");
      return [Number(major), Number(minor), Number(patch !== null && patch !== void 0 ? patch : "0")];
    }
    exports.parseVersionString = parseVersionString;
    function isFirstVersionHigherThanSecond(first, second) {
      return first[0] > second[0] || first[0] == second[0] && first[1] > second[1] || first[0] == second[0] && first[1] == second[1] && first[2] > second[2];
    }
    exports.isFirstVersionHigherThanSecond = isFirstVersionHigherThanSecond;
    function isFirstVersionEqualToSecond(first, second) {
      return first[0] === second[0] && first[1] === second[1] && first[2] === second[2];
    }
    exports.isFirstVersionEqualToSecond = isFirstVersionEqualToSecond;
  }
});

// node_modules/@aries-framework/core/build/utils/messageType.js
var require_messageType = __commonJS({
  "node_modules/@aries-framework/core/build/utils/messageType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.replaceNewDidCommPrefixWithLegacyDidSov = exports.replaceLegacyDidSovPrefix = exports.replaceNewDidCommPrefixWithLegacyDidSovOnMessage = exports.replaceLegacyDidSovPrefixOnMessage = exports.IsValidMessageType = exports.canHandleMessageType = exports.supportsIncomingMessageType = exports.parseMessageType = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var string_1 = require_string();
    var version_1 = require_version();
    function parseMessageType(messageType) {
      const [documentUri, protocolName, protocolVersion, messageName] = (0, string_1.rightSplit)(messageType, "/", 3);
      const [protocolMajorVersion, protocolMinorVersion] = (0, version_1.parseVersionString)(protocolVersion);
      return {
        documentUri,
        protocolName,
        protocolVersion,
        protocolMajorVersion,
        protocolMinorVersion,
        messageName,
        protocolUri: `${documentUri}/${protocolName}/${protocolVersion}`,
        messageTypeUri: messageType
      };
    }
    exports.parseMessageType = parseMessageType;
    function supportsIncomingMessageType(incomingMessageType, expectedMessageType, { allowLegacyDidSovPrefixMismatch = true } = {}) {
      const incomingDocumentUri = allowLegacyDidSovPrefixMismatch ? replaceLegacyDidSovPrefix(incomingMessageType.documentUri) : incomingMessageType.documentUri;
      const documentUriMatches = expectedMessageType.documentUri === incomingDocumentUri;
      const protocolNameMatches = expectedMessageType.protocolName === incomingMessageType.protocolName;
      const majorVersionMatches = expectedMessageType.protocolMajorVersion === incomingMessageType.protocolMajorVersion;
      const messageNameMatches = expectedMessageType.messageName === incomingMessageType.messageName;
      return documentUriMatches && protocolNameMatches && majorVersionMatches && messageNameMatches;
    }
    exports.supportsIncomingMessageType = supportsIncomingMessageType;
    function canHandleMessageType(messageClass, messageType) {
      return supportsIncomingMessageType(messageClass.type, messageType);
    }
    exports.canHandleMessageType = canHandleMessageType;
    function IsValidMessageType(messageType, validationOptions) {
      return (0, class_validator_1.ValidateBy)({
        name: "isValidMessageType",
        constraints: [messageType],
        validator: {
          validate: (value, args) => {
            const [expectedMessageType] = args.constraints;
            if (typeof value !== "string") {
              return false;
            }
            const incomingMessageType = parseMessageType(value);
            return supportsIncomingMessageType(incomingMessageType, expectedMessageType);
          },
          defaultMessage: (0, class_validator_1.buildMessage)((eachPrefix) => eachPrefix + "$property does not match the expected message type (only minor version may be lower)", validationOptions)
        }
      }, validationOptions);
    }
    exports.IsValidMessageType = IsValidMessageType;
    function replaceLegacyDidSovPrefixOnMessage(message) {
      message["@type"] = replaceLegacyDidSovPrefix(message["@type"]);
    }
    exports.replaceLegacyDidSovPrefixOnMessage = replaceLegacyDidSovPrefixOnMessage;
    function replaceNewDidCommPrefixWithLegacyDidSovOnMessage(message) {
      message["@type"] = replaceNewDidCommPrefixWithLegacyDidSov(message["@type"]);
    }
    exports.replaceNewDidCommPrefixWithLegacyDidSovOnMessage = replaceNewDidCommPrefixWithLegacyDidSovOnMessage;
    function replaceLegacyDidSovPrefix(messageType) {
      const didSovPrefix = "did:sov:BzCbsNYhMrjHiqZDTUASHg;spec";
      const didCommPrefix = "https://didcomm.org";
      if (messageType.startsWith(didSovPrefix)) {
        return messageType.replace(didSovPrefix, didCommPrefix);
      }
      return messageType;
    }
    exports.replaceLegacyDidSovPrefix = replaceLegacyDidSovPrefix;
    function replaceNewDidCommPrefixWithLegacyDidSov(messageType) {
      const didSovPrefix = "did:sov:BzCbsNYhMrjHiqZDTUASHg;spec";
      const didCommPrefix = "https://didcomm.org";
      if (messageType.startsWith(didCommPrefix)) {
        return messageType.replace(didCommPrefix, didSovPrefix);
      }
      return messageType;
    }
    exports.replaceNewDidCommPrefixWithLegacyDidSov = replaceNewDidCommPrefixWithLegacyDidSov;
  }
});

// node_modules/@aries-framework/core/build/agent/MessageHandlerRegistry.js
var require_MessageHandlerRegistry = __commonJS({
  "node_modules/@aries-framework/core/build/agent/MessageHandlerRegistry.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageHandlerRegistry = void 0;
    var tsyringe_1 = (init_esm53(), __toCommonJS(esm5_exports3));
    var messageType_1 = require_messageType();
    var MessageHandlerRegistry = class MessageHandlerRegistry {
      constructor() {
        this.messageHandlers = [];
      }
      registerMessageHandler(messageHandler) {
        this.messageHandlers.push(messageHandler);
      }
      getHandlerForMessageType(messageType) {
        const incomingMessageType = (0, messageType_1.parseMessageType)(messageType);
        for (const handler of this.messageHandlers) {
          for (const MessageClass of handler.supportedMessages) {
            if ((0, messageType_1.canHandleMessageType)(MessageClass, incomingMessageType))
              return handler;
          }
        }
      }
      getMessageClassForMessageType(messageType) {
        const incomingMessageType = (0, messageType_1.parseMessageType)(messageType);
        for (const handler of this.messageHandlers) {
          for (const MessageClass of handler.supportedMessages) {
            if ((0, messageType_1.canHandleMessageType)(MessageClass, incomingMessageType))
              return MessageClass;
          }
        }
      }
      /**
       * Returns array of message types that dispatcher is able to handle.
       * Message type format is MTURI specified at https://github.com/hyperledger/aries-rfcs/blob/main/concepts/0003-protocols/README.md#mturi.
       */
      get supportedMessageTypes() {
        return this.messageHandlers.reduce((all, cur) => [...all, ...cur.supportedMessages], []).map((m) => m.type);
      }
      /**
       * Returns array of protocol IDs that dispatcher is able to handle.
       * Protocol ID format is PIURI specified at https://github.com/hyperledger/aries-rfcs/blob/main/concepts/0003-protocols/README.md#piuri.
       */
      get supportedProtocols() {
        return Array.from(new Set(this.supportedMessageTypes.map((m) => m.protocolUri)));
      }
      filterSupportedProtocolsByMessageFamilies(messageFamilies) {
        return this.supportedProtocols.filter((protocolId) => messageFamilies.find((messageFamily) => protocolId.startsWith(messageFamily)));
      }
    };
    MessageHandlerRegistry = __decorate([
      (0, tsyringe_1.injectable)()
    ], MessageHandlerRegistry);
    exports.MessageHandlerRegistry = MessageHandlerRegistry;
  }
});

// node_modules/@aries-framework/core/build/plugins/DependencyManager.js
var require_DependencyManager = __commonJS({
  "node_modules/@aries-framework/core/build/plugins/DependencyManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DependencyManager = void 0;
    var tsyringe_1 = (init_esm53(), __toCommonJS(esm5_exports3));
    var FeatureRegistry_1 = require_FeatureRegistry();
    var MessageHandlerRegistry_1 = require_MessageHandlerRegistry();
    var error_1 = require_error();
    var DependencyManager = class {
      constructor(container = tsyringe_1.container.createChildContainer(), registeredModules = {}) {
        this.container = container;
        this.registeredModules = registeredModules;
      }
      registerModules(modules) {
        const featureRegistry = this.resolve(FeatureRegistry_1.FeatureRegistry);
        for (const [moduleKey, module2] of Object.entries(modules)) {
          if (this.registeredModules[moduleKey]) {
            throw new error_1.AriesFrameworkError(`Module with key ${moduleKey} has already been registered. Only a single module can be registered with the same key.`);
          }
          this.registeredModules[moduleKey] = module2;
          module2.register(this, featureRegistry);
        }
      }
      registerMessageHandlers(messageHandlers) {
        const messageHandlerRegistry = this.resolve(MessageHandlerRegistry_1.MessageHandlerRegistry);
        for (const messageHandler of messageHandlers) {
          messageHandlerRegistry.registerMessageHandler(messageHandler);
        }
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      registerSingleton(fromOrToken, to) {
        this.container.registerSingleton(fromOrToken, to);
      }
      resolve(token) {
        return this.container.resolve(token);
      }
      registerInstance(token, instance2) {
        this.container.registerInstance(token, instance2);
      }
      isRegistered(token) {
        return this.container.isRegistered(token);
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      registerContextScoped(token, provider) {
        if (provider)
          this.container.register(token, provider, { lifecycle: tsyringe_1.Lifecycle.ContainerScoped });
        else
          this.container.register(token, token, { lifecycle: tsyringe_1.Lifecycle.ContainerScoped });
      }
      /**
       * Dispose the dependency manager. Calls `.dispose()` on all instances that implement the `Disposable` interface and have
       * been constructed by the `DependencyManager`. This means all instances registered using `registerInstance` won't have the
       * dispose method called.
       */
      async dispose() {
        await this.container.dispose();
      }
      createChild() {
        return new DependencyManager(this.container.createChildContainer(), this.registeredModules);
      }
    };
    exports.DependencyManager = DependencyManager;
  }
});

// node_modules/@aries-framework/core/build/plugins/Module.js
var require_Module = __commonJS({
  "node_modules/@aries-framework/core/build/plugins/Module.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/plugins/index.js
var require_plugins = __commonJS({
  "node_modules/@aries-framework/core/build/plugins/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.injectAll = exports.injectable = exports.inject = void 0;
    __exportStar(require_DependencyManager(), exports);
    __exportStar(require_Module(), exports);
    var tsyringe_1 = (init_esm53(), __toCommonJS(esm5_exports3));
    Object.defineProperty(exports, "inject", { enumerable: true, get: function() {
      return tsyringe_1.inject;
    } });
    Object.defineProperty(exports, "injectable", { enumerable: true, get: function() {
      return tsyringe_1.injectable;
    } });
    Object.defineProperty(exports, "injectAll", { enumerable: true, get: function() {
      return tsyringe_1.injectAll;
    } });
  }
});

// node_modules/@aries-framework/core/build/crypto/signing-provider/SigningProviderRegistry.js
var require_SigningProviderRegistry = __commonJS({
  "node_modules/@aries-framework/core/build/crypto/signing-provider/SigningProviderRegistry.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SigningProviderRegistry = exports.SigningProviderToken = void 0;
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    exports.SigningProviderToken = Symbol("SigningProviderToken");
    var SigningProviderRegistry = class SigningProviderRegistry {
      constructor(signingKeyProviders) {
        this.signingKeyProviders = signingKeyProviders.filter((provider) => provider !== "default");
      }
      hasProviderForKeyType(keyType) {
        const signingKeyProvider = this.signingKeyProviders.find((x) => x.keyType === keyType);
        return signingKeyProvider !== void 0;
      }
      getProviderForKeyType(keyType) {
        const signingKeyProvider = this.signingKeyProviders.find((x) => x.keyType === keyType);
        if (!signingKeyProvider) {
          throw new error_1.AriesFrameworkError(`No signing key provider for key type: ${keyType}`);
        }
        return signingKeyProvider;
      }
    };
    SigningProviderRegistry = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.injectAll)(exports.SigningProviderToken)),
      __metadata("design:paramtypes", [Array])
    ], SigningProviderRegistry);
    exports.SigningProviderRegistry = SigningProviderRegistry;
  }
});

// node_modules/@aries-framework/core/build/crypto/signing-provider/SigningProviderError.js
var require_SigningProviderError = __commonJS({
  "node_modules/@aries-framework/core/build/crypto/signing-provider/SigningProviderError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SigningProviderError = void 0;
    var error_1 = require_error();
    var SigningProviderError = class extends error_1.AriesFrameworkError {
    };
    exports.SigningProviderError = SigningProviderError;
  }
});

// node_modules/@aries-framework/core/build/crypto/signing-provider/index.js
var require_signing_provider = __commonJS({
  "node_modules/@aries-framework/core/build/crypto/signing-provider/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_SigningProvider(), exports);
    __exportStar(require_SigningProviderRegistry(), exports);
    __exportStar(require_SigningProviderError(), exports);
  }
});

// node_modules/@aries-framework/core/build/crypto/index.js
var require_crypto = __commonJS({
  "node_modules/@aries-framework/core/build/crypto/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Key = exports.KeyType = void 0;
    var KeyType_1 = require_KeyType();
    Object.defineProperty(exports, "KeyType", { enumerable: true, get: function() {
      return KeyType_1.KeyType;
    } });
    var Key_1 = require_Key();
    Object.defineProperty(exports, "Key", { enumerable: true, get: function() {
      return Key_1.Key;
    } });
    __exportStar(require_signing_provider(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/vc/constants.js
var require_constants2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EXPANDED_TYPE_CREDENTIALS_CONTEXT_V1_VC_TYPE = exports.VERIFIABLE_PRESENTATION_TYPE = exports.VERIFIABLE_CREDENTIAL_TYPE = exports.SECURITY_SIGNATURE_URL = exports.SECURITY_PROOF_URL = exports.CREDENTIALS_ISSUER_URL = exports.SECURITY_CONTEXT_BBS_URL = exports.CREDENTIALS_CONTEXT_V1_URL = exports.DID_V1_CONTEXT_URL = exports.SECURITY_X25519_CONTEXT_URL = exports.SECURITY_CONTEXT_URL = exports.SECURITY_CONTEXT_V3_URL = exports.SECURITY_CONTEXT_V2_URL = exports.SECURITY_CONTEXT_V1_URL = void 0;
    exports.SECURITY_CONTEXT_V1_URL = "https://w3id.org/security/v1";
    exports.SECURITY_CONTEXT_V2_URL = "https://w3id.org/security/v2";
    exports.SECURITY_CONTEXT_V3_URL = "https://w3id.org/security/v3-unstable";
    exports.SECURITY_CONTEXT_URL = exports.SECURITY_CONTEXT_V2_URL;
    exports.SECURITY_X25519_CONTEXT_URL = "https://w3id.org/security/suites/x25519-2019/v1";
    exports.DID_V1_CONTEXT_URL = "https://www.w3.org/ns/did/v1";
    exports.CREDENTIALS_CONTEXT_V1_URL = "https://www.w3.org/2018/credentials/v1";
    exports.SECURITY_CONTEXT_BBS_URL = "https://w3id.org/security/bbs/v1";
    exports.CREDENTIALS_ISSUER_URL = "https://www.w3.org/2018/credentials#issuer";
    exports.SECURITY_PROOF_URL = "https://w3id.org/security#proof";
    exports.SECURITY_SIGNATURE_URL = "https://w3id.org/security#signature";
    exports.VERIFIABLE_CREDENTIAL_TYPE = "VerifiableCredential";
    exports.VERIFIABLE_PRESENTATION_TYPE = "VerifiablePresentation";
    exports.EXPANDED_TYPE_CREDENTIALS_CONTEXT_V1_VC_TYPE = "https://www.w3.org/2018/credentials#VerifiableCredential";
  }
});

// node_modules/@aries-framework/core/build/modules/vc/signature-suites/ed25519/constants.js
var require_constants3 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/signature-suites/ed25519/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ED25519_SUITE_CONTEXT_URL_2020 = exports.ED25519_SUITE_CONTEXT_URL_2018 = void 0;
    exports.ED25519_SUITE_CONTEXT_URL_2018 = "https://w3id.org/security/suites/ed25519-2018/v1";
    exports.ED25519_SUITE_CONTEXT_URL_2020 = "https://w3id.org/security/suites/ed25519-2020/v1";
  }
});

// node_modules/luxon/build/cjs-browser/luxon.js
var require_luxon = __commonJS({
  "node_modules/luxon/build/cjs-browser/luxon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _defineProperties14(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass14(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties14(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties14(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    function _getPrototypeOf2(o) {
      _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf2(o);
    }
    function _setPrototypeOf2(o, p) {
      _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf2(o, p);
    }
    function _isNativeReflectConstruct2() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct2(Parent, args, Class) {
      if (_isNativeReflectConstruct2()) {
        _construct2 = Reflect.construct;
      } else {
        _construct2 = function _construct3(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance2 = new Constructor();
          if (Class2)
            _setPrototypeOf2(instance2, Class2.prototype);
          return instance2;
        };
      }
      return _construct2.apply(null, arguments);
    }
    function _isNativeFunction2(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _wrapNativeSuper2(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper2 = function _wrapNativeSuper3(Class2) {
        if (Class2 === null || !_isNativeFunction2(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct2(Class2, arguments, _getPrototypeOf2(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf2(Wrapper, Class2);
      };
      return _wrapNativeSuper2(Class);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _unsupportedIterableToArray15(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray15(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(n2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray15(o, minLen);
    }
    function _arrayLikeToArray15(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _createForOfIteratorHelperLoose12(o) {
      var i = 0;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (o = _unsupportedIterableToArray15(o)))
          return function() {
            if (i >= o.length)
              return {
                done: true
              };
            return {
              done: false,
              value: o[i++]
            };
          };
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      i = o[Symbol.iterator]();
      return i.next.bind(i);
    }
    var LuxonError = function(_Error) {
      _inheritsLoose(LuxonError2, _Error);
      function LuxonError2() {
        return _Error.apply(this, arguments) || this;
      }
      return LuxonError2;
    }(_wrapNativeSuper2(Error));
    var InvalidDateTimeError = function(_LuxonError) {
      _inheritsLoose(InvalidDateTimeError2, _LuxonError);
      function InvalidDateTimeError2(reason) {
        return _LuxonError.call(this, "Invalid DateTime: " + reason.toMessage()) || this;
      }
      return InvalidDateTimeError2;
    }(LuxonError);
    var InvalidIntervalError = function(_LuxonError2) {
      _inheritsLoose(InvalidIntervalError2, _LuxonError2);
      function InvalidIntervalError2(reason) {
        return _LuxonError2.call(this, "Invalid Interval: " + reason.toMessage()) || this;
      }
      return InvalidIntervalError2;
    }(LuxonError);
    var InvalidDurationError = function(_LuxonError3) {
      _inheritsLoose(InvalidDurationError2, _LuxonError3);
      function InvalidDurationError2(reason) {
        return _LuxonError3.call(this, "Invalid Duration: " + reason.toMessage()) || this;
      }
      return InvalidDurationError2;
    }(LuxonError);
    var ConflictingSpecificationError = function(_LuxonError4) {
      _inheritsLoose(ConflictingSpecificationError2, _LuxonError4);
      function ConflictingSpecificationError2() {
        return _LuxonError4.apply(this, arguments) || this;
      }
      return ConflictingSpecificationError2;
    }(LuxonError);
    var InvalidUnitError = function(_LuxonError5) {
      _inheritsLoose(InvalidUnitError2, _LuxonError5);
      function InvalidUnitError2(unit) {
        return _LuxonError5.call(this, "Invalid unit " + unit) || this;
      }
      return InvalidUnitError2;
    }(LuxonError);
    var InvalidArgumentError = function(_LuxonError6) {
      _inheritsLoose(InvalidArgumentError2, _LuxonError6);
      function InvalidArgumentError2() {
        return _LuxonError6.apply(this, arguments) || this;
      }
      return InvalidArgumentError2;
    }(LuxonError);
    var ZoneIsAbstractError = function(_LuxonError7) {
      _inheritsLoose(ZoneIsAbstractError2, _LuxonError7);
      function ZoneIsAbstractError2() {
        return _LuxonError7.call(this, "Zone is an abstract class") || this;
      }
      return ZoneIsAbstractError2;
    }(LuxonError);
    var n = "numeric";
    var s = "short";
    var l = "long";
    var DATE_SHORT = {
      year: n,
      month: n,
      day: n
    };
    var DATE_MED = {
      year: n,
      month: s,
      day: n
    };
    var DATE_MED_WITH_WEEKDAY = {
      year: n,
      month: s,
      day: n,
      weekday: s
    };
    var DATE_FULL = {
      year: n,
      month: l,
      day: n
    };
    var DATE_HUGE = {
      year: n,
      month: l,
      day: n,
      weekday: l
    };
    var TIME_SIMPLE = {
      hour: n,
      minute: n
    };
    var TIME_WITH_SECONDS = {
      hour: n,
      minute: n,
      second: n
    };
    var TIME_WITH_SHORT_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      timeZoneName: s
    };
    var TIME_WITH_LONG_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      timeZoneName: l
    };
    var TIME_24_SIMPLE = {
      hour: n,
      minute: n,
      hour12: false
    };
    var TIME_24_WITH_SECONDS = {
      hour: n,
      minute: n,
      second: n,
      hour12: false
    };
    var TIME_24_WITH_SHORT_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      hour12: false,
      timeZoneName: s
    };
    var TIME_24_WITH_LONG_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      hour12: false,
      timeZoneName: l
    };
    var DATETIME_SHORT = {
      year: n,
      month: n,
      day: n,
      hour: n,
      minute: n
    };
    var DATETIME_SHORT_WITH_SECONDS = {
      year: n,
      month: n,
      day: n,
      hour: n,
      minute: n,
      second: n
    };
    var DATETIME_MED = {
      year: n,
      month: s,
      day: n,
      hour: n,
      minute: n
    };
    var DATETIME_MED_WITH_SECONDS = {
      year: n,
      month: s,
      day: n,
      hour: n,
      minute: n,
      second: n
    };
    var DATETIME_MED_WITH_WEEKDAY = {
      year: n,
      month: s,
      day: n,
      weekday: s,
      hour: n,
      minute: n
    };
    var DATETIME_FULL = {
      year: n,
      month: l,
      day: n,
      hour: n,
      minute: n,
      timeZoneName: s
    };
    var DATETIME_FULL_WITH_SECONDS = {
      year: n,
      month: l,
      day: n,
      hour: n,
      minute: n,
      second: n,
      timeZoneName: s
    };
    var DATETIME_HUGE = {
      year: n,
      month: l,
      day: n,
      weekday: l,
      hour: n,
      minute: n,
      timeZoneName: l
    };
    var DATETIME_HUGE_WITH_SECONDS = {
      year: n,
      month: l,
      day: n,
      weekday: l,
      hour: n,
      minute: n,
      second: n,
      timeZoneName: l
    };
    function isUndefined(o) {
      return typeof o === "undefined";
    }
    function isNumber2(o) {
      return typeof o === "number";
    }
    function isInteger(o) {
      return typeof o === "number" && o % 1 === 0;
    }
    function isString2(o) {
      return typeof o === "string";
    }
    function isDate2(o) {
      return Object.prototype.toString.call(o) === "[object Date]";
    }
    function hasIntl() {
      try {
        return typeof Intl !== "undefined" && Intl.DateTimeFormat;
      } catch (e) {
        return false;
      }
    }
    function hasFormatToParts() {
      return !isUndefined(Intl.DateTimeFormat.prototype.formatToParts);
    }
    function hasRelative() {
      try {
        return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
      } catch (e) {
        return false;
      }
    }
    function maybeArray(thing) {
      return Array.isArray(thing) ? thing : [thing];
    }
    function bestBy(arr, by, compare) {
      if (arr.length === 0) {
        return void 0;
      }
      return arr.reduce(function(best, next) {
        var pair = [by(next), next];
        if (!best) {
          return pair;
        } else if (compare(best[0], pair[0]) === best[0]) {
          return best;
        } else {
          return pair;
        }
      }, null)[1];
    }
    function pick(obj, keys) {
      return keys.reduce(function(a, k) {
        a[k] = obj[k];
        return a;
      }, {});
    }
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    function integerBetween(thing, bottom, top) {
      return isInteger(thing) && thing >= bottom && thing <= top;
    }
    function floorMod(x, n2) {
      return x - n2 * Math.floor(x / n2);
    }
    function padStart(input, n2) {
      if (n2 === void 0) {
        n2 = 2;
      }
      var minus = input < 0 ? "-" : "";
      var target = minus ? input * -1 : input;
      var result2;
      if (target.toString().length < n2) {
        result2 = ("0".repeat(n2) + target).slice(-n2);
      } else {
        result2 = target.toString();
      }
      return "" + minus + result2;
    }
    function parseInteger(string) {
      if (isUndefined(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseInt(string, 10);
      }
    }
    function parseMillis(fraction) {
      if (isUndefined(fraction) || fraction === null || fraction === "") {
        return void 0;
      } else {
        var f2 = parseFloat("0." + fraction) * 1e3;
        return Math.floor(f2);
      }
    }
    function roundTo(number, digits, towardZero) {
      if (towardZero === void 0) {
        towardZero = false;
      }
      var factor = Math.pow(10, digits), rounder = towardZero ? Math.trunc : Math.round;
      return rounder(number * factor) / factor;
    }
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    function daysInMonth(year, month) {
      var modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
      if (modMonth === 2) {
        return isLeapYear(modYear) ? 29 : 28;
      } else {
        return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
      }
    }
    function objToLocalTS(obj) {
      var d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);
      if (obj.year < 100 && obj.year >= 0) {
        d = new Date(d);
        d.setUTCFullYear(d.getUTCFullYear() - 1900);
      }
      return +d;
    }
    function weeksInWeekYear(weekYear) {
      var p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
      return p1 === 4 || p2 === 3 ? 53 : 52;
    }
    function untruncateYear(year) {
      if (year > 99) {
        return year;
      } else
        return year > 60 ? 1900 + year : 2e3 + year;
    }
    function parseZoneInfo(ts, offsetFormat, locale, timeZone) {
      if (timeZone === void 0) {
        timeZone = null;
      }
      var date = new Date(ts), intlOpts = {
        hour12: false,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      };
      if (timeZone) {
        intlOpts.timeZone = timeZone;
      }
      var modified = Object.assign({
        timeZoneName: offsetFormat
      }, intlOpts), intl = hasIntl();
      if (intl && hasFormatToParts()) {
        var parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find(function(m) {
          return m.type.toLowerCase() === "timezonename";
        });
        return parsed ? parsed.value : null;
      } else if (intl) {
        var without = new Intl.DateTimeFormat(locale, intlOpts).format(date), included = new Intl.DateTimeFormat(locale, modified).format(date), diffed = included.substring(without.length), trimmed = diffed.replace(/^[, \u200e]+/, "");
        return trimmed;
      } else {
        return null;
      }
    }
    function signedOffset(offHourStr, offMinuteStr) {
      var offHour = parseInt(offHourStr, 10);
      if (Number.isNaN(offHour)) {
        offHour = 0;
      }
      var offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
      return offHour * 60 + offMinSigned;
    }
    function asNumber(value) {
      var numericValue = Number(value);
      if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
        throw new InvalidArgumentError("Invalid unit value " + value);
      return numericValue;
    }
    function normalizeObject(obj, normalizer, nonUnitKeys) {
      var normalized = {};
      for (var u in obj) {
        if (hasOwnProperty(obj, u)) {
          if (nonUnitKeys.indexOf(u) >= 0)
            continue;
          var v = obj[u];
          if (v === void 0 || v === null)
            continue;
          normalized[normalizer(u)] = asNumber(v);
        }
      }
      return normalized;
    }
    function formatOffset(offset2, format2) {
      var hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
      switch (format2) {
        case "short":
          return "" + sign + padStart(hours, 2) + ":" + padStart(minutes, 2);
        case "narrow":
          return "" + sign + hours + (minutes > 0 ? ":" + minutes : "");
        case "techie":
          return "" + sign + padStart(hours, 2) + padStart(minutes, 2);
        default:
          throw new RangeError("Value format " + format2 + " is out of range for property format");
      }
    }
    function timeObject(obj) {
      return pick(obj, ["hour", "minute", "second", "millisecond"]);
    }
    var ianaRegex = /[A-Za-z_+-]{1,256}(:?\/[A-Za-z_+-]{1,256}(\/[A-Za-z_+-]{1,256})?)?/;
    function stringify2(obj) {
      return JSON.stringify(obj, Object.keys(obj).sort());
    }
    var monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    var monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
    function months(length2) {
      switch (length2) {
        case "narrow":
          return [].concat(monthsNarrow);
        case "short":
          return [].concat(monthsShort);
        case "long":
          return [].concat(monthsLong);
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
        case "2-digit":
          return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
        default:
          return null;
      }
    }
    var weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
    var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
    function weekdays(length2) {
      switch (length2) {
        case "narrow":
          return [].concat(weekdaysNarrow);
        case "short":
          return [].concat(weekdaysShort);
        case "long":
          return [].concat(weekdaysLong);
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7"];
        default:
          return null;
      }
    }
    var meridiems = ["AM", "PM"];
    var erasLong = ["Before Christ", "Anno Domini"];
    var erasShort = ["BC", "AD"];
    var erasNarrow = ["B", "A"];
    function eras(length2) {
      switch (length2) {
        case "narrow":
          return [].concat(erasNarrow);
        case "short":
          return [].concat(erasShort);
        case "long":
          return [].concat(erasLong);
        default:
          return null;
      }
    }
    function meridiemForDateTime(dt) {
      return meridiems[dt.hour < 12 ? 0 : 1];
    }
    function weekdayForDateTime(dt, length2) {
      return weekdays(length2)[dt.weekday - 1];
    }
    function monthForDateTime(dt, length2) {
      return months(length2)[dt.month - 1];
    }
    function eraForDateTime(dt, length2) {
      return eras(length2)[dt.year < 0 ? 0 : 1];
    }
    function formatRelativeTime(unit, count, numeric, narrow) {
      if (numeric === void 0) {
        numeric = "always";
      }
      if (narrow === void 0) {
        narrow = false;
      }
      var units = {
        years: ["year", "yr."],
        quarters: ["quarter", "qtr."],
        months: ["month", "mo."],
        weeks: ["week", "wk."],
        days: ["day", "day", "days"],
        hours: ["hour", "hr."],
        minutes: ["minute", "min."],
        seconds: ["second", "sec."]
      };
      var lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
      if (numeric === "auto" && lastable) {
        var isDay = unit === "days";
        switch (count) {
          case 1:
            return isDay ? "tomorrow" : "next " + units[unit][0];
          case -1:
            return isDay ? "yesterday" : "last " + units[unit][0];
          case 0:
            return isDay ? "today" : "this " + units[unit][0];
        }
      }
      var isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
      return isInPast ? fmtValue + " " + fmtUnit + " ago" : "in " + fmtValue + " " + fmtUnit;
    }
    function formatString(knownFormat) {
      var filtered = pick(knownFormat, ["weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "hour12"]), key = stringify2(filtered), dateTimeHuge = "EEEE, LLLL d, yyyy, h:mm a";
      switch (key) {
        case stringify2(DATE_SHORT):
          return "M/d/yyyy";
        case stringify2(DATE_MED):
          return "LLL d, yyyy";
        case stringify2(DATE_MED_WITH_WEEKDAY):
          return "EEE, LLL d, yyyy";
        case stringify2(DATE_FULL):
          return "LLLL d, yyyy";
        case stringify2(DATE_HUGE):
          return "EEEE, LLLL d, yyyy";
        case stringify2(TIME_SIMPLE):
          return "h:mm a";
        case stringify2(TIME_WITH_SECONDS):
          return "h:mm:ss a";
        case stringify2(TIME_WITH_SHORT_OFFSET):
          return "h:mm a";
        case stringify2(TIME_WITH_LONG_OFFSET):
          return "h:mm a";
        case stringify2(TIME_24_SIMPLE):
          return "HH:mm";
        case stringify2(TIME_24_WITH_SECONDS):
          return "HH:mm:ss";
        case stringify2(TIME_24_WITH_SHORT_OFFSET):
          return "HH:mm";
        case stringify2(TIME_24_WITH_LONG_OFFSET):
          return "HH:mm";
        case stringify2(DATETIME_SHORT):
          return "M/d/yyyy, h:mm a";
        case stringify2(DATETIME_MED):
          return "LLL d, yyyy, h:mm a";
        case stringify2(DATETIME_FULL):
          return "LLLL d, yyyy, h:mm a";
        case stringify2(DATETIME_HUGE):
          return dateTimeHuge;
        case stringify2(DATETIME_SHORT_WITH_SECONDS):
          return "M/d/yyyy, h:mm:ss a";
        case stringify2(DATETIME_MED_WITH_SECONDS):
          return "LLL d, yyyy, h:mm:ss a";
        case stringify2(DATETIME_MED_WITH_WEEKDAY):
          return "EEE, d LLL yyyy, h:mm a";
        case stringify2(DATETIME_FULL_WITH_SECONDS):
          return "LLLL d, yyyy, h:mm:ss a";
        case stringify2(DATETIME_HUGE_WITH_SECONDS):
          return "EEEE, LLLL d, yyyy, h:mm:ss a";
        default:
          return dateTimeHuge;
      }
    }
    function stringifyTokens(splits, tokenToString) {
      var s2 = "";
      for (var _iterator = _createForOfIteratorHelperLoose12(splits), _step; !(_step = _iterator()).done; ) {
        var token = _step.value;
        if (token.literal) {
          s2 += token.val;
        } else {
          s2 += tokenToString(token.val);
        }
      }
      return s2;
    }
    var _macroTokenToFormatOpts = {
      D: DATE_SHORT,
      DD: DATE_MED,
      DDD: DATE_FULL,
      DDDD: DATE_HUGE,
      t: TIME_SIMPLE,
      tt: TIME_WITH_SECONDS,
      ttt: TIME_WITH_SHORT_OFFSET,
      tttt: TIME_WITH_LONG_OFFSET,
      T: TIME_24_SIMPLE,
      TT: TIME_24_WITH_SECONDS,
      TTT: TIME_24_WITH_SHORT_OFFSET,
      TTTT: TIME_24_WITH_LONG_OFFSET,
      f: DATETIME_SHORT,
      ff: DATETIME_MED,
      fff: DATETIME_FULL,
      ffff: DATETIME_HUGE,
      F: DATETIME_SHORT_WITH_SECONDS,
      FF: DATETIME_MED_WITH_SECONDS,
      FFF: DATETIME_FULL_WITH_SECONDS,
      FFFF: DATETIME_HUGE_WITH_SECONDS
    };
    var Formatter = function() {
      Formatter2.create = function create(locale, opts) {
        if (opts === void 0) {
          opts = {};
        }
        return new Formatter2(locale, opts);
      };
      Formatter2.parseFormat = function parseFormat(fmt) {
        var current = null, currentFull = "", bracketed = false;
        var splits = [];
        for (var i = 0; i < fmt.length; i++) {
          var c = fmt.charAt(i);
          if (c === "'") {
            if (currentFull.length > 0) {
              splits.push({
                literal: bracketed,
                val: currentFull
              });
            }
            current = null;
            currentFull = "";
            bracketed = !bracketed;
          } else if (bracketed) {
            currentFull += c;
          } else if (c === current) {
            currentFull += c;
          } else {
            if (currentFull.length > 0) {
              splits.push({
                literal: false,
                val: currentFull
              });
            }
            currentFull = c;
            current = c;
          }
        }
        if (currentFull.length > 0) {
          splits.push({
            literal: bracketed,
            val: currentFull
          });
        }
        return splits;
      };
      Formatter2.macroTokenToFormatOpts = function macroTokenToFormatOpts(token) {
        return _macroTokenToFormatOpts[token];
      };
      function Formatter2(locale, formatOpts) {
        this.opts = formatOpts;
        this.loc = locale;
        this.systemLoc = null;
      }
      var _proto = Formatter2.prototype;
      _proto.formatWithSystemDefault = function formatWithSystemDefault(dt, opts) {
        if (this.systemLoc === null) {
          this.systemLoc = this.loc.redefaultToSystem();
        }
        var df = this.systemLoc.dtFormatter(dt, Object.assign({}, this.opts, opts));
        return df.format();
      };
      _proto.formatDateTime = function formatDateTime(dt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));
        return df.format();
      };
      _proto.formatDateTimeParts = function formatDateTimeParts(dt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));
        return df.formatToParts();
      };
      _proto.resolvedOptions = function resolvedOptions(dt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));
        return df.resolvedOptions();
      };
      _proto.num = function num(n2, p) {
        if (p === void 0) {
          p = 0;
        }
        if (this.opts.forceSimple) {
          return padStart(n2, p);
        }
        var opts = Object.assign({}, this.opts);
        if (p > 0) {
          opts.padTo = p;
        }
        return this.loc.numberFormatter(opts).format(n2);
      };
      _proto.formatDateTimeFromString = function formatDateTimeFromString(dt, fmt) {
        var _this = this;
        var knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory" && hasFormatToParts(), string = function string2(opts, extract) {
          return _this.loc.extract(dt, opts, extract);
        }, formatOffset2 = function formatOffset3(opts) {
          if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
            return "Z";
          }
          return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
        }, meridiem = function meridiem2() {
          return knownEnglish ? meridiemForDateTime(dt) : string({
            hour: "numeric",
            hour12: true
          }, "dayperiod");
        }, month = function month2(length2, standalone) {
          return knownEnglish ? monthForDateTime(dt, length2) : string(standalone ? {
            month: length2
          } : {
            month: length2,
            day: "numeric"
          }, "month");
        }, weekday = function weekday2(length2, standalone) {
          return knownEnglish ? weekdayForDateTime(dt, length2) : string(standalone ? {
            weekday: length2
          } : {
            weekday: length2,
            month: "long",
            day: "numeric"
          }, "weekday");
        }, maybeMacro = function maybeMacro2(token) {
          var formatOpts = Formatter2.macroTokenToFormatOpts(token);
          if (formatOpts) {
            return _this.formatWithSystemDefault(dt, formatOpts);
          } else {
            return token;
          }
        }, era = function era2(length2) {
          return knownEnglish ? eraForDateTime(dt, length2) : string({
            era: length2
          }, "era");
        }, tokenToString = function tokenToString2(token) {
          switch (token) {
            case "S":
              return _this.num(dt.millisecond);
            case "u":
            case "SSS":
              return _this.num(dt.millisecond, 3);
            case "s":
              return _this.num(dt.second);
            case "ss":
              return _this.num(dt.second, 2);
            case "m":
              return _this.num(dt.minute);
            case "mm":
              return _this.num(dt.minute, 2);
            case "h":
              return _this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
            case "hh":
              return _this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
            case "H":
              return _this.num(dt.hour);
            case "HH":
              return _this.num(dt.hour, 2);
            case "Z":
              return formatOffset2({
                format: "narrow",
                allowZ: _this.opts.allowZ
              });
            case "ZZ":
              return formatOffset2({
                format: "short",
                allowZ: _this.opts.allowZ
              });
            case "ZZZ":
              return formatOffset2({
                format: "techie",
                allowZ: _this.opts.allowZ
              });
            case "ZZZZ":
              return dt.zone.offsetName(dt.ts, {
                format: "short",
                locale: _this.loc.locale
              });
            case "ZZZZZ":
              return dt.zone.offsetName(dt.ts, {
                format: "long",
                locale: _this.loc.locale
              });
            case "z":
              return dt.zoneName;
            case "a":
              return meridiem();
            case "d":
              return useDateTimeFormatter ? string({
                day: "numeric"
              }, "day") : _this.num(dt.day);
            case "dd":
              return useDateTimeFormatter ? string({
                day: "2-digit"
              }, "day") : _this.num(dt.day, 2);
            case "c":
              return _this.num(dt.weekday);
            case "ccc":
              return weekday("short", true);
            case "cccc":
              return weekday("long", true);
            case "ccccc":
              return weekday("narrow", true);
            case "E":
              return _this.num(dt.weekday);
            case "EEE":
              return weekday("short", false);
            case "EEEE":
              return weekday("long", false);
            case "EEEEE":
              return weekday("narrow", false);
            case "L":
              return useDateTimeFormatter ? string({
                month: "numeric",
                day: "numeric"
              }, "month") : _this.num(dt.month);
            case "LL":
              return useDateTimeFormatter ? string({
                month: "2-digit",
                day: "numeric"
              }, "month") : _this.num(dt.month, 2);
            case "LLL":
              return month("short", true);
            case "LLLL":
              return month("long", true);
            case "LLLLL":
              return month("narrow", true);
            case "M":
              return useDateTimeFormatter ? string({
                month: "numeric"
              }, "month") : _this.num(dt.month);
            case "MM":
              return useDateTimeFormatter ? string({
                month: "2-digit"
              }, "month") : _this.num(dt.month, 2);
            case "MMM":
              return month("short", false);
            case "MMMM":
              return month("long", false);
            case "MMMMM":
              return month("narrow", false);
            case "y":
              return useDateTimeFormatter ? string({
                year: "numeric"
              }, "year") : _this.num(dt.year);
            case "yy":
              return useDateTimeFormatter ? string({
                year: "2-digit"
              }, "year") : _this.num(dt.year.toString().slice(-2), 2);
            case "yyyy":
              return useDateTimeFormatter ? string({
                year: "numeric"
              }, "year") : _this.num(dt.year, 4);
            case "yyyyyy":
              return useDateTimeFormatter ? string({
                year: "numeric"
              }, "year") : _this.num(dt.year, 6);
            case "G":
              return era("short");
            case "GG":
              return era("long");
            case "GGGGG":
              return era("narrow");
            case "kk":
              return _this.num(dt.weekYear.toString().slice(-2), 2);
            case "kkkk":
              return _this.num(dt.weekYear, 4);
            case "W":
              return _this.num(dt.weekNumber);
            case "WW":
              return _this.num(dt.weekNumber, 2);
            case "o":
              return _this.num(dt.ordinal);
            case "ooo":
              return _this.num(dt.ordinal, 3);
            case "q":
              return _this.num(dt.quarter);
            case "qq":
              return _this.num(dt.quarter, 2);
            case "X":
              return _this.num(Math.floor(dt.ts / 1e3));
            case "x":
              return _this.num(dt.ts);
            default:
              return maybeMacro(token);
          }
        };
        return stringifyTokens(Formatter2.parseFormat(fmt), tokenToString);
      };
      _proto.formatDurationFromString = function formatDurationFromString(dur, fmt) {
        var _this2 = this;
        var tokenToField = function tokenToField2(token) {
          switch (token[0]) {
            case "S":
              return "millisecond";
            case "s":
              return "second";
            case "m":
              return "minute";
            case "h":
              return "hour";
            case "d":
              return "day";
            case "M":
              return "month";
            case "y":
              return "year";
            default:
              return null;
          }
        }, tokenToString = function tokenToString2(lildur) {
          return function(token) {
            var mapped = tokenToField(token);
            if (mapped) {
              return _this2.num(lildur.get(mapped), token.length);
            } else {
              return token;
            }
          };
        }, tokens = Formatter2.parseFormat(fmt), realTokens = tokens.reduce(function(found, _ref) {
          var literal = _ref.literal, val = _ref.val;
          return literal ? found : found.concat(val);
        }, []), collapsed = dur.shiftTo.apply(dur, realTokens.map(tokenToField).filter(function(t) {
          return t;
        }));
        return stringifyTokens(tokens, tokenToString(collapsed));
      };
      return Formatter2;
    }();
    var Invalid = function() {
      function Invalid2(reason, explanation) {
        this.reason = reason;
        this.explanation = explanation;
      }
      var _proto = Invalid2.prototype;
      _proto.toMessage = function toMessage() {
        if (this.explanation) {
          return this.reason + ": " + this.explanation;
        } else {
          return this.reason;
        }
      };
      return Invalid2;
    }();
    var Zone = function() {
      function Zone2() {
      }
      var _proto = Zone2.prototype;
      _proto.offsetName = function offsetName(ts, opts) {
        throw new ZoneIsAbstractError();
      };
      _proto.formatOffset = function formatOffset2(ts, format2) {
        throw new ZoneIsAbstractError();
      };
      _proto.offset = function offset2(ts) {
        throw new ZoneIsAbstractError();
      };
      _proto.equals = function equals2(otherZone) {
        throw new ZoneIsAbstractError();
      };
      _createClass14(Zone2, [{
        key: "type",
        /**
         * The type of zone
         * @abstract
         * @type {string}
         */
        get: function get() {
          throw new ZoneIsAbstractError();
        }
        /**
         * The name of this zone.
         * @abstract
         * @type {string}
         */
      }, {
        key: "name",
        get: function get() {
          throw new ZoneIsAbstractError();
        }
        /**
         * Returns whether the offset is known to be fixed for the whole year.
         * @abstract
         * @type {boolean}
         */
      }, {
        key: "universal",
        get: function get() {
          throw new ZoneIsAbstractError();
        }
      }, {
        key: "isValid",
        get: function get() {
          throw new ZoneIsAbstractError();
        }
      }]);
      return Zone2;
    }();
    var singleton2 = null;
    var LocalZone = function(_Zone) {
      _inheritsLoose(LocalZone2, _Zone);
      function LocalZone2() {
        return _Zone.apply(this, arguments) || this;
      }
      var _proto = LocalZone2.prototype;
      _proto.offsetName = function offsetName(ts, _ref) {
        var format2 = _ref.format, locale = _ref.locale;
        return parseZoneInfo(ts, format2, locale);
      };
      _proto.formatOffset = function formatOffset$1(ts, format2) {
        return formatOffset(this.offset(ts), format2);
      };
      _proto.offset = function offset2(ts) {
        return -new Date(ts).getTimezoneOffset();
      };
      _proto.equals = function equals2(otherZone) {
        return otherZone.type === "local";
      };
      _createClass14(LocalZone2, [{
        key: "type",
        /** @override **/
        get: function get() {
          return "local";
        }
        /** @override **/
      }, {
        key: "name",
        get: function get() {
          if (hasIntl()) {
            return new Intl.DateTimeFormat().resolvedOptions().timeZone;
          } else
            return "local";
        }
        /** @override **/
      }, {
        key: "universal",
        get: function get() {
          return false;
        }
      }, {
        key: "isValid",
        get: function get() {
          return true;
        }
      }], [{
        key: "instance",
        /**
         * Get a singleton instance of the local zone
         * @return {LocalZone}
         */
        get: function get() {
          if (singleton2 === null) {
            singleton2 = new LocalZone2();
          }
          return singleton2;
        }
      }]);
      return LocalZone2;
    }(Zone);
    var matchingRegex = RegExp("^" + ianaRegex.source + "$");
    var dtfCache = {};
    function makeDTF(zone) {
      if (!dtfCache[zone]) {
        dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
          hour12: false,
          timeZone: zone,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit"
        });
      }
      return dtfCache[zone];
    }
    var typeToPos = {
      year: 0,
      month: 1,
      day: 2,
      hour: 3,
      minute: 4,
      second: 5
    };
    function hackyOffset(dtf, date) {
      var formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted), fMonth = parsed[1], fDay = parsed[2], fYear = parsed[3], fHour = parsed[4], fMinute = parsed[5], fSecond = parsed[6];
      return [fYear, fMonth, fDay, fHour, fMinute, fSecond];
    }
    function partsOffset(dtf, date) {
      var formatted = dtf.formatToParts(date), filled = [];
      for (var i = 0; i < formatted.length; i++) {
        var _formatted$i = formatted[i], type = _formatted$i.type, value = _formatted$i.value, pos = typeToPos[type];
        if (!isUndefined(pos)) {
          filled[pos] = parseInt(value, 10);
        }
      }
      return filled;
    }
    var ianaZoneCache = {};
    var IANAZone = function(_Zone) {
      _inheritsLoose(IANAZone2, _Zone);
      IANAZone2.create = function create(name) {
        if (!ianaZoneCache[name]) {
          ianaZoneCache[name] = new IANAZone2(name);
        }
        return ianaZoneCache[name];
      };
      IANAZone2.resetCache = function resetCache() {
        ianaZoneCache = {};
        dtfCache = {};
      };
      IANAZone2.isValidSpecifier = function isValidSpecifier(s2) {
        return !!(s2 && s2.match(matchingRegex));
      };
      IANAZone2.isValidZone = function isValidZone(zone) {
        try {
          new Intl.DateTimeFormat("en-US", {
            timeZone: zone
          }).format();
          return true;
        } catch (e) {
          return false;
        }
      };
      IANAZone2.parseGMTOffset = function parseGMTOffset(specifier) {
        if (specifier) {
          var match2 = specifier.match(/^Etc\/GMT(0|[+-]\d{1,2})$/i);
          if (match2) {
            return -60 * parseInt(match2[1]);
          }
        }
        return null;
      };
      function IANAZone2(name) {
        var _this;
        _this = _Zone.call(this) || this;
        _this.zoneName = name;
        _this.valid = IANAZone2.isValidZone(name);
        return _this;
      }
      var _proto = IANAZone2.prototype;
      _proto.offsetName = function offsetName(ts, _ref) {
        var format2 = _ref.format, locale = _ref.locale;
        return parseZoneInfo(ts, format2, locale, this.name);
      };
      _proto.formatOffset = function formatOffset$1(ts, format2) {
        return formatOffset(this.offset(ts), format2);
      };
      _proto.offset = function offset2(ts) {
        var date = new Date(ts);
        if (isNaN(date))
          return NaN;
        var dtf = makeDTF(this.name), _ref2 = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date), year = _ref2[0], month = _ref2[1], day = _ref2[2], hour = _ref2[3], minute = _ref2[4], second = _ref2[5], adjustedHour = hour === 24 ? 0 : hour;
        var asUTC = objToLocalTS({
          year,
          month,
          day,
          hour: adjustedHour,
          minute,
          second,
          millisecond: 0
        });
        var asTS = +date;
        var over = asTS % 1e3;
        asTS -= over >= 0 ? over : 1e3 + over;
        return (asUTC - asTS) / (60 * 1e3);
      };
      _proto.equals = function equals2(otherZone) {
        return otherZone.type === "iana" && otherZone.name === this.name;
      };
      _createClass14(IANAZone2, [{
        key: "type",
        get: function get() {
          return "iana";
        }
        /** @override **/
      }, {
        key: "name",
        get: function get() {
          return this.zoneName;
        }
        /** @override **/
      }, {
        key: "universal",
        get: function get() {
          return false;
        }
      }, {
        key: "isValid",
        get: function get() {
          return this.valid;
        }
      }]);
      return IANAZone2;
    }(Zone);
    var singleton$1 = null;
    var FixedOffsetZone = function(_Zone) {
      _inheritsLoose(FixedOffsetZone2, _Zone);
      FixedOffsetZone2.instance = function instance2(offset2) {
        return offset2 === 0 ? FixedOffsetZone2.utcInstance : new FixedOffsetZone2(offset2);
      };
      FixedOffsetZone2.parseSpecifier = function parseSpecifier(s2) {
        if (s2) {
          var r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
          if (r) {
            return new FixedOffsetZone2(signedOffset(r[1], r[2]));
          }
        }
        return null;
      };
      _createClass14(FixedOffsetZone2, null, [{
        key: "utcInstance",
        /**
         * Get a singleton instance of UTC
         * @return {FixedOffsetZone}
         */
        get: function get() {
          if (singleton$1 === null) {
            singleton$1 = new FixedOffsetZone2(0);
          }
          return singleton$1;
        }
      }]);
      function FixedOffsetZone2(offset2) {
        var _this;
        _this = _Zone.call(this) || this;
        _this.fixed = offset2;
        return _this;
      }
      var _proto = FixedOffsetZone2.prototype;
      _proto.offsetName = function offsetName() {
        return this.name;
      };
      _proto.formatOffset = function formatOffset$1(ts, format2) {
        return formatOffset(this.fixed, format2);
      };
      _proto.offset = function offset2() {
        return this.fixed;
      };
      _proto.equals = function equals2(otherZone) {
        return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
      };
      _createClass14(FixedOffsetZone2, [{
        key: "type",
        get: function get() {
          return "fixed";
        }
        /** @override **/
      }, {
        key: "name",
        get: function get() {
          return this.fixed === 0 ? "UTC" : "UTC" + formatOffset(this.fixed, "narrow");
        }
      }, {
        key: "universal",
        get: function get() {
          return true;
        }
      }, {
        key: "isValid",
        get: function get() {
          return true;
        }
      }]);
      return FixedOffsetZone2;
    }(Zone);
    var InvalidZone = function(_Zone) {
      _inheritsLoose(InvalidZone2, _Zone);
      function InvalidZone2(zoneName) {
        var _this;
        _this = _Zone.call(this) || this;
        _this.zoneName = zoneName;
        return _this;
      }
      var _proto = InvalidZone2.prototype;
      _proto.offsetName = function offsetName() {
        return null;
      };
      _proto.formatOffset = function formatOffset2() {
        return "";
      };
      _proto.offset = function offset2() {
        return NaN;
      };
      _proto.equals = function equals2() {
        return false;
      };
      _createClass14(InvalidZone2, [{
        key: "type",
        get: function get() {
          return "invalid";
        }
        /** @override **/
      }, {
        key: "name",
        get: function get() {
          return this.zoneName;
        }
        /** @override **/
      }, {
        key: "universal",
        get: function get() {
          return false;
        }
      }, {
        key: "isValid",
        get: function get() {
          return false;
        }
      }]);
      return InvalidZone2;
    }(Zone);
    function normalizeZone(input, defaultZone2) {
      var offset2;
      if (isUndefined(input) || input === null) {
        return defaultZone2;
      } else if (input instanceof Zone) {
        return input;
      } else if (isString2(input)) {
        var lowered = input.toLowerCase();
        if (lowered === "local")
          return defaultZone2;
        else if (lowered === "utc" || lowered === "gmt")
          return FixedOffsetZone.utcInstance;
        else if ((offset2 = IANAZone.parseGMTOffset(input)) != null) {
          return FixedOffsetZone.instance(offset2);
        } else if (IANAZone.isValidSpecifier(lowered))
          return IANAZone.create(input);
        else
          return FixedOffsetZone.parseSpecifier(lowered) || new InvalidZone(input);
      } else if (isNumber2(input)) {
        return FixedOffsetZone.instance(input);
      } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
        return input;
      } else {
        return new InvalidZone(input);
      }
    }
    var now = function now2() {
      return Date.now();
    };
    var defaultZone = null;
    var defaultLocale = null;
    var defaultNumberingSystem = null;
    var defaultOutputCalendar = null;
    var throwOnInvalid = false;
    var Settings = function() {
      function Settings2() {
      }
      Settings2.resetCaches = function resetCaches() {
        Locale.resetCache();
        IANAZone.resetCache();
      };
      _createClass14(Settings2, null, [{
        key: "now",
        /**
         * Get the callback for returning the current timestamp.
         * @type {function}
         */
        get: function get() {
          return now;
        },
        set: function set(n2) {
          now = n2;
        }
        /**
         * Get the default time zone to create DateTimes in.
         * @type {string}
         */
      }, {
        key: "defaultZoneName",
        get: function get() {
          return Settings2.defaultZone.name;
        },
        set: function set(z) {
          if (!z) {
            defaultZone = null;
          } else {
            defaultZone = normalizeZone(z);
          }
        }
        /**
         * Get the default time zone object to create DateTimes in. Does not affect existing instances.
         * @type {Zone}
         */
      }, {
        key: "defaultZone",
        get: function get() {
          return defaultZone || LocalZone.instance;
        }
        /**
         * Get the default locale to create DateTimes with. Does not affect existing instances.
         * @type {string}
         */
      }, {
        key: "defaultLocale",
        get: function get() {
          return defaultLocale;
        },
        set: function set(locale) {
          defaultLocale = locale;
        }
        /**
         * Get the default numbering system to create DateTimes with. Does not affect existing instances.
         * @type {string}
         */
      }, {
        key: "defaultNumberingSystem",
        get: function get() {
          return defaultNumberingSystem;
        },
        set: function set(numberingSystem) {
          defaultNumberingSystem = numberingSystem;
        }
        /**
         * Get the default output calendar to create DateTimes with. Does not affect existing instances.
         * @type {string}
         */
      }, {
        key: "defaultOutputCalendar",
        get: function get() {
          return defaultOutputCalendar;
        },
        set: function set(outputCalendar) {
          defaultOutputCalendar = outputCalendar;
        }
        /**
         * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
         * @type {boolean}
         */
      }, {
        key: "throwOnInvalid",
        get: function get() {
          return throwOnInvalid;
        },
        set: function set(t) {
          throwOnInvalid = t;
        }
      }]);
      return Settings2;
    }();
    var intlDTCache = {};
    function getCachedDTF(locString, opts) {
      if (opts === void 0) {
        opts = {};
      }
      var key = JSON.stringify([locString, opts]);
      var dtf = intlDTCache[key];
      if (!dtf) {
        dtf = new Intl.DateTimeFormat(locString, opts);
        intlDTCache[key] = dtf;
      }
      return dtf;
    }
    var intlNumCache = {};
    function getCachedINF(locString, opts) {
      if (opts === void 0) {
        opts = {};
      }
      var key = JSON.stringify([locString, opts]);
      var inf = intlNumCache[key];
      if (!inf) {
        inf = new Intl.NumberFormat(locString, opts);
        intlNumCache[key] = inf;
      }
      return inf;
    }
    var intlRelCache = {};
    function getCachedRTF(locString, opts) {
      if (opts === void 0) {
        opts = {};
      }
      var _opts = opts, base = _opts.base, cacheKeyOpts = _objectWithoutPropertiesLoose(_opts, ["base"]);
      var key = JSON.stringify([locString, cacheKeyOpts]);
      var inf = intlRelCache[key];
      if (!inf) {
        inf = new Intl.RelativeTimeFormat(locString, opts);
        intlRelCache[key] = inf;
      }
      return inf;
    }
    var sysLocaleCache = null;
    function systemLocale() {
      if (sysLocaleCache) {
        return sysLocaleCache;
      } else if (hasIntl()) {
        var computedSys = new Intl.DateTimeFormat().resolvedOptions().locale;
        sysLocaleCache = !computedSys || computedSys === "und" ? "en-US" : computedSys;
        return sysLocaleCache;
      } else {
        sysLocaleCache = "en-US";
        return sysLocaleCache;
      }
    }
    function parseLocaleString(localeStr) {
      var uIndex = localeStr.indexOf("-u-");
      if (uIndex === -1) {
        return [localeStr];
      } else {
        var options;
        var smaller = localeStr.substring(0, uIndex);
        try {
          options = getCachedDTF(localeStr).resolvedOptions();
        } catch (e) {
          options = getCachedDTF(smaller).resolvedOptions();
        }
        var _options = options, numberingSystem = _options.numberingSystem, calendar = _options.calendar;
        return [smaller, numberingSystem, calendar];
      }
    }
    function intlConfigString(localeStr, numberingSystem, outputCalendar) {
      if (hasIntl()) {
        if (outputCalendar || numberingSystem) {
          localeStr += "-u";
          if (outputCalendar) {
            localeStr += "-ca-" + outputCalendar;
          }
          if (numberingSystem) {
            localeStr += "-nu-" + numberingSystem;
          }
          return localeStr;
        } else {
          return localeStr;
        }
      } else {
        return [];
      }
    }
    function mapMonths(f2) {
      var ms = [];
      for (var i = 1; i <= 12; i++) {
        var dt = DateTime.utc(2016, i, 1);
        ms.push(f2(dt));
      }
      return ms;
    }
    function mapWeekdays(f2) {
      var ms = [];
      for (var i = 1; i <= 7; i++) {
        var dt = DateTime.utc(2016, 11, 13 + i);
        ms.push(f2(dt));
      }
      return ms;
    }
    function listStuff(loc, length2, defaultOK, englishFn, intlFn) {
      var mode = loc.listingMode(defaultOK);
      if (mode === "error") {
        return null;
      } else if (mode === "en") {
        return englishFn(length2);
      } else {
        return intlFn(length2);
      }
    }
    function supportsFastNumbers(loc) {
      if (loc.numberingSystem && loc.numberingSystem !== "latn") {
        return false;
      } else {
        return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || hasIntl() && new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
      }
    }
    var PolyNumberFormatter = function() {
      function PolyNumberFormatter2(intl, forceSimple, opts) {
        this.padTo = opts.padTo || 0;
        this.floor = opts.floor || false;
        if (!forceSimple && hasIntl()) {
          var intlOpts = {
            useGrouping: false
          };
          if (opts.padTo > 0)
            intlOpts.minimumIntegerDigits = opts.padTo;
          this.inf = getCachedINF(intl, intlOpts);
        }
      }
      var _proto = PolyNumberFormatter2.prototype;
      _proto.format = function format2(i) {
        if (this.inf) {
          var fixed = this.floor ? Math.floor(i) : i;
          return this.inf.format(fixed);
        } else {
          var _fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
          return padStart(_fixed, this.padTo);
        }
      };
      return PolyNumberFormatter2;
    }();
    var PolyDateFormatter = function() {
      function PolyDateFormatter2(dt, intl, opts) {
        this.opts = opts;
        this.hasIntl = hasIntl();
        var z;
        if (dt.zone.universal && this.hasIntl) {
          var gmtOffset = -1 * (dt.offset / 60);
          var offsetZ = gmtOffset >= 0 ? "Etc/GMT+" + gmtOffset : "Etc/GMT" + gmtOffset;
          var isOffsetZoneSupported = IANAZone.isValidZone(offsetZ);
          if (dt.offset !== 0 && isOffsetZoneSupported) {
            z = offsetZ;
            this.dt = dt;
          } else {
            z = "UTC";
            if (opts.timeZoneName) {
              this.dt = dt;
            } else {
              this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1e3);
            }
          }
        } else if (dt.zone.type === "local") {
          this.dt = dt;
        } else {
          this.dt = dt;
          z = dt.zone.name;
        }
        if (this.hasIntl) {
          var intlOpts = Object.assign({}, this.opts);
          if (z) {
            intlOpts.timeZone = z;
          }
          this.dtf = getCachedDTF(intl, intlOpts);
        }
      }
      var _proto2 = PolyDateFormatter2.prototype;
      _proto2.format = function format2() {
        if (this.hasIntl) {
          return this.dtf.format(this.dt.toJSDate());
        } else {
          var tokenFormat = formatString(this.opts), loc = Locale.create("en-US");
          return Formatter.create(loc).formatDateTimeFromString(this.dt, tokenFormat);
        }
      };
      _proto2.formatToParts = function formatToParts() {
        if (this.hasIntl && hasFormatToParts()) {
          return this.dtf.formatToParts(this.dt.toJSDate());
        } else {
          return [];
        }
      };
      _proto2.resolvedOptions = function resolvedOptions() {
        if (this.hasIntl) {
          return this.dtf.resolvedOptions();
        } else {
          return {
            locale: "en-US",
            numberingSystem: "latn",
            outputCalendar: "gregory"
          };
        }
      };
      return PolyDateFormatter2;
    }();
    var PolyRelFormatter = function() {
      function PolyRelFormatter2(intl, isEnglish, opts) {
        this.opts = Object.assign({
          style: "long"
        }, opts);
        if (!isEnglish && hasRelative()) {
          this.rtf = getCachedRTF(intl, opts);
        }
      }
      var _proto3 = PolyRelFormatter2.prototype;
      _proto3.format = function format2(count, unit) {
        if (this.rtf) {
          return this.rtf.format(count, unit);
        } else {
          return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
        }
      };
      _proto3.formatToParts = function formatToParts(count, unit) {
        if (this.rtf) {
          return this.rtf.formatToParts(count, unit);
        } else {
          return [];
        }
      };
      return PolyRelFormatter2;
    }();
    var Locale = function() {
      Locale2.fromOpts = function fromOpts(opts) {
        return Locale2.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
      };
      Locale2.create = function create(locale, numberingSystem, outputCalendar, defaultToEN) {
        if (defaultToEN === void 0) {
          defaultToEN = false;
        }
        var specifiedLocale = locale || Settings.defaultLocale, localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale()), numberingSystemR = numberingSystem || Settings.defaultNumberingSystem, outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
        return new Locale2(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
      };
      Locale2.resetCache = function resetCache() {
        sysLocaleCache = null;
        intlDTCache = {};
        intlNumCache = {};
        intlRelCache = {};
      };
      Locale2.fromObject = function fromObject(_temp) {
        var _ref = _temp === void 0 ? {} : _temp, locale = _ref.locale, numberingSystem = _ref.numberingSystem, outputCalendar = _ref.outputCalendar;
        return Locale2.create(locale, numberingSystem, outputCalendar);
      };
      function Locale2(locale, numbering, outputCalendar, specifiedLocale) {
        var _parseLocaleString = parseLocaleString(locale), parsedLocale = _parseLocaleString[0], parsedNumberingSystem = _parseLocaleString[1], parsedOutputCalendar = _parseLocaleString[2];
        this.locale = parsedLocale;
        this.numberingSystem = numbering || parsedNumberingSystem || null;
        this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
        this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
        this.weekdaysCache = {
          format: {},
          standalone: {}
        };
        this.monthsCache = {
          format: {},
          standalone: {}
        };
        this.meridiemCache = null;
        this.eraCache = {};
        this.specifiedLocale = specifiedLocale;
        this.fastNumbersCached = null;
      }
      var _proto4 = Locale2.prototype;
      _proto4.listingMode = function listingMode(defaultOK) {
        if (defaultOK === void 0) {
          defaultOK = true;
        }
        var intl = hasIntl(), hasFTP = intl && hasFormatToParts(), isActuallyEn = this.isEnglish(), hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
        if (!hasFTP && !(isActuallyEn && hasNoWeirdness) && !defaultOK) {
          return "error";
        } else if (!hasFTP || isActuallyEn && hasNoWeirdness) {
          return "en";
        } else {
          return "intl";
        }
      };
      _proto4.clone = function clone2(alts) {
        if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
          return this;
        } else {
          return Locale2.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);
        }
      };
      _proto4.redefaultToEN = function redefaultToEN(alts) {
        if (alts === void 0) {
          alts = {};
        }
        return this.clone(Object.assign({}, alts, {
          defaultToEN: true
        }));
      };
      _proto4.redefaultToSystem = function redefaultToSystem(alts) {
        if (alts === void 0) {
          alts = {};
        }
        return this.clone(Object.assign({}, alts, {
          defaultToEN: false
        }));
      };
      _proto4.months = function months$1(length2, format2, defaultOK) {
        var _this = this;
        if (format2 === void 0) {
          format2 = false;
        }
        if (defaultOK === void 0) {
          defaultOK = true;
        }
        return listStuff(this, length2, defaultOK, months, function() {
          var intl = format2 ? {
            month: length2,
            day: "numeric"
          } : {
            month: length2
          }, formatStr = format2 ? "format" : "standalone";
          if (!_this.monthsCache[formatStr][length2]) {
            _this.monthsCache[formatStr][length2] = mapMonths(function(dt) {
              return _this.extract(dt, intl, "month");
            });
          }
          return _this.monthsCache[formatStr][length2];
        });
      };
      _proto4.weekdays = function weekdays$1(length2, format2, defaultOK) {
        var _this2 = this;
        if (format2 === void 0) {
          format2 = false;
        }
        if (defaultOK === void 0) {
          defaultOK = true;
        }
        return listStuff(this, length2, defaultOK, weekdays, function() {
          var intl = format2 ? {
            weekday: length2,
            year: "numeric",
            month: "long",
            day: "numeric"
          } : {
            weekday: length2
          }, formatStr = format2 ? "format" : "standalone";
          if (!_this2.weekdaysCache[formatStr][length2]) {
            _this2.weekdaysCache[formatStr][length2] = mapWeekdays(function(dt) {
              return _this2.extract(dt, intl, "weekday");
            });
          }
          return _this2.weekdaysCache[formatStr][length2];
        });
      };
      _proto4.meridiems = function meridiems$1(defaultOK) {
        var _this3 = this;
        if (defaultOK === void 0) {
          defaultOK = true;
        }
        return listStuff(this, void 0, defaultOK, function() {
          return meridiems;
        }, function() {
          if (!_this3.meridiemCache) {
            var intl = {
              hour: "numeric",
              hour12: true
            };
            _this3.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(function(dt) {
              return _this3.extract(dt, intl, "dayperiod");
            });
          }
          return _this3.meridiemCache;
        });
      };
      _proto4.eras = function eras$1(length2, defaultOK) {
        var _this4 = this;
        if (defaultOK === void 0) {
          defaultOK = true;
        }
        return listStuff(this, length2, defaultOK, eras, function() {
          var intl = {
            era: length2
          };
          if (!_this4.eraCache[length2]) {
            _this4.eraCache[length2] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(function(dt) {
              return _this4.extract(dt, intl, "era");
            });
          }
          return _this4.eraCache[length2];
        });
      };
      _proto4.extract = function extract(dt, intlOpts, field) {
        var df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find(function(m) {
          return m.type.toLowerCase() === field;
        });
        return matching ? matching.value : null;
      };
      _proto4.numberFormatter = function numberFormatter(opts) {
        if (opts === void 0) {
          opts = {};
        }
        return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
      };
      _proto4.dtFormatter = function dtFormatter(dt, intlOpts) {
        if (intlOpts === void 0) {
          intlOpts = {};
        }
        return new PolyDateFormatter(dt, this.intl, intlOpts);
      };
      _proto4.relFormatter = function relFormatter(opts) {
        if (opts === void 0) {
          opts = {};
        }
        return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
      };
      _proto4.isEnglish = function isEnglish() {
        return this.locale === "en" || this.locale.toLowerCase() === "en-us" || hasIntl() && new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
      };
      _proto4.equals = function equals2(other) {
        return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
      };
      _createClass14(Locale2, [{
        key: "fastNumbers",
        get: function get() {
          if (this.fastNumbersCached == null) {
            this.fastNumbersCached = supportsFastNumbers(this);
          }
          return this.fastNumbersCached;
        }
      }]);
      return Locale2;
    }();
    function combineRegexes() {
      for (var _len = arguments.length, regexes = new Array(_len), _key = 0; _key < _len; _key++) {
        regexes[_key] = arguments[_key];
      }
      var full = regexes.reduce(function(f2, r) {
        return f2 + r.source;
      }, "");
      return RegExp("^" + full + "$");
    }
    function combineExtractors() {
      for (var _len2 = arguments.length, extractors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        extractors[_key2] = arguments[_key2];
      }
      return function(m) {
        return extractors.reduce(function(_ref, ex) {
          var mergedVals = _ref[0], mergedZone = _ref[1], cursor = _ref[2];
          var _ex = ex(m, cursor), val = _ex[0], zone = _ex[1], next = _ex[2];
          return [Object.assign(mergedVals, val), mergedZone || zone, next];
        }, [{}, null, 1]).slice(0, 2);
      };
    }
    function parse4(s2) {
      if (s2 == null) {
        return [null, null];
      }
      for (var _len3 = arguments.length, patterns = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        patterns[_key3 - 1] = arguments[_key3];
      }
      for (var _i = 0, _patterns = patterns; _i < _patterns.length; _i++) {
        var _patterns$_i = _patterns[_i], regex = _patterns$_i[0], extractor = _patterns$_i[1];
        var m = regex.exec(s2);
        if (m) {
          return extractor(m);
        }
      }
      return [null, null];
    }
    function simpleParse() {
      for (var _len4 = arguments.length, keys = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        keys[_key4] = arguments[_key4];
      }
      return function(match2, cursor) {
        var ret = {};
        var i;
        for (i = 0; i < keys.length; i++) {
          ret[keys[i]] = parseInteger(match2[cursor + i]);
        }
        return [ret, null, cursor + i];
      };
    }
    var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
    var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
    var isoTimeRegex = RegExp("" + isoTimeBaseRegex.source + offsetRegex.source + "?");
    var isoTimeExtensionRegex = RegExp("(?:T" + isoTimeRegex.source + ")?");
    var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
    var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
    var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
    var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
    var extractISOOrdinalData = simpleParse("year", "ordinal");
    var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
    var sqlTimeRegex = RegExp(isoTimeBaseRegex.source + " ?(?:" + offsetRegex.source + "|(" + ianaRegex.source + "))?");
    var sqlTimeExtensionRegex = RegExp("(?: " + sqlTimeRegex.source + ")?");
    function int(match2, pos, fallback) {
      var m = match2[pos];
      return isUndefined(m) ? fallback : parseInteger(m);
    }
    function extractISOYmd(match2, cursor) {
      var item = {
        year: int(match2, cursor),
        month: int(match2, cursor + 1, 1),
        day: int(match2, cursor + 2, 1)
      };
      return [item, null, cursor + 3];
    }
    function extractISOTime(match2, cursor) {
      var item = {
        hours: int(match2, cursor, 0),
        minutes: int(match2, cursor + 1, 0),
        seconds: int(match2, cursor + 2, 0),
        milliseconds: parseMillis(match2[cursor + 3])
      };
      return [item, null, cursor + 4];
    }
    function extractISOOffset(match2, cursor) {
      var local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
      return [{}, zone, cursor + 3];
    }
    function extractIANAZone(match2, cursor) {
      var zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
      return [{}, zone, cursor + 1];
    }
    var isoTimeOnly = RegExp("^T?" + isoTimeBaseRegex.source + "$");
    var isoDuration = /^-?P(?:(?:(-?\d{1,9})Y)?(?:(-?\d{1,9})M)?(?:(-?\d{1,9})W)?(?:(-?\d{1,9})D)?(?:T(?:(-?\d{1,9})H)?(?:(-?\d{1,9})M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,9}))?S)?)?)$/;
    function extractISODuration(match2) {
      var s2 = match2[0], yearStr = match2[1], monthStr = match2[2], weekStr = match2[3], dayStr = match2[4], hourStr = match2[5], minuteStr = match2[6], secondStr = match2[7], millisecondsStr = match2[8];
      var hasNegativePrefix = s2[0] === "-";
      var negativeSeconds = secondStr && secondStr[0] === "-";
      var maybeNegate = function maybeNegate2(num, force) {
        if (force === void 0) {
          force = false;
        }
        return num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
      };
      return [{
        years: maybeNegate(parseInteger(yearStr)),
        months: maybeNegate(parseInteger(monthStr)),
        weeks: maybeNegate(parseInteger(weekStr)),
        days: maybeNegate(parseInteger(dayStr)),
        hours: maybeNegate(parseInteger(hourStr)),
        minutes: maybeNegate(parseInteger(minuteStr)),
        seconds: maybeNegate(parseInteger(secondStr), secondStr === "-0"),
        milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
      }];
    }
    var obsOffsets = {
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result2 = {
        year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
        month: monthsShort.indexOf(monthStr) + 1,
        day: parseInteger(dayStr),
        hour: parseInteger(hourStr),
        minute: parseInteger(minuteStr)
      };
      if (secondStr)
        result2.second = parseInteger(secondStr);
      if (weekdayStr) {
        result2.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
      }
      return result2;
    }
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
    function extractRFC2822(match2) {
      var weekdayStr = match2[1], dayStr = match2[2], monthStr = match2[3], yearStr = match2[4], hourStr = match2[5], minuteStr = match2[6], secondStr = match2[7], obsOffset = match2[8], milOffset = match2[9], offHourStr = match2[10], offMinuteStr = match2[11], result2 = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      var offset2;
      if (obsOffset) {
        offset2 = obsOffsets[obsOffset];
      } else if (milOffset) {
        offset2 = 0;
      } else {
        offset2 = signedOffset(offHourStr, offMinuteStr);
      }
      return [result2, new FixedOffsetZone(offset2)];
    }
    function preprocessRFC2822(s2) {
      return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
    }
    var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
    var rfc850 = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
    var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
    function extractRFC1123Or850(match2) {
      var weekdayStr = match2[1], dayStr = match2[2], monthStr = match2[3], yearStr = match2[4], hourStr = match2[5], minuteStr = match2[6], secondStr = match2[7], result2 = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result2, FixedOffsetZone.utcInstance];
    }
    function extractASCII(match2) {
      var weekdayStr = match2[1], monthStr = match2[2], dayStr = match2[3], hourStr = match2[4], minuteStr = match2[5], secondStr = match2[6], yearStr = match2[7], result2 = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result2, FixedOffsetZone.utcInstance];
    }
    var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
    var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
    var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
    var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
    var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset);
    var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset);
    var extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset);
    var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset);
    function parseISODate(s2) {
      return parse4(s2, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
    }
    function parseRFC2822Date(s2) {
      return parse4(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
    }
    function parseHTTPDate(s2) {
      return parse4(s2, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
    }
    function parseISODuration(s2) {
      return parse4(s2, [isoDuration, extractISODuration]);
    }
    var extractISOTimeOnly = combineExtractors(extractISOTime);
    function parseISOTimeOnly(s2) {
      return parse4(s2, [isoTimeOnly, extractISOTimeOnly]);
    }
    var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
    var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
    var extractISOYmdTimeOffsetAndIANAZone = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
    var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
    function parseSQL(s2) {
      return parse4(s2, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeOffsetAndIANAZone], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
    }
    var INVALID = "Invalid Duration";
    var lowOrderMatrix = {
      weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1e3
      },
      days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1e3
      },
      hours: {
        minutes: 60,
        seconds: 60 * 60,
        milliseconds: 60 * 60 * 1e3
      },
      minutes: {
        seconds: 60,
        milliseconds: 60 * 1e3
      },
      seconds: {
        milliseconds: 1e3
      }
    };
    var casualMatrix = Object.assign({
      years: {
        quarters: 4,
        months: 12,
        weeks: 52,
        days: 365,
        hours: 365 * 24,
        minutes: 365 * 24 * 60,
        seconds: 365 * 24 * 60 * 60,
        milliseconds: 365 * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: 13,
        days: 91,
        hours: 91 * 24,
        minutes: 91 * 24 * 60,
        seconds: 91 * 24 * 60 * 60,
        milliseconds: 91 * 24 * 60 * 60 * 1e3
      },
      months: {
        weeks: 4,
        days: 30,
        hours: 30 * 24,
        minutes: 30 * 24 * 60,
        seconds: 30 * 24 * 60 * 60,
        milliseconds: 30 * 24 * 60 * 60 * 1e3
      }
    }, lowOrderMatrix);
    var daysInYearAccurate = 146097 / 400;
    var daysInMonthAccurate = 146097 / 4800;
    var accurateMatrix = Object.assign({
      years: {
        quarters: 4,
        months: 12,
        weeks: daysInYearAccurate / 7,
        days: daysInYearAccurate,
        hours: daysInYearAccurate * 24,
        minutes: daysInYearAccurate * 24 * 60,
        seconds: daysInYearAccurate * 24 * 60 * 60,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: daysInYearAccurate / 28,
        days: daysInYearAccurate / 4,
        hours: daysInYearAccurate * 24 / 4,
        minutes: daysInYearAccurate * 24 * 60 / 4,
        seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
      },
      months: {
        weeks: daysInMonthAccurate / 7,
        days: daysInMonthAccurate,
        hours: daysInMonthAccurate * 24,
        minutes: daysInMonthAccurate * 24 * 60,
        seconds: daysInMonthAccurate * 24 * 60 * 60,
        milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
      }
    }, lowOrderMatrix);
    var orderedUnits = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
    var reverseUnits = orderedUnits.slice(0).reverse();
    function clone(dur, alts, clear) {
      if (clear === void 0) {
        clear = false;
      }
      var conf = {
        values: clear ? alts.values : Object.assign({}, dur.values, alts.values || {}),
        loc: dur.loc.clone(alts.loc),
        conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy
      };
      return new Duration(conf);
    }
    function antiTrunc(n2) {
      return n2 < 0 ? Math.floor(n2) : Math.ceil(n2);
    }
    function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
      var conv = matrix[toUnit][fromUnit], raw = fromMap[fromUnit] / conv, sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]), added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
      toMap[toUnit] += added;
      fromMap[fromUnit] -= added * conv;
    }
    function normalizeValues(matrix, vals) {
      reverseUnits.reduce(function(previous, current) {
        if (!isUndefined(vals[current])) {
          if (previous) {
            convert(matrix, vals, previous, vals, current);
          }
          return current;
        } else {
          return previous;
        }
      }, null);
    }
    var Duration = function() {
      function Duration2(config) {
        var accurate = config.conversionAccuracy === "longterm" || false;
        this.values = config.values;
        this.loc = config.loc || Locale.create();
        this.conversionAccuracy = accurate ? "longterm" : "casual";
        this.invalid = config.invalid || null;
        this.matrix = accurate ? accurateMatrix : casualMatrix;
        this.isLuxonDuration = true;
      }
      Duration2.fromMillis = function fromMillis(count, opts) {
        return Duration2.fromObject(Object.assign({
          milliseconds: count
        }, opts));
      };
      Duration2.fromObject = function fromObject(obj) {
        if (obj == null || typeof obj !== "object") {
          throw new InvalidArgumentError("Duration.fromObject: argument expected to be an object, got " + (obj === null ? "null" : typeof obj));
        }
        return new Duration2({
          values: normalizeObject(obj, Duration2.normalizeUnit, [
            "locale",
            "numberingSystem",
            "conversionAccuracy",
            "zone"
            // a bit of debt; it's super inconvenient internally not to be able to blindly pass this
          ]),
          loc: Locale.fromObject(obj),
          conversionAccuracy: obj.conversionAccuracy
        });
      };
      Duration2.fromISO = function fromISO(text, opts) {
        var _parseISODuration = parseISODuration(text), parsed = _parseISODuration[0];
        if (parsed) {
          var obj = Object.assign(parsed, opts);
          return Duration2.fromObject(obj);
        } else {
          return Duration2.invalid("unparsable", 'the input "' + text + `" can't be parsed as ISO 8601`);
        }
      };
      Duration2.fromISOTime = function fromISOTime(text, opts) {
        var _parseISOTimeOnly = parseISOTimeOnly(text), parsed = _parseISOTimeOnly[0];
        if (parsed) {
          var obj = Object.assign(parsed, opts);
          return Duration2.fromObject(obj);
        } else {
          return Duration2.invalid("unparsable", 'the input "' + text + `" can't be parsed as ISO 8601`);
        }
      };
      Duration2.invalid = function invalid(reason, explanation) {
        if (explanation === void 0) {
          explanation = null;
        }
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
        }
        var invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDurationError(invalid2);
        } else {
          return new Duration2({
            invalid: invalid2
          });
        }
      };
      Duration2.normalizeUnit = function normalizeUnit2(unit) {
        var normalized = {
          year: "years",
          years: "years",
          quarter: "quarters",
          quarters: "quarters",
          month: "months",
          months: "months",
          week: "weeks",
          weeks: "weeks",
          day: "days",
          days: "days",
          hour: "hours",
          hours: "hours",
          minute: "minutes",
          minutes: "minutes",
          second: "seconds",
          seconds: "seconds",
          millisecond: "milliseconds",
          milliseconds: "milliseconds"
        }[unit ? unit.toLowerCase() : unit];
        if (!normalized)
          throw new InvalidUnitError(unit);
        return normalized;
      };
      Duration2.isDuration = function isDuration(o) {
        return o && o.isLuxonDuration || false;
      };
      var _proto = Duration2.prototype;
      _proto.toFormat = function toFormat(fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var fmtOpts = Object.assign({}, opts, {
          floor: opts.round !== false && opts.floor !== false
        });
        return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
      };
      _proto.toObject = function toObject(opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (!this.isValid)
          return {};
        var base = Object.assign({}, this.values);
        if (opts.includeConfig) {
          base.conversionAccuracy = this.conversionAccuracy;
          base.numberingSystem = this.loc.numberingSystem;
          base.locale = this.loc.locale;
        }
        return base;
      };
      _proto.toISO = function toISO() {
        if (!this.isValid)
          return null;
        var s2 = "P";
        if (this.years !== 0)
          s2 += this.years + "Y";
        if (this.months !== 0 || this.quarters !== 0)
          s2 += this.months + this.quarters * 3 + "M";
        if (this.weeks !== 0)
          s2 += this.weeks + "W";
        if (this.days !== 0)
          s2 += this.days + "D";
        if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
          s2 += "T";
        if (this.hours !== 0)
          s2 += this.hours + "H";
        if (this.minutes !== 0)
          s2 += this.minutes + "M";
        if (this.seconds !== 0 || this.milliseconds !== 0)
          s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
        if (s2 === "P")
          s2 += "T0S";
        return s2;
      };
      _proto.toISOTime = function toISOTime(opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (!this.isValid)
          return null;
        var millis = this.toMillis();
        if (millis < 0 || millis >= 864e5)
          return null;
        opts = Object.assign({
          suppressMilliseconds: false,
          suppressSeconds: false,
          includePrefix: false,
          format: "extended"
        }, opts);
        var value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
        var fmt = opts.format === "basic" ? "hhmm" : "hh:mm";
        if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
          fmt += opts.format === "basic" ? "ss" : ":ss";
          if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
            fmt += ".SSS";
          }
        }
        var str = value.toFormat(fmt);
        if (opts.includePrefix) {
          str = "T" + str;
        }
        return str;
      };
      _proto.toJSON = function toJSON() {
        return this.toISO();
      };
      _proto.toString = function toString() {
        return this.toISO();
      };
      _proto.toMillis = function toMillis() {
        return this.as("milliseconds");
      };
      _proto.valueOf = function valueOf() {
        return this.toMillis();
      };
      _proto.plus = function plus(duration) {
        if (!this.isValid)
          return this;
        var dur = friendlyDuration(duration), result2 = {};
        for (var _iterator = _createForOfIteratorHelperLoose12(orderedUnits), _step; !(_step = _iterator()).done; ) {
          var k = _step.value;
          if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
            result2[k] = dur.get(k) + this.get(k);
          }
        }
        return clone(this, {
          values: result2
        }, true);
      };
      _proto.minus = function minus(duration) {
        if (!this.isValid)
          return this;
        var dur = friendlyDuration(duration);
        return this.plus(dur.negate());
      };
      _proto.mapUnits = function mapUnits(fn) {
        if (!this.isValid)
          return this;
        var result2 = {};
        for (var _i = 0, _Object$keys = Object.keys(this.values); _i < _Object$keys.length; _i++) {
          var k = _Object$keys[_i];
          result2[k] = asNumber(fn(this.values[k], k));
        }
        return clone(this, {
          values: result2
        }, true);
      };
      _proto.get = function get(unit) {
        return this[Duration2.normalizeUnit(unit)];
      };
      _proto.set = function set(values) {
        if (!this.isValid)
          return this;
        var mixed = Object.assign(this.values, normalizeObject(values, Duration2.normalizeUnit, []));
        return clone(this, {
          values: mixed
        });
      };
      _proto.reconfigure = function reconfigure(_temp) {
        var _ref = _temp === void 0 ? {} : _temp, locale = _ref.locale, numberingSystem = _ref.numberingSystem, conversionAccuracy = _ref.conversionAccuracy;
        var loc = this.loc.clone({
          locale,
          numberingSystem
        }), opts = {
          loc
        };
        if (conversionAccuracy) {
          opts.conversionAccuracy = conversionAccuracy;
        }
        return clone(this, opts);
      };
      _proto.as = function as(unit) {
        return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
      };
      _proto.normalize = function normalize() {
        if (!this.isValid)
          return this;
        var vals = this.toObject();
        normalizeValues(this.matrix, vals);
        return clone(this, {
          values: vals
        }, true);
      };
      _proto.shiftTo = function shiftTo() {
        for (var _len = arguments.length, units = new Array(_len), _key = 0; _key < _len; _key++) {
          units[_key] = arguments[_key];
        }
        if (!this.isValid)
          return this;
        if (units.length === 0) {
          return this;
        }
        units = units.map(function(u) {
          return Duration2.normalizeUnit(u);
        });
        var built = {}, accumulated = {}, vals = this.toObject();
        var lastUnit;
        for (var _iterator2 = _createForOfIteratorHelperLoose12(orderedUnits), _step2; !(_step2 = _iterator2()).done; ) {
          var k = _step2.value;
          if (units.indexOf(k) >= 0) {
            lastUnit = k;
            var own = 0;
            for (var ak in accumulated) {
              own += this.matrix[ak][k] * accumulated[ak];
              accumulated[ak] = 0;
            }
            if (isNumber2(vals[k])) {
              own += vals[k];
            }
            var i = Math.trunc(own);
            built[k] = i;
            accumulated[k] = own - i;
            for (var down in vals) {
              if (orderedUnits.indexOf(down) > orderedUnits.indexOf(k)) {
                convert(this.matrix, vals, down, built, k);
              }
            }
          } else if (isNumber2(vals[k])) {
            accumulated[k] = vals[k];
          }
        }
        for (var key in accumulated) {
          if (accumulated[key] !== 0) {
            built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
          }
        }
        return clone(this, {
          values: built
        }, true).normalize();
      };
      _proto.negate = function negate() {
        if (!this.isValid)
          return this;
        var negated = {};
        for (var _i2 = 0, _Object$keys2 = Object.keys(this.values); _i2 < _Object$keys2.length; _i2++) {
          var k = _Object$keys2[_i2];
          negated[k] = -this.values[k];
        }
        return clone(this, {
          values: negated
        }, true);
      };
      _proto.equals = function equals2(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        if (!this.loc.equals(other.loc)) {
          return false;
        }
        function eq(v12, v2) {
          if (v12 === void 0 || v12 === 0)
            return v2 === void 0 || v2 === 0;
          return v12 === v2;
        }
        for (var _iterator3 = _createForOfIteratorHelperLoose12(orderedUnits), _step3; !(_step3 = _iterator3()).done; ) {
          var u = _step3.value;
          if (!eq(this.values[u], other.values[u])) {
            return false;
          }
        }
        return true;
      };
      _createClass14(Duration2, [{
        key: "locale",
        get: function get() {
          return this.isValid ? this.loc.locale : null;
        }
        /**
         * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
         *
         * @type {string}
         */
      }, {
        key: "numberingSystem",
        get: function get() {
          return this.isValid ? this.loc.numberingSystem : null;
        }
      }, {
        key: "years",
        get: function get() {
          return this.isValid ? this.values.years || 0 : NaN;
        }
        /**
         * Get the quarters.
         * @type {number}
         */
      }, {
        key: "quarters",
        get: function get() {
          return this.isValid ? this.values.quarters || 0 : NaN;
        }
        /**
         * Get the months.
         * @type {number}
         */
      }, {
        key: "months",
        get: function get() {
          return this.isValid ? this.values.months || 0 : NaN;
        }
        /**
         * Get the weeks
         * @type {number}
         */
      }, {
        key: "weeks",
        get: function get() {
          return this.isValid ? this.values.weeks || 0 : NaN;
        }
        /**
         * Get the days.
         * @type {number}
         */
      }, {
        key: "days",
        get: function get() {
          return this.isValid ? this.values.days || 0 : NaN;
        }
        /**
         * Get the hours.
         * @type {number}
         */
      }, {
        key: "hours",
        get: function get() {
          return this.isValid ? this.values.hours || 0 : NaN;
        }
        /**
         * Get the minutes.
         * @type {number}
         */
      }, {
        key: "minutes",
        get: function get() {
          return this.isValid ? this.values.minutes || 0 : NaN;
        }
        /**
         * Get the seconds.
         * @return {number}
         */
      }, {
        key: "seconds",
        get: function get() {
          return this.isValid ? this.values.seconds || 0 : NaN;
        }
        /**
         * Get the milliseconds.
         * @return {number}
         */
      }, {
        key: "milliseconds",
        get: function get() {
          return this.isValid ? this.values.milliseconds || 0 : NaN;
        }
        /**
         * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
         * on invalid DateTimes or Intervals.
         * @return {boolean}
         */
      }, {
        key: "isValid",
        get: function get() {
          return this.invalid === null;
        }
        /**
         * Returns an error code if this Duration became invalid, or null if the Duration is valid
         * @return {string}
         */
      }, {
        key: "invalidReason",
        get: function get() {
          return this.invalid ? this.invalid.reason : null;
        }
        /**
         * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
         * @type {string}
         */
      }, {
        key: "invalidExplanation",
        get: function get() {
          return this.invalid ? this.invalid.explanation : null;
        }
      }]);
      return Duration2;
    }();
    function friendlyDuration(durationish) {
      if (isNumber2(durationish)) {
        return Duration.fromMillis(durationish);
      } else if (Duration.isDuration(durationish)) {
        return durationish;
      } else if (typeof durationish === "object") {
        return Duration.fromObject(durationish);
      } else {
        throw new InvalidArgumentError("Unknown duration argument " + durationish + " of type " + typeof durationish);
      }
    }
    var INVALID$1 = "Invalid Interval";
    function validateStartEnd(start, end) {
      if (!start || !start.isValid) {
        return Interval.invalid("missing or invalid start");
      } else if (!end || !end.isValid) {
        return Interval.invalid("missing or invalid end");
      } else if (end < start) {
        return Interval.invalid("end before start", "The end of an interval must be after its start, but you had start=" + start.toISO() + " and end=" + end.toISO());
      } else {
        return null;
      }
    }
    var Interval = function() {
      function Interval2(config) {
        this.s = config.start;
        this.e = config.end;
        this.invalid = config.invalid || null;
        this.isLuxonInterval = true;
      }
      Interval2.invalid = function invalid(reason, explanation) {
        if (explanation === void 0) {
          explanation = null;
        }
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
        }
        var invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidIntervalError(invalid2);
        } else {
          return new Interval2({
            invalid: invalid2
          });
        }
      };
      Interval2.fromDateTimes = function fromDateTimes(start, end) {
        var builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
        var validateError = validateStartEnd(builtStart, builtEnd);
        if (validateError == null) {
          return new Interval2({
            start: builtStart,
            end: builtEnd
          });
        } else {
          return validateError;
        }
      };
      Interval2.after = function after(start, duration) {
        var dur = friendlyDuration(duration), dt = friendlyDateTime(start);
        return Interval2.fromDateTimes(dt, dt.plus(dur));
      };
      Interval2.before = function before(end, duration) {
        var dur = friendlyDuration(duration), dt = friendlyDateTime(end);
        return Interval2.fromDateTimes(dt.minus(dur), dt);
      };
      Interval2.fromISO = function fromISO(text, opts) {
        var _split = (text || "").split("/", 2), s2 = _split[0], e = _split[1];
        if (s2 && e) {
          var start, startIsValid;
          try {
            start = DateTime.fromISO(s2, opts);
            startIsValid = start.isValid;
          } catch (e2) {
            startIsValid = false;
          }
          var end, endIsValid;
          try {
            end = DateTime.fromISO(e, opts);
            endIsValid = end.isValid;
          } catch (e2) {
            endIsValid = false;
          }
          if (startIsValid && endIsValid) {
            return Interval2.fromDateTimes(start, end);
          }
          if (startIsValid) {
            var dur = Duration.fromISO(e, opts);
            if (dur.isValid) {
              return Interval2.after(start, dur);
            }
          } else if (endIsValid) {
            var _dur = Duration.fromISO(s2, opts);
            if (_dur.isValid) {
              return Interval2.before(end, _dur);
            }
          }
        }
        return Interval2.invalid("unparsable", 'the input "' + text + `" can't be parsed as ISO 8601`);
      };
      Interval2.isInterval = function isInterval(o) {
        return o && o.isLuxonInterval || false;
      };
      var _proto = Interval2.prototype;
      _proto.length = function length2(unit) {
        if (unit === void 0) {
          unit = "milliseconds";
        }
        return this.isValid ? this.toDuration.apply(this, [unit]).get(unit) : NaN;
      };
      _proto.count = function count(unit) {
        if (unit === void 0) {
          unit = "milliseconds";
        }
        if (!this.isValid)
          return NaN;
        var start = this.start.startOf(unit), end = this.end.startOf(unit);
        return Math.floor(end.diff(start, unit).get(unit)) + 1;
      };
      _proto.hasSame = function hasSame(unit) {
        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
      };
      _proto.isEmpty = function isEmpty2() {
        return this.s.valueOf() === this.e.valueOf();
      };
      _proto.isAfter = function isAfter(dateTime) {
        if (!this.isValid)
          return false;
        return this.s > dateTime;
      };
      _proto.isBefore = function isBefore(dateTime) {
        if (!this.isValid)
          return false;
        return this.e <= dateTime;
      };
      _proto.contains = function contains2(dateTime) {
        if (!this.isValid)
          return false;
        return this.s <= dateTime && this.e > dateTime;
      };
      _proto.set = function set(_temp) {
        var _ref = _temp === void 0 ? {} : _temp, start = _ref.start, end = _ref.end;
        if (!this.isValid)
          return this;
        return Interval2.fromDateTimes(start || this.s, end || this.e);
      };
      _proto.splitAt = function splitAt() {
        var _this = this;
        if (!this.isValid)
          return [];
        for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
          dateTimes[_key] = arguments[_key];
        }
        var sorted = dateTimes.map(friendlyDateTime).filter(function(d) {
          return _this.contains(d);
        }).sort(), results = [];
        var s2 = this.s, i = 0;
        while (s2 < this.e) {
          var added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
          results.push(Interval2.fromDateTimes(s2, next));
          s2 = next;
          i += 1;
        }
        return results;
      };
      _proto.splitBy = function splitBy(duration) {
        var dur = friendlyDuration(duration);
        if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
          return [];
        }
        var s2 = this.s, idx = 1, next;
        var results = [];
        while (s2 < this.e) {
          var added = this.start.plus(dur.mapUnits(function(x) {
            return x * idx;
          }));
          next = +added > +this.e ? this.e : added;
          results.push(Interval2.fromDateTimes(s2, next));
          s2 = next;
          idx += 1;
        }
        return results;
      };
      _proto.divideEqually = function divideEqually(numberOfParts) {
        if (!this.isValid)
          return [];
        return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
      };
      _proto.overlaps = function overlaps(other) {
        return this.e > other.s && this.s < other.e;
      };
      _proto.abutsStart = function abutsStart(other) {
        if (!this.isValid)
          return false;
        return +this.e === +other.s;
      };
      _proto.abutsEnd = function abutsEnd(other) {
        if (!this.isValid)
          return false;
        return +other.e === +this.s;
      };
      _proto.engulfs = function engulfs(other) {
        if (!this.isValid)
          return false;
        return this.s <= other.s && this.e >= other.e;
      };
      _proto.equals = function equals2(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        return this.s.equals(other.s) && this.e.equals(other.e);
      };
      _proto.intersection = function intersection(other) {
        if (!this.isValid)
          return this;
        var s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
        if (s2 >= e) {
          return null;
        } else {
          return Interval2.fromDateTimes(s2, e);
        }
      };
      _proto.union = function union(other) {
        if (!this.isValid)
          return this;
        var s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
        return Interval2.fromDateTimes(s2, e);
      };
      Interval2.merge = function merge(intervals) {
        var _intervals$sort$reduc = intervals.sort(function(a, b) {
          return a.s - b.s;
        }).reduce(function(_ref2, item) {
          var sofar = _ref2[0], current = _ref2[1];
          if (!current) {
            return [sofar, item];
          } else if (current.overlaps(item) || current.abutsStart(item)) {
            return [sofar, current.union(item)];
          } else {
            return [sofar.concat([current]), item];
          }
        }, [[], null]), found = _intervals$sort$reduc[0], final = _intervals$sort$reduc[1];
        if (final) {
          found.push(final);
        }
        return found;
      };
      Interval2.xor = function xor(intervals) {
        var _Array$prototype;
        var start = null, currentCount = 0;
        var results = [], ends = intervals.map(function(i2) {
          return [{
            time: i2.s,
            type: "s"
          }, {
            time: i2.e,
            type: "e"
          }];
        }), flattened = (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, ends), arr = flattened.sort(function(a, b) {
          return a.time - b.time;
        });
        for (var _iterator = _createForOfIteratorHelperLoose12(arr), _step; !(_step = _iterator()).done; ) {
          var i = _step.value;
          currentCount += i.type === "s" ? 1 : -1;
          if (currentCount === 1) {
            start = i.time;
          } else {
            if (start && +start !== +i.time) {
              results.push(Interval2.fromDateTimes(start, i.time));
            }
            start = null;
          }
        }
        return Interval2.merge(results);
      };
      _proto.difference = function difference() {
        var _this2 = this;
        for (var _len2 = arguments.length, intervals = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          intervals[_key2] = arguments[_key2];
        }
        return Interval2.xor([this].concat(intervals)).map(function(i) {
          return _this2.intersection(i);
        }).filter(function(i) {
          return i && !i.isEmpty();
        });
      };
      _proto.toString = function toString() {
        if (!this.isValid)
          return INVALID$1;
        return "[" + this.s.toISO() + " – " + this.e.toISO() + ")";
      };
      _proto.toISO = function toISO(opts) {
        if (!this.isValid)
          return INVALID$1;
        return this.s.toISO(opts) + "/" + this.e.toISO(opts);
      };
      _proto.toISODate = function toISODate() {
        if (!this.isValid)
          return INVALID$1;
        return this.s.toISODate() + "/" + this.e.toISODate();
      };
      _proto.toISOTime = function toISOTime(opts) {
        if (!this.isValid)
          return INVALID$1;
        return this.s.toISOTime(opts) + "/" + this.e.toISOTime(opts);
      };
      _proto.toFormat = function toFormat(dateFormat, _temp2) {
        var _ref3 = _temp2 === void 0 ? {} : _temp2, _ref3$separator = _ref3.separator, separator = _ref3$separator === void 0 ? " – " : _ref3$separator;
        if (!this.isValid)
          return INVALID$1;
        return "" + this.s.toFormat(dateFormat) + separator + this.e.toFormat(dateFormat);
      };
      _proto.toDuration = function toDuration(unit, opts) {
        if (!this.isValid) {
          return Duration.invalid(this.invalidReason);
        }
        return this.e.diff(this.s, unit, opts);
      };
      _proto.mapEndpoints = function mapEndpoints(mapFn) {
        return Interval2.fromDateTimes(mapFn(this.s), mapFn(this.e));
      };
      _createClass14(Interval2, [{
        key: "start",
        get: function get() {
          return this.isValid ? this.s : null;
        }
        /**
         * Returns the end of the Interval
         * @type {DateTime}
         */
      }, {
        key: "end",
        get: function get() {
          return this.isValid ? this.e : null;
        }
        /**
         * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
         * @type {boolean}
         */
      }, {
        key: "isValid",
        get: function get() {
          return this.invalidReason === null;
        }
        /**
         * Returns an error code if this Interval is invalid, or null if the Interval is valid
         * @type {string}
         */
      }, {
        key: "invalidReason",
        get: function get() {
          return this.invalid ? this.invalid.reason : null;
        }
        /**
         * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
         * @type {string}
         */
      }, {
        key: "invalidExplanation",
        get: function get() {
          return this.invalid ? this.invalid.explanation : null;
        }
      }]);
      return Interval2;
    }();
    var Info = function() {
      function Info2() {
      }
      Info2.hasDST = function hasDST(zone) {
        if (zone === void 0) {
          zone = Settings.defaultZone;
        }
        var proto = DateTime.now().setZone(zone).set({
          month: 12
        });
        return !zone.universal && proto.offset !== proto.set({
          month: 6
        }).offset;
      };
      Info2.isValidIANAZone = function isValidIANAZone(zone) {
        return IANAZone.isValidSpecifier(zone) && IANAZone.isValidZone(zone);
      };
      Info2.normalizeZone = function normalizeZone$1(input) {
        return normalizeZone(input, Settings.defaultZone);
      };
      Info2.months = function months2(length2, _temp) {
        if (length2 === void 0) {
          length2 = "long";
        }
        var _ref = _temp === void 0 ? {} : _temp, _ref$locale = _ref.locale, locale = _ref$locale === void 0 ? null : _ref$locale, _ref$numberingSystem = _ref.numberingSystem, numberingSystem = _ref$numberingSystem === void 0 ? null : _ref$numberingSystem, _ref$locObj = _ref.locObj, locObj = _ref$locObj === void 0 ? null : _ref$locObj, _ref$outputCalendar = _ref.outputCalendar, outputCalendar = _ref$outputCalendar === void 0 ? "gregory" : _ref$outputCalendar;
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length2);
      };
      Info2.monthsFormat = function monthsFormat(length2, _temp2) {
        if (length2 === void 0) {
          length2 = "long";
        }
        var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$locale = _ref2.locale, locale = _ref2$locale === void 0 ? null : _ref2$locale, _ref2$numberingSystem = _ref2.numberingSystem, numberingSystem = _ref2$numberingSystem === void 0 ? null : _ref2$numberingSystem, _ref2$locObj = _ref2.locObj, locObj = _ref2$locObj === void 0 ? null : _ref2$locObj, _ref2$outputCalendar = _ref2.outputCalendar, outputCalendar = _ref2$outputCalendar === void 0 ? "gregory" : _ref2$outputCalendar;
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length2, true);
      };
      Info2.weekdays = function weekdays2(length2, _temp3) {
        if (length2 === void 0) {
          length2 = "long";
        }
        var _ref3 = _temp3 === void 0 ? {} : _temp3, _ref3$locale = _ref3.locale, locale = _ref3$locale === void 0 ? null : _ref3$locale, _ref3$numberingSystem = _ref3.numberingSystem, numberingSystem = _ref3$numberingSystem === void 0 ? null : _ref3$numberingSystem, _ref3$locObj = _ref3.locObj, locObj = _ref3$locObj === void 0 ? null : _ref3$locObj;
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length2);
      };
      Info2.weekdaysFormat = function weekdaysFormat(length2, _temp4) {
        if (length2 === void 0) {
          length2 = "long";
        }
        var _ref4 = _temp4 === void 0 ? {} : _temp4, _ref4$locale = _ref4.locale, locale = _ref4$locale === void 0 ? null : _ref4$locale, _ref4$numberingSystem = _ref4.numberingSystem, numberingSystem = _ref4$numberingSystem === void 0 ? null : _ref4$numberingSystem, _ref4$locObj = _ref4.locObj, locObj = _ref4$locObj === void 0 ? null : _ref4$locObj;
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length2, true);
      };
      Info2.meridiems = function meridiems2(_temp5) {
        var _ref5 = _temp5 === void 0 ? {} : _temp5, _ref5$locale = _ref5.locale, locale = _ref5$locale === void 0 ? null : _ref5$locale;
        return Locale.create(locale).meridiems();
      };
      Info2.eras = function eras2(length2, _temp6) {
        if (length2 === void 0) {
          length2 = "short";
        }
        var _ref6 = _temp6 === void 0 ? {} : _temp6, _ref6$locale = _ref6.locale, locale = _ref6$locale === void 0 ? null : _ref6$locale;
        return Locale.create(locale, null, "gregory").eras(length2);
      };
      Info2.features = function features() {
        var intl = false, intlTokens = false, zones = false, relative = false;
        if (hasIntl()) {
          intl = true;
          intlTokens = hasFormatToParts();
          relative = hasRelative();
          try {
            zones = new Intl.DateTimeFormat("en", {
              timeZone: "America/New_York"
            }).resolvedOptions().timeZone === "America/New_York";
          } catch (e) {
            zones = false;
          }
        }
        return {
          intl,
          intlTokens,
          zones,
          relative
        };
      };
      return Info2;
    }();
    function dayDiff(earlier, later) {
      var utcDayStart = function utcDayStart2(dt) {
        return dt.toUTC(0, {
          keepLocalTime: true
        }).startOf("day").valueOf();
      }, ms = utcDayStart(later) - utcDayStart(earlier);
      return Math.floor(Duration.fromMillis(ms).as("days"));
    }
    function highOrderDiffs(cursor, later, units) {
      var differs = [["years", function(a, b) {
        return b.year - a.year;
      }], ["quarters", function(a, b) {
        return b.quarter - a.quarter;
      }], ["months", function(a, b) {
        return b.month - a.month + (b.year - a.year) * 12;
      }], ["weeks", function(a, b) {
        var days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }], ["days", dayDiff]];
      var results = {};
      var lowestOrder, highWater;
      for (var _i = 0, _differs = differs; _i < _differs.length; _i++) {
        var _differs$_i = _differs[_i], unit = _differs$_i[0], differ = _differs$_i[1];
        if (units.indexOf(unit) >= 0) {
          var _cursor$plus;
          lowestOrder = unit;
          var delta = differ(cursor, later);
          highWater = cursor.plus((_cursor$plus = {}, _cursor$plus[unit] = delta, _cursor$plus));
          if (highWater > later) {
            var _cursor$plus2;
            cursor = cursor.plus((_cursor$plus2 = {}, _cursor$plus2[unit] = delta - 1, _cursor$plus2));
            delta -= 1;
          } else {
            cursor = highWater;
          }
          results[unit] = delta;
        }
      }
      return [cursor, results, highWater, lowestOrder];
    }
    function _diff(earlier, later, units, opts) {
      var _highOrderDiffs = highOrderDiffs(earlier, later, units), cursor = _highOrderDiffs[0], results = _highOrderDiffs[1], highWater = _highOrderDiffs[2], lowestOrder = _highOrderDiffs[3];
      var remainingMillis = later - cursor;
      var lowerOrderUnits = units.filter(function(u) {
        return ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0;
      });
      if (lowerOrderUnits.length === 0) {
        if (highWater < later) {
          var _cursor$plus3;
          highWater = cursor.plus((_cursor$plus3 = {}, _cursor$plus3[lowestOrder] = 1, _cursor$plus3));
        }
        if (highWater !== cursor) {
          results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
        }
      }
      var duration = Duration.fromObject(Object.assign(results, opts));
      if (lowerOrderUnits.length > 0) {
        var _Duration$fromMillis;
        return (_Duration$fromMillis = Duration.fromMillis(remainingMillis, opts)).shiftTo.apply(_Duration$fromMillis, lowerOrderUnits).plus(duration);
      } else {
        return duration;
      }
    }
    var numberingSystems = {
      arab: "[٠-٩]",
      arabext: "[۰-۹]",
      bali: "[᭐-᭙]",
      beng: "[০-৯]",
      deva: "[०-९]",
      fullwide: "[０-９]",
      gujr: "[૦-૯]",
      hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
      khmr: "[០-៩]",
      knda: "[೦-೯]",
      laoo: "[໐-໙]",
      limb: "[᥆-᥏]",
      mlym: "[൦-൯]",
      mong: "[᠐-᠙]",
      mymr: "[၀-၉]",
      orya: "[୦-୯]",
      tamldec: "[௦-௯]",
      telu: "[౦-౯]",
      thai: "[๐-๙]",
      tibt: "[༠-༩]",
      latn: "\\d"
    };
    var numberingSystemsUTF16 = {
      arab: [1632, 1641],
      arabext: [1776, 1785],
      bali: [6992, 7001],
      beng: [2534, 2543],
      deva: [2406, 2415],
      fullwide: [65296, 65303],
      gujr: [2790, 2799],
      khmr: [6112, 6121],
      knda: [3302, 3311],
      laoo: [3792, 3801],
      limb: [6470, 6479],
      mlym: [3430, 3439],
      mong: [6160, 6169],
      mymr: [4160, 4169],
      orya: [2918, 2927],
      tamldec: [3046, 3055],
      telu: [3174, 3183],
      thai: [3664, 3673],
      tibt: [3872, 3881]
    };
    var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
    function parseDigits2(str) {
      var value = parseInt(str, 10);
      if (isNaN(value)) {
        value = "";
        for (var i = 0; i < str.length; i++) {
          var code = str.charCodeAt(i);
          if (str[i].search(numberingSystems.hanidec) !== -1) {
            value += hanidecChars.indexOf(str[i]);
          } else {
            for (var key in numberingSystemsUTF16) {
              var _numberingSystemsUTF = numberingSystemsUTF16[key], min2 = _numberingSystemsUTF[0], max2 = _numberingSystemsUTF[1];
              if (code >= min2 && code <= max2) {
                value += code - min2;
              }
            }
          }
        }
        return parseInt(value, 10);
      } else {
        return value;
      }
    }
    function digitRegex(_ref, append) {
      var numberingSystem = _ref.numberingSystem;
      if (append === void 0) {
        append = "";
      }
      return new RegExp("" + numberingSystems[numberingSystem || "latn"] + append);
    }
    var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
    function intUnit(regex, post) {
      if (post === void 0) {
        post = function post2(i) {
          return i;
        };
      }
      return {
        regex,
        deser: function deser(_ref) {
          var s2 = _ref[0];
          return post(parseDigits2(s2));
        }
      };
    }
    var NBSP = String.fromCharCode(160);
    var spaceOrNBSP = "( |" + NBSP + ")";
    var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
    function fixListRegex(s2) {
      return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
    }
    function stripInsensitivities(s2) {
      return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
    }
    function oneOf(strings, startIndex) {
      if (strings === null) {
        return null;
      } else {
        return {
          regex: RegExp(strings.map(fixListRegex).join("|")),
          deser: function deser(_ref2) {
            var s2 = _ref2[0];
            return strings.findIndex(function(i) {
              return stripInsensitivities(s2) === stripInsensitivities(i);
            }) + startIndex;
          }
        };
      }
    }
    function offset(regex, groups) {
      return {
        regex,
        deser: function deser(_ref3) {
          var h = _ref3[1], m = _ref3[2];
          return signedOffset(h, m);
        },
        groups
      };
    }
    function simple(regex) {
      return {
        regex,
        deser: function deser(_ref4) {
          var s2 = _ref4[0];
          return s2;
        }
      };
    }
    function escapeToken(value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function unitForToken(token, loc) {
      var one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = function literal2(t) {
        return {
          regex: RegExp(escapeToken(t.val)),
          deser: function deser(_ref5) {
            var s2 = _ref5[0];
            return s2;
          },
          literal: true
        };
      }, unitate = function unitate2(t) {
        if (token.literal) {
          return literal(t);
        }
        switch (t.val) {
          case "G":
            return oneOf(loc.eras("short", false), 0);
          case "GG":
            return oneOf(loc.eras("long", false), 0);
          case "y":
            return intUnit(oneToSix);
          case "yy":
            return intUnit(twoToFour, untruncateYear);
          case "yyyy":
            return intUnit(four);
          case "yyyyy":
            return intUnit(fourToSix);
          case "yyyyyy":
            return intUnit(six);
          case "M":
            return intUnit(oneOrTwo);
          case "MM":
            return intUnit(two);
          case "MMM":
            return oneOf(loc.months("short", true, false), 1);
          case "MMMM":
            return oneOf(loc.months("long", true, false), 1);
          case "L":
            return intUnit(oneOrTwo);
          case "LL":
            return intUnit(two);
          case "LLL":
            return oneOf(loc.months("short", false, false), 1);
          case "LLLL":
            return oneOf(loc.months("long", false, false), 1);
          case "d":
            return intUnit(oneOrTwo);
          case "dd":
            return intUnit(two);
          case "o":
            return intUnit(oneToThree);
          case "ooo":
            return intUnit(three);
          case "HH":
            return intUnit(two);
          case "H":
            return intUnit(oneOrTwo);
          case "hh":
            return intUnit(two);
          case "h":
            return intUnit(oneOrTwo);
          case "mm":
            return intUnit(two);
          case "m":
            return intUnit(oneOrTwo);
          case "q":
            return intUnit(oneOrTwo);
          case "qq":
            return intUnit(two);
          case "s":
            return intUnit(oneOrTwo);
          case "ss":
            return intUnit(two);
          case "S":
            return intUnit(oneToThree);
          case "SSS":
            return intUnit(three);
          case "u":
            return simple(oneToNine);
          case "a":
            return oneOf(loc.meridiems(), 0);
          case "kkkk":
            return intUnit(four);
          case "kk":
            return intUnit(twoToFour, untruncateYear);
          case "W":
            return intUnit(oneOrTwo);
          case "WW":
            return intUnit(two);
          case "E":
          case "c":
            return intUnit(one);
          case "EEE":
            return oneOf(loc.weekdays("short", false, false), 1);
          case "EEEE":
            return oneOf(loc.weekdays("long", false, false), 1);
          case "ccc":
            return oneOf(loc.weekdays("short", true, false), 1);
          case "cccc":
            return oneOf(loc.weekdays("long", true, false), 1);
          case "Z":
          case "ZZ":
            return offset(new RegExp("([+-]" + oneOrTwo.source + ")(?::(" + two.source + "))?"), 2);
          case "ZZZ":
            return offset(new RegExp("([+-]" + oneOrTwo.source + ")(" + two.source + ")?"), 2);
          case "z":
            return simple(/[a-z_+-/]{1,256}?/i);
          default:
            return literal(t);
        }
      };
      var unit = unitate(token) || {
        invalidReason: MISSING_FTP
      };
      unit.token = token;
      return unit;
    }
    var partTypeStyleToTokenVal = {
      year: {
        "2-digit": "yy",
        numeric: "yyyyy"
      },
      month: {
        numeric: "M",
        "2-digit": "MM",
        short: "MMM",
        long: "MMMM"
      },
      day: {
        numeric: "d",
        "2-digit": "dd"
      },
      weekday: {
        short: "EEE",
        long: "EEEE"
      },
      dayperiod: "a",
      dayPeriod: "a",
      hour: {
        numeric: "h",
        "2-digit": "hh"
      },
      minute: {
        numeric: "m",
        "2-digit": "mm"
      },
      second: {
        numeric: "s",
        "2-digit": "ss"
      }
    };
    function tokenForPart(part, locale, formatOpts) {
      var type = part.type, value = part.value;
      if (type === "literal") {
        return {
          literal: true,
          val: value
        };
      }
      var style = formatOpts[type];
      var val = partTypeStyleToTokenVal[type];
      if (typeof val === "object") {
        val = val[style];
      }
      if (val) {
        return {
          literal: false,
          val
        };
      }
      return void 0;
    }
    function buildRegex(units) {
      var re = units.map(function(u) {
        return u.regex;
      }).reduce(function(f2, r) {
        return f2 + "(" + r.source + ")";
      }, "");
      return ["^" + re + "$", units];
    }
    function match(input, regex, handlers) {
      var matches2 = input.match(regex);
      if (matches2) {
        var all = {};
        var matchIndex = 1;
        for (var i in handlers) {
          if (hasOwnProperty(handlers, i)) {
            var h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
            if (!h.literal && h.token) {
              all[h.token.val[0]] = h.deser(matches2.slice(matchIndex, matchIndex + groups));
            }
            matchIndex += groups;
          }
        }
        return [matches2, all];
      } else {
        return [matches2, {}];
      }
    }
    function dateTimeFromMatches(matches2) {
      var toField = function toField2(token) {
        switch (token) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
          case "H":
            return "hour";
          case "d":
            return "day";
          case "o":
            return "ordinal";
          case "L":
          case "M":
            return "month";
          case "y":
            return "year";
          case "E":
          case "c":
            return "weekday";
          case "W":
            return "weekNumber";
          case "k":
            return "weekYear";
          case "q":
            return "quarter";
          default:
            return null;
        }
      };
      var zone;
      if (!isUndefined(matches2.Z)) {
        zone = new FixedOffsetZone(matches2.Z);
      } else if (!isUndefined(matches2.z)) {
        zone = IANAZone.create(matches2.z);
      } else {
        zone = null;
      }
      if (!isUndefined(matches2.q)) {
        matches2.M = (matches2.q - 1) * 3 + 1;
      }
      if (!isUndefined(matches2.h)) {
        if (matches2.h < 12 && matches2.a === 1) {
          matches2.h += 12;
        } else if (matches2.h === 12 && matches2.a === 0) {
          matches2.h = 0;
        }
      }
      if (matches2.G === 0 && matches2.y) {
        matches2.y = -matches2.y;
      }
      if (!isUndefined(matches2.u)) {
        matches2.S = parseMillis(matches2.u);
      }
      var vals = Object.keys(matches2).reduce(function(r, k) {
        var f2 = toField(k);
        if (f2) {
          r[f2] = matches2[k];
        }
        return r;
      }, {});
      return [vals, zone];
    }
    var dummyDateTimeCache = null;
    function getDummyDateTime() {
      if (!dummyDateTimeCache) {
        dummyDateTimeCache = DateTime.fromMillis(1555555555555);
      }
      return dummyDateTimeCache;
    }
    function maybeExpandMacroToken(token, locale) {
      if (token.literal) {
        return token;
      }
      var formatOpts = Formatter.macroTokenToFormatOpts(token.val);
      if (!formatOpts) {
        return token;
      }
      var formatter = Formatter.create(locale, formatOpts);
      var parts = formatter.formatDateTimeParts(getDummyDateTime());
      var tokens = parts.map(function(p) {
        return tokenForPart(p, locale, formatOpts);
      });
      if (tokens.includes(void 0)) {
        return token;
      }
      return tokens;
    }
    function expandMacroTokens(tokens, locale) {
      var _Array$prototype;
      return (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, tokens.map(function(t) {
        return maybeExpandMacroToken(t, locale);
      }));
    }
    function explainFromTokens(locale, input, format2) {
      var tokens = expandMacroTokens(Formatter.parseFormat(format2), locale), units = tokens.map(function(t) {
        return unitForToken(t, locale);
      }), disqualifyingUnit = units.find(function(t) {
        return t.invalidReason;
      });
      if (disqualifyingUnit) {
        return {
          input,
          tokens,
          invalidReason: disqualifyingUnit.invalidReason
        };
      } else {
        var _buildRegex = buildRegex(units), regexString = _buildRegex[0], handlers = _buildRegex[1], regex = RegExp(regexString, "i"), _match2 = match(input, regex, handlers), rawMatches = _match2[0], matches2 = _match2[1], _ref6 = matches2 ? dateTimeFromMatches(matches2) : [null, null], result2 = _ref6[0], zone = _ref6[1];
        if (hasOwnProperty(matches2, "a") && hasOwnProperty(matches2, "H")) {
          throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
        }
        return {
          input,
          tokens,
          regex,
          rawMatches,
          matches: matches2,
          result: result2,
          zone
        };
      }
    }
    function parseFromTokens(locale, input, format2) {
      var _explainFromTokens = explainFromTokens(locale, input, format2), result2 = _explainFromTokens.result, zone = _explainFromTokens.zone, invalidReason = _explainFromTokens.invalidReason;
      return [result2, zone, invalidReason];
    }
    var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    function unitOutOfRange(unit, value) {
      return new Invalid("unit out of range", "you specified " + value + " (of type " + typeof value + ") as a " + unit + ", which is invalid");
    }
    function dayOfWeek(year, month, day) {
      var js = new Date(Date.UTC(year, month - 1, day)).getUTCDay();
      return js === 0 ? 7 : js;
    }
    function computeOrdinal(year, month, day) {
      return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
    }
    function uncomputeOrdinal(year, ordinal) {
      var table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex(function(i) {
        return i < ordinal;
      }), day = ordinal - table[month0];
      return {
        month: month0 + 1,
        day
      };
    }
    function gregorianToWeek(gregObj) {
      var year = gregObj.year, month = gregObj.month, day = gregObj.day, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
      var weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
      if (weekNumber < 1) {
        weekYear = year - 1;
        weekNumber = weeksInWeekYear(weekYear);
      } else if (weekNumber > weeksInWeekYear(year)) {
        weekYear = year + 1;
        weekNumber = 1;
      } else {
        weekYear = year;
      }
      return Object.assign({
        weekYear,
        weekNumber,
        weekday
      }, timeObject(gregObj));
    }
    function weekToGregorian(weekData) {
      var weekYear = weekData.weekYear, weekNumber = weekData.weekNumber, weekday = weekData.weekday, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
      var ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
      if (ordinal < 1) {
        year = weekYear - 1;
        ordinal += daysInYear(year);
      } else if (ordinal > yearInDays) {
        year = weekYear + 1;
        ordinal -= daysInYear(weekYear);
      } else {
        year = weekYear;
      }
      var _uncomputeOrdinal = uncomputeOrdinal(year, ordinal), month = _uncomputeOrdinal.month, day = _uncomputeOrdinal.day;
      return Object.assign({
        year,
        month,
        day
      }, timeObject(weekData));
    }
    function gregorianToOrdinal(gregData) {
      var year = gregData.year, month = gregData.month, day = gregData.day, ordinal = computeOrdinal(year, month, day);
      return Object.assign({
        year,
        ordinal
      }, timeObject(gregData));
    }
    function ordinalToGregorian(ordinalData) {
      var year = ordinalData.year, ordinal = ordinalData.ordinal, _uncomputeOrdinal2 = uncomputeOrdinal(year, ordinal), month = _uncomputeOrdinal2.month, day = _uncomputeOrdinal2.day;
      return Object.assign({
        year,
        month,
        day
      }, timeObject(ordinalData));
    }
    function hasInvalidWeekData(obj) {
      var validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
      if (!validYear) {
        return unitOutOfRange("weekYear", obj.weekYear);
      } else if (!validWeek) {
        return unitOutOfRange("week", obj.week);
      } else if (!validWeekday) {
        return unitOutOfRange("weekday", obj.weekday);
      } else
        return false;
    }
    function hasInvalidOrdinalData(obj) {
      var validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validOrdinal) {
        return unitOutOfRange("ordinal", obj.ordinal);
      } else
        return false;
    }
    function hasInvalidGregorianData(obj) {
      var validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validMonth) {
        return unitOutOfRange("month", obj.month);
      } else if (!validDay) {
        return unitOutOfRange("day", obj.day);
      } else
        return false;
    }
    function hasInvalidTimeData(obj) {
      var hour = obj.hour, minute = obj.minute, second = obj.second, millisecond = obj.millisecond;
      var validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
      if (!validHour) {
        return unitOutOfRange("hour", hour);
      } else if (!validMinute) {
        return unitOutOfRange("minute", minute);
      } else if (!validSecond) {
        return unitOutOfRange("second", second);
      } else if (!validMillisecond) {
        return unitOutOfRange("millisecond", millisecond);
      } else
        return false;
    }
    var INVALID$2 = "Invalid DateTime";
    var MAX_DATE2 = 864e13;
    function unsupportedZone(zone) {
      return new Invalid("unsupported zone", 'the zone "' + zone.name + '" is not supported');
    }
    function possiblyCachedWeekData(dt) {
      if (dt.weekData === null) {
        dt.weekData = gregorianToWeek(dt.c);
      }
      return dt.weekData;
    }
    function clone$1(inst, alts) {
      var current = {
        ts: inst.ts,
        zone: inst.zone,
        c: inst.c,
        o: inst.o,
        loc: inst.loc,
        invalid: inst.invalid
      };
      return new DateTime(Object.assign({}, current, alts, {
        old: current
      }));
    }
    function fixOffset(localTS, o, tz) {
      var utcGuess = localTS - o * 60 * 1e3;
      var o2 = tz.offset(utcGuess);
      if (o === o2) {
        return [utcGuess, o];
      }
      utcGuess -= (o2 - o) * 60 * 1e3;
      var o3 = tz.offset(utcGuess);
      if (o2 === o3) {
        return [utcGuess, o2];
      }
      return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
    }
    function tsToObj(ts, offset2) {
      ts += offset2 * 60 * 1e3;
      var d = new Date(ts);
      return {
        year: d.getUTCFullYear(),
        month: d.getUTCMonth() + 1,
        day: d.getUTCDate(),
        hour: d.getUTCHours(),
        minute: d.getUTCMinutes(),
        second: d.getUTCSeconds(),
        millisecond: d.getUTCMilliseconds()
      };
    }
    function objToTS(obj, offset2, zone) {
      return fixOffset(objToLocalTS(obj), offset2, zone);
    }
    function adjustTime(inst, dur) {
      var oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = Object.assign({}, inst.c, {
        year,
        month,
        day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
      }), millisToAdd = Duration.fromObject({
        years: dur.years - Math.trunc(dur.years),
        quarters: dur.quarters - Math.trunc(dur.quarters),
        months: dur.months - Math.trunc(dur.months),
        weeks: dur.weeks - Math.trunc(dur.weeks),
        days: dur.days - Math.trunc(dur.days),
        hours: dur.hours,
        minutes: dur.minutes,
        seconds: dur.seconds,
        milliseconds: dur.milliseconds
      }).as("milliseconds"), localTS = objToLocalTS(c);
      var _fixOffset = fixOffset(localTS, oPre, inst.zone), ts = _fixOffset[0], o = _fixOffset[1];
      if (millisToAdd !== 0) {
        ts += millisToAdd;
        o = inst.zone.offset(ts);
      }
      return {
        ts,
        o
      };
    }
    function parseDataToDateTime(parsed, parsedZone, opts, format2, text) {
      var setZone = opts.setZone, zone = opts.zone;
      if (parsed && Object.keys(parsed).length !== 0) {
        var interpretationZone = parsedZone || zone, inst = DateTime.fromObject(Object.assign(parsed, opts, {
          zone: interpretationZone,
          // setZone is a valid option in the calling methods, but not in fromObject
          setZone: void 0
        }));
        return setZone ? inst : inst.setZone(zone);
      } else {
        return DateTime.invalid(new Invalid("unparsable", 'the input "' + text + `" can't be parsed as ` + format2));
      }
    }
    function toTechFormat(dt, format2, allowZ) {
      if (allowZ === void 0) {
        allowZ = true;
      }
      return dt.isValid ? Formatter.create(Locale.create("en-US"), {
        allowZ,
        forceSimple: true
      }).formatDateTimeFromString(dt, format2) : null;
    }
    function toTechTimeFormat(dt, _ref) {
      var _ref$suppressSeconds = _ref.suppressSeconds, suppressSeconds = _ref$suppressSeconds === void 0 ? false : _ref$suppressSeconds, _ref$suppressMillisec = _ref.suppressMilliseconds, suppressMilliseconds = _ref$suppressMillisec === void 0 ? false : _ref$suppressMillisec, includeOffset = _ref.includeOffset, _ref$includePrefix = _ref.includePrefix, includePrefix = _ref$includePrefix === void 0 ? false : _ref$includePrefix, _ref$includeZone = _ref.includeZone, includeZone = _ref$includeZone === void 0 ? false : _ref$includeZone, _ref$spaceZone = _ref.spaceZone, spaceZone = _ref$spaceZone === void 0 ? false : _ref$spaceZone, _ref$format = _ref.format, format2 = _ref$format === void 0 ? "extended" : _ref$format;
      var fmt = format2 === "basic" ? "HHmm" : "HH:mm";
      if (!suppressSeconds || dt.second !== 0 || dt.millisecond !== 0) {
        fmt += format2 === "basic" ? "ss" : ":ss";
        if (!suppressMilliseconds || dt.millisecond !== 0) {
          fmt += ".SSS";
        }
      }
      if ((includeZone || includeOffset) && spaceZone) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += format2 === "basic" ? "ZZZ" : "ZZ";
      }
      var str = toTechFormat(dt, fmt);
      if (includePrefix) {
        str = "T" + str;
      }
      return str;
    }
    var defaultUnitValues = {
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultWeekUnitValues = {
      weekNumber: 1,
      weekday: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultOrdinalUnitValues = {
      ordinal: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var orderedUnits$1 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
    var orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"];
    var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
    function normalizeUnit(unit) {
      var normalized = {
        year: "year",
        years: "year",
        month: "month",
        months: "month",
        day: "day",
        days: "day",
        hour: "hour",
        hours: "hour",
        minute: "minute",
        minutes: "minute",
        quarter: "quarter",
        quarters: "quarter",
        second: "second",
        seconds: "second",
        millisecond: "millisecond",
        milliseconds: "millisecond",
        weekday: "weekday",
        weekdays: "weekday",
        weeknumber: "weekNumber",
        weeksnumber: "weekNumber",
        weeknumbers: "weekNumber",
        weekyear: "weekYear",
        weekyears: "weekYear",
        ordinal: "ordinal"
      }[unit.toLowerCase()];
      if (!normalized)
        throw new InvalidUnitError(unit);
      return normalized;
    }
    function quickDT(obj, zone) {
      for (var _iterator = _createForOfIteratorHelperLoose12(orderedUnits$1), _step; !(_step = _iterator()).done; ) {
        var u = _step.value;
        if (isUndefined(obj[u])) {
          obj[u] = defaultUnitValues[u];
        }
      }
      var invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
      if (invalid) {
        return DateTime.invalid(invalid);
      }
      var tsNow = Settings.now(), offsetProvis = zone.offset(tsNow), _objToTS = objToTS(obj, offsetProvis, zone), ts = _objToTS[0], o = _objToTS[1];
      return new DateTime({
        ts,
        zone,
        o
      });
    }
    function diffRelative(start, end, opts) {
      var round = isUndefined(opts.round) ? true : opts.round, format2 = function format3(c, unit2) {
        c = roundTo(c, round || opts.calendary ? 0 : 2, true);
        var formatter = end.loc.clone(opts).relFormatter(opts);
        return formatter.format(c, unit2);
      }, differ = function differ2(unit2) {
        if (opts.calendary) {
          if (!end.hasSame(start, unit2)) {
            return end.startOf(unit2).diff(start.startOf(unit2), unit2).get(unit2);
          } else
            return 0;
        } else {
          return end.diff(start, unit2).get(unit2);
        }
      };
      if (opts.unit) {
        return format2(differ(opts.unit), opts.unit);
      }
      for (var _iterator2 = _createForOfIteratorHelperLoose12(opts.units), _step2; !(_step2 = _iterator2()).done; ) {
        var unit = _step2.value;
        var count = differ(unit);
        if (Math.abs(count) >= 1) {
          return format2(count, unit);
        }
      }
      return format2(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
    }
    var DateTime = function() {
      function DateTime2(config) {
        var zone = config.zone || Settings.defaultZone;
        var invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
        this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
        var c = null, o = null;
        if (!invalid) {
          var unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
          if (unchanged) {
            var _ref2 = [config.old.c, config.old.o];
            c = _ref2[0];
            o = _ref2[1];
          } else {
            var ot = zone.offset(this.ts);
            c = tsToObj(this.ts, ot);
            invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
            c = invalid ? null : c;
            o = invalid ? null : ot;
          }
        }
        this._zone = zone;
        this.loc = config.loc || Locale.create();
        this.invalid = invalid;
        this.weekData = null;
        this.c = c;
        this.o = o;
        this.isLuxonDateTime = true;
      }
      DateTime2.now = function now2() {
        return new DateTime2({});
      };
      DateTime2.local = function local(year, month, day, hour, minute, second, millisecond) {
        if (isUndefined(year)) {
          return DateTime2.now();
        } else {
          return quickDT({
            year,
            month,
            day,
            hour,
            minute,
            second,
            millisecond
          }, Settings.defaultZone);
        }
      };
      DateTime2.utc = function utc(year, month, day, hour, minute, second, millisecond) {
        if (isUndefined(year)) {
          return new DateTime2({
            ts: Settings.now(),
            zone: FixedOffsetZone.utcInstance
          });
        } else {
          return quickDT({
            year,
            month,
            day,
            hour,
            minute,
            second,
            millisecond
          }, FixedOffsetZone.utcInstance);
        }
      };
      DateTime2.fromJSDate = function fromJSDate(date, options) {
        if (options === void 0) {
          options = {};
        }
        var ts = isDate2(date) ? date.valueOf() : NaN;
        if (Number.isNaN(ts)) {
          return DateTime2.invalid("invalid input");
        }
        var zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime2.invalid(unsupportedZone(zoneToUse));
        }
        return new DateTime2({
          ts,
          zone: zoneToUse,
          loc: Locale.fromObject(options)
        });
      };
      DateTime2.fromMillis = function fromMillis(milliseconds, options) {
        if (options === void 0) {
          options = {};
        }
        if (!isNumber2(milliseconds)) {
          throw new InvalidArgumentError("fromMillis requires a numerical input, but received a " + typeof milliseconds + " with value " + milliseconds);
        } else if (milliseconds < -MAX_DATE2 || milliseconds > MAX_DATE2) {
          return DateTime2.invalid("Timestamp out of range");
        } else {
          return new DateTime2({
            ts: milliseconds,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      };
      DateTime2.fromSeconds = function fromSeconds(seconds, options) {
        if (options === void 0) {
          options = {};
        }
        if (!isNumber2(seconds)) {
          throw new InvalidArgumentError("fromSeconds requires a numerical input");
        } else {
          return new DateTime2({
            ts: seconds * 1e3,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      };
      DateTime2.fromObject = function fromObject(obj) {
        var zoneToUse = normalizeZone(obj.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime2.invalid(unsupportedZone(zoneToUse));
        }
        var tsNow = Settings.now(), offsetProvis = zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit, ["zone", "locale", "outputCalendar", "numberingSystem"]), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(obj);
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        var useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
        var units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
        if (useWeekData) {
          units = orderedWeekUnits;
          defaultValues = defaultWeekUnitValues;
          objNow = gregorianToWeek(objNow);
        } else if (containsOrdinal) {
          units = orderedOrdinalUnits;
          defaultValues = defaultOrdinalUnitValues;
          objNow = gregorianToOrdinal(objNow);
        } else {
          units = orderedUnits$1;
          defaultValues = defaultUnitValues;
        }
        var foundFirst = false;
        for (var _iterator3 = _createForOfIteratorHelperLoose12(units), _step3; !(_step3 = _iterator3()).done; ) {
          var u = _step3.value;
          var v = normalized[u];
          if (!isUndefined(v)) {
            foundFirst = true;
          } else if (foundFirst) {
            normalized[u] = defaultValues[u];
          } else {
            normalized[u] = objNow[u];
          }
        }
        var higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
        if (invalid) {
          return DateTime2.invalid(invalid);
        }
        var gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, _objToTS2 = objToTS(gregorian, offsetProvis, zoneToUse), tsFinal = _objToTS2[0], offsetFinal = _objToTS2[1], inst = new DateTime2({
          ts: tsFinal,
          zone: zoneToUse,
          o: offsetFinal,
          loc
        });
        if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
          return DateTime2.invalid("mismatched weekday", "you can't specify both a weekday of " + normalized.weekday + " and a date of " + inst.toISO());
        }
        return inst;
      };
      DateTime2.fromISO = function fromISO(text, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _parseISODate = parseISODate(text), vals = _parseISODate[0], parsedZone = _parseISODate[1];
        return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
      };
      DateTime2.fromRFC2822 = function fromRFC2822(text, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _parseRFC2822Date = parseRFC2822Date(text), vals = _parseRFC2822Date[0], parsedZone = _parseRFC2822Date[1];
        return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
      };
      DateTime2.fromHTTP = function fromHTTP(text, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _parseHTTPDate = parseHTTPDate(text), vals = _parseHTTPDate[0], parsedZone = _parseHTTPDate[1];
        return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
      };
      DateTime2.fromFormat = function fromFormat(text, fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (isUndefined(text) || isUndefined(fmt)) {
          throw new InvalidArgumentError("fromFormat requires an input string and a format");
        }
        var _opts = opts, _opts$locale = _opts.locale, locale = _opts$locale === void 0 ? null : _opts$locale, _opts$numberingSystem = _opts.numberingSystem, numberingSystem = _opts$numberingSystem === void 0 ? null : _opts$numberingSystem, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        }), _parseFromTokens = parseFromTokens(localeToUse, text, fmt), vals = _parseFromTokens[0], parsedZone = _parseFromTokens[1], invalid = _parseFromTokens[2];
        if (invalid) {
          return DateTime2.invalid(invalid);
        } else {
          return parseDataToDateTime(vals, parsedZone, opts, "format " + fmt, text);
        }
      };
      DateTime2.fromString = function fromString(text, fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        return DateTime2.fromFormat(text, fmt, opts);
      };
      DateTime2.fromSQL = function fromSQL(text, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _parseSQL = parseSQL(text), vals = _parseSQL[0], parsedZone = _parseSQL[1];
        return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
      };
      DateTime2.invalid = function invalid(reason, explanation) {
        if (explanation === void 0) {
          explanation = null;
        }
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
        }
        var invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDateTimeError(invalid2);
        } else {
          return new DateTime2({
            invalid: invalid2
          });
        }
      };
      DateTime2.isDateTime = function isDateTime(o) {
        return o && o.isLuxonDateTime || false;
      };
      var _proto = DateTime2.prototype;
      _proto.get = function get(unit) {
        return this[unit];
      };
      _proto.resolvedLocaleOpts = function resolvedLocaleOpts(opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _Formatter$create$res = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this), locale = _Formatter$create$res.locale, numberingSystem = _Formatter$create$res.numberingSystem, calendar = _Formatter$create$res.calendar;
        return {
          locale,
          numberingSystem,
          outputCalendar: calendar
        };
      };
      _proto.toUTC = function toUTC(offset2, opts) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        if (opts === void 0) {
          opts = {};
        }
        return this.setZone(FixedOffsetZone.instance(offset2), opts);
      };
      _proto.toLocal = function toLocal() {
        return this.setZone(Settings.defaultZone);
      };
      _proto.setZone = function setZone(zone, _temp) {
        var _ref3 = _temp === void 0 ? {} : _temp, _ref3$keepLocalTime = _ref3.keepLocalTime, keepLocalTime = _ref3$keepLocalTime === void 0 ? false : _ref3$keepLocalTime, _ref3$keepCalendarTim = _ref3.keepCalendarTime, keepCalendarTime = _ref3$keepCalendarTim === void 0 ? false : _ref3$keepCalendarTim;
        zone = normalizeZone(zone, Settings.defaultZone);
        if (zone.equals(this.zone)) {
          return this;
        } else if (!zone.isValid) {
          return DateTime2.invalid(unsupportedZone(zone));
        } else {
          var newTS = this.ts;
          if (keepLocalTime || keepCalendarTime) {
            var offsetGuess = zone.offset(this.ts);
            var asObj = this.toObject();
            var _objToTS3 = objToTS(asObj, offsetGuess, zone);
            newTS = _objToTS3[0];
          }
          return clone$1(this, {
            ts: newTS,
            zone
          });
        }
      };
      _proto.reconfigure = function reconfigure(_temp2) {
        var _ref4 = _temp2 === void 0 ? {} : _temp2, locale = _ref4.locale, numberingSystem = _ref4.numberingSystem, outputCalendar = _ref4.outputCalendar;
        var loc = this.loc.clone({
          locale,
          numberingSystem,
          outputCalendar
        });
        return clone$1(this, {
          loc
        });
      };
      _proto.setLocale = function setLocale(locale) {
        return this.reconfigure({
          locale
        });
      };
      _proto.set = function set(values) {
        if (!this.isValid)
          return this;
        var normalized = normalizeObject(values, normalizeUnit, []), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        var mixed;
        if (settingWeekStuff) {
          mixed = weekToGregorian(Object.assign(gregorianToWeek(this.c), normalized));
        } else if (!isUndefined(normalized.ordinal)) {
          mixed = ordinalToGregorian(Object.assign(gregorianToOrdinal(this.c), normalized));
        } else {
          mixed = Object.assign(this.toObject(), normalized);
          if (isUndefined(normalized.day)) {
            mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
          }
        }
        var _objToTS4 = objToTS(mixed, this.o, this.zone), ts = _objToTS4[0], o = _objToTS4[1];
        return clone$1(this, {
          ts,
          o
        });
      };
      _proto.plus = function plus(duration) {
        if (!this.isValid)
          return this;
        var dur = friendlyDuration(duration);
        return clone$1(this, adjustTime(this, dur));
      };
      _proto.minus = function minus(duration) {
        if (!this.isValid)
          return this;
        var dur = friendlyDuration(duration).negate();
        return clone$1(this, adjustTime(this, dur));
      };
      _proto.startOf = function startOf(unit) {
        if (!this.isValid)
          return this;
        var o = {}, normalizedUnit = Duration.normalizeUnit(unit);
        switch (normalizedUnit) {
          case "years":
            o.month = 1;
          case "quarters":
          case "months":
            o.day = 1;
          case "weeks":
          case "days":
            o.hour = 0;
          case "hours":
            o.minute = 0;
          case "minutes":
            o.second = 0;
          case "seconds":
            o.millisecond = 0;
            break;
        }
        if (normalizedUnit === "weeks") {
          o.weekday = 1;
        }
        if (normalizedUnit === "quarters") {
          var q = Math.ceil(this.month / 3);
          o.month = (q - 1) * 3 + 1;
        }
        return this.set(o);
      };
      _proto.endOf = function endOf(unit) {
        var _this$plus;
        return this.isValid ? this.plus((_this$plus = {}, _this$plus[unit] = 1, _this$plus)).startOf(unit).minus(1) : this;
      };
      _proto.toFormat = function toFormat(fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID$2;
      };
      _proto.toLocaleString = function toLocaleString(opts) {
        if (opts === void 0) {
          opts = DATE_SHORT;
        }
        return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTime(this) : INVALID$2;
      };
      _proto.toLocaleParts = function toLocaleParts(opts) {
        if (opts === void 0) {
          opts = {};
        }
        return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
      };
      _proto.toISO = function toISO(opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (!this.isValid) {
          return null;
        }
        return this.toISODate(opts) + "T" + this.toISOTime(opts);
      };
      _proto.toISODate = function toISODate(_temp3) {
        var _ref5 = _temp3 === void 0 ? {} : _temp3, _ref5$format = _ref5.format, format2 = _ref5$format === void 0 ? "extended" : _ref5$format;
        var fmt = format2 === "basic" ? "yyyyMMdd" : "yyyy-MM-dd";
        if (this.year > 9999) {
          fmt = "+" + fmt;
        }
        return toTechFormat(this, fmt);
      };
      _proto.toISOWeekDate = function toISOWeekDate() {
        return toTechFormat(this, "kkkk-'W'WW-c");
      };
      _proto.toISOTime = function toISOTime(_temp4) {
        var _ref6 = _temp4 === void 0 ? {} : _temp4, _ref6$suppressMillise = _ref6.suppressMilliseconds, suppressMilliseconds = _ref6$suppressMillise === void 0 ? false : _ref6$suppressMillise, _ref6$suppressSeconds = _ref6.suppressSeconds, suppressSeconds = _ref6$suppressSeconds === void 0 ? false : _ref6$suppressSeconds, _ref6$includeOffset = _ref6.includeOffset, includeOffset = _ref6$includeOffset === void 0 ? true : _ref6$includeOffset, _ref6$includePrefix = _ref6.includePrefix, includePrefix = _ref6$includePrefix === void 0 ? false : _ref6$includePrefix, _ref6$format = _ref6.format, format2 = _ref6$format === void 0 ? "extended" : _ref6$format;
        return toTechTimeFormat(this, {
          suppressSeconds,
          suppressMilliseconds,
          includeOffset,
          includePrefix,
          format: format2
        });
      };
      _proto.toRFC2822 = function toRFC2822() {
        return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
      };
      _proto.toHTTP = function toHTTP() {
        return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
      };
      _proto.toSQLDate = function toSQLDate() {
        return toTechFormat(this, "yyyy-MM-dd");
      };
      _proto.toSQLTime = function toSQLTime(_temp5) {
        var _ref7 = _temp5 === void 0 ? {} : _temp5, _ref7$includeOffset = _ref7.includeOffset, includeOffset = _ref7$includeOffset === void 0 ? true : _ref7$includeOffset, _ref7$includeZone = _ref7.includeZone, includeZone = _ref7$includeZone === void 0 ? false : _ref7$includeZone;
        return toTechTimeFormat(this, {
          includeOffset,
          includeZone,
          spaceZone: true
        });
      };
      _proto.toSQL = function toSQL(opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (!this.isValid) {
          return null;
        }
        return this.toSQLDate() + " " + this.toSQLTime(opts);
      };
      _proto.toString = function toString() {
        return this.isValid ? this.toISO() : INVALID$2;
      };
      _proto.valueOf = function valueOf() {
        return this.toMillis();
      };
      _proto.toMillis = function toMillis() {
        return this.isValid ? this.ts : NaN;
      };
      _proto.toSeconds = function toSeconds() {
        return this.isValid ? this.ts / 1e3 : NaN;
      };
      _proto.toJSON = function toJSON() {
        return this.toISO();
      };
      _proto.toBSON = function toBSON() {
        return this.toJSDate();
      };
      _proto.toObject = function toObject(opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (!this.isValid)
          return {};
        var base = Object.assign({}, this.c);
        if (opts.includeConfig) {
          base.outputCalendar = this.outputCalendar;
          base.numberingSystem = this.loc.numberingSystem;
          base.locale = this.loc.locale;
        }
        return base;
      };
      _proto.toJSDate = function toJSDate() {
        return new Date(this.isValid ? this.ts : NaN);
      };
      _proto.diff = function diff(otherDateTime, unit, opts) {
        if (unit === void 0) {
          unit = "milliseconds";
        }
        if (opts === void 0) {
          opts = {};
        }
        if (!this.isValid || !otherDateTime.isValid) {
          return Duration.invalid(this.invalid || otherDateTime.invalid, "created by diffing an invalid DateTime");
        }
        var durOpts = Object.assign({
          locale: this.locale,
          numberingSystem: this.numberingSystem
        }, opts);
        var units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = _diff(earlier, later, units, durOpts);
        return otherIsLater ? diffed.negate() : diffed;
      };
      _proto.diffNow = function diffNow(unit, opts) {
        if (unit === void 0) {
          unit = "milliseconds";
        }
        if (opts === void 0) {
          opts = {};
        }
        return this.diff(DateTime2.now(), unit, opts);
      };
      _proto.until = function until(otherDateTime) {
        return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
      };
      _proto.hasSame = function hasSame(otherDateTime, unit) {
        if (!this.isValid)
          return false;
        var inputMs = otherDateTime.valueOf();
        var otherZoneDateTime = this.setZone(otherDateTime.zone, {
          keepLocalTime: true
        });
        return otherZoneDateTime.startOf(unit) <= inputMs && inputMs <= otherZoneDateTime.endOf(unit);
      };
      _proto.equals = function equals2(other) {
        return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
      };
      _proto.toRelative = function toRelative(options) {
        if (options === void 0) {
          options = {};
        }
        if (!this.isValid)
          return null;
        var base = options.base || DateTime2.fromObject({
          zone: this.zone
        }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
        var units = ["years", "months", "days", "hours", "minutes", "seconds"];
        var unit = options.unit;
        if (Array.isArray(options.unit)) {
          units = options.unit;
          unit = void 0;
        }
        return diffRelative(base, this.plus(padding), Object.assign(options, {
          numeric: "always",
          units,
          unit
        }));
      };
      _proto.toRelativeCalendar = function toRelativeCalendar(options) {
        if (options === void 0) {
          options = {};
        }
        if (!this.isValid)
          return null;
        return diffRelative(options.base || DateTime2.fromObject({
          zone: this.zone
        }), this, Object.assign(options, {
          numeric: "auto",
          units: ["years", "months", "days"],
          calendary: true
        }));
      };
      DateTime2.min = function min2() {
        for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
          dateTimes[_key] = arguments[_key];
        }
        if (!dateTimes.every(DateTime2.isDateTime)) {
          throw new InvalidArgumentError("min requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, function(i) {
          return i.valueOf();
        }, Math.min);
      };
      DateTime2.max = function max2() {
        for (var _len2 = arguments.length, dateTimes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          dateTimes[_key2] = arguments[_key2];
        }
        if (!dateTimes.every(DateTime2.isDateTime)) {
          throw new InvalidArgumentError("max requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, function(i) {
          return i.valueOf();
        }, Math.max);
      };
      DateTime2.fromFormatExplain = function fromFormatExplain(text, fmt, options) {
        if (options === void 0) {
          options = {};
        }
        var _options = options, _options$locale = _options.locale, locale = _options$locale === void 0 ? null : _options$locale, _options$numberingSys = _options.numberingSystem, numberingSystem = _options$numberingSys === void 0 ? null : _options$numberingSys, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        });
        return explainFromTokens(localeToUse, text, fmt);
      };
      DateTime2.fromStringExplain = function fromStringExplain(text, fmt, options) {
        if (options === void 0) {
          options = {};
        }
        return DateTime2.fromFormatExplain(text, fmt, options);
      };
      _createClass14(DateTime2, [{
        key: "isValid",
        get: function get() {
          return this.invalid === null;
        }
        /**
         * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
         * @type {string}
         */
      }, {
        key: "invalidReason",
        get: function get() {
          return this.invalid ? this.invalid.reason : null;
        }
        /**
         * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
         * @type {string}
         */
      }, {
        key: "invalidExplanation",
        get: function get() {
          return this.invalid ? this.invalid.explanation : null;
        }
        /**
         * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
         *
         * @type {string}
         */
      }, {
        key: "locale",
        get: function get() {
          return this.isValid ? this.loc.locale : null;
        }
        /**
         * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
         *
         * @type {string}
         */
      }, {
        key: "numberingSystem",
        get: function get() {
          return this.isValid ? this.loc.numberingSystem : null;
        }
        /**
         * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
         *
         * @type {string}
         */
      }, {
        key: "outputCalendar",
        get: function get() {
          return this.isValid ? this.loc.outputCalendar : null;
        }
        /**
         * Get the time zone associated with this DateTime.
         * @type {Zone}
         */
      }, {
        key: "zone",
        get: function get() {
          return this._zone;
        }
        /**
         * Get the name of the time zone.
         * @type {string}
         */
      }, {
        key: "zoneName",
        get: function get() {
          return this.isValid ? this.zone.name : null;
        }
        /**
         * Get the year
         * @example DateTime.local(2017, 5, 25).year //=> 2017
         * @type {number}
         */
      }, {
        key: "year",
        get: function get() {
          return this.isValid ? this.c.year : NaN;
        }
        /**
         * Get the quarter
         * @example DateTime.local(2017, 5, 25).quarter //=> 2
         * @type {number}
         */
      }, {
        key: "quarter",
        get: function get() {
          return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
        }
        /**
         * Get the month (1-12).
         * @example DateTime.local(2017, 5, 25).month //=> 5
         * @type {number}
         */
      }, {
        key: "month",
        get: function get() {
          return this.isValid ? this.c.month : NaN;
        }
        /**
         * Get the day of the month (1-30ish).
         * @example DateTime.local(2017, 5, 25).day //=> 25
         * @type {number}
         */
      }, {
        key: "day",
        get: function get() {
          return this.isValid ? this.c.day : NaN;
        }
        /**
         * Get the hour of the day (0-23).
         * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
         * @type {number}
         */
      }, {
        key: "hour",
        get: function get() {
          return this.isValid ? this.c.hour : NaN;
        }
        /**
         * Get the minute of the hour (0-59).
         * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
         * @type {number}
         */
      }, {
        key: "minute",
        get: function get() {
          return this.isValid ? this.c.minute : NaN;
        }
        /**
         * Get the second of the minute (0-59).
         * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
         * @type {number}
         */
      }, {
        key: "second",
        get: function get() {
          return this.isValid ? this.c.second : NaN;
        }
        /**
         * Get the millisecond of the second (0-999).
         * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
         * @type {number}
         */
      }, {
        key: "millisecond",
        get: function get() {
          return this.isValid ? this.c.millisecond : NaN;
        }
        /**
         * Get the week year
         * @see https://en.wikipedia.org/wiki/ISO_week_date
         * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
         * @type {number}
         */
      }, {
        key: "weekYear",
        get: function get() {
          return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
        }
        /**
         * Get the week number of the week year (1-52ish).
         * @see https://en.wikipedia.org/wiki/ISO_week_date
         * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
         * @type {number}
         */
      }, {
        key: "weekNumber",
        get: function get() {
          return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
        }
        /**
         * Get the day of the week.
         * 1 is Monday and 7 is Sunday
         * @see https://en.wikipedia.org/wiki/ISO_week_date
         * @example DateTime.local(2014, 11, 31).weekday //=> 4
         * @type {number}
         */
      }, {
        key: "weekday",
        get: function get() {
          return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
        }
        /**
         * Get the ordinal (meaning the day of the year)
         * @example DateTime.local(2017, 5, 25).ordinal //=> 145
         * @type {number|DateTime}
         */
      }, {
        key: "ordinal",
        get: function get() {
          return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
        }
        /**
         * Get the human readable short month name, such as 'Oct'.
         * Defaults to the system's locale if no locale has been specified
         * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
         * @type {string}
         */
      }, {
        key: "monthShort",
        get: function get() {
          return this.isValid ? Info.months("short", {
            locObj: this.loc
          })[this.month - 1] : null;
        }
        /**
         * Get the human readable long month name, such as 'October'.
         * Defaults to the system's locale if no locale has been specified
         * @example DateTime.local(2017, 10, 30).monthLong //=> October
         * @type {string}
         */
      }, {
        key: "monthLong",
        get: function get() {
          return this.isValid ? Info.months("long", {
            locObj: this.loc
          })[this.month - 1] : null;
        }
        /**
         * Get the human readable short weekday, such as 'Mon'.
         * Defaults to the system's locale if no locale has been specified
         * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
         * @type {string}
         */
      }, {
        key: "weekdayShort",
        get: function get() {
          return this.isValid ? Info.weekdays("short", {
            locObj: this.loc
          })[this.weekday - 1] : null;
        }
        /**
         * Get the human readable long weekday, such as 'Monday'.
         * Defaults to the system's locale if no locale has been specified
         * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
         * @type {string}
         */
      }, {
        key: "weekdayLong",
        get: function get() {
          return this.isValid ? Info.weekdays("long", {
            locObj: this.loc
          })[this.weekday - 1] : null;
        }
        /**
         * Get the UTC offset of this DateTime in minutes
         * @example DateTime.now().offset //=> -240
         * @example DateTime.utc().offset //=> 0
         * @type {number}
         */
      }, {
        key: "offset",
        get: function get() {
          return this.isValid ? +this.o : NaN;
        }
        /**
         * Get the short human name for the zone's current offset, for example "EST" or "EDT".
         * Defaults to the system's locale if no locale has been specified
         * @type {string}
         */
      }, {
        key: "offsetNameShort",
        get: function get() {
          if (this.isValid) {
            return this.zone.offsetName(this.ts, {
              format: "short",
              locale: this.locale
            });
          } else {
            return null;
          }
        }
        /**
         * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
         * Defaults to the system's locale if no locale has been specified
         * @type {string}
         */
      }, {
        key: "offsetNameLong",
        get: function get() {
          if (this.isValid) {
            return this.zone.offsetName(this.ts, {
              format: "long",
              locale: this.locale
            });
          } else {
            return null;
          }
        }
        /**
         * Get whether this zone's offset ever changes, as in a DST.
         * @type {boolean}
         */
      }, {
        key: "isOffsetFixed",
        get: function get() {
          return this.isValid ? this.zone.universal : null;
        }
        /**
         * Get whether the DateTime is in a DST.
         * @type {boolean}
         */
      }, {
        key: "isInDST",
        get: function get() {
          if (this.isOffsetFixed) {
            return false;
          } else {
            return this.offset > this.set({
              month: 1
            }).offset || this.offset > this.set({
              month: 5
            }).offset;
          }
        }
        /**
         * Returns true if this DateTime is in a leap year, false otherwise
         * @example DateTime.local(2016).isInLeapYear //=> true
         * @example DateTime.local(2013).isInLeapYear //=> false
         * @type {boolean}
         */
      }, {
        key: "isInLeapYear",
        get: function get() {
          return isLeapYear(this.year);
        }
        /**
         * Returns the number of days in this DateTime's month
         * @example DateTime.local(2016, 2).daysInMonth //=> 29
         * @example DateTime.local(2016, 3).daysInMonth //=> 31
         * @type {number}
         */
      }, {
        key: "daysInMonth",
        get: function get() {
          return daysInMonth(this.year, this.month);
        }
        /**
         * Returns the number of days in this DateTime's year
         * @example DateTime.local(2016).daysInYear //=> 366
         * @example DateTime.local(2013).daysInYear //=> 365
         * @type {number}
         */
      }, {
        key: "daysInYear",
        get: function get() {
          return this.isValid ? daysInYear(this.year) : NaN;
        }
        /**
         * Returns the number of weeks in this DateTime's year
         * @see https://en.wikipedia.org/wiki/ISO_week_date
         * @example DateTime.local(2004).weeksInWeekYear //=> 53
         * @example DateTime.local(2013).weeksInWeekYear //=> 52
         * @type {number}
         */
      }, {
        key: "weeksInWeekYear",
        get: function get() {
          return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
        }
      }], [{
        key: "DATE_SHORT",
        get: function get() {
          return DATE_SHORT;
        }
        /**
         * {@link toLocaleString} format like 'Oct 14, 1983'
         * @type {Object}
         */
      }, {
        key: "DATE_MED",
        get: function get() {
          return DATE_MED;
        }
        /**
         * {@link toLocaleString} format like 'Fri, Oct 14, 1983'
         * @type {Object}
         */
      }, {
        key: "DATE_MED_WITH_WEEKDAY",
        get: function get() {
          return DATE_MED_WITH_WEEKDAY;
        }
        /**
         * {@link toLocaleString} format like 'October 14, 1983'
         * @type {Object}
         */
      }, {
        key: "DATE_FULL",
        get: function get() {
          return DATE_FULL;
        }
        /**
         * {@link toLocaleString} format like 'Tuesday, October 14, 1983'
         * @type {Object}
         */
      }, {
        key: "DATE_HUGE",
        get: function get() {
          return DATE_HUGE;
        }
        /**
         * {@link toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
         * @type {Object}
         */
      }, {
        key: "TIME_SIMPLE",
        get: function get() {
          return TIME_SIMPLE;
        }
        /**
         * {@link toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
         * @type {Object}
         */
      }, {
        key: "TIME_WITH_SECONDS",
        get: function get() {
          return TIME_WITH_SECONDS;
        }
        /**
         * {@link toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
         * @type {Object}
         */
      }, {
        key: "TIME_WITH_SHORT_OFFSET",
        get: function get() {
          return TIME_WITH_SHORT_OFFSET;
        }
        /**
         * {@link toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
         * @type {Object}
         */
      }, {
        key: "TIME_WITH_LONG_OFFSET",
        get: function get() {
          return TIME_WITH_LONG_OFFSET;
        }
        /**
         * {@link toLocaleString} format like '09:30', always 24-hour.
         * @type {Object}
         */
      }, {
        key: "TIME_24_SIMPLE",
        get: function get() {
          return TIME_24_SIMPLE;
        }
        /**
         * {@link toLocaleString} format like '09:30:23', always 24-hour.
         * @type {Object}
         */
      }, {
        key: "TIME_24_WITH_SECONDS",
        get: function get() {
          return TIME_24_WITH_SECONDS;
        }
        /**
         * {@link toLocaleString} format like '09:30:23 EDT', always 24-hour.
         * @type {Object}
         */
      }, {
        key: "TIME_24_WITH_SHORT_OFFSET",
        get: function get() {
          return TIME_24_WITH_SHORT_OFFSET;
        }
        /**
         * {@link toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
         * @type {Object}
         */
      }, {
        key: "TIME_24_WITH_LONG_OFFSET",
        get: function get() {
          return TIME_24_WITH_LONG_OFFSET;
        }
        /**
         * {@link toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
         * @type {Object}
         */
      }, {
        key: "DATETIME_SHORT",
        get: function get() {
          return DATETIME_SHORT;
        }
        /**
         * {@link toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
         * @type {Object}
         */
      }, {
        key: "DATETIME_SHORT_WITH_SECONDS",
        get: function get() {
          return DATETIME_SHORT_WITH_SECONDS;
        }
        /**
         * {@link toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
         * @type {Object}
         */
      }, {
        key: "DATETIME_MED",
        get: function get() {
          return DATETIME_MED;
        }
        /**
         * {@link toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
         * @type {Object}
         */
      }, {
        key: "DATETIME_MED_WITH_SECONDS",
        get: function get() {
          return DATETIME_MED_WITH_SECONDS;
        }
        /**
         * {@link toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
         * @type {Object}
         */
      }, {
        key: "DATETIME_MED_WITH_WEEKDAY",
        get: function get() {
          return DATETIME_MED_WITH_WEEKDAY;
        }
        /**
         * {@link toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
         * @type {Object}
         */
      }, {
        key: "DATETIME_FULL",
        get: function get() {
          return DATETIME_FULL;
        }
        /**
         * {@link toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
         * @type {Object}
         */
      }, {
        key: "DATETIME_FULL_WITH_SECONDS",
        get: function get() {
          return DATETIME_FULL_WITH_SECONDS;
        }
        /**
         * {@link toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
         * @type {Object}
         */
      }, {
        key: "DATETIME_HUGE",
        get: function get() {
          return DATETIME_HUGE;
        }
        /**
         * {@link toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
         * @type {Object}
         */
      }, {
        key: "DATETIME_HUGE_WITH_SECONDS",
        get: function get() {
          return DATETIME_HUGE_WITH_SECONDS;
        }
      }]);
      return DateTime2;
    }();
    function friendlyDateTime(dateTimeish) {
      if (DateTime.isDateTime(dateTimeish)) {
        return dateTimeish;
      } else if (dateTimeish && dateTimeish.valueOf && isNumber2(dateTimeish.valueOf())) {
        return DateTime.fromJSDate(dateTimeish);
      } else if (dateTimeish && typeof dateTimeish === "object") {
        return DateTime.fromObject(dateTimeish);
      } else {
        throw new InvalidArgumentError("Unknown datetime argument: " + dateTimeish + ", of type " + typeof dateTimeish);
      }
    }
    var VERSION = "1.28.1";
    exports.DateTime = DateTime;
    exports.Duration = Duration;
    exports.FixedOffsetZone = FixedOffsetZone;
    exports.IANAZone = IANAZone;
    exports.Info = Info;
    exports.Interval = Interval;
    exports.InvalidZone = InvalidZone;
    exports.LocalZone = LocalZone;
    exports.Settings = Settings;
    exports.VERSION = VERSION;
    exports.Zone = Zone;
  }
});

// node_modules/@aries-framework/core/build/storage/Metadata.js
var require_Metadata = __commonJS({
  "node_modules/@aries-framework/core/build/storage/Metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Metadata = void 0;
    var Metadata3 = class {
      constructor(data) {
        this.data = data;
      }
      /**
       * Gets the value by key in the metadata
       *
       * Any extension of the `BaseRecord` can implement their own typed metadata
       *
       * @param key the key to retrieve the metadata by
       * @returns the value saved in the key value pair
       * @returns null when the key could not be found
       */
      get(key) {
        var _a;
        return (_a = this.data[key]) !== null && _a !== void 0 ? _a : null;
      }
      /**
       * Will set, or override, a key-value pair on the metadata
       *
       * @param key the key to set the metadata by
       * @param value the value to set in the metadata
       */
      set(key, value) {
        this.data[key] = value;
      }
      /**
       * Adds a record to a metadata key
       *
       * @param key the key to add the metadata at
       * @param value the value to add in the metadata
       */
      add(key, value) {
        this.data[key] = Object.assign(Object.assign({}, this.data[key]), value);
      }
      /**
       * Retrieves all the metadata for a record
       *
       * @returns all the metadata that exists on the record
       */
      get keys() {
        return Object.keys(this.data);
      }
      /**
       * Will delete the key value pair in the metadata
       *
       * @param key the key to delete the data by
       */
      delete(key) {
        delete this.data[key];
      }
    };
    exports.Metadata = Metadata3;
  }
});

// node_modules/@aries-framework/core/build/utils/transformers.js
var require_transformers = __commonJS({
  "node_modules/@aries-framework/core/build/utils/transformers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsStringOrStringArray = exports.IsMap = exports.DateParser = exports.DateTransformer = exports.MetadataTransformer = exports.RecordTransformer = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var luxon_1 = require_luxon();
    var Metadata_1 = require_Metadata();
    var JsonTransformer_1 = require_JsonTransformer();
    function RecordTransformer(Class) {
      return (0, class_transformer_1.Transform)(({ value, type }) => {
        switch (type) {
          case class_transformer_1.TransformationType.CLASS_TO_PLAIN:
            return Object.entries(value).reduce((accumulator, [key, attribute]) => Object.assign(Object.assign({}, accumulator), { [key]: JsonTransformer_1.JsonTransformer.toJSON(attribute) }), {});
          case class_transformer_1.TransformationType.PLAIN_TO_CLASS:
            return Object.entries(value).reduce((accumulator, [key, attribute]) => Object.assign(Object.assign({}, accumulator), { [key]: JsonTransformer_1.JsonTransformer.fromJSON(attribute, Class) }), {});
          default:
            return value;
        }
      });
    }
    exports.RecordTransformer = RecordTransformer;
    function MetadataTransformer() {
      return (0, class_transformer_1.Transform)(({ value, type }) => {
        if (type === class_transformer_1.TransformationType.CLASS_TO_PLAIN) {
          return Object.assign({}, value.data);
        }
        if (type === class_transformer_1.TransformationType.PLAIN_TO_CLASS) {
          return new Metadata_1.Metadata(value);
        }
        if (type === class_transformer_1.TransformationType.CLASS_TO_CLASS) {
          return new Metadata_1.Metadata(Object.assign({}, value.data));
        }
      });
    }
    exports.MetadataTransformer = MetadataTransformer;
    function DateTransformer() {
      return (0, class_transformer_1.Transform)(({ value, type }) => {
        if (type === class_transformer_1.TransformationType.CLASS_TO_PLAIN) {
          return value.toISOString();
        }
        if (type === class_transformer_1.TransformationType.PLAIN_TO_CLASS) {
          return new Date(value);
        }
        if (type === class_transformer_1.TransformationType.CLASS_TO_CLASS) {
          return new Date(value.getTime());
        }
      });
    }
    exports.DateTransformer = DateTransformer;
    function DateParser(value) {
      const parsedDate = new Date(value);
      if (parsedDate instanceof Date && !isNaN(parsedDate.getTime())) {
        return parsedDate;
      }
      const luxonDate = luxon_1.DateTime.fromSQL(value);
      if (luxonDate.isValid) {
        return new Date(luxonDate.toString());
      }
      return /* @__PURE__ */ new Date();
    }
    exports.DateParser = DateParser;
    function IsMap(validationOptions) {
      return (0, class_validator_1.ValidateBy)({
        name: "isMap",
        validator: {
          validate: (value) => value instanceof Map,
          defaultMessage: (0, class_validator_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a Map", validationOptions)
        }
      }, validationOptions);
    }
    exports.IsMap = IsMap;
    function IsStringOrStringArray(validationOptions) {
      return (0, class_validator_1.ValidateBy)({
        name: "isStringOrStringArray",
        validator: {
          validate: (value) => (0, class_validator_1.isString)(value) || Array.isArray(value) && value.every((v) => (0, class_validator_1.isString)(v)),
          defaultMessage: (0, class_validator_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a string or string array", validationOptions)
        }
      }, validationOptions);
    }
    exports.IsStringOrStringArray = IsStringOrStringArray;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/key-type/bls12381g1.js
var require_bls12381g1 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/key-type/bls12381g1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keyDidBls12381g1 = exports.getBls12381g1VerificationMethod = void 0;
    var crypto_1 = require_crypto();
    var Key_1 = require_Key();
    var VERIFICATION_METHOD_TYPE_BLS12381G1_KEY_2020 = "Bls12381G1Key2020";
    function getBls12381g1VerificationMethod(did, key) {
      return {
        id: `${did}#${key.fingerprint}`,
        type: VERIFICATION_METHOD_TYPE_BLS12381G1_KEY_2020,
        controller: did,
        publicKeyBase58: key.publicKeyBase58
      };
    }
    exports.getBls12381g1VerificationMethod = getBls12381g1VerificationMethod;
    exports.keyDidBls12381g1 = {
      supportedVerificationMethodTypes: [VERIFICATION_METHOD_TYPE_BLS12381G1_KEY_2020],
      getVerificationMethods: (did, key) => [getBls12381g1VerificationMethod(did, key)],
      getKeyFromVerificationMethod: (verificationMethod) => {
        if (verificationMethod.type !== VERIFICATION_METHOD_TYPE_BLS12381G1_KEY_2020 || !verificationMethod.publicKeyBase58) {
          throw new Error("Invalid verification method passed");
        }
        return Key_1.Key.fromPublicKeyBase58(verificationMethod.publicKeyBase58, crypto_1.KeyType.Bls12381g1);
      }
    };
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/key-type/bls12381g2.js
var require_bls12381g2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/key-type/bls12381g2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keyDidBls12381g2 = exports.getBls12381g2VerificationMethod = exports.VERIFICATION_METHOD_TYPE_BLS12381G2_KEY_2020 = void 0;
    var crypto_1 = require_crypto();
    var Key_1 = require_Key();
    exports.VERIFICATION_METHOD_TYPE_BLS12381G2_KEY_2020 = "Bls12381G2Key2020";
    function getBls12381g2VerificationMethod(did, key) {
      return {
        id: `${did}#${key.fingerprint}`,
        type: exports.VERIFICATION_METHOD_TYPE_BLS12381G2_KEY_2020,
        controller: did,
        publicKeyBase58: key.publicKeyBase58
      };
    }
    exports.getBls12381g2VerificationMethod = getBls12381g2VerificationMethod;
    exports.keyDidBls12381g2 = {
      supportedVerificationMethodTypes: [exports.VERIFICATION_METHOD_TYPE_BLS12381G2_KEY_2020],
      getVerificationMethods: (did, key) => [getBls12381g2VerificationMethod(did, key)],
      getKeyFromVerificationMethod: (verificationMethod) => {
        if (verificationMethod.type !== exports.VERIFICATION_METHOD_TYPE_BLS12381G2_KEY_2020 || !verificationMethod.publicKeyBase58) {
          throw new Error("Invalid verification method passed");
        }
        return Key_1.Key.fromPublicKeyBase58(verificationMethod.publicKeyBase58, crypto_1.KeyType.Bls12381g2);
      }
    };
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/key-type/bls12381g1g2.js
var require_bls12381g1g2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/key-type/bls12381g1g2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keyDidBls12381g1g2 = exports.getBls12381g1g2VerificationMethod = void 0;
    var crypto_1 = require_crypto();
    var Key_1 = require_Key();
    var bls12381g1_1 = require_bls12381g1();
    var bls12381g2_1 = require_bls12381g2();
    function getBls12381g1g2VerificationMethod(did, key) {
      const g1PublicKey = key.publicKey.slice(0, 48);
      const g2PublicKey = key.publicKey.slice(48);
      const bls12381g1Key = Key_1.Key.fromPublicKey(g1PublicKey, crypto_1.KeyType.Bls12381g1);
      const bls12381g2Key = Key_1.Key.fromPublicKey(g2PublicKey, crypto_1.KeyType.Bls12381g2);
      const bls12381g1VerificationMethod = (0, bls12381g1_1.getBls12381g1VerificationMethod)(did, bls12381g1Key);
      const bls12381g2VerificationMethod = (0, bls12381g2_1.getBls12381g2VerificationMethod)(did, bls12381g2Key);
      return [bls12381g1VerificationMethod, bls12381g2VerificationMethod];
    }
    exports.getBls12381g1g2VerificationMethod = getBls12381g1g2VerificationMethod;
    exports.keyDidBls12381g1g2 = {
      supportedVerificationMethodTypes: [],
      getVerificationMethods: getBls12381g1g2VerificationMethod,
      getKeyFromVerificationMethod: () => {
        throw new Error("Not supported for bls12381g1g2 key");
      }
    };
  }
});

// node_modules/@stablelib/random/lib/source/browser.js
var require_browser = __commonJS({
  "node_modules/@stablelib/random/lib/source/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BrowserRandomSource = void 0;
    var QUOTA = 65536;
    var BrowserRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
          this._crypto = browserCrypto;
          this.isAvailable = true;
          this.isInstantiated = true;
        }
      }
      randomBytes(length2) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Browser random byte generator is not available.");
        }
        const out = new Uint8Array(length2);
        for (let i = 0; i < out.length; i += QUOTA) {
          this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
        }
        return out;
      }
    };
    exports.BrowserRandomSource = BrowserRandomSource;
  }
});

// browser-external:crypto
var require_crypto2 = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@stablelib/random/lib/source/node.js
var require_node = __commonJS({
  "node_modules/@stablelib/random/lib/source/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodeRandomSource = void 0;
    var wipe_1 = require_wipe();
    var NodeRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (typeof __require !== "undefined") {
          const nodeCrypto = require_crypto2();
          if (nodeCrypto && nodeCrypto.randomBytes) {
            this._crypto = nodeCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
          }
        }
      }
      randomBytes(length2) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Node.js random byte generator is not available.");
        }
        let buffer = this._crypto.randomBytes(length2);
        if (buffer.length !== length2) {
          throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        const out = new Uint8Array(length2);
        for (let i = 0; i < out.length; i++) {
          out[i] = buffer[i];
        }
        (0, wipe_1.wipe)(buffer);
        return out;
      }
    };
    exports.NodeRandomSource = NodeRandomSource;
  }
});

// node_modules/@stablelib/random/lib/source/system.js
var require_system = __commonJS({
  "node_modules/@stablelib/random/lib/source/system.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SystemRandomSource = void 0;
    var browser_1 = require_browser();
    var node_1 = require_node();
    var SystemRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.name = "";
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Browser";
          return;
        }
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Node";
          return;
        }
      }
      randomBytes(length2) {
        if (!this.isAvailable) {
          throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length2);
      }
    };
    exports.SystemRandomSource = SystemRandomSource;
  }
});

// node_modules/@stablelib/random/lib/random.js
var require_random = __commonJS({
  "node_modules/@stablelib/random/lib/random.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
    var system_1 = require_system();
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.defaultRandomSource = new system_1.SystemRandomSource();
    function randomBytes(length2, prng = exports.defaultRandomSource) {
      return prng.randomBytes(length2);
    }
    exports.randomBytes = randomBytes;
    function randomUint32(prng = exports.defaultRandomSource) {
      const buf = randomBytes(4, prng);
      const result2 = (0, binary_1.readUint32LE)(buf);
      (0, wipe_1.wipe)(buf);
      return result2;
    }
    exports.randomUint32 = randomUint32;
    var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function randomString(length2, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
      if (charset.length < 2) {
        throw new Error("randomString charset is too short");
      }
      if (charset.length > 256) {
        throw new Error("randomString charset is too long");
      }
      let out = "";
      const charsLen = charset.length;
      const maxByte = 256 - 256 % charsLen;
      while (length2 > 0) {
        const buf = randomBytes(Math.ceil(length2 * 256 / maxByte), prng);
        for (let i = 0; i < buf.length && length2 > 0; i++) {
          const randomByte = buf[i];
          if (randomByte < maxByte) {
            out += charset.charAt(randomByte % charsLen);
            length2--;
          }
        }
        (0, wipe_1.wipe)(buf);
      }
      return out;
    }
    exports.randomString = randomString;
    function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
      const length2 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
      return randomString(length2, charset, prng);
    }
    exports.randomStringForEntropy = randomStringForEntropy;
  }
});

// node_modules/@stablelib/sha512/lib/sha512.js
var require_sha512 = __commonJS({
  "node_modules/@stablelib/sha512/lib/sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 64;
    exports.BLOCK_SIZE = 128;
    var SHA512 = (
      /** @class */
      function() {
        function SHA5122() {
          this.digestLength = exports.DIGEST_LENGTH;
          this.blockSize = exports.BLOCK_SIZE;
          this._stateHi = new Int32Array(8);
          this._stateLo = new Int32Array(8);
          this._tempHi = new Int32Array(16);
          this._tempLo = new Int32Array(16);
          this._buffer = new Uint8Array(256);
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          this.reset();
        }
        SHA5122.prototype._initState = function() {
          this._stateHi[0] = 1779033703;
          this._stateHi[1] = 3144134277;
          this._stateHi[2] = 1013904242;
          this._stateHi[3] = 2773480762;
          this._stateHi[4] = 1359893119;
          this._stateHi[5] = 2600822924;
          this._stateHi[6] = 528734635;
          this._stateHi[7] = 1541459225;
          this._stateLo[0] = 4089235720;
          this._stateLo[1] = 2227873595;
          this._stateLo[2] = 4271175723;
          this._stateLo[3] = 1595750129;
          this._stateLo[4] = 2917565137;
          this._stateLo[5] = 725511199;
          this._stateLo[6] = 4215389547;
          this._stateLo[7] = 327033209;
        };
        SHA5122.prototype.reset = function() {
          this._initState();
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          return this;
        };
        SHA5122.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._tempHi);
          wipe_1.wipe(this._tempLo);
          this.reset();
        };
        SHA5122.prototype.update = function(data, dataLength) {
          if (dataLength === void 0) {
            dataLength = data.length;
          }
          if (this._finished) {
            throw new Error("SHA512: can't update because hash was finished.");
          }
          var dataPos = 0;
          this._bytesHashed += dataLength;
          if (this._bufferLength > 0) {
            while (this._bufferLength < exports.BLOCK_SIZE && dataLength > 0) {
              this._buffer[this._bufferLength++] = data[dataPos++];
              dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
              hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
              this._bufferLength = 0;
            }
          }
          if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data, dataPos, dataLength);
            dataLength %= this.blockSize;
          }
          while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          return this;
        };
        SHA5122.prototype.finish = function(out) {
          if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = bytesHashed / 536870912 | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = bytesHashed % 128 < 112 ? 128 : 256;
            this._buffer[left] = 128;
            for (var i = left + 1; i < padLength - 8; i++) {
              this._buffer[i] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
            this._finished = true;
          }
          for (var i = 0; i < this.digestLength / 8; i++) {
            binary_1.writeUint32BE(this._stateHi[i], out, i * 8);
            binary_1.writeUint32BE(this._stateLo[i], out, i * 8 + 4);
          }
          return this;
        };
        SHA5122.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        SHA5122.prototype.saveState = function() {
          if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
          }
          return {
            stateHi: new Int32Array(this._stateHi),
            stateLo: new Int32Array(this._stateLo),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          };
        };
        SHA5122.prototype.restoreState = function(savedState) {
          this._stateHi.set(savedState.stateHi);
          this._stateLo.set(savedState.stateLo);
          this._bufferLength = savedState.bufferLength;
          if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
          }
          this._bytesHashed = savedState.bytesHashed;
          this._finished = false;
          return this;
        };
        SHA5122.prototype.cleanSavedState = function(savedState) {
          wipe_1.wipe(savedState.stateHi);
          wipe_1.wipe(savedState.stateLo);
          if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
          }
          savedState.bufferLength = 0;
          savedState.bytesHashed = 0;
        };
        return SHA5122;
      }()
    );
    exports.SHA512 = SHA512;
    var K = new Int32Array([
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ]);
    function hashBlocks(wh, wl, hh, hl, m, pos, len) {
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var h, l;
      var th, tl;
      var a, b, c, d;
      while (len >= 128) {
        for (var i = 0; i < 16; i++) {
          var j = 8 * i + pos;
          wh[i] = binary_1.readUint32BE(m, j);
          wl[i] = binary_1.readUint32BE(m, j + 4);
        }
        for (var i = 0; i < 80; i++) {
          var bh0 = ah0;
          var bh1 = ah1;
          var bh2 = ah2;
          var bh3 = ah3;
          var bh4 = ah4;
          var bh5 = ah5;
          var bh6 = ah6;
          var bh7 = ah7;
          var bl0 = al0;
          var bl1 = al1;
          var bl2 = al2;
          var bl3 = al3;
          var bl4 = al4;
          var bl5 = al5;
          var bl6 = al6;
          var bl7 = al7;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = ah4 & ah5 ^ ~ah4 & ah6;
          l = al4 & al5 ^ ~al4 & al6;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = K[i * 2];
          l = K[i * 2 + 1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = wh[i % 16];
          l = wl[i % 16];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          th = c & 65535 | d << 16;
          tl = a & 65535 | b << 16;
          h = th;
          l = tl;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh7 = c & 65535 | d << 16;
          bl7 = a & 65535 | b << 16;
          h = bh3;
          l = bl3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = th;
          l = tl;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh3 = c & 65535 | d << 16;
          bl3 = a & 65535 | b << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i % 16 === 15) {
            for (var j = 0; j < 16; j++) {
              h = wh[j];
              l = wl[j];
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = wh[(j + 9) % 16];
              l = wl[(j + 9) % 16];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              th = wh[(j + 1) % 16];
              tl = wl[(j + 1) % 16];
              h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              th = wh[(j + 14) % 16];
              tl = wl[(j + 14) % 16];
              h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              wh[j] = c & 65535 | d << 16;
              wl[j] = a & 65535 | b << 16;
            }
          }
        }
        h = ah0;
        l = al0;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[0];
        l = hl[0];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[0] = ah0 = c & 65535 | d << 16;
        hl[0] = al0 = a & 65535 | b << 16;
        h = ah1;
        l = al1;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[1];
        l = hl[1];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[1] = ah1 = c & 65535 | d << 16;
        hl[1] = al1 = a & 65535 | b << 16;
        h = ah2;
        l = al2;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[2];
        l = hl[2];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[2] = ah2 = c & 65535 | d << 16;
        hl[2] = al2 = a & 65535 | b << 16;
        h = ah3;
        l = al3;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[3];
        l = hl[3];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[3] = ah3 = c & 65535 | d << 16;
        hl[3] = al3 = a & 65535 | b << 16;
        h = ah4;
        l = al4;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[4];
        l = hl[4];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[4] = ah4 = c & 65535 | d << 16;
        hl[4] = al4 = a & 65535 | b << 16;
        h = ah5;
        l = al5;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[5];
        l = hl[5];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[5] = ah5 = c & 65535 | d << 16;
        hl[5] = al5 = a & 65535 | b << 16;
        h = ah6;
        l = al6;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[6];
        l = hl[6];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[6] = ah6 = c & 65535 | d << 16;
        hl[6] = al6 = a & 65535 | b << 16;
        h = ah7;
        l = al7;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[7];
        l = hl[7];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[7] = ah7 = c & 65535 | d << 16;
        hl[7] = al7 = a & 65535 | b << 16;
        pos += 128;
        len -= 128;
      }
      return pos;
    }
    function hash(data) {
      var h = new SHA512();
      h.update(data);
      var digest = h.digest();
      h.clean();
      return digest;
    }
    exports.hash = hash;
  }
});

// node_modules/@stablelib/ed25519/lib/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/@stablelib/ed25519/lib/ed25519.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertSecretKeyToX25519 = exports.convertPublicKeyToX25519 = exports.verify = exports.sign = exports.extractPublicKeyFromSecretKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.SEED_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = exports.SIGNATURE_LENGTH = void 0;
    var random_1 = require_random();
    var sha512_1 = require_sha512();
    var wipe_1 = require_wipe();
    exports.SIGNATURE_LENGTH = 64;
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 64;
    exports.SEED_LENGTH = 32;
    function gf(init) {
      const r = new Float64Array(16);
      if (init) {
        for (let i = 0; i < init.length; i++) {
          r[i] = init[i];
        }
      }
      return r;
    }
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf();
    var gf1 = gf([1]);
    var D = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D2 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var I = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function set25519(r, a) {
      for (let i = 0; i < 16; i++) {
        r[i] = a[i] | 0;
      }
    }
    function car25519(o) {
      let c = 1;
      for (let i = 0; i < 16; i++) {
        let v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q, b) {
      const c = ~(b - 1);
      for (let i = 0; i < 16; i++) {
        const t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }
    function pack25519(o, n) {
      const m = gf();
      const t = gf();
      for (let i = 0; i < 16; i++) {
        t[i] = n[i];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (let j = 0; j < 2; j++) {
        m[0] = t[0] - 65517;
        for (let i = 1; i < 15; i++) {
          m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        const b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (let i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    function verify32(x, y) {
      let d = 0;
      for (let i = 0; i < 32; i++) {
        d |= x[i] ^ y[i];
      }
      return (1 & d - 1 >>> 8) - 1;
    }
    function neq25519(a, b) {
      const c = new Uint8Array(32);
      const d = new Uint8Array(32);
      pack25519(c, a);
      pack25519(d, b);
      return verify32(c, d);
    }
    function par25519(a) {
      const d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    function unpack25519(o, n) {
      for (let i = 0; i < 16; i++) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      }
      o[15] &= 32767;
    }
    function add(o, a, b) {
      for (let i = 0; i < 16; i++) {
        o[i] = a[i] + b[i];
      }
    }
    function sub(o, a, b) {
      for (let i = 0; i < 16; i++) {
        o[i] = a[i] - b[i];
      }
    }
    function mul(o, a, b) {
      let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function square(o, a) {
      mul(o, a, a);
    }
    function inv25519(o, i) {
      const c = gf();
      let a;
      for (a = 0; a < 16; a++) {
        c[a] = i[a];
      }
      for (a = 253; a >= 0; a--) {
        square(c, c);
        if (a !== 2 && a !== 4) {
          mul(c, c, i);
        }
      }
      for (a = 0; a < 16; a++) {
        o[a] = c[a];
      }
    }
    function pow2523(o, i) {
      const c = gf();
      let a;
      for (a = 0; a < 16; a++) {
        c[a] = i[a];
      }
      for (a = 250; a >= 0; a--) {
        square(c, c);
        if (a !== 1) {
          mul(c, c, i);
        }
      }
      for (a = 0; a < 16; a++) {
        o[a] = c[a];
      }
    }
    function edadd(p, q) {
      const a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f2 = gf(), g = gf(), h = gf(), t = gf();
      sub(a, p[1], p[0]);
      sub(t, q[1], q[0]);
      mul(a, a, t);
      add(b, p[0], p[1]);
      add(t, q[0], q[1]);
      mul(b, b, t);
      mul(c, p[3], q[3]);
      mul(c, c, D2);
      mul(d, p[2], q[2]);
      add(d, d, d);
      sub(e, b, a);
      sub(f2, d, c);
      add(g, d, c);
      add(h, b, a);
      mul(p[0], e, f2);
      mul(p[1], h, g);
      mul(p[2], g, f2);
      mul(p[3], e, h);
    }
    function cswap(p, q, b) {
      for (let i = 0; i < 4; i++) {
        sel25519(p[i], q[i], b);
      }
    }
    function pack(r, p) {
      const tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      mul(tx, p[0], zi);
      mul(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p, q, s) {
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (let i = 255; i >= 0; --i) {
        const b = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q, b);
        edadd(q, p);
        edadd(p, p);
        cswap(p, q, b);
      }
    }
    function scalarbase(p, s) {
      const q = [gf(), gf(), gf(), gf()];
      set25519(q[0], X);
      set25519(q[1], Y);
      set25519(q[2], gf1);
      mul(q[3], X, Y);
      scalarmult(p, q, s);
    }
    function generateKeyPairFromSeed(seed) {
      if (seed.length !== exports.SEED_LENGTH) {
        throw new Error(`ed25519: seed must be ${exports.SEED_LENGTH} bytes`);
      }
      const d = (0, sha512_1.hash)(seed);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      const publicKey = new Uint8Array(32);
      const p = [gf(), gf(), gf(), gf()];
      scalarbase(p, d);
      pack(publicKey, p);
      const secretKey = new Uint8Array(64);
      secretKey.set(seed);
      secretKey.set(publicKey, 32);
      return {
        publicKey,
        secretKey
      };
    }
    exports.generateKeyPairFromSeed = generateKeyPairFromSeed;
    function generateKeyPair(prng) {
      const seed = (0, random_1.randomBytes)(32, prng);
      const result2 = generateKeyPairFromSeed(seed);
      (0, wipe_1.wipe)(seed);
      return result2;
    }
    exports.generateKeyPair = generateKeyPair;
    function extractPublicKeyFromSecretKey(secretKey) {
      if (secretKey.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`ed25519: secret key must be ${exports.SECRET_KEY_LENGTH} bytes`);
      }
      return new Uint8Array(secretKey.subarray(32));
    }
    exports.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;
    var L = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    function modL(r, x) {
      let carry;
      let i;
      let j;
      let k;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12; j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = Math.floor((x[j] + 128) / 256);
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0; j < 32; j++) {
        x[j] -= carry * L[j];
      }
      for (i = 0; i < 32; i++) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }
    function reduce(r) {
      const x = new Float64Array(64);
      for (let i = 0; i < 64; i++) {
        x[i] = r[i];
      }
      for (let i = 0; i < 64; i++) {
        r[i] = 0;
      }
      modL(r, x);
    }
    function sign(secretKey, message) {
      const x = new Float64Array(64);
      const p = [gf(), gf(), gf(), gf()];
      const d = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      const signature = new Uint8Array(64);
      signature.set(d.subarray(32), 32);
      const hs = new sha512_1.SHA512();
      hs.update(signature.subarray(32));
      hs.update(message);
      const r = hs.digest();
      hs.clean();
      reduce(r);
      scalarbase(p, r);
      pack(signature, p);
      hs.reset();
      hs.update(signature.subarray(0, 32));
      hs.update(secretKey.subarray(32));
      hs.update(message);
      const h = hs.digest();
      reduce(h);
      for (let i = 0; i < 32; i++) {
        x[i] = r[i];
      }
      for (let i = 0; i < 32; i++) {
        for (let j = 0; j < 32; j++) {
          x[i + j] += h[i] * d[j];
        }
      }
      modL(signature.subarray(32), x);
      return signature;
    }
    exports.sign = sign;
    function unpackneg(r, p) {
      const t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p);
      square(num, r[1]);
      mul(den, num, D);
      sub(num, num, r[2]);
      add(den, r[2], den);
      square(den2, den);
      square(den4, den2);
      mul(den6, den4, den2);
      mul(t, den6, num);
      mul(t, t, den);
      pow2523(t, t);
      mul(t, t, num);
      mul(t, t, den);
      mul(t, t, den);
      mul(r[0], t, den);
      square(chk, r[0]);
      mul(chk, chk, den);
      if (neq25519(chk, num)) {
        mul(r[0], r[0], I);
      }
      square(chk, r[0]);
      mul(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r[0]) === p[31] >> 7) {
        sub(r[0], gf0, r[0]);
      }
      mul(r[3], r[0], r[1]);
      return 0;
    }
    function verify(publicKey, message, signature) {
      const t = new Uint8Array(32);
      const p = [gf(), gf(), gf(), gf()];
      const q = [gf(), gf(), gf(), gf()];
      if (signature.length !== exports.SIGNATURE_LENGTH) {
        throw new Error(`ed25519: signature must be ${exports.SIGNATURE_LENGTH} bytes`);
      }
      if (unpackneg(q, publicKey)) {
        return false;
      }
      const hs = new sha512_1.SHA512();
      hs.update(signature.subarray(0, 32));
      hs.update(publicKey);
      hs.update(message);
      const h = hs.digest();
      reduce(h);
      scalarmult(p, q, h);
      scalarbase(q, signature.subarray(32));
      edadd(p, q);
      pack(t, p);
      if (verify32(signature, t)) {
        return false;
      }
      return true;
    }
    exports.verify = verify;
    function convertPublicKeyToX25519(publicKey) {
      let q = [gf(), gf(), gf(), gf()];
      if (unpackneg(q, publicKey)) {
        throw new Error("Ed25519: invalid public key");
      }
      let a = gf();
      let b = gf();
      let y = q[1];
      add(a, gf1, y);
      sub(b, gf1, y);
      inv25519(b, b);
      mul(a, a, b);
      let z = new Uint8Array(32);
      pack25519(z, a);
      return z;
    }
    exports.convertPublicKeyToX25519 = convertPublicKeyToX25519;
    function convertSecretKeyToX25519(secretKey) {
      const d = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      const o = new Uint8Array(d.subarray(0, 32));
      (0, wipe_1.wipe)(d);
      return o;
    }
    exports.convertSecretKeyToX25519 = convertSecretKeyToX25519;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/key-type/ed25519.js
var require_ed255192 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/key-type/ed25519.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertPublicKeyToX25519 = exports.keyDidEd25519 = exports.getEd25519VerificationMethod = exports.VERIFICATION_METHOD_TYPE_ED25519_VERIFICATION_KEY_2020 = exports.VERIFICATION_METHOD_TYPE_ED25519_VERIFICATION_KEY_2018 = void 0;
    var ed25519_1 = require_ed25519();
    Object.defineProperty(exports, "convertPublicKeyToX25519", { enumerable: true, get: function() {
      return ed25519_1.convertPublicKeyToX25519;
    } });
    var crypto_1 = require_crypto();
    var Key_1 = require_Key();
    exports.VERIFICATION_METHOD_TYPE_ED25519_VERIFICATION_KEY_2018 = "Ed25519VerificationKey2018";
    exports.VERIFICATION_METHOD_TYPE_ED25519_VERIFICATION_KEY_2020 = "Ed25519VerificationKey2020";
    function getEd25519VerificationMethod({ key, id, controller }) {
      return {
        id,
        type: exports.VERIFICATION_METHOD_TYPE_ED25519_VERIFICATION_KEY_2018,
        controller,
        publicKeyBase58: key.publicKeyBase58
      };
    }
    exports.getEd25519VerificationMethod = getEd25519VerificationMethod;
    exports.keyDidEd25519 = {
      supportedVerificationMethodTypes: [
        exports.VERIFICATION_METHOD_TYPE_ED25519_VERIFICATION_KEY_2018,
        exports.VERIFICATION_METHOD_TYPE_ED25519_VERIFICATION_KEY_2020
      ],
      getVerificationMethods: (did, key) => [
        getEd25519VerificationMethod({ id: `${did}#${key.fingerprint}`, key, controller: did })
      ],
      getKeyFromVerificationMethod: (verificationMethod) => {
        if (verificationMethod.type === exports.VERIFICATION_METHOD_TYPE_ED25519_VERIFICATION_KEY_2018 && verificationMethod.publicKeyBase58) {
          return Key_1.Key.fromPublicKeyBase58(verificationMethod.publicKeyBase58, crypto_1.KeyType.Ed25519);
        }
        if (verificationMethod.type === exports.VERIFICATION_METHOD_TYPE_ED25519_VERIFICATION_KEY_2020 && verificationMethod.publicKeyMultibase) {
          return Key_1.Key.fromFingerprint(verificationMethod.publicKeyMultibase);
        }
        throw new Error("Invalid verification method passed");
      }
    };
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/key-type/x25519.js
var require_x25519 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/key-type/x25519.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keyDidX25519 = exports.getX25519VerificationMethod = void 0;
    var crypto_1 = require_crypto();
    var Key_1 = require_Key();
    var VERIFICATION_METHOD_TYPE_X25519_KEY_AGREEMENT_KEY_2019 = "X25519KeyAgreementKey2019";
    function getX25519VerificationMethod({ key, id, controller }) {
      return {
        id,
        type: VERIFICATION_METHOD_TYPE_X25519_KEY_AGREEMENT_KEY_2019,
        controller,
        publicKeyBase58: key.publicKeyBase58
      };
    }
    exports.getX25519VerificationMethod = getX25519VerificationMethod;
    exports.keyDidX25519 = {
      supportedVerificationMethodTypes: [VERIFICATION_METHOD_TYPE_X25519_KEY_AGREEMENT_KEY_2019],
      getVerificationMethods: (did, key) => [
        getX25519VerificationMethod({ id: `${did}#${key.fingerprint}`, key, controller: did })
      ],
      getKeyFromVerificationMethod: (verificationMethod) => {
        if (verificationMethod.type !== VERIFICATION_METHOD_TYPE_X25519_KEY_AGREEMENT_KEY_2019 || !verificationMethod.publicKeyBase58) {
          throw new Error("Invalid verification method passed");
        }
        return Key_1.Key.fromPublicKeyBase58(verificationMethod.publicKeyBase58, crypto_1.KeyType.X25519);
      }
    };
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/key-type/keyDidMapping.js
var require_keyDidMapping = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/key-type/keyDidMapping.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getKeyDidMappingByVerificationMethod = exports.getKeyDidMappingByKeyType = void 0;
    var crypto_1 = require_crypto();
    var bls12381g1_1 = require_bls12381g1();
    var bls12381g1g2_1 = require_bls12381g1g2();
    var bls12381g2_1 = require_bls12381g2();
    var ed25519_1 = require_ed255192();
    var x25519_1 = require_x25519();
    var keyDidMapping = {
      [crypto_1.KeyType.Ed25519]: ed25519_1.keyDidEd25519,
      [crypto_1.KeyType.X25519]: x25519_1.keyDidX25519,
      [crypto_1.KeyType.Bls12381g1]: bls12381g1_1.keyDidBls12381g1,
      [crypto_1.KeyType.Bls12381g2]: bls12381g2_1.keyDidBls12381g2,
      [crypto_1.KeyType.Bls12381g1g2]: bls12381g1g2_1.keyDidBls12381g1g2
    };
    var verificationMethodKeyDidMapping = Object.values(crypto_1.KeyType).reduce((mapping, keyType) => {
      const supported = keyDidMapping[keyType].supportedVerificationMethodTypes.reduce((accumulator, vMethodKeyType) => Object.assign(Object.assign({}, accumulator), { [vMethodKeyType]: keyDidMapping[keyType] }), {});
      return Object.assign(Object.assign({}, mapping), supported);
    }, {});
    function getKeyDidMappingByKeyType(keyType) {
      const keyDid = keyDidMapping[keyType];
      if (!keyDid) {
        throw new Error(`Unsupported key did from key type '${keyType}'`);
      }
      return keyDid;
    }
    exports.getKeyDidMappingByKeyType = getKeyDidMappingByKeyType;
    function getKeyDidMappingByVerificationMethod(verificationMethod) {
      const keyDid = verificationMethodKeyDidMapping[verificationMethod.type];
      if (!keyDid) {
        throw new Error(`Unsupported key did from verification method type '${verificationMethod.type}'`);
      }
      return keyDid;
    }
    exports.getKeyDidMappingByVerificationMethod = getKeyDidMappingByVerificationMethod;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/key-type/index.js
var require_key_type = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/key-type/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getKeyDidMappingByVerificationMethod = exports.getKeyDidMappingByKeyType = void 0;
    var keyDidMapping_1 = require_keyDidMapping();
    Object.defineProperty(exports, "getKeyDidMappingByKeyType", { enumerable: true, get: function() {
      return keyDidMapping_1.getKeyDidMappingByKeyType;
    } });
    Object.defineProperty(exports, "getKeyDidMappingByVerificationMethod", { enumerable: true, get: function() {
      return keyDidMapping_1.getKeyDidMappingByVerificationMethod;
    } });
    __exportStar(require_bls12381g2(), exports);
    __exportStar(require_bls12381g1(), exports);
    __exportStar(require_bls12381g1g2(), exports);
    __exportStar(require_ed255192(), exports);
    __exportStar(require_x25519(), exports);
  }
});

// node_modules/@aries-framework/core/build/utils/uri.js
var require_uri = __commonJS({
  "node_modules/@aries-framework/core/build/utils/uri.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getProtocolScheme = void 0;
    function getProtocolScheme(url) {
      const [protocolScheme] = url.split(":");
      return protocolScheme;
    }
    exports.getProtocolScheme = getProtocolScheme;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/service/DidDocumentService.js
var require_DidDocumentService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/service/DidDocumentService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidDocumentService = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var uri_1 = require_uri();
    var DidDocumentService = class {
      constructor(options) {
        if (options) {
          this.id = options.id;
          this.serviceEndpoint = options.serviceEndpoint;
          this.type = options.type;
        }
      }
      get protocolScheme() {
        return (0, uri_1.getProtocolScheme)(this.serviceEndpoint);
      }
    };
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], DidDocumentService.prototype, "id", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], DidDocumentService.prototype, "serviceEndpoint", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], DidDocumentService.prototype, "type", void 0);
    exports.DidDocumentService = DidDocumentService;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/service/DidCommV1Service.js
var require_DidCommV1Service = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/service/DidCommV1Service.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidCommV1Service = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var DidDocumentService_1 = require_DidDocumentService();
    var DidCommV1Service = class extends DidDocumentService_1.DidDocumentService {
      constructor(options) {
        super(Object.assign(Object.assign({}, options), { type: DidCommV1Service.type }));
        this.priority = 0;
        if (options) {
          this.recipientKeys = options.recipientKeys;
          this.routingKeys = options.routingKeys;
          this.accept = options.accept;
          if (options.priority)
            this.priority = options.priority;
        }
      }
    };
    DidCommV1Service.type = "did-communication";
    __decorate([
      (0, class_validator_1.ArrayNotEmpty)(),
      (0, class_validator_1.IsString)({ each: true }),
      __metadata("design:type", Array)
    ], DidCommV1Service.prototype, "recipientKeys", void 0);
    __decorate([
      (0, class_validator_1.IsString)({ each: true }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], DidCommV1Service.prototype, "routingKeys", void 0);
    __decorate([
      (0, class_validator_1.IsString)({ each: true }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], DidCommV1Service.prototype, "accept", void 0);
    exports.DidCommV1Service = DidCommV1Service;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/service/DidCommV2Service.js
var require_DidCommV2Service = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/service/DidCommV2Service.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidCommV2Service = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var DidDocumentService_1 = require_DidDocumentService();
    var DidCommV2Service = class extends DidDocumentService_1.DidDocumentService {
      constructor(options) {
        super(Object.assign(Object.assign({}, options), { type: DidCommV2Service.type }));
        if (options) {
          this.routingKeys = options.routingKeys;
          this.accept = options.accept;
        }
      }
    };
    DidCommV2Service.type = "DIDComm";
    __decorate([
      (0, class_validator_1.IsString)({ each: true }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], DidCommV2Service.prototype, "routingKeys", void 0);
    __decorate([
      (0, class_validator_1.IsString)({ each: true }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], DidCommV2Service.prototype, "accept", void 0);
    exports.DidCommV2Service = DidCommV2Service;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/service/IndyAgentService.js
var require_IndyAgentService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/service/IndyAgentService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyAgentService = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var DidDocumentService_1 = require_DidDocumentService();
    var IndyAgentService = class extends DidDocumentService_1.DidDocumentService {
      constructor(options) {
        super(Object.assign(Object.assign({}, options), { type: IndyAgentService.type }));
        this.priority = 0;
        if (options) {
          this.recipientKeys = options.recipientKeys;
          this.routingKeys = options.routingKeys;
          if (options.priority)
            this.priority = options.priority;
        }
      }
    };
    IndyAgentService.type = "IndyAgent";
    __decorate([
      (0, class_validator_1.ArrayNotEmpty)(),
      (0, class_validator_1.IsString)({ each: true }),
      __metadata("design:type", Array)
    ], IndyAgentService.prototype, "recipientKeys", void 0);
    __decorate([
      (0, class_validator_1.IsString)({ each: true }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], IndyAgentService.prototype, "routingKeys", void 0);
    exports.IndyAgentService = IndyAgentService;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/service/ServiceTransformer.js
var require_ServiceTransformer = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/service/ServiceTransformer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServiceTransformer = exports.serviceTypes = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var DidCommV1Service_1 = require_DidCommV1Service();
    var DidCommV2Service_1 = require_DidCommV2Service();
    var DidDocumentService_1 = require_DidDocumentService();
    var IndyAgentService_1 = require_IndyAgentService();
    exports.serviceTypes = {
      [IndyAgentService_1.IndyAgentService.type]: IndyAgentService_1.IndyAgentService,
      [DidCommV1Service_1.DidCommV1Service.type]: DidCommV1Service_1.DidCommV1Service,
      [DidCommV2Service_1.DidCommV2Service.type]: DidCommV2Service_1.DidCommV2Service
    };
    function ServiceTransformer() {
      return (0, class_transformer_1.Transform)(({ value }) => {
        return value === null || value === void 0 ? void 0 : value.map((serviceJson) => {
          var _a;
          const serviceClass = (_a = exports.serviceTypes[serviceJson.type]) !== null && _a !== void 0 ? _a : DidDocumentService_1.DidDocumentService;
          const service = (0, class_transformer_1.plainToInstance)(serviceClass, serviceJson);
          return service;
        });
      }, {
        toClassOnly: true
      });
    }
    exports.ServiceTransformer = ServiceTransformer;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/service/index.js
var require_service = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/service/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serviceTypes = exports.ServiceTransformer = exports.DidCommV2Service = exports.DidDocumentService = exports.DidCommV1Service = exports.IndyAgentService = void 0;
    var DidCommV1Service_1 = require_DidCommV1Service();
    Object.defineProperty(exports, "DidCommV1Service", { enumerable: true, get: function() {
      return DidCommV1Service_1.DidCommV1Service;
    } });
    var DidCommV2Service_1 = require_DidCommV2Service();
    Object.defineProperty(exports, "DidCommV2Service", { enumerable: true, get: function() {
      return DidCommV2Service_1.DidCommV2Service;
    } });
    var DidDocumentService_1 = require_DidDocumentService();
    Object.defineProperty(exports, "DidDocumentService", { enumerable: true, get: function() {
      return DidDocumentService_1.DidDocumentService;
    } });
    var IndyAgentService_1 = require_IndyAgentService();
    Object.defineProperty(exports, "IndyAgentService", { enumerable: true, get: function() {
      return IndyAgentService_1.IndyAgentService;
    } });
    var ServiceTransformer_1 = require_ServiceTransformer();
    Object.defineProperty(exports, "ServiceTransformer", { enumerable: true, get: function() {
      return ServiceTransformer_1.ServiceTransformer;
    } });
    Object.defineProperty(exports, "serviceTypes", { enumerable: true, get: function() {
      return ServiceTransformer_1.serviceTypes;
    } });
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/verificationMethod/VerificationMethod.js
var require_VerificationMethod = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/verificationMethod/VerificationMethod.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VerificationMethod = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var VerificationMethod = class {
      constructor(options) {
        if (options) {
          this.id = options.id;
          this.type = options.type;
          this.controller = options.controller;
          this.publicKeyBase58 = options.publicKeyBase58;
          this.publicKeyBase64 = options.publicKeyBase64;
          this.publicKeyJwk = options.publicKeyJwk;
          this.publicKeyHex = options.publicKeyHex;
          this.publicKeyMultibase = options.publicKeyMultibase;
          this.publicKeyPem = options.publicKeyPem;
          this.blockchainAccountId = options.blockchainAccountId;
          this.ethereumAddress = options.ethereumAddress;
        }
      }
    };
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], VerificationMethod.prototype, "id", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], VerificationMethod.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], VerificationMethod.prototype, "controller", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], VerificationMethod.prototype, "publicKeyBase58", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], VerificationMethod.prototype, "publicKeyBase64", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], VerificationMethod.prototype, "publicKeyHex", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], VerificationMethod.prototype, "publicKeyMultibase", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], VerificationMethod.prototype, "publicKeyPem", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], VerificationMethod.prototype, "blockchainAccountId", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], VerificationMethod.prototype, "ethereumAddress", void 0);
    exports.VerificationMethod = VerificationMethod;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/verificationMethod/VerificationMethodTransformer.js
var require_VerificationMethodTransformer = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/verificationMethod/VerificationMethodTransformer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VerificationMethodTransformer = exports.IsStringOrVerificationMethod = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var JsonTransformer_1 = require_JsonTransformer();
    var VerificationMethod_1 = require_VerificationMethod();
    function IsStringOrVerificationMethod(validationOptions) {
      return (0, class_validator_1.ValidateBy)({
        name: "isStringOrVerificationMethod",
        validator: {
          validate: (value) => (0, class_validator_1.isString)(value) || (0, class_validator_1.isInstance)(value, VerificationMethod_1.VerificationMethod),
          defaultMessage: (0, class_validator_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a string or instance of VerificationMethod", validationOptions)
        }
      }, validationOptions);
    }
    exports.IsStringOrVerificationMethod = IsStringOrVerificationMethod;
    function VerificationMethodTransformer() {
      return (0, class_transformer_1.Transform)(({ value, type }) => {
        if (type === class_transformer_1.TransformationType.PLAIN_TO_CLASS) {
          return value === null || value === void 0 ? void 0 : value.map((auth) => {
            if (typeof auth === "string") {
              return String(auth);
            }
            return JsonTransformer_1.JsonTransformer.fromJSON(auth, VerificationMethod_1.VerificationMethod);
          });
        } else if (type === class_transformer_1.TransformationType.CLASS_TO_PLAIN) {
          return value === null || value === void 0 ? void 0 : value.map((auth) => typeof auth === "string" ? auth : JsonTransformer_1.JsonTransformer.toJSON(auth));
        }
        return value;
      });
    }
    exports.VerificationMethodTransformer = VerificationMethodTransformer;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/verificationMethod/index.js
var require_verificationMethod = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/verificationMethod/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsStringOrVerificationMethod = exports.VerificationMethodTransformer = exports.VerificationMethod = void 0;
    var VerificationMethod_1 = require_VerificationMethod();
    Object.defineProperty(exports, "VerificationMethod", { enumerable: true, get: function() {
      return VerificationMethod_1.VerificationMethod;
    } });
    var VerificationMethodTransformer_1 = require_VerificationMethodTransformer();
    Object.defineProperty(exports, "VerificationMethodTransformer", { enumerable: true, get: function() {
      return VerificationMethodTransformer_1.VerificationMethodTransformer;
    } });
    Object.defineProperty(exports, "IsStringOrVerificationMethod", { enumerable: true, get: function() {
      return VerificationMethodTransformer_1.IsStringOrVerificationMethod;
    } });
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/DidDocument.js
var require_DidDocument = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/DidDocument.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __asyncValues = exports && exports.__asyncValues || function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findVerificationMethodByKeyType = exports.keyReferenceToKey = exports.DidDocument = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var crypto_1 = require_crypto();
    var JsonTransformer_1 = require_JsonTransformer();
    var transformers_1 = require_transformers();
    var key_type_1 = require_key_type();
    var service_1 = require_service();
    var verificationMethod_1 = require_verificationMethod();
    var DidDocument = class {
      constructor(options) {
        var _a;
        this.context = ["https://w3id.org/did/v1"];
        if (options) {
          this.context = (_a = options.context) !== null && _a !== void 0 ? _a : this.context;
          this.id = options.id;
          this.alsoKnownAs = options.alsoKnownAs;
          this.controller = options.controller;
          this.verificationMethod = options.verificationMethod;
          this.service = options.service;
          this.authentication = options.authentication;
          this.assertionMethod = options.assertionMethod;
          this.keyAgreement = options.keyAgreement;
          this.capabilityInvocation = options.capabilityInvocation;
          this.capabilityDelegation = options.capabilityDelegation;
        }
      }
      dereferenceVerificationMethod(keyId) {
        var _a;
        const verificationMethod = (_a = this.verificationMethod) === null || _a === void 0 ? void 0 : _a.find((key) => key.id.endsWith(keyId));
        if (!verificationMethod) {
          throw new Error(`Unable to locate verification method with id '${keyId}'`);
        }
        return verificationMethod;
      }
      dereferenceKey(keyId, allowedPurposes) {
        var _a;
        const allPurposes = [
          "authentication",
          "keyAgreement",
          "assertionMethod",
          "capabilityInvocation",
          "capabilityDelegation"
        ];
        const purposes = allowedPurposes !== null && allowedPurposes !== void 0 ? allowedPurposes : allPurposes;
        for (const purpose of purposes) {
          for (const key of (_a = this[purpose]) !== null && _a !== void 0 ? _a : []) {
            if (typeof key === "string" && key.endsWith(keyId)) {
              return this.dereferenceVerificationMethod(key);
            } else if (typeof key !== "string" && key.id.endsWith(keyId)) {
              return key;
            }
          }
        }
        throw new Error(`Unable to locate verification method with id '${keyId}' in purposes ${purposes}`);
      }
      /**
       * Returns all of the service endpoints matching the given type.
       *
       * @param type The type of service(s) to query.
       */
      getServicesByType(type) {
        var _a, _b;
        return (_b = (_a = this.service) === null || _a === void 0 ? void 0 : _a.filter((service) => service.type === type)) !== null && _b !== void 0 ? _b : [];
      }
      /**
       * Returns all of the service endpoints matching the given class
       *
       * @param classType The class to query services.
       */
      getServicesByClassType(classType) {
        var _a, _b;
        return (_b = (_a = this.service) === null || _a === void 0 ? void 0 : _a.filter((service) => service instanceof classType)) !== null && _b !== void 0 ? _b : [];
      }
      /**
       * Get all DIDComm services ordered by priority descending. This means the highest
       * priority will be the first entry.
       */
      get didCommServices() {
        var _a, _b;
        const didCommServiceTypes = [service_1.IndyAgentService.type, service_1.DidCommV1Service.type];
        const services = (_b = (_a = this.service) === null || _a === void 0 ? void 0 : _a.filter((service) => didCommServiceTypes.includes(service.type))) !== null && _b !== void 0 ? _b : [];
        return services.sort((a, b) => b.priority - a.priority);
      }
      // TODO: it would probably be easier if we add a utility to each service so we don't have to handle logic for all service types here
      get recipientKeys() {
        let recipientKeys = [];
        for (const service of this.didCommServices) {
          if (service instanceof service_1.IndyAgentService) {
            recipientKeys = [
              ...recipientKeys,
              ...service.recipientKeys.map((publicKeyBase58) => crypto_1.Key.fromPublicKeyBase58(publicKeyBase58, crypto_1.KeyType.Ed25519))
            ];
          } else if (service instanceof service_1.DidCommV1Service) {
            recipientKeys = [
              ...recipientKeys,
              ...service.recipientKeys.map((recipientKey) => keyReferenceToKey(this, recipientKey))
            ];
          }
        }
        return recipientKeys;
      }
      toJSON() {
        return JsonTransformer_1.JsonTransformer.toJSON(this);
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "@context" }),
      (0, transformers_1.IsStringOrStringArray)(),
      __metadata("design:type", Object)
    ], DidDocument.prototype, "context", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], DidDocument.prototype, "id", void 0);
    __decorate([
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.IsString)({ each: true }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], DidDocument.prototype, "alsoKnownAs", void 0);
    __decorate([
      (0, transformers_1.IsStringOrStringArray)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Object)
    ], DidDocument.prototype, "controller", void 0);
    __decorate([
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)({ each: true }),
      (0, class_transformer_1.Type)(() => verificationMethod_1.VerificationMethod),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], DidDocument.prototype, "verificationMethod", void 0);
    __decorate([
      (0, class_validator_1.IsArray)(),
      (0, service_1.ServiceTransformer)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], DidDocument.prototype, "service", void 0);
    __decorate([
      (0, class_validator_1.IsArray)(),
      (0, verificationMethod_1.VerificationMethodTransformer)(),
      (0, verificationMethod_1.IsStringOrVerificationMethod)({ each: true }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], DidDocument.prototype, "authentication", void 0);
    __decorate([
      (0, class_validator_1.IsArray)(),
      (0, verificationMethod_1.VerificationMethodTransformer)(),
      (0, verificationMethod_1.IsStringOrVerificationMethod)({ each: true }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], DidDocument.prototype, "assertionMethod", void 0);
    __decorate([
      (0, class_validator_1.IsArray)(),
      (0, verificationMethod_1.VerificationMethodTransformer)(),
      (0, verificationMethod_1.IsStringOrVerificationMethod)({ each: true }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], DidDocument.prototype, "keyAgreement", void 0);
    __decorate([
      (0, class_validator_1.IsArray)(),
      (0, verificationMethod_1.VerificationMethodTransformer)(),
      (0, verificationMethod_1.IsStringOrVerificationMethod)({ each: true }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], DidDocument.prototype, "capabilityInvocation", void 0);
    __decorate([
      (0, class_validator_1.IsArray)(),
      (0, verificationMethod_1.VerificationMethodTransformer)(),
      (0, verificationMethod_1.IsStringOrVerificationMethod)({ each: true }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], DidDocument.prototype, "capabilityDelegation", void 0);
    exports.DidDocument = DidDocument;
    function keyReferenceToKey(didDocument, keyId) {
      const verificationMethod = didDocument.dereferenceKey(keyId, ["authentication", "keyAgreement"]);
      const { getKeyFromVerificationMethod } = (0, key_type_1.getKeyDidMappingByVerificationMethod)(verificationMethod);
      const key = getKeyFromVerificationMethod(verificationMethod);
      return key;
    }
    exports.keyReferenceToKey = keyReferenceToKey;
    async function findVerificationMethodByKeyType(keyType, didDocument) {
      var _a, e_1, _b, _c, _d, e_2, _e, _f;
      const didVerificationMethods = [
        "verificationMethod",
        "authentication",
        "keyAgreement",
        "assertionMethod",
        "capabilityInvocation",
        "capabilityDelegation"
      ];
      try {
        for (var _g = true, didVerificationMethods_1 = __asyncValues(didVerificationMethods), didVerificationMethods_1_1; didVerificationMethods_1_1 = await didVerificationMethods_1.next(), _a = didVerificationMethods_1_1.done, !_a; ) {
          _c = didVerificationMethods_1_1.value;
          _g = false;
          try {
            const purpose = _c;
            const key = didDocument[purpose];
            if (key instanceof Array) {
              try {
                for (var _h = true, key_1 = (e_2 = void 0, __asyncValues(key)), key_1_1; key_1_1 = await key_1.next(), _d = key_1_1.done, !_d; ) {
                  _f = key_1_1.value;
                  _h = false;
                  try {
                    const method = _f;
                    if (typeof method !== "string") {
                      if (method.type === keyType) {
                        return method;
                      }
                    }
                  } finally {
                    _h = true;
                  }
                }
              } catch (e_2_1) {
                e_2 = { error: e_2_1 };
              } finally {
                try {
                  if (!_h && !_d && (_e = key_1.return))
                    await _e.call(key_1);
                } finally {
                  if (e_2)
                    throw e_2.error;
                }
              }
            }
          } finally {
            _g = true;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_g && !_a && (_b = didVerificationMethods_1.return))
            await _b.call(didVerificationMethods_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return null;
    }
    exports.findVerificationMethodByKeyType = findVerificationMethodByKeyType;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/DidDocumentBuilder.js
var require_DidDocumentBuilder = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/DidDocumentBuilder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidDocumentBuilder = void 0;
    var DidDocument_1 = require_DidDocument();
    var verificationMethod_1 = require_verificationMethod();
    var DidDocumentBuilder = class {
      constructor(id) {
        this.didDocument = new DidDocument_1.DidDocument({
          id
        });
      }
      addContext(context2) {
        if (typeof this.didDocument.context === "string") {
          this.didDocument.context = [this.didDocument.context, context2];
        } else {
          this.didDocument.context.push(context2);
        }
        return this;
      }
      addService(service) {
        if (!this.didDocument.service) {
          this.didDocument.service = [];
        }
        this.didDocument.service.push(service);
        return this;
      }
      addVerificationMethod(verificationMethod) {
        if (!this.didDocument.verificationMethod) {
          this.didDocument.verificationMethod = [];
        }
        this.didDocument.verificationMethod.push(verificationMethod instanceof verificationMethod_1.VerificationMethod ? verificationMethod : new verificationMethod_1.VerificationMethod(verificationMethod));
        return this;
      }
      addAuthentication(authentication) {
        if (!this.didDocument.authentication) {
          this.didDocument.authentication = [];
        }
        const verificationMethod = authentication instanceof verificationMethod_1.VerificationMethod || typeof authentication === "string" ? authentication : new verificationMethod_1.VerificationMethod(authentication);
        this.didDocument.authentication.push(verificationMethod);
        return this;
      }
      addAssertionMethod(assertionMethod) {
        if (!this.didDocument.assertionMethod) {
          this.didDocument.assertionMethod = [];
        }
        const verificationMethod = assertionMethod instanceof verificationMethod_1.VerificationMethod || typeof assertionMethod === "string" ? assertionMethod : new verificationMethod_1.VerificationMethod(assertionMethod);
        this.didDocument.assertionMethod.push(verificationMethod);
        return this;
      }
      addCapabilityDelegation(capabilityDelegation) {
        if (!this.didDocument.capabilityDelegation) {
          this.didDocument.capabilityDelegation = [];
        }
        const verificationMethod = capabilityDelegation instanceof verificationMethod_1.VerificationMethod || typeof capabilityDelegation === "string" ? capabilityDelegation : new verificationMethod_1.VerificationMethod(capabilityDelegation);
        this.didDocument.capabilityDelegation.push(verificationMethod);
        return this;
      }
      addCapabilityInvocation(capabilityInvocation) {
        if (!this.didDocument.capabilityInvocation) {
          this.didDocument.capabilityInvocation = [];
        }
        const verificationMethod = capabilityInvocation instanceof verificationMethod_1.VerificationMethod || typeof capabilityInvocation === "string" ? capabilityInvocation : new verificationMethod_1.VerificationMethod(capabilityInvocation);
        this.didDocument.capabilityInvocation.push(verificationMethod);
        return this;
      }
      addKeyAgreement(keyAgreement) {
        if (!this.didDocument.keyAgreement) {
          this.didDocument.keyAgreement = [];
        }
        const verificationMethod = keyAgreement instanceof verificationMethod_1.VerificationMethod || typeof keyAgreement === "string" ? keyAgreement : new verificationMethod_1.VerificationMethod(keyAgreement);
        this.didDocument.keyAgreement.push(verificationMethod);
        return this;
      }
      build() {
        return this.didDocument;
      }
    };
    exports.DidDocumentBuilder = DidDocumentBuilder;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/keyDidDocument.js
var require_keyDidDocument = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/keyDidDocument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDidDocumentForKey = void 0;
    var crypto_1 = require_crypto();
    var constants_1 = require_constants2();
    var constants_2 = require_constants3();
    var DidDocumentBuilder_1 = require_DidDocumentBuilder();
    var bls12381g1_1 = require_bls12381g1();
    var bls12381g1g2_1 = require_bls12381g1g2();
    var bls12381g2_1 = require_bls12381g2();
    var ed25519_1 = require_ed255192();
    var x25519_1 = require_x25519();
    var didDocumentKeyTypeMapping = {
      [crypto_1.KeyType.Ed25519]: getEd25519DidDoc,
      [crypto_1.KeyType.X25519]: getX25519DidDoc,
      [crypto_1.KeyType.Bls12381g1]: getBls12381g1DidDoc,
      [crypto_1.KeyType.Bls12381g2]: getBls12381g2DidDoc,
      [crypto_1.KeyType.Bls12381g1g2]: getBls12381g1g2DidDoc
    };
    function getDidDocumentForKey(did, key) {
      const getDidDocument = didDocumentKeyTypeMapping[key.keyType];
      return getDidDocument(did, key);
    }
    exports.getDidDocumentForKey = getDidDocumentForKey;
    function getBls12381g1DidDoc(did, key) {
      const verificationMethod = (0, bls12381g1_1.getBls12381g1VerificationMethod)(did, key);
      return getSignatureKeyBase({
        did,
        key,
        verificationMethod
      }).addContext(constants_1.SECURITY_CONTEXT_BBS_URL).build();
    }
    function getBls12381g1g2DidDoc(did, key) {
      const verificationMethods = (0, bls12381g1g2_1.getBls12381g1g2VerificationMethod)(did, key);
      const didDocumentBuilder = new DidDocumentBuilder_1.DidDocumentBuilder(did);
      for (const verificationMethod of verificationMethods) {
        didDocumentBuilder.addVerificationMethod(verificationMethod).addAuthentication(verificationMethod.id).addAssertionMethod(verificationMethod.id).addCapabilityDelegation(verificationMethod.id).addCapabilityInvocation(verificationMethod.id);
      }
      return didDocumentBuilder.addContext(constants_1.SECURITY_CONTEXT_BBS_URL).build();
    }
    function getEd25519DidDoc(did, key) {
      const verificationMethod = (0, ed25519_1.getEd25519VerificationMethod)({ id: `${did}#${key.fingerprint}`, key, controller: did });
      const publicKeyX25519 = (0, ed25519_1.convertPublicKeyToX25519)(key.publicKey);
      const didKeyX25519 = crypto_1.Key.fromPublicKey(publicKeyX25519, crypto_1.KeyType.X25519);
      const x25519VerificationMethod = (0, x25519_1.getX25519VerificationMethod)({
        id: `${did}#${didKeyX25519.fingerprint}`,
        key: didKeyX25519,
        controller: did
      });
      const didDocBuilder = getSignatureKeyBase({ did, key, verificationMethod });
      didDocBuilder.addContext(constants_2.ED25519_SUITE_CONTEXT_URL_2018).addContext(constants_1.SECURITY_X25519_CONTEXT_URL).addKeyAgreement(x25519VerificationMethod);
      return didDocBuilder.build();
    }
    function getX25519DidDoc(did, key) {
      const verificationMethod = (0, x25519_1.getX25519VerificationMethod)({ id: `${did}#${key.fingerprint}`, key, controller: did });
      const document = new DidDocumentBuilder_1.DidDocumentBuilder(did).addKeyAgreement(verificationMethod).addContext(constants_1.SECURITY_X25519_CONTEXT_URL).build();
      return document;
    }
    function getBls12381g2DidDoc(did, key) {
      const verificationMethod = (0, bls12381g2_1.getBls12381g2VerificationMethod)(did, key);
      return getSignatureKeyBase({
        did,
        key,
        verificationMethod
      }).addContext(constants_1.SECURITY_CONTEXT_BBS_URL).build();
    }
    function getSignatureKeyBase({ did, key, verificationMethod }) {
      const keyId = `${did}#${key.fingerprint}`;
      return new DidDocumentBuilder_1.DidDocumentBuilder(did).addVerificationMethod(verificationMethod).addAuthentication(keyId).addAssertionMethod(keyId).addCapabilityDelegation(keyId).addCapabilityInvocation(keyId);
    }
  }
});

// node_modules/did-resolver/lib/resolver.cjs
var require_resolver = __commonJS({
  "node_modules/did-resolver/lib/resolver.cjs"(exports) {
    function _catch(body, recover) {
      try {
        var result2 = body();
      } catch (e) {
        return recover(e);
      }
      if (result2 && result2.then) {
        return result2.then(void 0, recover);
      }
      return result2;
    }
    function inMemoryCache() {
      const cache = /* @__PURE__ */ new Map();
      return function(parsed, resolve) {
        try {
          let _temp22 = function(_result) {
            if (_exit)
              return _result;
            const cached = cache.get(parsed.didUrl);
            return cached !== void 0 ? cached : Promise.resolve(resolve()).then(function(result2) {
              var _result$didResolution;
              if (((_result$didResolution = result2.didResolutionMetadata) == null ? void 0 : _result$didResolution.error) !== "notFound") {
                cache.set(parsed.didUrl, result2);
              }
              return result2;
            });
          };
          var _temp2 = _temp22;
          let _exit;
          const _temp = function() {
            if (parsed.params && parsed.params["no-cache"] === "true") {
              return Promise.resolve(resolve()).then(function(_await$resolve) {
                _exit = 1;
                return _await$resolve;
              });
            }
          }();
          return Promise.resolve(_temp && _temp.then ? _temp.then(_temp22) : _temp22(_temp));
        } catch (e) {
          return Promise.reject(e);
        }
      };
    }
    function noCache(parsed, resolve) {
      return resolve();
    }
    var PCT_ENCODED = "(?:%[0-9a-fA-F]{2})";
    var ID_CHAR = `(?:[a-zA-Z0-9._-]|${PCT_ENCODED})`;
    var METHOD = "([a-z0-9]+)";
    var METHOD_ID = `((?:${ID_CHAR}*:)*(${ID_CHAR}+))`;
    var PARAM_CHAR = "[a-zA-Z0-9_.:%-]";
    var PARAM = `;${PARAM_CHAR}+=${PARAM_CHAR}*`;
    var PARAMS = `((${PARAM})*)`;
    var PATH = `(/[^#?]*)?`;
    var QUERY = `([?][^#]*)?`;
    var FRAGMENT = `(#.*)?`;
    var DID_MATCHER = new RegExp(`^did:${METHOD}:${METHOD_ID}${PARAMS}${PATH}${QUERY}${FRAGMENT}$`);
    function parse4(didUrl) {
      if (didUrl === "" || !didUrl)
        return null;
      const sections = didUrl.match(DID_MATCHER);
      if (sections) {
        const parts = {
          did: `did:${sections[1]}:${sections[2]}`,
          method: sections[1],
          id: sections[2],
          didUrl
        };
        if (sections[4]) {
          const params = sections[4].slice(1).split(";");
          parts.params = {};
          for (const p of params) {
            const kv = p.split("=");
            parts.params[kv[0]] = kv[1];
          }
        }
        if (sections[6])
          parts.path = sections[6];
        if (sections[7])
          parts.query = sections[7].slice(1);
        if (sections[8])
          parts.fragment = sections[8].slice(1);
        return parts;
      }
      return null;
    }
    var EMPTY_RESULT = {
      didResolutionMetadata: {},
      didDocument: null,
      didDocumentMetadata: {}
    };
    function wrapLegacyResolver(resolve) {
      return function(did, parsed, resolver) {
        try {
          return Promise.resolve(_catch(function() {
            return Promise.resolve(resolve(did, parsed, resolver)).then(function(doc) {
              return {
                ...EMPTY_RESULT,
                didResolutionMetadata: {
                  contentType: "application/did+ld+json"
                },
                didDocument: doc
              };
            });
          }, function(e) {
            return {
              ...EMPTY_RESULT,
              didResolutionMetadata: {
                error: "notFound",
                message: e.toString()
                // This is not in spec, but may be helpful
              }
            };
          }));
        } catch (e) {
          return Promise.reject(e);
        }
      };
    }
    var Resolver = class {
      constructor(registry2 = {}, options = {}) {
        this.registry = void 0;
        this.cache = void 0;
        this.registry = registry2;
        this.cache = options.cache === true ? inMemoryCache() : options.cache || noCache;
        if (options.legacyResolvers) {
          Object.keys(options.legacyResolvers).map((methodName) => {
            if (!this.registry[methodName]) {
              this.registry[methodName] = wrapLegacyResolver(
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                options.legacyResolvers[methodName]
              );
            }
          });
        }
      }
      resolve(didUrl, options = {}) {
        try {
          const _this = this;
          const parsed = parse4(didUrl);
          if (parsed === null) {
            return Promise.resolve({
              ...EMPTY_RESULT,
              didResolutionMetadata: {
                error: "invalidDid"
              }
            });
          }
          const resolver = _this.registry[parsed.method];
          if (!resolver) {
            return Promise.resolve({
              ...EMPTY_RESULT,
              didResolutionMetadata: {
                error: "unsupportedDidMethod"
              }
            });
          }
          return Promise.resolve(_this.cache(parsed, () => resolver(parsed.did, parsed, _this, options)));
        } catch (e) {
          return Promise.reject(e);
        }
      }
    };
    exports.Resolver = Resolver;
    exports.inMemoryCache = inMemoryCache;
    exports.noCache = noCache;
    exports.parse = parse4;
    exports.wrapLegacyResolver = wrapLegacyResolver;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/parse.js
var require_parse = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tryParseDid = exports.parseDid = void 0;
    var did_resolver_1 = require_resolver();
    function parseDid(did) {
      const parsed = tryParseDid(did);
      if (!parsed) {
        throw new Error(`Error parsing did '${did}'`);
      }
      return parsed;
    }
    exports.parseDid = parseDid;
    function tryParseDid(did) {
      return (0, did_resolver_1.parse)(did);
    }
    exports.tryParseDid = tryParseDid;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/methods/key/DidKey.js
var require_DidKey = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/methods/key/DidKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidKey = void 0;
    var Key_1 = require_Key();
    var keyDidDocument_1 = require_keyDidDocument();
    var parse_1 = require_parse();
    var DidKey = class {
      constructor(key) {
        this.key = key;
      }
      static fromDid(did) {
        const parsed = (0, parse_1.parseDid)(did);
        const key = Key_1.Key.fromFingerprint(parsed.id);
        return new DidKey(key);
      }
      get did() {
        return `did:key:${this.key.fingerprint}`;
      }
      get didDocument() {
        return (0, keyDidDocument_1.getDidDocumentForKey)(this.did, this.key);
      }
    };
    exports.DidKey = DidKey;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/DidDocumentRole.js
var require_DidDocumentRole = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/DidDocumentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidDocumentRole = void 0;
    var DidDocumentRole;
    (function(DidDocumentRole2) {
      DidDocumentRole2["Created"] = "created";
      DidDocumentRole2["Received"] = "received";
    })(DidDocumentRole = exports.DidDocumentRole || (exports.DidDocumentRole = {}));
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isFunction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isFunction = void 0;
    function isFunction(value) {
      return typeof value === "function";
    }
    exports.isFunction = isFunction;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js
var require_createErrorClass = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createErrorClass = void 0;
    function createErrorClass(createImpl) {
      var _super = function(instance2) {
        Error.call(instance2);
        instance2.stack = new Error().stack;
      };
      var ctorFunc = createImpl(_super);
      ctorFunc.prototype = Object.create(Error.prototype);
      ctorFunc.prototype.constructor = ctorFunc;
      return ctorFunc;
    }
    exports.createErrorClass = createErrorClass;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js
var require_UnsubscriptionError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnsubscriptionError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.UnsubscriptionError = createErrorClass_1.createErrorClass(function(_super) {
      return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
          return i + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/arrRemove.js
var require_arrRemove = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/arrRemove.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arrRemove = void 0;
    function arrRemove(arr, item) {
      if (arr) {
        var index = arr.indexOf(item);
        0 <= index && arr.splice(index, 1);
      }
    }
    exports.arrRemove = arrRemove;
  }
});

// node_modules/rxjs/dist/cjs/internal/Subscription.js
var require_Subscription = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Subscription.js"(exports) {
    "use strict";
    var __values3 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSubscription = exports.EMPTY_SUBSCRIPTION = exports.Subscription = void 0;
    var isFunction_1 = require_isFunction();
    var UnsubscriptionError_1 = require_UnsubscriptionError();
    var arrRemove_1 = require_arrRemove();
    var Subscription = function() {
      function Subscription2(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
      }
      Subscription2.prototype.unsubscribe = function() {
        var e_1, _a, e_2, _b;
        var errors;
        if (!this.closed) {
          this.closed = true;
          var _parentage = this._parentage;
          if (_parentage) {
            this._parentage = null;
            if (Array.isArray(_parentage)) {
              try {
                for (var _parentage_1 = __values3(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                  var parent_1 = _parentage_1_1.value;
                  parent_1.remove(this);
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                    _a.call(_parentage_1);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
            } else {
              _parentage.remove(this);
            }
          }
          var initialFinalizer = this.initialTeardown;
          if (isFunction_1.isFunction(initialFinalizer)) {
            try {
              initialFinalizer();
            } catch (e) {
              errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
            }
          }
          var _finalizers = this._finalizers;
          if (_finalizers) {
            this._finalizers = null;
            try {
              for (var _finalizers_1 = __values3(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                var finalizer = _finalizers_1_1.value;
                try {
                  execFinalizer(finalizer);
                } catch (err) {
                  errors = errors !== null && errors !== void 0 ? errors : [];
                  if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                    errors = __spreadArray2(__spreadArray2([], __read2(errors)), __read2(err.errors));
                  } else {
                    errors.push(err);
                  }
                }
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                  _b.call(_finalizers_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
          if (errors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
          }
        }
      };
      Subscription2.prototype.add = function(teardown) {
        var _a;
        if (teardown && teardown !== this) {
          if (this.closed) {
            execFinalizer(teardown);
          } else {
            if (teardown instanceof Subscription2) {
              if (teardown.closed || teardown._hasParent(this)) {
                return;
              }
              teardown._addParent(this);
            }
            (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
          }
        }
      };
      Subscription2.prototype._hasParent = function(parent) {
        var _parentage = this._parentage;
        return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
      };
      Subscription2.prototype._addParent = function(parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
      };
      Subscription2.prototype._removeParent = function(parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) {
          this._parentage = null;
        } else if (Array.isArray(_parentage)) {
          arrRemove_1.arrRemove(_parentage, parent);
        }
      };
      Subscription2.prototype.remove = function(teardown) {
        var _finalizers = this._finalizers;
        _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
        if (teardown instanceof Subscription2) {
          teardown._removeParent(this);
        }
      };
      Subscription2.EMPTY = function() {
        var empty = new Subscription2();
        empty.closed = true;
        return empty;
      }();
      return Subscription2;
    }();
    exports.Subscription = Subscription;
    exports.EMPTY_SUBSCRIPTION = Subscription.EMPTY;
    function isSubscription(value) {
      return value instanceof Subscription || value && "closed" in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe);
    }
    exports.isSubscription = isSubscription;
    function execFinalizer(finalizer) {
      if (isFunction_1.isFunction(finalizer)) {
        finalizer();
      } else {
        finalizer.unsubscribe();
      }
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/config.js
var require_config = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.config = void 0;
    exports.config = {
      onUnhandledError: null,
      onStoppedNotification: null,
      Promise: void 0,
      useDeprecatedSynchronousErrorHandling: false,
      useDeprecatedNextContext: false
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js
var require_timeoutProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timeoutProvider = void 0;
    exports.timeoutProvider = {
      setTimeout: function(handler, timeout2) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = exports.timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
          return delegate.setTimeout.apply(delegate, __spreadArray2([handler, timeout2], __read2(args)));
        }
        return setTimeout.apply(void 0, __spreadArray2([handler, timeout2], __read2(args)));
      },
      clearTimeout: function(handle) {
        var delegate = exports.timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js
var require_reportUnhandledError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportUnhandledError = void 0;
    var config_1 = require_config();
    var timeoutProvider_1 = require_timeoutProvider();
    function reportUnhandledError(err) {
      timeoutProvider_1.timeoutProvider.setTimeout(function() {
        var onUnhandledError = config_1.config.onUnhandledError;
        if (onUnhandledError) {
          onUnhandledError(err);
        } else {
          throw err;
        }
      });
    }
    exports.reportUnhandledError = reportUnhandledError;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/noop.js
var require_noop = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/noop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.noop = void 0;
    function noop() {
    }
    exports.noop = noop;
  }
});

// node_modules/rxjs/dist/cjs/internal/NotificationFactories.js
var require_NotificationFactories = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/NotificationFactories.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createNotification = exports.nextNotification = exports.errorNotification = exports.COMPLETE_NOTIFICATION = void 0;
    exports.COMPLETE_NOTIFICATION = function() {
      return createNotification("C", void 0, void 0);
    }();
    function errorNotification(error) {
      return createNotification("E", void 0, error);
    }
    exports.errorNotification = errorNotification;
    function nextNotification(value) {
      return createNotification("N", value, void 0);
    }
    exports.nextNotification = nextNotification;
    function createNotification(kind, value, error) {
      return {
        kind,
        value,
        error
      };
    }
    exports.createNotification = createNotification;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/errorContext.js
var require_errorContext = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/errorContext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.captureError = exports.errorContext = void 0;
    var config_1 = require_config();
    var context2 = null;
    function errorContext(cb) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling) {
        var isRoot = !context2;
        if (isRoot) {
          context2 = { errorThrown: false, error: null };
        }
        cb();
        if (isRoot) {
          var _a = context2, errorThrown = _a.errorThrown, error = _a.error;
          context2 = null;
          if (errorThrown) {
            throw error;
          }
        }
      } else {
        cb();
      }
    }
    exports.errorContext = errorContext;
    function captureError(err) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling && context2) {
        context2.errorThrown = true;
        context2.error = err;
      }
    }
    exports.captureError = captureError;
  }
});

// node_modules/rxjs/dist/cjs/internal/Subscriber.js
var require_Subscriber = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Subscriber.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = void 0;
    var isFunction_1 = require_isFunction();
    var Subscription_1 = require_Subscription();
    var config_1 = require_config();
    var reportUnhandledError_1 = require_reportUnhandledError();
    var noop_1 = require_noop();
    var NotificationFactories_1 = require_NotificationFactories();
    var timeoutProvider_1 = require_timeoutProvider();
    var errorContext_1 = require_errorContext();
    var Subscriber = function(_super) {
      __extends2(Subscriber2, _super);
      function Subscriber2(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
          _this.destination = destination;
          if (Subscription_1.isSubscription(destination)) {
            destination.add(_this);
          }
        } else {
          _this.destination = exports.EMPTY_OBSERVER;
        }
        return _this;
      }
      Subscriber2.create = function(next, error, complete) {
        return new SafeSubscriber(next, error, complete);
      };
      Subscriber2.prototype.next = function(value) {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
        } else {
          this._next(value);
        }
      };
      Subscriber2.prototype.error = function(err) {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
        } else {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber2.prototype.complete = function() {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
        } else {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber2.prototype.unsubscribe = function() {
        if (!this.closed) {
          this.isStopped = true;
          _super.prototype.unsubscribe.call(this);
          this.destination = null;
        }
      };
      Subscriber2.prototype._next = function(value) {
        this.destination.next(value);
      };
      Subscriber2.prototype._error = function(err) {
        try {
          this.destination.error(err);
        } finally {
          this.unsubscribe();
        }
      };
      Subscriber2.prototype._complete = function() {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      };
      return Subscriber2;
    }(Subscription_1.Subscription);
    exports.Subscriber = Subscriber;
    var _bind = Function.prototype.bind;
    function bind(fn, thisArg) {
      return _bind.call(fn, thisArg);
    }
    var ConsumerObserver = function() {
      function ConsumerObserver2(partialObserver) {
        this.partialObserver = partialObserver;
      }
      ConsumerObserver2.prototype.next = function(value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) {
          try {
            partialObserver.next(value);
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      ConsumerObserver2.prototype.error = function(err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) {
          try {
            partialObserver.error(err);
          } catch (error) {
            handleUnhandledError(error);
          }
        } else {
          handleUnhandledError(err);
        }
      };
      ConsumerObserver2.prototype.complete = function() {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) {
          try {
            partialObserver.complete();
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      return ConsumerObserver2;
    }();
    var SafeSubscriber = function(_super) {
      __extends2(SafeSubscriber2, _super);
      function SafeSubscriber2(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
          partialObserver = {
            next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
            error: error !== null && error !== void 0 ? error : void 0,
            complete: complete !== null && complete !== void 0 ? complete : void 0
          };
        } else {
          var context_12;
          if (_this && config_1.config.useDeprecatedNextContext) {
            context_12 = Object.create(observerOrNext);
            context_12.unsubscribe = function() {
              return _this.unsubscribe();
            };
            partialObserver = {
              next: observerOrNext.next && bind(observerOrNext.next, context_12),
              error: observerOrNext.error && bind(observerOrNext.error, context_12),
              complete: observerOrNext.complete && bind(observerOrNext.complete, context_12)
            };
          } else {
            partialObserver = observerOrNext;
          }
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
      }
      return SafeSubscriber2;
    }(Subscriber);
    exports.SafeSubscriber = SafeSubscriber;
    function handleUnhandledError(error) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling) {
        errorContext_1.captureError(error);
      } else {
        reportUnhandledError_1.reportUnhandledError(error);
      }
    }
    function defaultErrorHandler(err) {
      throw err;
    }
    function handleStoppedNotification(notification, subscriber) {
      var onStoppedNotification = config_1.config.onStoppedNotification;
      onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
        return onStoppedNotification(notification, subscriber);
      });
    }
    exports.EMPTY_OBSERVER = {
      closed: true,
      next: noop_1.noop,
      error: defaultErrorHandler,
      complete: noop_1.noop
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/symbol/observable.js
var require_observable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/symbol/observable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observable = void 0;
    exports.observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
  }
});

// node_modules/rxjs/dist/cjs/internal/util/identity.js
var require_identity = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/identity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.identity = void 0;
    function identity(x) {
      return x;
    }
    exports.identity = identity;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/pipe.js
var require_pipe = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/pipe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pipeFromArray = exports.pipe = void 0;
    var identity_1 = require_identity();
    function pipe() {
      var fns = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
      }
      return pipeFromArray(fns);
    }
    exports.pipe = pipe;
    function pipeFromArray(fns) {
      if (fns.length === 0) {
        return identity_1.identity;
      }
      if (fns.length === 1) {
        return fns[0];
      }
      return function piped(input) {
        return fns.reduce(function(prev, fn) {
          return fn(prev);
        }, input);
      };
    }
    exports.pipeFromArray = pipeFromArray;
  }
});

// node_modules/rxjs/dist/cjs/internal/Observable.js
var require_Observable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Observable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Observable = void 0;
    var Subscriber_1 = require_Subscriber();
    var Subscription_1 = require_Subscription();
    var observable_1 = require_observable();
    var pipe_1 = require_pipe();
    var config_1 = require_config();
    var isFunction_1 = require_isFunction();
    var errorContext_1 = require_errorContext();
    var Observable = function() {
      function Observable2(subscribe) {
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      Observable2.prototype.lift = function(operator) {
        var observable = new Observable2();
        observable.source = this;
        observable.operator = operator;
        return observable;
      };
      Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
        var _this = this;
        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error, complete);
        errorContext_1.errorContext(function() {
          var _a = _this, operator = _a.operator, source = _a.source;
          subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
        });
        return subscriber;
      };
      Observable2.prototype._trySubscribe = function(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          sink.error(err);
        }
      };
      Observable2.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var subscriber = new Subscriber_1.SafeSubscriber({
            next: function(value) {
              try {
                next(value);
              } catch (err) {
                reject(err);
                subscriber.unsubscribe();
              }
            },
            error: reject,
            complete: resolve
          });
          _this.subscribe(subscriber);
        });
      };
      Observable2.prototype._subscribe = function(subscriber) {
        var _a;
        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
      };
      Observable2.prototype[observable_1.observable] = function() {
        return this;
      };
      Observable2.prototype.pipe = function() {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operations[_i] = arguments[_i];
        }
        return pipe_1.pipeFromArray(operations)(this);
      };
      Observable2.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var value;
          _this.subscribe(function(x) {
            return value = x;
          }, function(err) {
            return reject(err);
          }, function() {
            return resolve(value);
          });
        });
      };
      Observable2.create = function(subscribe) {
        return new Observable2(subscribe);
      };
      return Observable2;
    }();
    exports.Observable = Observable;
    function getPromiseCtor(promiseCtor) {
      var _a;
      return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a !== void 0 ? _a : Promise;
    }
    function isObserver(value) {
      return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);
    }
    function isSubscriber(value) {
      return value && value instanceof Subscriber_1.Subscriber || isObserver(value) && Subscription_1.isSubscription(value);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/lift.js
var require_lift = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/lift.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.operate = exports.hasLift = void 0;
    var isFunction_1 = require_isFunction();
    function hasLift(source) {
      return isFunction_1.isFunction(source === null || source === void 0 ? void 0 : source.lift);
    }
    exports.hasLift = hasLift;
    function operate(init) {
      return function(source) {
        if (hasLift(source)) {
          return source.lift(function(liftedSource) {
            try {
              return init(liftedSource, this);
            } catch (err) {
              this.error(err);
            }
          });
        }
        throw new TypeError("Unable to lift unknown Observable type");
      };
    }
    exports.operate = operate;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js
var require_OperatorSubscriber = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OperatorSubscriber = exports.createOperatorSubscriber = void 0;
    var Subscriber_1 = require_Subscriber();
    function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
      return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
    }
    exports.createOperatorSubscriber = createOperatorSubscriber;
    var OperatorSubscriber = function(_super) {
      __extends2(OperatorSubscriber2, _super);
      function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this.shouldUnsubscribe = shouldUnsubscribe;
        _this._next = onNext ? function(value) {
          try {
            onNext(value);
          } catch (err) {
            destination.error(err);
          }
        } : _super.prototype._next;
        _this._error = onError ? function(err) {
          try {
            onError(err);
          } catch (err2) {
            destination.error(err2);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._error;
        _this._complete = onComplete ? function() {
          try {
            onComplete();
          } catch (err) {
            destination.error(err);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._complete;
        return _this;
      }
      OperatorSubscriber2.prototype.unsubscribe = function() {
        var _a;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
          var closed_1 = this.closed;
          _super.prototype.unsubscribe.call(this);
          !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
        }
      };
      return OperatorSubscriber2;
    }(Subscriber_1.Subscriber);
    exports.OperatorSubscriber = OperatorSubscriber;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/refCount.js
var require_refCount = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/refCount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.refCount = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function refCount() {
      return lift_1.operate(function(source, subscriber) {
        var connection = null;
        source._refCount++;
        var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
          if (!source || source._refCount <= 0 || 0 < --source._refCount) {
            connection = null;
            return;
          }
          var sharedConnection = source._connection;
          var conn = connection;
          connection = null;
          if (sharedConnection && (!conn || sharedConnection === conn)) {
            sharedConnection.unsubscribe();
          }
          subscriber.unsubscribe();
        });
        source.subscribe(refCounter);
        if (!refCounter.closed) {
          connection = source.connect();
        }
      });
    }
    exports.refCount = refCount;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js
var require_ConnectableObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectableObservable = void 0;
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    var refCount_1 = require_refCount();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var lift_1 = require_lift();
    var ConnectableObservable = function(_super) {
      __extends2(ConnectableObservable2, _super);
      function ConnectableObservable2(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._subject = null;
        _this._refCount = 0;
        _this._connection = null;
        if (lift_1.hasLift(source)) {
          _this.lift = source.lift;
        }
        return _this;
      }
      ConnectableObservable2.prototype._subscribe = function(subscriber) {
        return this.getSubject().subscribe(subscriber);
      };
      ConnectableObservable2.prototype.getSubject = function() {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }
        return this._subject;
      };
      ConnectableObservable2.prototype._teardown = function() {
        this._refCount = 0;
        var _connection = this._connection;
        this._subject = this._connection = null;
        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
      };
      ConnectableObservable2.prototype.connect = function() {
        var _this = this;
        var connection = this._connection;
        if (!connection) {
          connection = this._connection = new Subscription_1.Subscription();
          var subject_1 = this.getSubject();
          connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, void 0, function() {
            _this._teardown();
            subject_1.complete();
          }, function(err) {
            _this._teardown();
            subject_1.error(err);
          }, function() {
            return _this._teardown();
          })));
          if (connection.closed) {
            this._connection = null;
            connection = Subscription_1.Subscription.EMPTY;
          }
        }
        return connection;
      };
      ConnectableObservable2.prototype.refCount = function() {
        return refCount_1.refCount()(this);
      };
      return ConnectableObservable2;
    }(Observable_1.Observable);
    exports.ConnectableObservable = ConnectableObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js
var require_performanceTimestampProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.performanceTimestampProvider = void 0;
    exports.performanceTimestampProvider = {
      now: function() {
        return (exports.performanceTimestampProvider.delegate || performance).now();
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js
var require_animationFrameProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.animationFrameProvider = void 0;
    var Subscription_1 = require_Subscription();
    exports.animationFrameProvider = {
      schedule: function(callback) {
        var request = requestAnimationFrame;
        var cancel = cancelAnimationFrame;
        var delegate = exports.animationFrameProvider.delegate;
        if (delegate) {
          request = delegate.requestAnimationFrame;
          cancel = delegate.cancelAnimationFrame;
        }
        var handle = request(function(timestamp) {
          cancel = void 0;
          callback(timestamp);
        });
        return new Subscription_1.Subscription(function() {
          return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
        });
      },
      requestAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray2([], __read2(args)));
      },
      cancelAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray2([], __read2(args)));
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js
var require_animationFrames = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.animationFrames = void 0;
    var Observable_1 = require_Observable();
    var performanceTimestampProvider_1 = require_performanceTimestampProvider();
    var animationFrameProvider_1 = require_animationFrameProvider();
    function animationFrames(timestampProvider) {
      return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
    }
    exports.animationFrames = animationFrames;
    function animationFramesFactory(timestampProvider) {
      return new Observable_1.Observable(function(subscriber) {
        var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
        var start = provider.now();
        var id = 0;
        var run = function() {
          if (!subscriber.closed) {
            id = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function(timestamp) {
              id = 0;
              var now = provider.now();
              subscriber.next({
                timestamp: timestampProvider ? now : timestamp,
                elapsed: now - start
              });
              run();
            });
          }
        };
        run();
        return function() {
          if (id) {
            animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
          }
        };
      });
    }
    var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
  }
});

// node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js
var require_ObjectUnsubscribedError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ObjectUnsubscribedError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function(_super) {
      return function ObjectUnsubscribedErrorImpl() {
        _super(this);
        this.name = "ObjectUnsubscribedError";
        this.message = "object unsubscribed";
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/Subject.js
var require_Subject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Subject.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __values3 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnonymousSubject = exports.Subject = void 0;
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
    var arrRemove_1 = require_arrRemove();
    var errorContext_1 = require_errorContext();
    var Subject = function(_super) {
      __extends2(Subject2, _super);
      function Subject2() {
        var _this = _super.call(this) || this;
        _this.closed = false;
        _this.currentObservers = null;
        _this.observers = [];
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
      }
      Subject2.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      };
      Subject2.prototype._throwIfClosed = function() {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
      };
      Subject2.prototype.next = function(value) {
        var _this = this;
        errorContext_1.errorContext(function() {
          var e_1, _a;
          _this._throwIfClosed();
          if (!_this.isStopped) {
            if (!_this.currentObservers) {
              _this.currentObservers = Array.from(_this.observers);
            }
            try {
              for (var _b = __values3(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var observer = _c.value;
                observer.next(value);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a = _b.return))
                  _a.call(_b);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }
        });
      };
      Subject2.prototype.error = function(err) {
        var _this = this;
        errorContext_1.errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.hasError = _this.isStopped = true;
            _this.thrownError = err;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().error(err);
            }
          }
        });
      };
      Subject2.prototype.complete = function() {
        var _this = this;
        errorContext_1.errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.isStopped = true;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().complete();
            }
          }
        });
      };
      Subject2.prototype.unsubscribe = function() {
        this.isStopped = this.closed = true;
        this.observers = this.currentObservers = null;
      };
      Object.defineProperty(Subject2.prototype, "observed", {
        get: function() {
          var _a;
          return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
        },
        enumerable: false,
        configurable: true
      });
      Subject2.prototype._trySubscribe = function(subscriber) {
        this._throwIfClosed();
        return _super.prototype._trySubscribe.call(this, subscriber);
      };
      Subject2.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
      };
      Subject2.prototype._innerSubscribe = function(subscriber) {
        var _this = this;
        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
        if (hasError || isStopped) {
          return Subscription_1.EMPTY_SUBSCRIPTION;
        }
        this.currentObservers = null;
        observers.push(subscriber);
        return new Subscription_1.Subscription(function() {
          _this.currentObservers = null;
          arrRemove_1.arrRemove(observers, subscriber);
        });
      };
      Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped) {
          subscriber.complete();
        }
      };
      Subject2.prototype.asObservable = function() {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
      };
      Subject2.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
      };
      return Subject2;
    }(Observable_1.Observable);
    exports.Subject = Subject;
    var AnonymousSubject = function(_super) {
      __extends2(AnonymousSubject2, _super);
      function AnonymousSubject2(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
      }
      AnonymousSubject2.prototype.next = function(value) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
      };
      AnonymousSubject2.prototype.error = function(err) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
      };
      AnonymousSubject2.prototype.complete = function() {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
      };
      AnonymousSubject2.prototype._subscribe = function(subscriber) {
        var _a, _b;
        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1.EMPTY_SUBSCRIPTION;
      };
      return AnonymousSubject2;
    }(Subject);
    exports.AnonymousSubject = AnonymousSubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js
var require_BehaviorSubject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BehaviorSubject = void 0;
    var Subject_1 = require_Subject();
    var BehaviorSubject = function(_super) {
      __extends2(BehaviorSubject2, _super);
      function BehaviorSubject2(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
      }
      Object.defineProperty(BehaviorSubject2.prototype, "value", {
        get: function() {
          return this.getValue();
        },
        enumerable: false,
        configurable: true
      });
      BehaviorSubject2.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        !subscription.closed && subscriber.next(this._value);
        return subscription;
      };
      BehaviorSubject2.prototype.getValue = function() {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
        if (hasError) {
          throw thrownError;
        }
        this._throwIfClosed();
        return _value;
      };
      BehaviorSubject2.prototype.next = function(value) {
        _super.prototype.next.call(this, this._value = value);
      };
      return BehaviorSubject2;
    }(Subject_1.Subject);
    exports.BehaviorSubject = BehaviorSubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js
var require_dateTimestampProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dateTimestampProvider = void 0;
    exports.dateTimestampProvider = {
      now: function() {
        return (exports.dateTimestampProvider.delegate || Date).now();
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/ReplaySubject.js
var require_ReplaySubject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/ReplaySubject.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReplaySubject = void 0;
    var Subject_1 = require_Subject();
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var ReplaySubject = function(_super) {
      __extends2(ReplaySubject2, _super);
      function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
        if (_bufferSize === void 0) {
          _bufferSize = Infinity;
        }
        if (_windowTime === void 0) {
          _windowTime = Infinity;
        }
        if (_timestampProvider === void 0) {
          _timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
        }
        var _this = _super.call(this) || this;
        _this._bufferSize = _bufferSize;
        _this._windowTime = _windowTime;
        _this._timestampProvider = _timestampProvider;
        _this._buffer = [];
        _this._infiniteTimeWindow = true;
        _this._infiniteTimeWindow = _windowTime === Infinity;
        _this._bufferSize = Math.max(1, _bufferSize);
        _this._windowTime = Math.max(1, _windowTime);
        return _this;
      }
      ReplaySubject2.prototype.next = function(value) {
        var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
        if (!isStopped) {
          _buffer.push(value);
          !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
        }
        this._trimBuffer();
        _super.prototype.next.call(this, value);
      };
      ReplaySubject2.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._trimBuffer();
        var subscription = this._innerSubscribe(subscriber);
        var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
        var copy = _buffer.slice();
        for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
          subscriber.next(copy[i]);
        }
        this._checkFinalizedStatuses(subscriber);
        return subscription;
      };
      ReplaySubject2.prototype._trimBuffer = function() {
        var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
        if (!_infiniteTimeWindow) {
          var now = _timestampProvider.now();
          var last = 0;
          for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
            last = i;
          }
          last && _buffer.splice(0, last + 1);
        }
      };
      return ReplaySubject2;
    }(Subject_1.Subject);
    exports.ReplaySubject = ReplaySubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/AsyncSubject.js
var require_AsyncSubject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/AsyncSubject.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncSubject = void 0;
    var Subject_1 = require_Subject();
    var AsyncSubject = function(_super) {
      __extends2(AsyncSubject2, _super);
      function AsyncSubject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._value = null;
        _this._hasValue = false;
        _this._isComplete = false;
        return _this;
      }
      AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped || _isComplete) {
          _hasValue && subscriber.next(_value);
          subscriber.complete();
        }
      };
      AsyncSubject2.prototype.next = function(value) {
        if (!this.isStopped) {
          this._value = value;
          this._hasValue = true;
        }
      };
      AsyncSubject2.prototype.complete = function() {
        var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
        if (!_isComplete) {
          this._isComplete = true;
          _hasValue && _super.prototype.next.call(this, _value);
          _super.prototype.complete.call(this);
        }
      };
      return AsyncSubject2;
    }(Subject_1.Subject);
    exports.AsyncSubject = AsyncSubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/Action.js
var require_Action = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/Action.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Action = void 0;
    var Subscription_1 = require_Subscription();
    var Action = function(_super) {
      __extends2(Action2, _super);
      function Action2(scheduler, work) {
        return _super.call(this) || this;
      }
      Action2.prototype.schedule = function(state, delay3) {
        if (delay3 === void 0) {
          delay3 = 0;
        }
        return this;
      };
      return Action2;
    }(Subscription_1.Subscription);
    exports.Action = Action;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js
var require_intervalProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.intervalProvider = void 0;
    exports.intervalProvider = {
      setInterval: function(handler, timeout2) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = exports.intervalProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
          return delegate.setInterval.apply(delegate, __spreadArray2([handler, timeout2], __read2(args)));
        }
        return setInterval.apply(void 0, __spreadArray2([handler, timeout2], __read2(args)));
      },
      clearInterval: function(handle) {
        var delegate = exports.intervalProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js
var require_AsyncAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncAction = void 0;
    var Action_1 = require_Action();
    var intervalProvider_1 = require_intervalProvider();
    var arrRemove_1 = require_arrRemove();
    var AsyncAction = function(_super) {
      __extends2(AsyncAction2, _super);
      function AsyncAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
      }
      AsyncAction2.prototype.schedule = function(state, delay3) {
        var _a;
        if (delay3 === void 0) {
          delay3 = 0;
        }
        if (this.closed) {
          return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, delay3);
        }
        this.pending = true;
        this.delay = delay3;
        this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay3);
        return this;
      };
      AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay3) {
        if (delay3 === void 0) {
          delay3 = 0;
        }
        return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay3);
      };
      AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay3) {
        if (delay3 === void 0) {
          delay3 = 0;
        }
        if (delay3 != null && this.delay === delay3 && this.pending === false) {
          return id;
        }
        if (id != null) {
          intervalProvider_1.intervalProvider.clearInterval(id);
        }
        return void 0;
      };
      AsyncAction2.prototype.execute = function(state, delay3) {
        if (this.closed) {
          return new Error("executing a cancelled action");
        }
        this.pending = false;
        var error = this._execute(state, delay3);
        if (error) {
          return error;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      };
      AsyncAction2.prototype._execute = function(state, _delay) {
        var errored = false;
        var errorValue;
        try {
          this.work(state);
        } catch (e) {
          errored = true;
          errorValue = e ? e : new Error("Scheduled action threw falsy error");
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      };
      AsyncAction2.prototype.unsubscribe = function() {
        if (!this.closed) {
          var _a = this, id = _a.id, scheduler = _a.scheduler;
          var actions = scheduler.actions;
          this.work = this.state = this.scheduler = null;
          this.pending = false;
          arrRemove_1.arrRemove(actions, this);
          if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
          }
          this.delay = null;
          _super.prototype.unsubscribe.call(this);
        }
      };
      return AsyncAction2;
    }(Action_1.Action);
    exports.AsyncAction = AsyncAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/Immediate.js
var require_Immediate = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/Immediate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TestTools = exports.Immediate = void 0;
    var nextHandle = 1;
    var resolved;
    var activeHandles = {};
    function findAndClearHandle(handle) {
      if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
      }
      return false;
    }
    exports.Immediate = {
      setImmediate: function(cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        if (!resolved) {
          resolved = Promise.resolve();
        }
        resolved.then(function() {
          return findAndClearHandle(handle) && cb();
        });
        return handle;
      },
      clearImmediate: function(handle) {
        findAndClearHandle(handle);
      }
    };
    exports.TestTools = {
      pending: function() {
        return Object.keys(activeHandles).length;
      }
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js
var require_immediateProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.immediateProvider = void 0;
    var Immediate_1 = require_Immediate();
    var setImmediate2 = Immediate_1.Immediate.setImmediate;
    var clearImmediate = Immediate_1.Immediate.clearImmediate;
    exports.immediateProvider = {
      setImmediate: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate2).apply(void 0, __spreadArray2([], __read2(args)));
      },
      clearImmediate: function(handle) {
        var delegate = exports.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js
var require_AsapAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsapAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var immediateProvider_1 = require_immediateProvider();
    var AsapAction = function(_super) {
      __extends2(AsapAction2, _super);
      function AsapAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
        if (delay3 === void 0) {
          delay3 = 0;
        }
        if (delay3 !== null && delay3 > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay3);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
      };
      AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay3) {
        var _a;
        if (delay3 === void 0) {
          delay3 = 0;
        }
        if (delay3 != null ? delay3 > 0 : this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay3);
        }
        var actions = scheduler.actions;
        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
          immediateProvider_1.immediateProvider.clearImmediate(id);
          if (scheduler._scheduled === id) {
            scheduler._scheduled = void 0;
          }
        }
        return void 0;
      };
      return AsapAction2;
    }(AsyncAction_1.AsyncAction);
    exports.AsapAction = AsapAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/Scheduler.js
var require_Scheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Scheduler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Scheduler = void 0;
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var Scheduler = function() {
      function Scheduler2(schedulerActionCtor, now) {
        if (now === void 0) {
          now = Scheduler2.now;
        }
        this.schedulerActionCtor = schedulerActionCtor;
        this.now = now;
      }
      Scheduler2.prototype.schedule = function(work, delay3, state) {
        if (delay3 === void 0) {
          delay3 = 0;
        }
        return new this.schedulerActionCtor(this, work).schedule(state, delay3);
      };
      Scheduler2.now = dateTimestampProvider_1.dateTimestampProvider.now;
      return Scheduler2;
    }();
    exports.Scheduler = Scheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js
var require_AsyncScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncScheduler = void 0;
    var Scheduler_1 = require_Scheduler();
    var AsyncScheduler = function(_super) {
      __extends2(AsyncScheduler2, _super);
      function AsyncScheduler2(SchedulerAction, now) {
        if (now === void 0) {
          now = Scheduler_1.Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, now) || this;
        _this.actions = [];
        _this._active = false;
        return _this;
      }
      AsyncScheduler2.prototype.flush = function(action) {
        var actions = this.actions;
        if (this._active) {
          actions.push(action);
          return;
        }
        var error;
        this._active = true;
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());
        this._active = false;
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsyncScheduler2;
    }(Scheduler_1.Scheduler);
    exports.AsyncScheduler = AsyncScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js
var require_AsapScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsapScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var AsapScheduler = function(_super) {
      __extends2(AsapScheduler2, _super);
      function AsapScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AsapScheduler2.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsapScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.AsapScheduler = AsapScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/asap.js
var require_asap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/asap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.asap = exports.asapScheduler = void 0;
    var AsapAction_1 = require_AsapAction();
    var AsapScheduler_1 = require_AsapScheduler();
    exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
    exports.asap = exports.asapScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/async.js
var require_async = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.async = exports.asyncScheduler = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var AsyncScheduler_1 = require_AsyncScheduler();
    exports.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
    exports.async = exports.asyncScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js
var require_QueueAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueueAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var QueueAction = function(_super) {
      __extends2(QueueAction2, _super);
      function QueueAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      QueueAction2.prototype.schedule = function(state, delay3) {
        if (delay3 === void 0) {
          delay3 = 0;
        }
        if (delay3 > 0) {
          return _super.prototype.schedule.call(this, state, delay3);
        }
        this.delay = delay3;
        this.state = state;
        this.scheduler.flush(this);
        return this;
      };
      QueueAction2.prototype.execute = function(state, delay3) {
        return delay3 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay3) : this._execute(state, delay3);
      };
      QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
        if (delay3 === void 0) {
          delay3 = 0;
        }
        if (delay3 != null && delay3 > 0 || delay3 == null && this.delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay3);
        }
        scheduler.flush(this);
        return 0;
      };
      return QueueAction2;
    }(AsyncAction_1.AsyncAction);
    exports.QueueAction = QueueAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js
var require_QueueScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueueScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var QueueScheduler = function(_super) {
      __extends2(QueueScheduler2, _super);
      function QueueScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return QueueScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.QueueScheduler = QueueScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/queue.js
var require_queue = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/queue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.queue = exports.queueScheduler = void 0;
    var QueueAction_1 = require_QueueAction();
    var QueueScheduler_1 = require_QueueScheduler();
    exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
    exports.queue = exports.queueScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js
var require_AnimationFrameAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnimationFrameAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var animationFrameProvider_1 = require_animationFrameProvider();
    var AnimationFrameAction = function(_super) {
      __extends2(AnimationFrameAction2, _super);
      function AnimationFrameAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
        if (delay3 === void 0) {
          delay3 = 0;
        }
        if (delay3 !== null && delay3 > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay3);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
          return scheduler.flush(void 0);
        }));
      };
      AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay3) {
        var _a;
        if (delay3 === void 0) {
          delay3 = 0;
        }
        if (delay3 != null ? delay3 > 0 : this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay3);
        }
        var actions = scheduler.actions;
        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
          animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
          scheduler._scheduled = void 0;
        }
        return void 0;
      };
      return AnimationFrameAction2;
    }(AsyncAction_1.AsyncAction);
    exports.AnimationFrameAction = AnimationFrameAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js
var require_AnimationFrameScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnimationFrameScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var AnimationFrameScheduler = function(_super) {
      __extends2(AnimationFrameScheduler2, _super);
      function AnimationFrameScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AnimationFrameScheduler2.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AnimationFrameScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.AnimationFrameScheduler = AnimationFrameScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js
var require_animationFrame = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.animationFrame = exports.animationFrameScheduler = void 0;
    var AnimationFrameAction_1 = require_AnimationFrameAction();
    var AnimationFrameScheduler_1 = require_AnimationFrameScheduler();
    exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
    exports.animationFrame = exports.animationFrameScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js
var require_VirtualTimeScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VirtualAction = exports.VirtualTimeScheduler = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var Subscription_1 = require_Subscription();
    var AsyncScheduler_1 = require_AsyncScheduler();
    var VirtualTimeScheduler = function(_super) {
      __extends2(VirtualTimeScheduler2, _super);
      function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
        if (schedulerActionCtor === void 0) {
          schedulerActionCtor = VirtualAction;
        }
        if (maxFrames === void 0) {
          maxFrames = Infinity;
        }
        var _this = _super.call(this, schedulerActionCtor, function() {
          return _this.frame;
        }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
      }
      VirtualTimeScheduler2.prototype.flush = function() {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error;
        var action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
          actions.shift();
          this.frame = action.delay;
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        }
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      VirtualTimeScheduler2.frameTimeFactor = 10;
      return VirtualTimeScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.VirtualTimeScheduler = VirtualTimeScheduler;
    var VirtualAction = function(_super) {
      __extends2(VirtualAction2, _super);
      function VirtualAction2(scheduler, work, index) {
        if (index === void 0) {
          index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
      }
      VirtualAction2.prototype.schedule = function(state, delay3) {
        if (delay3 === void 0) {
          delay3 = 0;
        }
        if (Number.isFinite(delay3)) {
          if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay3);
          }
          this.active = false;
          var action = new VirtualAction2(this.scheduler, this.work);
          this.add(action);
          return action.schedule(state, delay3);
        } else {
          return Subscription_1.Subscription.EMPTY;
        }
      };
      VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
        if (delay3 === void 0) {
          delay3 = 0;
        }
        this.delay = scheduler.frame + delay3;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction2.sortActions);
        return 1;
      };
      VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay3) {
        if (delay3 === void 0) {
          delay3 = 0;
        }
        return void 0;
      };
      VirtualAction2.prototype._execute = function(state, delay3) {
        if (this.active === true) {
          return _super.prototype._execute.call(this, state, delay3);
        }
      };
      VirtualAction2.sortActions = function(a, b) {
        if (a.delay === b.delay) {
          if (a.index === b.index) {
            return 0;
          } else if (a.index > b.index) {
            return 1;
          } else {
            return -1;
          }
        } else if (a.delay > b.delay) {
          return 1;
        } else {
          return -1;
        }
      };
      return VirtualAction2;
    }(AsyncAction_1.AsyncAction);
    exports.VirtualAction = VirtualAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/empty.js
var require_empty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/empty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.empty = exports.EMPTY = void 0;
    var Observable_1 = require_Observable();
    exports.EMPTY = new Observable_1.Observable(function(subscriber) {
      return subscriber.complete();
    });
    function empty(scheduler) {
      return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
    }
    exports.empty = empty;
    function emptyScheduled(scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        return scheduler.schedule(function() {
          return subscriber.complete();
        });
      });
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isScheduler.js
var require_isScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isScheduler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isScheduler = void 0;
    var isFunction_1 = require_isFunction();
    function isScheduler(value) {
      return value && isFunction_1.isFunction(value.schedule);
    }
    exports.isScheduler = isScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/args.js
var require_args = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/args.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.popNumber = exports.popScheduler = exports.popResultSelector = void 0;
    var isFunction_1 = require_isFunction();
    var isScheduler_1 = require_isScheduler();
    function last(arr) {
      return arr[arr.length - 1];
    }
    function popResultSelector(args) {
      return isFunction_1.isFunction(last(args)) ? args.pop() : void 0;
    }
    exports.popResultSelector = popResultSelector;
    function popScheduler(args) {
      return isScheduler_1.isScheduler(last(args)) ? args.pop() : void 0;
    }
    exports.popScheduler = popScheduler;
    function popNumber(args, defaultValue) {
      return typeof last(args) === "number" ? args.pop() : defaultValue;
    }
    exports.popNumber = popNumber;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isArrayLike = void 0;
    exports.isArrayLike = function(x) {
      return x && typeof x.length === "number" && typeof x !== "function";
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isPromise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPromise = void 0;
    var isFunction_1 = require_isFunction();
    function isPromise3(value) {
      return isFunction_1.isFunction(value === null || value === void 0 ? void 0 : value.then);
    }
    exports.isPromise = isPromise3;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js
var require_isInteropObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isInteropObservable = void 0;
    var observable_1 = require_observable();
    var isFunction_1 = require_isFunction();
    function isInteropObservable(input) {
      return isFunction_1.isFunction(input[observable_1.observable]);
    }
    exports.isInteropObservable = isInteropObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js
var require_isAsyncIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAsyncIterable = void 0;
    var isFunction_1 = require_isFunction();
    function isAsyncIterable(obj) {
      return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
    }
    exports.isAsyncIterable = isAsyncIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js
var require_throwUnobservableError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createInvalidObservableTypeError = void 0;
    function createInvalidObservableTypeError(input) {
      return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
    }
    exports.createInvalidObservableTypeError = createInvalidObservableTypeError;
  }
});

// node_modules/rxjs/dist/cjs/internal/symbol/iterator.js
var require_iterator = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/symbol/iterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.iterator = exports.getSymbolIterator = void 0;
    function getSymbolIterator() {
      if (typeof Symbol !== "function" || !Symbol.iterator) {
        return "@@iterator";
      }
      return Symbol.iterator;
    }
    exports.getSymbolIterator = getSymbolIterator;
    exports.iterator = getSymbolIterator();
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isIterable.js
var require_isIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isIterable = void 0;
    var iterator_1 = require_iterator();
    var isFunction_1 = require_isFunction();
    function isIterable(input) {
      return isFunction_1.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1.iterator]);
    }
    exports.isIterable = isIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js
var require_isReadableStreamLike = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js"(exports) {
    "use strict";
    var __generator3 = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __await = exports && exports.__await || function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f2, v) {
        if (f2(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isReadableStreamLike = exports.readableStreamLikeToAsyncGenerator = void 0;
    var isFunction_1 = require_isFunction();
    function readableStreamLikeToAsyncGenerator(readableStream) {
      return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
        var reader, _a, value, done;
        return __generator3(this, function(_b) {
          switch (_b.label) {
            case 0:
              reader = readableStream.getReader();
              _b.label = 1;
            case 1:
              _b.trys.push([1, , 9, 10]);
              _b.label = 2;
            case 2:
              if (false)
                return [3, 8];
              return [4, __await(reader.read())];
            case 3:
              _a = _b.sent(), value = _a.value, done = _a.done;
              if (!done)
                return [3, 5];
              return [4, __await(void 0)];
            case 4:
              return [2, _b.sent()];
            case 5:
              return [4, __await(value)];
            case 6:
              return [4, _b.sent()];
            case 7:
              _b.sent();
              return [3, 2];
            case 8:
              return [3, 10];
            case 9:
              reader.releaseLock();
              return [7];
            case 10:
              return [2];
          }
        });
      });
    }
    exports.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
    function isReadableStreamLike(obj) {
      return isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
    }
    exports.isReadableStreamLike = isReadableStreamLike;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js
var require_innerFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js"(exports) {
    "use strict";
    var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator3 = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __asyncValues = exports && exports.__asyncValues || function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values3 === "function" ? __values3(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    var __values3 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromReadableStreamLike = exports.fromAsyncIterable = exports.fromIterable = exports.fromPromise = exports.fromArrayLike = exports.fromInteropObservable = exports.innerFrom = void 0;
    var isArrayLike_1 = require_isArrayLike();
    var isPromise_1 = require_isPromise();
    var Observable_1 = require_Observable();
    var isInteropObservable_1 = require_isInteropObservable();
    var isAsyncIterable_1 = require_isAsyncIterable();
    var throwUnobservableError_1 = require_throwUnobservableError();
    var isIterable_1 = require_isIterable();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    var isFunction_1 = require_isFunction();
    var reportUnhandledError_1 = require_reportUnhandledError();
    var observable_1 = require_observable();
    function innerFrom(input) {
      if (input instanceof Observable_1.Observable) {
        return input;
      }
      if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
          return fromInteropObservable(input);
        }
        if (isArrayLike_1.isArrayLike(input)) {
          return fromArrayLike(input);
        }
        if (isPromise_1.isPromise(input)) {
          return fromPromise(input);
        }
        if (isAsyncIterable_1.isAsyncIterable(input)) {
          return fromAsyncIterable(input);
        }
        if (isIterable_1.isIterable(input)) {
          return fromIterable(input);
        }
        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
          return fromReadableStreamLike(input);
        }
      }
      throw throwUnobservableError_1.createInvalidObservableTypeError(input);
    }
    exports.innerFrom = innerFrom;
    function fromInteropObservable(obj) {
      return new Observable_1.Observable(function(subscriber) {
        var obs = obj[observable_1.observable]();
        if (isFunction_1.isFunction(obs.subscribe)) {
          return obs.subscribe(subscriber);
        }
        throw new TypeError("Provided object does not correctly implement Symbol.observable");
      });
    }
    exports.fromInteropObservable = fromInteropObservable;
    function fromArrayLike(array) {
      return new Observable_1.Observable(function(subscriber) {
        for (var i = 0; i < array.length && !subscriber.closed; i++) {
          subscriber.next(array[i]);
        }
        subscriber.complete();
      });
    }
    exports.fromArrayLike = fromArrayLike;
    function fromPromise(promise) {
      return new Observable_1.Observable(function(subscriber) {
        promise.then(function(value) {
          if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
          }
        }, function(err) {
          return subscriber.error(err);
        }).then(null, reportUnhandledError_1.reportUnhandledError);
      });
    }
    exports.fromPromise = fromPromise;
    function fromIterable(iterable) {
      return new Observable_1.Observable(function(subscriber) {
        var e_1, _a;
        try {
          for (var iterable_1 = __values3(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
            var value = iterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
              _a.call(iterable_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        subscriber.complete();
      });
    }
    exports.fromIterable = fromIterable;
    function fromAsyncIterable(asyncIterable) {
      return new Observable_1.Observable(function(subscriber) {
        process2(asyncIterable, subscriber).catch(function(err) {
          return subscriber.error(err);
        });
      });
    }
    exports.fromAsyncIterable = fromAsyncIterable;
    function fromReadableStreamLike(readableStream) {
      return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
    }
    exports.fromReadableStreamLike = fromReadableStreamLike;
    function process2(asyncIterable, subscriber) {
      var asyncIterable_1, asyncIterable_1_1;
      var e_2, _a;
      return __awaiter3(this, void 0, void 0, function() {
        var value, e_2_1;
        return __generator3(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 5, 6, 11]);
              asyncIterable_1 = __asyncValues(asyncIterable);
              _b.label = 1;
            case 1:
              return [4, asyncIterable_1.next()];
            case 2:
              if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
                return [3, 4];
              value = asyncIterable_1_1.value;
              subscriber.next(value);
              if (subscriber.closed) {
                return [2];
              }
              _b.label = 3;
            case 3:
              return [3, 1];
            case 4:
              return [3, 11];
            case 5:
              e_2_1 = _b.sent();
              e_2 = { error: e_2_1 };
              return [3, 11];
            case 6:
              _b.trys.push([6, , 9, 10]);
              if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
                return [3, 8];
              return [4, _a.call(asyncIterable_1)];
            case 7:
              _b.sent();
              _b.label = 8;
            case 8:
              return [3, 10];
            case 9:
              if (e_2)
                throw e_2.error;
              return [7];
            case 10:
              return [7];
            case 11:
              subscriber.complete();
              return [2];
          }
        });
      });
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js
var require_executeSchedule = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.executeSchedule = void 0;
    function executeSchedule(parentSubscription, scheduler, work, delay3, repeat2) {
      if (delay3 === void 0) {
        delay3 = 0;
      }
      if (repeat2 === void 0) {
        repeat2 = false;
      }
      var scheduleSubscription = scheduler.schedule(function() {
        work();
        if (repeat2) {
          parentSubscription.add(this.schedule(null, delay3));
        } else {
          this.unsubscribe();
        }
      }, delay3);
      parentSubscription.add(scheduleSubscription);
      if (!repeat2) {
        return scheduleSubscription;
      }
    }
    exports.executeSchedule = executeSchedule;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/observeOn.js
var require_observeOn = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/observeOn.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observeOn = void 0;
    var executeSchedule_1 = require_executeSchedule();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function observeOn(scheduler, delay3) {
      if (delay3 === void 0) {
        delay3 = 0;
      }
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.next(value);
          }, delay3);
        }, function() {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.complete();
          }, delay3);
        }, function(err) {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.error(err);
          }, delay3);
        }));
      });
    }
    exports.observeOn = observeOn;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js
var require_subscribeOn = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.subscribeOn = void 0;
    var lift_1 = require_lift();
    function subscribeOn(scheduler, delay3) {
      if (delay3 === void 0) {
        delay3 = 0;
      }
      return lift_1.operate(function(source, subscriber) {
        subscriber.add(scheduler.schedule(function() {
          return source.subscribe(subscriber);
        }, delay3));
      });
    }
    exports.subscribeOn = subscribeOn;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js
var require_scheduleObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleObservable = void 0;
    var innerFrom_1 = require_innerFrom();
    var observeOn_1 = require_observeOn();
    var subscribeOn_1 = require_subscribeOn();
    function scheduleObservable(input, scheduler) {
      return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
    }
    exports.scheduleObservable = scheduleObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js
var require_schedulePromise = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schedulePromise = void 0;
    var innerFrom_1 = require_innerFrom();
    var observeOn_1 = require_observeOn();
    var subscribeOn_1 = require_subscribeOn();
    function schedulePromise(input, scheduler) {
      return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
    }
    exports.schedulePromise = schedulePromise;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js
var require_scheduleArray = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleArray = void 0;
    var Observable_1 = require_Observable();
    function scheduleArray(input, scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        var i = 0;
        return scheduler.schedule(function() {
          if (i === input.length) {
            subscriber.complete();
          } else {
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
              this.schedule();
            }
          }
        });
      });
    }
    exports.scheduleArray = scheduleArray;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js
var require_scheduleIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleIterable = void 0;
    var Observable_1 = require_Observable();
    var iterator_1 = require_iterator();
    var isFunction_1 = require_isFunction();
    var executeSchedule_1 = require_executeSchedule();
    function scheduleIterable(input, scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        var iterator;
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          iterator = input[iterator_1.iterator]();
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            var _a;
            var value;
            var done;
            try {
              _a = iterator.next(), value = _a.value, done = _a.done;
            } catch (err) {
              subscriber.error(err);
              return;
            }
            if (done) {
              subscriber.complete();
            } else {
              subscriber.next(value);
            }
          }, 0, true);
        });
        return function() {
          return isFunction_1.isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return();
        };
      });
    }
    exports.scheduleIterable = scheduleIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js
var require_scheduleAsyncIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleAsyncIterable = void 0;
    var Observable_1 = require_Observable();
    var executeSchedule_1 = require_executeSchedule();
    function scheduleAsyncIterable(input, scheduler) {
      if (!input) {
        throw new Error("Iterable cannot be null");
      }
      return new Observable_1.Observable(function(subscriber) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          var iterator = input[Symbol.asyncIterator]();
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            iterator.next().then(function(result2) {
              if (result2.done) {
                subscriber.complete();
              } else {
                subscriber.next(result2.value);
              }
            });
          }, 0, true);
        });
      });
    }
    exports.scheduleAsyncIterable = scheduleAsyncIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js
var require_scheduleReadableStreamLike = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleReadableStreamLike = void 0;
    var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    function scheduleReadableStreamLike(input, scheduler) {
      return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
    }
    exports.scheduleReadableStreamLike = scheduleReadableStreamLike;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js
var require_scheduled = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduled = void 0;
    var scheduleObservable_1 = require_scheduleObservable();
    var schedulePromise_1 = require_schedulePromise();
    var scheduleArray_1 = require_scheduleArray();
    var scheduleIterable_1 = require_scheduleIterable();
    var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
    var isInteropObservable_1 = require_isInteropObservable();
    var isPromise_1 = require_isPromise();
    var isArrayLike_1 = require_isArrayLike();
    var isIterable_1 = require_isIterable();
    var isAsyncIterable_1 = require_isAsyncIterable();
    var throwUnobservableError_1 = require_throwUnobservableError();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    var scheduleReadableStreamLike_1 = require_scheduleReadableStreamLike();
    function scheduled(input, scheduler) {
      if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
          return scheduleObservable_1.scheduleObservable(input, scheduler);
        }
        if (isArrayLike_1.isArrayLike(input)) {
          return scheduleArray_1.scheduleArray(input, scheduler);
        }
        if (isPromise_1.isPromise(input)) {
          return schedulePromise_1.schedulePromise(input, scheduler);
        }
        if (isAsyncIterable_1.isAsyncIterable(input)) {
          return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
        }
        if (isIterable_1.isIterable(input)) {
          return scheduleIterable_1.scheduleIterable(input, scheduler);
        }
        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
          return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
        }
      }
      throw throwUnobservableError_1.createInvalidObservableTypeError(input);
    }
    exports.scheduled = scheduled;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/from.js
var require_from = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/from.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.from = void 0;
    var scheduled_1 = require_scheduled();
    var innerFrom_1 = require_innerFrom();
    function from(input, scheduler) {
      return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
    }
    exports.from = from;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/of.js
var require_of = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/of.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.of = void 0;
    var args_1 = require_args();
    var from_1 = require_from();
    function of() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      return from_1.from(args, scheduler);
    }
    exports.of = of;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/throwError.js
var require_throwError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/throwError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throwError = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    function throwError(errorOrErrorFactory, scheduler) {
      var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
        return errorOrErrorFactory;
      };
      var init = function(subscriber) {
        return subscriber.error(errorFactory());
      };
      return new Observable_1.Observable(scheduler ? function(subscriber) {
        return scheduler.schedule(init, 0, subscriber);
      } : init);
    }
    exports.throwError = throwError;
  }
});

// node_modules/rxjs/dist/cjs/internal/Notification.js
var require_Notification = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Notification.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observeNotification = exports.Notification = exports.NotificationKind = void 0;
    var empty_1 = require_empty();
    var of_1 = require_of();
    var throwError_1 = require_throwError();
    var isFunction_1 = require_isFunction();
    var NotificationKind;
    (function(NotificationKind2) {
      NotificationKind2["NEXT"] = "N";
      NotificationKind2["ERROR"] = "E";
      NotificationKind2["COMPLETE"] = "C";
    })(NotificationKind = exports.NotificationKind || (exports.NotificationKind = {}));
    var Notification = function() {
      function Notification2(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === "N";
      }
      Notification2.prototype.observe = function(observer) {
        return observeNotification(this, observer);
      };
      Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
        return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
      };
      Notification2.prototype.accept = function(nextOrObserver, error, complete) {
        var _a;
        return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
      };
      Notification2.prototype.toObservable = function() {
        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
        var result2 = kind === "N" ? of_1.of(value) : kind === "E" ? throwError_1.throwError(function() {
          return error;
        }) : kind === "C" ? empty_1.EMPTY : 0;
        if (!result2) {
          throw new TypeError("Unexpected notification kind " + kind);
        }
        return result2;
      };
      Notification2.createNext = function(value) {
        return new Notification2("N", value);
      };
      Notification2.createError = function(err) {
        return new Notification2("E", void 0, err);
      };
      Notification2.createComplete = function() {
        return Notification2.completeNotification;
      };
      Notification2.completeNotification = new Notification2("C");
      return Notification2;
    }();
    exports.Notification = Notification;
    function observeNotification(notification, observer) {
      var _a, _b, _c;
      var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
      if (typeof kind !== "string") {
        throw new TypeError('Invalid notification, missing "kind"');
      }
      kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
    }
    exports.observeNotification = observeNotification;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isObservable.js
var require_isObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isObservable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isObservable = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    function isObservable(obj) {
      return !!obj && (obj instanceof Observable_1.Observable || isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe));
    }
    exports.isObservable = isObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/EmptyError.js
var require_EmptyError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/EmptyError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmptyError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.EmptyError = createErrorClass_1.createErrorClass(function(_super) {
      return function EmptyErrorImpl() {
        _super(this);
        this.name = "EmptyError";
        this.message = "no elements in sequence";
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/lastValueFrom.js
var require_lastValueFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/lastValueFrom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lastValueFrom = void 0;
    var EmptyError_1 = require_EmptyError();
    function lastValueFrom(source, config) {
      var hasConfig = typeof config === "object";
      return new Promise(function(resolve, reject) {
        var _hasValue = false;
        var _value;
        source.subscribe({
          next: function(value) {
            _value = value;
            _hasValue = true;
          },
          error: reject,
          complete: function() {
            if (_hasValue) {
              resolve(_value);
            } else if (hasConfig) {
              resolve(config.defaultValue);
            } else {
              reject(new EmptyError_1.EmptyError());
            }
          }
        });
      });
    }
    exports.lastValueFrom = lastValueFrom;
  }
});

// node_modules/rxjs/dist/cjs/internal/firstValueFrom.js
var require_firstValueFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/firstValueFrom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.firstValueFrom = void 0;
    var EmptyError_1 = require_EmptyError();
    var Subscriber_1 = require_Subscriber();
    function firstValueFrom(source, config) {
      var hasConfig = typeof config === "object";
      return new Promise(function(resolve, reject) {
        var subscriber = new Subscriber_1.SafeSubscriber({
          next: function(value) {
            resolve(value);
            subscriber.unsubscribe();
          },
          error: reject,
          complete: function() {
            if (hasConfig) {
              resolve(config.defaultValue);
            } else {
              reject(new EmptyError_1.EmptyError());
            }
          }
        });
        source.subscribe(subscriber);
      });
    }
    exports.firstValueFrom = firstValueFrom;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js
var require_ArgumentOutOfRangeError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArgumentOutOfRangeError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function(_super) {
      return function ArgumentOutOfRangeErrorImpl() {
        _super(this);
        this.name = "ArgumentOutOfRangeError";
        this.message = "argument out of range";
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js
var require_NotFoundError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NotFoundError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.NotFoundError = createErrorClass_1.createErrorClass(function(_super) {
      return function NotFoundErrorImpl(message) {
        _super(this);
        this.name = "NotFoundError";
        this.message = message;
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/SequenceError.js
var require_SequenceError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/SequenceError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SequenceError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
      return function SequenceErrorImpl(message) {
        _super(this);
        this.name = "SequenceError";
        this.message = message;
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isDate.js
var require_isDate = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isDate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidDate = void 0;
    function isValidDate(value) {
      return value instanceof Date && !isNaN(value);
    }
    exports.isValidDate = isValidDate;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timeout.js
var require_timeout = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timeout = exports.TimeoutError = void 0;
    var async_1 = require_async();
    var isDate_1 = require_isDate();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var createErrorClass_1 = require_createErrorClass();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var executeSchedule_1 = require_executeSchedule();
    exports.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
      return function TimeoutErrorImpl(info) {
        if (info === void 0) {
          info = null;
        }
        _super(this);
        this.message = "Timeout has occurred";
        this.name = "TimeoutError";
        this.info = info;
      };
    });
    function timeout2(config, schedulerArg) {
      var _a = isDate_1.isValidDate(config) ? { first: config } : typeof config === "number" ? { each: config } : config, first = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_1.asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
      if (first == null && each == null) {
        throw new TypeError("No timeout provided.");
      }
      return lift_1.operate(function(source, subscriber) {
        var originalSourceSubscription;
        var timerSubscription;
        var lastValue = null;
        var seen = 0;
        var startTimer = function(delay3) {
          timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            try {
              originalSourceSubscription.unsubscribe();
              innerFrom_1.innerFrom(_with({
                meta,
                lastValue,
                seen
              })).subscribe(subscriber);
            } catch (err) {
              subscriber.error(err);
            }
          }, delay3);
        };
        originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          seen++;
          subscriber.next(lastValue = value);
          each > 0 && startTimer(each);
        }, void 0, void 0, function() {
          if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
            timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          }
          lastValue = null;
        }));
        !seen && startTimer(first != null ? typeof first === "number" ? first : +first - scheduler.now() : each);
      });
    }
    exports.timeout = timeout2;
    function timeoutErrorFactory(info) {
      throw new exports.TimeoutError(info);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/map.js
var require_map = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.map = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function map(project, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          subscriber.next(project.call(thisArg, value, index++));
        }));
      });
    }
    exports.map = map;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js
var require_mapOneOrManyArgs = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapOneOrManyArgs = void 0;
    var map_1 = require_map();
    var isArray2 = Array.isArray;
    function callOrApply(fn, args) {
      return isArray2(args) ? fn.apply(void 0, __spreadArray2([], __read2(args))) : fn(args);
    }
    function mapOneOrManyArgs(fn) {
      return map_1.map(function(args) {
        return callOrApply(fn, args);
      });
    }
    exports.mapOneOrManyArgs = mapOneOrManyArgs;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js
var require_bindCallbackInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bindCallbackInternals = void 0;
    var isScheduler_1 = require_isScheduler();
    var Observable_1 = require_Observable();
    var subscribeOn_1 = require_subscribeOn();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var observeOn_1 = require_observeOn();
    var AsyncSubject_1 = require_AsyncSubject();
    function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
      if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
          scheduler = resultSelector;
        } else {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
          };
        }
      }
      if (scheduler) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
        };
      }
      return function() {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var subject = new AsyncSubject_1.AsyncSubject();
        var uninitialized = true;
        return new Observable_1.Observable(function(subscriber) {
          var subs = subject.subscribe(subscriber);
          if (uninitialized) {
            uninitialized = false;
            var isAsync_1 = false;
            var isComplete_1 = false;
            callbackFunc.apply(_this, __spreadArray2(__spreadArray2([], __read2(args)), [
              function() {
                var results = [];
                for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                  results[_i2] = arguments[_i2];
                }
                if (isNodeStyle) {
                  var err = results.shift();
                  if (err != null) {
                    subject.error(err);
                    return;
                  }
                }
                subject.next(1 < results.length ? results : results[0]);
                isComplete_1 = true;
                if (isAsync_1) {
                  subject.complete();
                }
              }
            ]));
            if (isComplete_1) {
              subject.complete();
            }
            isAsync_1 = true;
          }
          return subs;
        });
      };
    }
    exports.bindCallbackInternals = bindCallbackInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js
var require_bindCallback = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bindCallback = void 0;
    var bindCallbackInternals_1 = require_bindCallbackInternals();
    function bindCallback(callbackFunc, resultSelector, scheduler) {
      return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
    }
    exports.bindCallback = bindCallback;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js
var require_bindNodeCallback = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bindNodeCallback = void 0;
    var bindCallbackInternals_1 = require_bindCallbackInternals();
    function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
      return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
    }
    exports.bindNodeCallback = bindNodeCallback;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js
var require_argsArgArrayOrObject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.argsArgArrayOrObject = void 0;
    var isArray2 = Array.isArray;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectProto = Object.prototype;
    var getKeys = Object.keys;
    function argsArgArrayOrObject(args) {
      if (args.length === 1) {
        var first_1 = args[0];
        if (isArray2(first_1)) {
          return { args: first_1, keys: null };
        }
        if (isPOJO(first_1)) {
          var keys = getKeys(first_1);
          return {
            args: keys.map(function(key) {
              return first_1[key];
            }),
            keys
          };
        }
      }
      return { args, keys: null };
    }
    exports.argsArgArrayOrObject = argsArgArrayOrObject;
    function isPOJO(obj) {
      return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/createObject.js
var require_createObject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/createObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createObject = void 0;
    function createObject(keys, values) {
      return keys.reduce(function(result2, key, i) {
        return result2[key] = values[i], result2;
      }, {});
    }
    exports.createObject = createObject;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js
var require_combineLatest = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineLatestInit = exports.combineLatest = void 0;
    var Observable_1 = require_Observable();
    var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
    var from_1 = require_from();
    var identity_1 = require_identity();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var args_1 = require_args();
    var createObject_1 = require_createObject();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var executeSchedule_1 = require_executeSchedule();
    function combineLatest() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var resultSelector = args_1.popResultSelector(args);
      var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
      if (observables.length === 0) {
        return from_1.from([], scheduler);
      }
      var result2 = new Observable_1.Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
        return createObject_1.createObject(keys, values);
      } : identity_1.identity));
      return resultSelector ? result2.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result2;
    }
    exports.combineLatest = combineLatest;
    function combineLatestInit(observables, scheduler, valueTransform) {
      if (valueTransform === void 0) {
        valueTransform = identity_1.identity;
      }
      return function(subscriber) {
        maybeSchedule(scheduler, function() {
          var length2 = observables.length;
          var values = new Array(length2);
          var active = length2;
          var remainingFirstValues = length2;
          var _loop_1 = function(i2) {
            maybeSchedule(scheduler, function() {
              var source = from_1.from(observables[i2], scheduler);
              var hasFirstValue = false;
              source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                values[i2] = value;
                if (!hasFirstValue) {
                  hasFirstValue = true;
                  remainingFirstValues--;
                }
                if (!remainingFirstValues) {
                  subscriber.next(valueTransform(values.slice()));
                }
              }, function() {
                if (!--active) {
                  subscriber.complete();
                }
              }));
            }, subscriber);
          };
          for (var i = 0; i < length2; i++) {
            _loop_1(i);
          }
        }, subscriber);
      };
    }
    exports.combineLatestInit = combineLatestInit;
    function maybeSchedule(scheduler, execute, subscription) {
      if (scheduler) {
        executeSchedule_1.executeSchedule(subscription, scheduler, execute);
      } else {
        execute();
      }
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js
var require_mergeInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeInternals = void 0;
    var innerFrom_1 = require_innerFrom();
    var executeSchedule_1 = require_executeSchedule();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
      var buffer = [];
      var active = 0;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        if (isComplete && !buffer.length && !active) {
          subscriber.complete();
        }
      };
      var outerNext = function(value) {
        return active < concurrent ? doInnerSub(value) : buffer.push(value);
      };
      var doInnerSub = function(value) {
        expand && subscriber.next(value);
        active++;
        var innerComplete = false;
        innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
          onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
          if (expand) {
            outerNext(innerValue);
          } else {
            subscriber.next(innerValue);
          }
        }, function() {
          innerComplete = true;
        }, void 0, function() {
          if (innerComplete) {
            try {
              active--;
              var _loop_1 = function() {
                var bufferedValue = buffer.shift();
                if (innerSubScheduler) {
                  executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function() {
                    return doInnerSub(bufferedValue);
                  });
                } else {
                  doInnerSub(bufferedValue);
                }
              };
              while (buffer.length && active < concurrent) {
                _loop_1();
              }
              checkComplete();
            } catch (err) {
              subscriber.error(err);
            }
          }
        }));
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function() {
        isComplete = true;
        checkComplete();
      }));
      return function() {
        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
      };
    }
    exports.mergeInternals = mergeInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js
var require_mergeMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeMap = void 0;
    var map_1 = require_map();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    var isFunction_1 = require_isFunction();
    function mergeMap(project, resultSelector, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      if (isFunction_1.isFunction(resultSelector)) {
        return mergeMap(function(a, i) {
          return map_1.map(function(b, ii) {
            return resultSelector(a, b, i, ii);
          })(innerFrom_1.innerFrom(project(a, i)));
        }, concurrent);
      } else if (typeof resultSelector === "number") {
        concurrent = resultSelector;
      }
      return lift_1.operate(function(source, subscriber) {
        return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent);
      });
    }
    exports.mergeMap = mergeMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js
var require_mergeAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeAll = void 0;
    var mergeMap_1 = require_mergeMap();
    var identity_1 = require_identity();
    function mergeAll(concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      return mergeMap_1.mergeMap(identity_1.identity, concurrent);
    }
    exports.mergeAll = mergeAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatAll.js
var require_concatAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatAll = void 0;
    var mergeAll_1 = require_mergeAll();
    function concatAll() {
      return mergeAll_1.mergeAll(1);
    }
    exports.concatAll = concatAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/concat.js
var require_concat = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/concat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concat = void 0;
    var concatAll_1 = require_concatAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function concat() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));
    }
    exports.concat = concat;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/defer.js
var require_defer = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/defer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defer = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    function defer(observableFactory) {
      return new Observable_1.Observable(function(subscriber) {
        innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
      });
    }
    exports.defer = defer;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/connectable.js
var require_connectable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/connectable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.connectable = void 0;
    var Subject_1 = require_Subject();
    var Observable_1 = require_Observable();
    var defer_1 = require_defer();
    var DEFAULT_CONFIG = {
      connector: function() {
        return new Subject_1.Subject();
      },
      resetOnDisconnect: true
    };
    function connectable(source, config) {
      if (config === void 0) {
        config = DEFAULT_CONFIG;
      }
      var connection = null;
      var connector = config.connector, _a = config.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
      var subject = connector();
      var result2 = new Observable_1.Observable(function(subscriber) {
        return subject.subscribe(subscriber);
      });
      result2.connect = function() {
        if (!connection || connection.closed) {
          connection = defer_1.defer(function() {
            return source;
          }).subscribe(subject);
          if (resetOnDisconnect) {
            connection.add(function() {
              return subject = connector();
            });
          }
        }
        return connection;
      };
      return result2;
    }
    exports.connectable = connectable;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js
var require_forkJoin = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.forkJoin = void 0;
    var Observable_1 = require_Observable();
    var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
    var innerFrom_1 = require_innerFrom();
    var args_1 = require_args();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var createObject_1 = require_createObject();
    function forkJoin() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
      var result2 = new Observable_1.Observable(function(subscriber) {
        var length2 = sources.length;
        if (!length2) {
          subscriber.complete();
          return;
        }
        var values = new Array(length2);
        var remainingCompletions = length2;
        var remainingEmissions = length2;
        var _loop_1 = function(sourceIndex2) {
          var hasValue = false;
          innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (!hasValue) {
              hasValue = true;
              remainingEmissions--;
            }
            values[sourceIndex2] = value;
          }, function() {
            return remainingCompletions--;
          }, void 0, function() {
            if (!remainingCompletions || !hasValue) {
              if (!remainingEmissions) {
                subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
              }
              subscriber.complete();
            }
          }));
        };
        for (var sourceIndex = 0; sourceIndex < length2; sourceIndex++) {
          _loop_1(sourceIndex);
        }
      });
      return resultSelector ? result2.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result2;
    }
    exports.forkJoin = forkJoin;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js
var require_fromEvent = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromEvent = void 0;
    var innerFrom_1 = require_innerFrom();
    var Observable_1 = require_Observable();
    var mergeMap_1 = require_mergeMap();
    var isArrayLike_1 = require_isArrayLike();
    var isFunction_1 = require_isFunction();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var nodeEventEmitterMethods = ["addListener", "removeListener"];
    var eventTargetMethods = ["addEventListener", "removeEventListener"];
    var jqueryMethods = ["on", "off"];
    function fromEvent(target, eventName, options, resultSelector) {
      if (isFunction_1.isFunction(options)) {
        resultSelector = options;
        options = void 0;
      }
      if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
      }
      var _a = __read2(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
        return function(handler) {
          return target[methodName](eventName, handler, options);
        };
      }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
      if (!add) {
        if (isArrayLike_1.isArrayLike(target)) {
          return mergeMap_1.mergeMap(function(subTarget) {
            return fromEvent(subTarget, eventName, options);
          })(innerFrom_1.innerFrom(target));
        }
      }
      if (!add) {
        throw new TypeError("Invalid event target");
      }
      return new Observable_1.Observable(function(subscriber) {
        var handler = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return subscriber.next(1 < args.length ? args : args[0]);
        };
        add(handler);
        return function() {
          return remove(handler);
        };
      });
    }
    exports.fromEvent = fromEvent;
    function toCommonHandlerRegistry(target, eventName) {
      return function(methodName) {
        return function(handler) {
          return target[methodName](eventName, handler);
        };
      };
    }
    function isNodeStyleEventEmitter(target) {
      return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
    }
    function isJQueryStyleEventEmitter(target) {
      return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
    }
    function isEventTarget(target) {
      return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js
var require_fromEventPattern = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromEventPattern = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    function fromEventPattern(addHandler, removeHandler, resultSelector) {
      if (resultSelector) {
        return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
      }
      return new Observable_1.Observable(function(subscriber) {
        var handler = function() {
          var e = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            e[_i] = arguments[_i];
          }
          return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue = addHandler(handler);
        return isFunction_1.isFunction(removeHandler) ? function() {
          return removeHandler(handler, retValue);
        } : void 0;
      });
    }
    exports.fromEventPattern = fromEventPattern;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/generate.js
var require_generate = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/generate.js"(exports) {
    "use strict";
    var __generator3 = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generate = void 0;
    var identity_1 = require_identity();
    var isScheduler_1 = require_isScheduler();
    var defer_1 = require_defer();
    var scheduleIterable_1 = require_scheduleIterable();
    function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
      var _a, _b;
      var resultSelector;
      var initialState;
      if (arguments.length === 1) {
        _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity_1.identity : _b, scheduler = _a.scheduler;
      } else {
        initialState = initialStateOrOptions;
        if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
          resultSelector = identity_1.identity;
          scheduler = resultSelectorOrScheduler;
        } else {
          resultSelector = resultSelectorOrScheduler;
        }
      }
      function gen() {
        var state;
        return __generator3(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              state = initialState;
              _a2.label = 1;
            case 1:
              if (!(!condition || condition(state)))
                return [3, 4];
              return [4, resultSelector(state)];
            case 2:
              _a2.sent();
              _a2.label = 3;
            case 3:
              state = iterate(state);
              return [3, 1];
            case 4:
              return [2];
          }
        });
      }
      return defer_1.defer(scheduler ? function() {
        return scheduleIterable_1.scheduleIterable(gen(), scheduler);
      } : gen);
    }
    exports.generate = generate;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/iif.js
var require_iif = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/iif.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.iif = void 0;
    var defer_1 = require_defer();
    function iif(condition, trueResult, falseResult) {
      return defer_1.defer(function() {
        return condition() ? trueResult : falseResult;
      });
    }
    exports.iif = iif;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/timer.js
var require_timer = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/timer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timer = void 0;
    var Observable_1 = require_Observable();
    var async_1 = require_async();
    var isScheduler_1 = require_isScheduler();
    var isDate_1 = require_isDate();
    function timer(dueTime, intervalOrScheduler, scheduler) {
      if (dueTime === void 0) {
        dueTime = 0;
      }
      if (scheduler === void 0) {
        scheduler = async_1.async;
      }
      var intervalDuration = -1;
      if (intervalOrScheduler != null) {
        if (isScheduler_1.isScheduler(intervalOrScheduler)) {
          scheduler = intervalOrScheduler;
        } else {
          intervalDuration = intervalOrScheduler;
        }
      }
      return new Observable_1.Observable(function(subscriber) {
        var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
        if (due < 0) {
          due = 0;
        }
        var n = 0;
        return scheduler.schedule(function() {
          if (!subscriber.closed) {
            subscriber.next(n++);
            if (0 <= intervalDuration) {
              this.schedule(void 0, intervalDuration);
            } else {
              subscriber.complete();
            }
          }
        }, due);
      });
    }
    exports.timer = timer;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/interval.js
var require_interval = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/interval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.interval = void 0;
    var async_1 = require_async();
    var timer_1 = require_timer();
    function interval(period, scheduler) {
      if (period === void 0) {
        period = 0;
      }
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      if (period < 0) {
        period = 0;
      }
      return timer_1.timer(period, period, scheduler);
    }
    exports.interval = interval;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/merge.js
var require_merge2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var mergeAll_1 = require_mergeAll();
    var innerFrom_1 = require_innerFrom();
    var empty_1 = require_empty();
    var args_1 = require_args();
    var from_1 = require_from();
    function merge() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var concurrent = args_1.popNumber(args, Infinity);
      var sources = args;
      return !sources.length ? empty_1.EMPTY : sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler));
    }
    exports.merge = merge;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/never.js
var require_never = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/never.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.never = exports.NEVER = void 0;
    var Observable_1 = require_Observable();
    var noop_1 = require_noop();
    exports.NEVER = new Observable_1.Observable(noop_1.noop);
    function never() {
      return exports.NEVER;
    }
    exports.never = never;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js
var require_argsOrArgArray = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.argsOrArgArray = void 0;
    var isArray2 = Array.isArray;
    function argsOrArgArray(args) {
      return args.length === 1 && isArray2(args[0]) ? args[0] : args;
    }
    exports.argsOrArgArray = argsOrArgArray;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js
var require_onErrorResumeNext = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.onErrorResumeNext = void 0;
    var Observable_1 = require_Observable();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var innerFrom_1 = require_innerFrom();
    function onErrorResumeNext() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
      return new Observable_1.Observable(function(subscriber) {
        var sourceIndex = 0;
        var subscribeNext = function() {
          if (sourceIndex < nextSources.length) {
            var nextSource = void 0;
            try {
              nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
            } catch (err) {
              subscribeNext();
              return;
            }
            var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, void 0, noop_1.noop, noop_1.noop);
            nextSource.subscribe(innerSubscriber);
            innerSubscriber.add(subscribeNext);
          } else {
            subscriber.complete();
          }
        };
        subscribeNext();
      });
    }
    exports.onErrorResumeNext = onErrorResumeNext;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/pairs.js
var require_pairs = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/pairs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pairs = void 0;
    var from_1 = require_from();
    function pairs(obj, scheduler) {
      return from_1.from(Object.entries(obj), scheduler);
    }
    exports.pairs = pairs;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/not.js
var require_not = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/not.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.not = void 0;
    function not(pred, thisArg) {
      return function(value, index) {
        return !pred.call(thisArg, value, index);
      };
    }
    exports.not = not;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/filter.js
var require_filter = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/filter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filter = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function filter(predicate, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return predicate.call(thisArg, value, index++) && subscriber.next(value);
        }));
      });
    }
    exports.filter = filter;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/partition.js
var require_partition = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/partition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.partition = void 0;
    var not_1 = require_not();
    var filter_1 = require_filter();
    var innerFrom_1 = require_innerFrom();
    function partition(source, predicate, thisArg) {
      return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source))];
    }
    exports.partition = partition;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/race.js
var require_race = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/race.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.raceInit = exports.race = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function race() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      sources = argsOrArgArray_1.argsOrArgArray(sources);
      return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));
    }
    exports.race = race;
    function raceInit(sources) {
      return function(subscriber) {
        var subscriptions = [];
        var _loop_1 = function(i2) {
          subscriptions.push(innerFrom_1.innerFrom(sources[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (subscriptions) {
              for (var s = 0; s < subscriptions.length; s++) {
                s !== i2 && subscriptions[s].unsubscribe();
              }
              subscriptions = null;
            }
            subscriber.next(value);
          })));
        };
        for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
          _loop_1(i);
        }
      };
    }
    exports.raceInit = raceInit;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/range.js
var require_range = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/range.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.range = void 0;
    var Observable_1 = require_Observable();
    var empty_1 = require_empty();
    function range(start, count, scheduler) {
      if (count == null) {
        count = start;
        start = 0;
      }
      if (count <= 0) {
        return empty_1.EMPTY;
      }
      var end = count + start;
      return new Observable_1.Observable(scheduler ? function(subscriber) {
        var n = start;
        return scheduler.schedule(function() {
          if (n < end) {
            subscriber.next(n++);
            this.schedule();
          } else {
            subscriber.complete();
          }
        });
      } : function(subscriber) {
        var n = start;
        while (n < end && !subscriber.closed) {
          subscriber.next(n++);
        }
        subscriber.complete();
      });
    }
    exports.range = range;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/using.js
var require_using = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/using.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.using = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var empty_1 = require_empty();
    function using(resourceFactory, observableFactory) {
      return new Observable_1.Observable(function(subscriber) {
        var resource = resourceFactory();
        var result2 = observableFactory(resource);
        var source = result2 ? innerFrom_1.innerFrom(result2) : empty_1.EMPTY;
        source.subscribe(subscriber);
        return function() {
          if (resource) {
            resource.unsubscribe();
          }
        };
      });
    }
    exports.using = using;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/zip.js
var require_zip = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/zip.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zip = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var empty_1 = require_empty();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var args_1 = require_args();
    function zip() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      var sources = argsOrArgArray_1.argsOrArgArray(args);
      return sources.length ? new Observable_1.Observable(function(subscriber) {
        var buffers = sources.map(function() {
          return [];
        });
        var completed = sources.map(function() {
          return false;
        });
        subscriber.add(function() {
          buffers = completed = null;
        });
        var _loop_1 = function(sourceIndex2) {
          innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            buffers[sourceIndex2].push(value);
            if (buffers.every(function(buffer) {
              return buffer.length;
            })) {
              var result2 = buffers.map(function(buffer) {
                return buffer.shift();
              });
              subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray2([], __read2(result2))) : result2);
              if (buffers.some(function(buffer, i) {
                return !buffer.length && completed[i];
              })) {
                subscriber.complete();
              }
            }
          }, function() {
            completed[sourceIndex2] = true;
            !buffers[sourceIndex2].length && subscriber.complete();
          }));
        };
        for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
          _loop_1(sourceIndex);
        }
        return function() {
          buffers = completed = null;
        };
      }) : empty_1.EMPTY;
    }
    exports.zip = zip;
  }
});

// node_modules/rxjs/dist/cjs/internal/types.js
var require_types = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/audit.js
var require_audit = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/audit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.audit = void 0;
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function audit(durationSelector) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        var durationSubscriber = null;
        var isComplete = false;
        var endDuration = function() {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          durationSubscriber = null;
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
          isComplete && subscriber.complete();
        };
        var cleanupDuration = function() {
          durationSubscriber = null;
          isComplete && subscriber.complete();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          lastValue = value;
          if (!durationSubscriber) {
            innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
          }
        }, function() {
          isComplete = true;
          (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
        }));
      });
    }
    exports.audit = audit;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/auditTime.js
var require_auditTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/auditTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.auditTime = void 0;
    var async_1 = require_async();
    var audit_1 = require_audit();
    var timer_1 = require_timer();
    function auditTime(duration, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return audit_1.audit(function() {
        return timer_1.timer(duration, scheduler);
      });
    }
    exports.auditTime = auditTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/buffer.js
var require_buffer3 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/buffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buffer = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function buffer(closingNotifier) {
      return lift_1.operate(function(source, subscriber) {
        var currentBuffer = [];
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return currentBuffer.push(value);
        }, function() {
          subscriber.next(currentBuffer);
          subscriber.complete();
        }));
        innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          var b = currentBuffer;
          currentBuffer = [];
          subscriber.next(b);
        }, noop_1.noop));
        return function() {
          currentBuffer = null;
        };
      });
    }
    exports.buffer = buffer;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js
var require_bufferCount = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js"(exports) {
    "use strict";
    var __values3 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferCount = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    function bufferCount(bufferSize, startBufferEvery) {
      if (startBufferEvery === void 0) {
        startBufferEvery = null;
      }
      startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
      return lift_1.operate(function(source, subscriber) {
        var buffers = [];
        var count = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a, e_2, _b;
          var toEmit = null;
          if (count++ % startBufferEvery === 0) {
            buffers.push([]);
          }
          try {
            for (var buffers_1 = __values3(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
              var buffer = buffers_1_1.value;
              buffer.push(value);
              if (bufferSize <= buffer.length) {
                toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
                toEmit.push(buffer);
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
                _a.call(buffers_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          if (toEmit) {
            try {
              for (var toEmit_1 = __values3(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
                var buffer = toEmit_1_1.value;
                arrRemove_1.arrRemove(buffers, buffer);
                subscriber.next(buffer);
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return))
                  _b.call(toEmit_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
        }, function() {
          var e_3, _a;
          try {
            for (var buffers_2 = __values3(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
              var buffer = buffers_2_1.value;
              subscriber.next(buffer);
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return))
                _a.call(buffers_2);
            } finally {
              if (e_3)
                throw e_3.error;
            }
          }
          subscriber.complete();
        }, void 0, function() {
          buffers = null;
        }));
      });
    }
    exports.bufferCount = bufferCount;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js
var require_bufferTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js"(exports) {
    "use strict";
    var __values3 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferTime = void 0;
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    var async_1 = require_async();
    var args_1 = require_args();
    var executeSchedule_1 = require_executeSchedule();
    function bufferTime(bufferTimeSpan) {
      var _a, _b;
      var otherArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        otherArgs[_i - 1] = arguments[_i];
      }
      var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
      var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
      var maxBufferSize = otherArgs[1] || Infinity;
      return lift_1.operate(function(source, subscriber) {
        var bufferRecords = [];
        var restartOnEmit = false;
        var emit = function(record) {
          var buffer = record.buffer, subs = record.subs;
          subs.unsubscribe();
          arrRemove_1.arrRemove(bufferRecords, record);
          subscriber.next(buffer);
          restartOnEmit && startBuffer();
        };
        var startBuffer = function() {
          if (bufferRecords) {
            var subs = new Subscription_1.Subscription();
            subscriber.add(subs);
            var buffer = [];
            var record_1 = {
              buffer,
              subs
            };
            bufferRecords.push(record_1);
            executeSchedule_1.executeSchedule(subs, scheduler, function() {
              return emit(record_1);
            }, bufferTimeSpan);
          }
        };
        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
          executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
        } else {
          restartOnEmit = true;
        }
        startBuffer();
        var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a2;
          var recordsCopy = bufferRecords.slice();
          try {
            for (var recordsCopy_1 = __values3(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
              var record = recordsCopy_1_1.value;
              var buffer = record.buffer;
              buffer.push(value);
              maxBufferSize <= buffer.length && emit(record);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return))
                _a2.call(recordsCopy_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }, function() {
          while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
            subscriber.next(bufferRecords.shift().buffer);
          }
          bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
          subscriber.complete();
          subscriber.unsubscribe();
        }, void 0, function() {
          return bufferRecords = null;
        });
        source.subscribe(bufferTimeSubscriber);
      });
    }
    exports.bufferTime = bufferTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js
var require_bufferToggle = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js"(exports) {
    "use strict";
    var __values3 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferToggle = void 0;
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var arrRemove_1 = require_arrRemove();
    function bufferToggle(openings, closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var buffers = [];
        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
          var buffer = [];
          buffers.push(buffer);
          var closingSubscription = new Subscription_1.Subscription();
          var emitBuffer = function() {
            arrRemove_1.arrRemove(buffers, buffer);
            subscriber.next(buffer);
            closingSubscription.unsubscribe();
          };
          closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
        }, noop_1.noop));
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          try {
            for (var buffers_1 = __values3(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
              var buffer = buffers_1_1.value;
              buffer.push(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
                _a.call(buffers_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }, function() {
          while (buffers.length > 0) {
            subscriber.next(buffers.shift());
          }
          subscriber.complete();
        }));
      });
    }
    exports.bufferToggle = bufferToggle;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js
var require_bufferWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferWhen = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function bufferWhen(closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var buffer = null;
        var closingSubscriber = null;
        var openBuffer = function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          var b = buffer;
          buffer = [];
          b && subscriber.next(b);
          innerFrom_1.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop));
        };
        openBuffer();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return buffer === null || buffer === void 0 ? void 0 : buffer.push(value);
        }, function() {
          buffer && subscriber.next(buffer);
          subscriber.complete();
        }, void 0, function() {
          return buffer = closingSubscriber = null;
        }));
      });
    }
    exports.bufferWhen = bufferWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/catchError.js
var require_catchError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/catchError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.catchError = void 0;
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var lift_1 = require_lift();
    function catchError(selector) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub = null;
        var syncUnsub = false;
        var handledResult;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
          handledResult = innerFrom_1.innerFrom(selector(err, catchError(selector)(source)));
          if (innerSub) {
            innerSub.unsubscribe();
            innerSub = null;
            handledResult.subscribe(subscriber);
          } else {
            syncUnsub = true;
          }
        }));
        if (syncUnsub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        }
      });
    }
    exports.catchError = catchError;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js
var require_scanInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scanInternals = void 0;
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
      return function(source, subscriber) {
        var hasState = hasSeed;
        var state = seed;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var i = index++;
          state = hasState ? accumulator(state, value, i) : (hasState = true, value);
          emitOnNext && subscriber.next(state);
        }, emitBeforeComplete && function() {
          hasState && subscriber.next(state);
          subscriber.complete();
        }));
      };
    }
    exports.scanInternals = scanInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/reduce.js
var require_reduce = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/reduce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reduce = void 0;
    var scanInternals_1 = require_scanInternals();
    var lift_1 = require_lift();
    function reduce(accumulator, seed) {
      return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
    }
    exports.reduce = reduce;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/toArray.js
var require_toArray = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/toArray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toArray = void 0;
    var reduce_1 = require_reduce();
    var lift_1 = require_lift();
    var arrReducer = function(arr, value) {
      return arr.push(value), arr;
    };
    function toArray() {
      return lift_1.operate(function(source, subscriber) {
        reduce_1.reduce(arrReducer, [])(source).subscribe(subscriber);
      });
    }
    exports.toArray = toArray;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js
var require_joinAllInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinAllInternals = void 0;
    var identity_1 = require_identity();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var pipe_1 = require_pipe();
    var mergeMap_1 = require_mergeMap();
    var toArray_1 = require_toArray();
    function joinAllInternals(joinFn, project) {
      return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function(sources) {
        return joinFn(sources);
      }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
    }
    exports.joinAllInternals = joinAllInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js
var require_combineLatestAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineLatestAll = void 0;
    var combineLatest_1 = require_combineLatest();
    var joinAllInternals_1 = require_joinAllInternals();
    function combineLatestAll(project) {
      return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
    }
    exports.combineLatestAll = combineLatestAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineAll.js
var require_combineAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineAll = void 0;
    var combineLatestAll_1 = require_combineLatestAll();
    exports.combineAll = combineLatestAll_1.combineLatestAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js
var require_combineLatest2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineLatest = void 0;
    var combineLatest_1 = require_combineLatest();
    var lift_1 = require_lift();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var pipe_1 = require_pipe();
    var args_1 = require_args();
    function combineLatest() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      return resultSelector ? pipe_1.pipe(combineLatest.apply(void 0, __spreadArray2([], __read2(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1.operate(function(source, subscriber) {
        combineLatest_1.combineLatestInit(__spreadArray2([source], __read2(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);
      });
    }
    exports.combineLatest = combineLatest;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js
var require_combineLatestWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineLatestWith = void 0;
    var combineLatest_1 = require_combineLatest2();
    function combineLatestWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return combineLatest_1.combineLatest.apply(void 0, __spreadArray2([], __read2(otherSources)));
    }
    exports.combineLatestWith = combineLatestWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMap.js
var require_concatMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatMap = void 0;
    var mergeMap_1 = require_mergeMap();
    var isFunction_1 = require_isFunction();
    function concatMap(project, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
    }
    exports.concatMap = concatMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js
var require_concatMapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatMapTo = void 0;
    var concatMap_1 = require_concatMap();
    var isFunction_1 = require_isFunction();
    function concatMapTo(innerObservable, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
        return innerObservable;
      }, resultSelector) : concatMap_1.concatMap(function() {
        return innerObservable;
      });
    }
    exports.concatMapTo = concatMapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concat.js
var require_concat2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concat.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concat = void 0;
    var lift_1 = require_lift();
    var concatAll_1 = require_concatAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function concat() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      return lift_1.operate(function(source, subscriber) {
        concatAll_1.concatAll()(from_1.from(__spreadArray2([source], __read2(args)), scheduler)).subscribe(subscriber);
      });
    }
    exports.concat = concat;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatWith.js
var require_concatWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatWith.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatWith = void 0;
    var concat_1 = require_concat2();
    function concatWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return concat_1.concat.apply(void 0, __spreadArray2([], __read2(otherSources)));
    }
    exports.concatWith = concatWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js
var require_fromSubscribable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromSubscribable = void 0;
    var Observable_1 = require_Observable();
    function fromSubscribable(subscribable) {
      return new Observable_1.Observable(function(subscriber) {
        return subscribable.subscribe(subscriber);
      });
    }
    exports.fromSubscribable = fromSubscribable;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/connect.js
var require_connect = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/connect.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.connect = void 0;
    var Subject_1 = require_Subject();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var fromSubscribable_1 = require_fromSubscribable();
    var DEFAULT_CONFIG = {
      connector: function() {
        return new Subject_1.Subject();
      }
    };
    function connect(selector, config) {
      if (config === void 0) {
        config = DEFAULT_CONFIG;
      }
      var connector = config.connector;
      return lift_1.operate(function(source, subscriber) {
        var subject = connector();
        innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
        subscriber.add(source.subscribe(subject));
      });
    }
    exports.connect = connect;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/count.js
var require_count = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/count.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.count = void 0;
    var reduce_1 = require_reduce();
    function count(predicate) {
      return reduce_1.reduce(function(total, value, i) {
        return !predicate || predicate(value, i) ? total + 1 : total;
      }, 0);
    }
    exports.count = count;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/debounce.js
var require_debounce = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/debounce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.debounce = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function debounce(durationSelector) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        var durationSubscriber = null;
        var emit = function() {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          durationSubscriber = null;
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          hasValue = true;
          lastValue = value;
          durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
          innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
        }, function() {
          emit();
          subscriber.complete();
        }, void 0, function() {
          lastValue = durationSubscriber = null;
        }));
      });
    }
    exports.debounce = debounce;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js
var require_debounceTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.debounceTime = void 0;
    var async_1 = require_async();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function debounceTime(dueTime, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return lift_1.operate(function(source, subscriber) {
        var activeTask = null;
        var lastValue = null;
        var lastTime = null;
        var emit = function() {
          if (activeTask) {
            activeTask.unsubscribe();
            activeTask = null;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        };
        function emitWhenIdle() {
          var targetTime = lastTime + dueTime;
          var now = scheduler.now();
          if (now < targetTime) {
            activeTask = this.schedule(void 0, targetTime - now);
            subscriber.add(activeTask);
            return;
          }
          emit();
        }
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          lastValue = value;
          lastTime = scheduler.now();
          if (!activeTask) {
            activeTask = scheduler.schedule(emitWhenIdle, dueTime);
            subscriber.add(activeTask);
          }
        }, function() {
          emit();
          subscriber.complete();
        }, void 0, function() {
          lastValue = activeTask = null;
        }));
      });
    }
    exports.debounceTime = debounceTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js
var require_defaultIfEmpty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultIfEmpty = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function defaultIfEmpty(defaultValue) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          subscriber.next(value);
        }, function() {
          if (!hasValue) {
            subscriber.next(defaultValue);
          }
          subscriber.complete();
        }));
      });
    }
    exports.defaultIfEmpty = defaultIfEmpty;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/take.js
var require_take = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/take.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.take = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function take(count) {
      return count <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var seen = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (++seen <= count) {
            subscriber.next(value);
            if (count <= seen) {
              subscriber.complete();
            }
          }
        }));
      });
    }
    exports.take = take;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js
var require_ignoreElements = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ignoreElements = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    function ignoreElements() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
      });
    }
    exports.ignoreElements = ignoreElements;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mapTo.js
var require_mapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mapTo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapTo = void 0;
    var map_1 = require_map();
    function mapTo(value) {
      return map_1.map(function() {
        return value;
      });
    }
    exports.mapTo = mapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js
var require_delayWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.delayWhen = void 0;
    var concat_1 = require_concat();
    var take_1 = require_take();
    var ignoreElements_1 = require_ignoreElements();
    var mapTo_1 = require_mapTo();
    var mergeMap_1 = require_mergeMap();
    var innerFrom_1 = require_innerFrom();
    function delayWhen(delayDurationSelector, subscriptionDelay) {
      if (subscriptionDelay) {
        return function(source) {
          return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
        };
      }
      return mergeMap_1.mergeMap(function(value, index) {
        return innerFrom_1.innerFrom(delayDurationSelector(value, index)).pipe(take_1.take(1), mapTo_1.mapTo(value));
      });
    }
    exports.delayWhen = delayWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/delay.js
var require_delay = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/delay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.delay = void 0;
    var async_1 = require_async();
    var delayWhen_1 = require_delayWhen();
    var timer_1 = require_timer();
    function delay3(due, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      var duration = timer_1.timer(due, scheduler);
      return delayWhen_1.delayWhen(function() {
        return duration;
      });
    }
    exports.delay = delay3;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js
var require_dematerialize = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dematerialize = void 0;
    var Notification_1 = require_Notification();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function dematerialize() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(notification) {
          return Notification_1.observeNotification(notification, subscriber);
        }));
      });
    }
    exports.dematerialize = dematerialize;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinct.js
var require_distinct = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/distinct.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distinct = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var innerFrom_1 = require_innerFrom();
    function distinct(keySelector, flushes) {
      return lift_1.operate(function(source, subscriber) {
        var distinctKeys = /* @__PURE__ */ new Set();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var key = keySelector ? keySelector(value) : value;
          if (!distinctKeys.has(key)) {
            distinctKeys.add(key);
            subscriber.next(value);
          }
        }));
        flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          return distinctKeys.clear();
        }, noop_1.noop));
      });
    }
    exports.distinct = distinct;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js
var require_distinctUntilChanged = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distinctUntilChanged = void 0;
    var identity_1 = require_identity();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function distinctUntilChanged(comparator, keySelector) {
      if (keySelector === void 0) {
        keySelector = identity_1.identity;
      }
      comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
      return lift_1.operate(function(source, subscriber) {
        var previousKey;
        var first = true;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var currentKey = keySelector(value);
          if (first || !comparator(previousKey, currentKey)) {
            first = false;
            previousKey = currentKey;
            subscriber.next(value);
          }
        }));
      });
    }
    exports.distinctUntilChanged = distinctUntilChanged;
    function defaultCompare(a, b) {
      return a === b;
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js
var require_distinctUntilKeyChanged = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distinctUntilKeyChanged = void 0;
    var distinctUntilChanged_1 = require_distinctUntilChanged();
    function distinctUntilKeyChanged(key, compare) {
      return distinctUntilChanged_1.distinctUntilChanged(function(x, y) {
        return compare ? compare(x[key], y[key]) : x[key] === y[key];
      });
    }
    exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js
var require_throwIfEmpty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throwIfEmpty = void 0;
    var EmptyError_1 = require_EmptyError();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function throwIfEmpty(errorFactory) {
      if (errorFactory === void 0) {
        errorFactory = defaultErrorFactory;
      }
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          subscriber.next(value);
        }, function() {
          return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
        }));
      });
    }
    exports.throwIfEmpty = throwIfEmpty;
    function defaultErrorFactory() {
      return new EmptyError_1.EmptyError();
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/elementAt.js
var require_elementAt = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/elementAt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.elementAt = void 0;
    var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
    var filter_1 = require_filter();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var take_1 = require_take();
    function elementAt(index, defaultValue) {
      if (index < 0) {
        throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
      }
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(filter_1.filter(function(v, i) {
          return i === index;
        }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
        }));
      };
    }
    exports.elementAt = elementAt;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/endWith.js
var require_endWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/endWith.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.endWith = void 0;
    var concat_1 = require_concat();
    var of_1 = require_of();
    function endWith() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      return function(source) {
        return concat_1.concat(source, of_1.of.apply(void 0, __spreadArray2([], __read2(values))));
      };
    }
    exports.endWith = endWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/every.js
var require_every = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/every.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.every = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function every(predicate, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (!predicate.call(thisArg, value, index++, source)) {
            subscriber.next(false);
            subscriber.complete();
          }
        }, function() {
          subscriber.next(true);
          subscriber.complete();
        }));
      });
    }
    exports.every = every;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js
var require_exhaustMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exhaustMap = void 0;
    var map_1 = require_map();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function exhaustMap(project, resultSelector) {
      if (resultSelector) {
        return function(source) {
          return source.pipe(exhaustMap(function(a, i) {
            return innerFrom_1.innerFrom(project(a, i)).pipe(map_1.map(function(b, ii) {
              return resultSelector(a, b, i, ii);
            }));
          }));
        };
      }
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        var innerSub = null;
        var isComplete = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(outerValue) {
          if (!innerSub) {
            innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
              innerSub = null;
              isComplete && subscriber.complete();
            });
            innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
          }
        }, function() {
          isComplete = true;
          !innerSub && subscriber.complete();
        }));
      });
    }
    exports.exhaustMap = exhaustMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js
var require_exhaustAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exhaustAll = void 0;
    var exhaustMap_1 = require_exhaustMap();
    var identity_1 = require_identity();
    function exhaustAll() {
      return exhaustMap_1.exhaustMap(identity_1.identity);
    }
    exports.exhaustAll = exhaustAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaust.js
var require_exhaust = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/exhaust.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exhaust = void 0;
    var exhaustAll_1 = require_exhaustAll();
    exports.exhaust = exhaustAll_1.exhaustAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/expand.js
var require_expand = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/expand.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.expand = void 0;
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    function expand(project, concurrent, scheduler) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
      return lift_1.operate(function(source, subscriber) {
        return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, void 0, true, scheduler);
      });
    }
    exports.expand = expand;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/finalize.js
var require_finalize = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/finalize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.finalize = void 0;
    var lift_1 = require_lift();
    function finalize(callback) {
      return lift_1.operate(function(source, subscriber) {
        try {
          source.subscribe(subscriber);
        } finally {
          subscriber.add(callback);
        }
      });
    }
    exports.finalize = finalize;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/find.js
var require_find = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/find.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFind = exports.find = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function find(predicate, thisArg) {
      return lift_1.operate(createFind(predicate, thisArg, "value"));
    }
    exports.find = find;
    function createFind(predicate, thisArg, emit) {
      var findIndex = emit === "index";
      return function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var i = index++;
          if (predicate.call(thisArg, value, i, source)) {
            subscriber.next(findIndex ? i : value);
            subscriber.complete();
          }
        }, function() {
          subscriber.next(findIndex ? -1 : void 0);
          subscriber.complete();
        }));
      };
    }
    exports.createFind = createFind;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/findIndex.js
var require_findIndex = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/findIndex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findIndex = void 0;
    var lift_1 = require_lift();
    var find_1 = require_find();
    function findIndex(predicate, thisArg) {
      return lift_1.operate(find_1.createFind(predicate, thisArg, "index"));
    }
    exports.findIndex = findIndex;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/first.js
var require_first = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/first.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.first = void 0;
    var EmptyError_1 = require_EmptyError();
    var filter_1 = require_filter();
    var take_1 = require_take();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var identity_1 = require_identity();
    function first(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(predicate ? filter_1.filter(function(v, i) {
          return predicate(v, i, source);
        }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new EmptyError_1.EmptyError();
        }));
      };
    }
    exports.first = first;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/groupBy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.groupBy = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function groupBy(keySelector, elementOrOptions, duration, connector) {
      return lift_1.operate(function(source, subscriber) {
        var element;
        if (!elementOrOptions || typeof elementOrOptions === "function") {
          element = elementOrOptions;
        } else {
          duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
        }
        var groups = /* @__PURE__ */ new Map();
        var notify = function(cb) {
          groups.forEach(cb);
          cb(subscriber);
        };
        var handleError = function(err) {
          return notify(function(consumer) {
            return consumer.error(err);
          });
        };
        var activeGroups = 0;
        var teardownAttempted = false;
        var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function(value) {
          try {
            var key_1 = keySelector(value);
            var group_1 = groups.get(key_1);
            if (!group_1) {
              groups.set(key_1, group_1 = connector ? connector() : new Subject_1.Subject());
              var grouped = createGroupedObservable(key_1, group_1);
              subscriber.next(grouped);
              if (duration) {
                var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function() {
                  group_1.complete();
                  durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
                }, void 0, void 0, function() {
                  return groups.delete(key_1);
                });
                groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
              }
            }
            group_1.next(element ? element(value) : value);
          } catch (err) {
            handleError(err);
          }
        }, function() {
          return notify(function(consumer) {
            return consumer.complete();
          });
        }, handleError, function() {
          return groups.clear();
        }, function() {
          teardownAttempted = true;
          return activeGroups === 0;
        });
        source.subscribe(groupBySourceSubscriber);
        function createGroupedObservable(key, groupSubject) {
          var result2 = new Observable_1.Observable(function(groupSubscriber) {
            activeGroups++;
            var innerSub = groupSubject.subscribe(groupSubscriber);
            return function() {
              innerSub.unsubscribe();
              --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
            };
          });
          result2.key = key;
          return result2;
        }
      });
    }
    exports.groupBy = groupBy;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmpty = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function isEmpty2() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          subscriber.next(false);
          subscriber.complete();
        }, function() {
          subscriber.next(true);
          subscriber.complete();
        }));
      });
    }
    exports.isEmpty = isEmpty2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/takeLast.js
var require_takeLast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/takeLast.js"(exports) {
    "use strict";
    var __values3 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.takeLast = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function takeLast(count) {
      return count <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var buffer = [];
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          buffer.push(value);
          count < buffer.length && buffer.shift();
        }, function() {
          var e_1, _a;
          try {
            for (var buffer_1 = __values3(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
              var value = buffer_1_1.value;
              subscriber.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return))
                _a.call(buffer_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          subscriber.complete();
        }, void 0, function() {
          buffer = null;
        }));
      });
    }
    exports.takeLast = takeLast;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/last.js
var require_last = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/last.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.last = void 0;
    var EmptyError_1 = require_EmptyError();
    var filter_1 = require_filter();
    var takeLast_1 = require_takeLast();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var identity_1 = require_identity();
    function last(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(predicate ? filter_1.filter(function(v, i) {
          return predicate(v, i, source);
        }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new EmptyError_1.EmptyError();
        }));
      };
    }
    exports.last = last;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/materialize.js
var require_materialize = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/materialize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.materialize = void 0;
    var Notification_1 = require_Notification();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function materialize() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          subscriber.next(Notification_1.Notification.createNext(value));
        }, function() {
          subscriber.next(Notification_1.Notification.createComplete());
          subscriber.complete();
        }, function(err) {
          subscriber.next(Notification_1.Notification.createError(err));
          subscriber.complete();
        }));
      });
    }
    exports.materialize = materialize;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/max.js
var require_max = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/max.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.max = void 0;
    var reduce_1 = require_reduce();
    var isFunction_1 = require_isFunction();
    function max2(comparer) {
      return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
        return comparer(x, y) > 0 ? x : y;
      } : function(x, y) {
        return x > y ? x : y;
      });
    }
    exports.max = max2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/flatMap.js
var require_flatMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/flatMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.flatMap = void 0;
    var mergeMap_1 = require_mergeMap();
    exports.flatMap = mergeMap_1.mergeMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js
var require_mergeMapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeMapTo = void 0;
    var mergeMap_1 = require_mergeMap();
    var isFunction_1 = require_isFunction();
    function mergeMapTo(innerObservable, resultSelector, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      if (isFunction_1.isFunction(resultSelector)) {
        return mergeMap_1.mergeMap(function() {
          return innerObservable;
        }, resultSelector, concurrent);
      }
      if (typeof resultSelector === "number") {
        concurrent = resultSelector;
      }
      return mergeMap_1.mergeMap(function() {
        return innerObservable;
      }, concurrent);
    }
    exports.mergeMapTo = mergeMapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js
var require_mergeScan = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeScan = void 0;
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    function mergeScan(accumulator, seed, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      return lift_1.operate(function(source, subscriber) {
        var state = seed;
        return mergeInternals_1.mergeInternals(source, subscriber, function(value, index) {
          return accumulator(state, value, index);
        }, concurrent, function(value) {
          state = value;
        }, false, void 0, function() {
          return state = null;
        });
      });
    }
    exports.mergeScan = mergeScan;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/merge.js
var require_merge3 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/merge.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var lift_1 = require_lift();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var mergeAll_1 = require_mergeAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function merge() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var concurrent = args_1.popNumber(args, Infinity);
      args = argsOrArgArray_1.argsOrArgArray(args);
      return lift_1.operate(function(source, subscriber) {
        mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray2([source], __read2(args)), scheduler)).subscribe(subscriber);
      });
    }
    exports.merge = merge;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js
var require_mergeWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeWith = void 0;
    var merge_1 = require_merge3();
    function mergeWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return merge_1.merge.apply(void 0, __spreadArray2([], __read2(otherSources)));
    }
    exports.mergeWith = mergeWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/min.js
var require_min = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/min.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.min = void 0;
    var reduce_1 = require_reduce();
    var isFunction_1 = require_isFunction();
    function min2(comparer) {
      return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
        return comparer(x, y) < 0 ? x : y;
      } : function(x, y) {
        return x < y ? x : y;
      });
    }
    exports.min = min2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/multicast.js
var require_multicast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/multicast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multicast = void 0;
    var ConnectableObservable_1 = require_ConnectableObservable();
    var isFunction_1 = require_isFunction();
    var connect_1 = require_connect();
    function multicast(subjectOrSubjectFactory, selector) {
      var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
        return subjectOrSubjectFactory;
      };
      if (isFunction_1.isFunction(selector)) {
        return connect_1.connect(selector, {
          connector: subjectFactory
        });
      }
      return function(source) {
        return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory);
      };
    }
    exports.multicast = multicast;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js
var require_onErrorResumeNextWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.onErrorResumeNext = exports.onErrorResumeNextWith = void 0;
    var argsOrArgArray_1 = require_argsOrArgArray();
    var onErrorResumeNext_1 = require_onErrorResumeNext();
    function onErrorResumeNextWith() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
      return function(source) {
        return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, __spreadArray2([source], __read2(nextSources)));
      };
    }
    exports.onErrorResumeNextWith = onErrorResumeNextWith;
    exports.onErrorResumeNext = onErrorResumeNextWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/pairwise.js
var require_pairwise = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/pairwise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pairwise = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function pairwise() {
      return lift_1.operate(function(source, subscriber) {
        var prev;
        var hasPrev = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var p = prev;
          prev = value;
          hasPrev && subscriber.next([p, value]);
          hasPrev = true;
        }));
      });
    }
    exports.pairwise = pairwise;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/pluck.js
var require_pluck = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/pluck.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pluck = void 0;
    var map_1 = require_map();
    function pluck() {
      var properties = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i] = arguments[_i];
      }
      var length2 = properties.length;
      if (length2 === 0) {
        throw new Error("list of properties cannot be empty.");
      }
      return map_1.map(function(x) {
        var currentProp = x;
        for (var i = 0; i < length2; i++) {
          var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
          if (typeof p !== "undefined") {
            currentProp = p;
          } else {
            return void 0;
          }
        }
        return currentProp;
      });
    }
    exports.pluck = pluck;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publish.js
var require_publish = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publish.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publish = void 0;
    var Subject_1 = require_Subject();
    var multicast_1 = require_multicast();
    var connect_1 = require_connect();
    function publish(selector) {
      return selector ? function(source) {
        return connect_1.connect(selector)(source);
      } : function(source) {
        return multicast_1.multicast(new Subject_1.Subject())(source);
      };
    }
    exports.publish = publish;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js
var require_publishBehavior = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publishBehavior = void 0;
    var BehaviorSubject_1 = require_BehaviorSubject();
    var ConnectableObservable_1 = require_ConnectableObservable();
    function publishBehavior(initialValue) {
      return function(source) {
        var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
        return new ConnectableObservable_1.ConnectableObservable(source, function() {
          return subject;
        });
      };
    }
    exports.publishBehavior = publishBehavior;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publishLast.js
var require_publishLast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publishLast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publishLast = void 0;
    var AsyncSubject_1 = require_AsyncSubject();
    var ConnectableObservable_1 = require_ConnectableObservable();
    function publishLast() {
      return function(source) {
        var subject = new AsyncSubject_1.AsyncSubject();
        return new ConnectableObservable_1.ConnectableObservable(source, function() {
          return subject;
        });
      };
    }
    exports.publishLast = publishLast;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js
var require_publishReplay = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publishReplay = void 0;
    var ReplaySubject_1 = require_ReplaySubject();
    var multicast_1 = require_multicast();
    var isFunction_1 = require_isFunction();
    function publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
      if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
        timestampProvider = selectorOrScheduler;
      }
      var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
      return function(source) {
        return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source);
      };
    }
    exports.publishReplay = publishReplay;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/raceWith.js
var require_raceWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/raceWith.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.raceWith = void 0;
    var race_1 = require_race();
    var lift_1 = require_lift();
    var identity_1 = require_identity();
    function raceWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return !otherSources.length ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        race_1.raceInit(__spreadArray2([source], __read2(otherSources)))(subscriber);
      });
    }
    exports.raceWith = raceWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/repeat.js
var require_repeat = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/repeat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.repeat = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var timer_1 = require_timer();
    function repeat2(countOrConfig) {
      var _a;
      var count = Infinity;
      var delay3;
      if (countOrConfig != null) {
        if (typeof countOrConfig === "object") {
          _a = countOrConfig.count, count = _a === void 0 ? Infinity : _a, delay3 = countOrConfig.delay;
        } else {
          count = countOrConfig;
        }
      }
      return count <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var soFar = 0;
        var sourceSub;
        var resubscribe = function() {
          sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
          sourceSub = null;
          if (delay3 != null) {
            var notifier = typeof delay3 === "number" ? timer_1.timer(delay3) : innerFrom_1.innerFrom(delay3(soFar));
            var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              subscribeToSource();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            subscribeToSource();
          }
        };
        var subscribeToSource = function() {
          var syncUnsub = false;
          sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
            if (++soFar < count) {
              if (sourceSub) {
                resubscribe();
              } else {
                syncUnsub = true;
              }
            } else {
              subscriber.complete();
            }
          }));
          if (syncUnsub) {
            resubscribe();
          }
        };
        subscribeToSource();
      });
    }
    exports.repeat = repeat2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js
var require_repeatWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.repeatWhen = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function repeatWhen(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub;
        var syncResub = false;
        var completions$;
        var isNotifierComplete = false;
        var isMainComplete = false;
        var checkComplete = function() {
          return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
        };
        var getCompletionSubject = function() {
          if (!completions$) {
            completions$ = new Subject_1.Subject();
            innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              if (innerSub) {
                subscribeForRepeatWhen();
              } else {
                syncResub = true;
              }
            }, function() {
              isNotifierComplete = true;
              checkComplete();
            }));
          }
          return completions$;
        };
        var subscribeForRepeatWhen = function() {
          isMainComplete = false;
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
            isMainComplete = true;
            !checkComplete() && getCompletionSubject().next();
          }));
          if (syncResub) {
            innerSub.unsubscribe();
            innerSub = null;
            syncResub = false;
            subscribeForRepeatWhen();
          }
        };
        subscribeForRepeatWhen();
      });
    }
    exports.repeatWhen = repeatWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/retry.js
var require_retry = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/retry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.retry = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var identity_1 = require_identity();
    var timer_1 = require_timer();
    var innerFrom_1 = require_innerFrom();
    function retry(configOrCount) {
      if (configOrCount === void 0) {
        configOrCount = Infinity;
      }
      var config;
      if (configOrCount && typeof configOrCount === "object") {
        config = configOrCount;
      } else {
        config = {
          count: configOrCount
        };
      }
      var _a = config.count, count = _a === void 0 ? Infinity : _a, delay3 = config.delay, _b = config.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
      return count <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        var soFar = 0;
        var innerSub;
        var subscribeForRetry = function() {
          var syncUnsub = false;
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (resetOnSuccess) {
              soFar = 0;
            }
            subscriber.next(value);
          }, void 0, function(err) {
            if (soFar++ < count) {
              var resub_1 = function() {
                if (innerSub) {
                  innerSub.unsubscribe();
                  innerSub = null;
                  subscribeForRetry();
                } else {
                  syncUnsub = true;
                }
              };
              if (delay3 != null) {
                var notifier = typeof delay3 === "number" ? timer_1.timer(delay3) : innerFrom_1.innerFrom(delay3(err, soFar));
                var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                  notifierSubscriber_1.unsubscribe();
                  resub_1();
                }, function() {
                  subscriber.complete();
                });
                notifier.subscribe(notifierSubscriber_1);
              } else {
                resub_1();
              }
            } else {
              subscriber.error(err);
            }
          }));
          if (syncUnsub) {
            innerSub.unsubscribe();
            innerSub = null;
            subscribeForRetry();
          }
        };
        subscribeForRetry();
      });
    }
    exports.retry = retry;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js
var require_retryWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.retryWhen = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function retryWhen(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub;
        var syncResub = false;
        var errors$;
        var subscribeForRetryWhen = function() {
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
            if (!errors$) {
              errors$ = new Subject_1.Subject();
              innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                return innerSub ? subscribeForRetryWhen() : syncResub = true;
              }));
            }
            if (errors$) {
              errors$.next(err);
            }
          }));
          if (syncResub) {
            innerSub.unsubscribe();
            innerSub = null;
            syncResub = false;
            subscribeForRetryWhen();
          }
        };
        subscribeForRetryWhen();
      });
    }
    exports.retryWhen = retryWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/sample.js
var require_sample = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/sample.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sample = void 0;
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function sample(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          lastValue = value;
        }));
        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        }, noop_1.noop));
      });
    }
    exports.sample = sample;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js
var require_sampleTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sampleTime = void 0;
    var async_1 = require_async();
    var sample_1 = require_sample();
    var interval_1 = require_interval();
    function sampleTime(period, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return sample_1.sample(interval_1.interval(period, scheduler));
    }
    exports.sampleTime = sampleTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/scan.js
var require_scan = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/scan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scan = void 0;
    var lift_1 = require_lift();
    var scanInternals_1 = require_scanInternals();
    function scan(accumulator, seed) {
      return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
    }
    exports.scan = scan;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js
var require_sequenceEqual = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sequenceEqual = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function sequenceEqual(compareTo, comparator) {
      if (comparator === void 0) {
        comparator = function(a, b) {
          return a === b;
        };
      }
      return lift_1.operate(function(source, subscriber) {
        var aState = createState();
        var bState = createState();
        var emit = function(isEqual) {
          subscriber.next(isEqual);
          subscriber.complete();
        };
        var createSubscriber = function(selfState, otherState) {
          var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(a) {
            var buffer = otherState.buffer, complete = otherState.complete;
            if (buffer.length === 0) {
              complete ? emit(false) : selfState.buffer.push(a);
            } else {
              !comparator(a, buffer.shift()) && emit(false);
            }
          }, function() {
            selfState.complete = true;
            var complete = otherState.complete, buffer = otherState.buffer;
            complete && emit(buffer.length === 0);
            sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
          });
          return sequenceEqualSubscriber;
        };
        source.subscribe(createSubscriber(aState, bState));
        innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
      });
    }
    exports.sequenceEqual = sequenceEqual;
    function createState() {
      return {
        buffer: [],
        complete: false
      };
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/share.js
var require_share = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/share.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.share = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var Subscriber_1 = require_Subscriber();
    var lift_1 = require_lift();
    function share(options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.connector, connector = _a === void 0 ? function() {
        return new Subject_1.Subject();
      } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
      return function(wrapperSource) {
        var connection;
        var resetConnection;
        var subject;
        var refCount = 0;
        var hasCompleted = false;
        var hasErrored = false;
        var cancelReset = function() {
          resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
          resetConnection = void 0;
        };
        var reset = function() {
          cancelReset();
          connection = subject = void 0;
          hasCompleted = hasErrored = false;
        };
        var resetAndUnsubscribe = function() {
          var conn = connection;
          reset();
          conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
        };
        return lift_1.operate(function(source, subscriber) {
          refCount++;
          if (!hasErrored && !hasCompleted) {
            cancelReset();
          }
          var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
          subscriber.add(function() {
            refCount--;
            if (refCount === 0 && !hasErrored && !hasCompleted) {
              resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
            }
          });
          dest.subscribe(subscriber);
          if (!connection && refCount > 0) {
            connection = new Subscriber_1.SafeSubscriber({
              next: function(value) {
                return dest.next(value);
              },
              error: function(err) {
                hasErrored = true;
                cancelReset();
                resetConnection = handleReset(reset, resetOnError, err);
                dest.error(err);
              },
              complete: function() {
                hasCompleted = true;
                cancelReset();
                resetConnection = handleReset(reset, resetOnComplete);
                dest.complete();
              }
            });
            innerFrom_1.innerFrom(source).subscribe(connection);
          }
        })(wrapperSource);
      };
    }
    exports.share = share;
    function handleReset(reset, on) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      if (on === true) {
        reset();
        return;
      }
      if (on === false) {
        return;
      }
      var onSubscriber = new Subscriber_1.SafeSubscriber({
        next: function() {
          onSubscriber.unsubscribe();
          reset();
        }
      });
      return innerFrom_1.innerFrom(on.apply(void 0, __spreadArray2([], __read2(args)))).subscribe(onSubscriber);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js
var require_shareReplay = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shareReplay = void 0;
    var ReplaySubject_1 = require_ReplaySubject();
    var share_1 = require_share();
    function shareReplay(configOrBufferSize, windowTime, scheduler) {
      var _a, _b, _c;
      var bufferSize;
      var refCount = false;
      if (configOrBufferSize && typeof configOrBufferSize === "object") {
        _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
      } else {
        bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
      }
      return share_1.share({
        connector: function() {
          return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
        },
        resetOnError: true,
        resetOnComplete: false,
        resetOnRefCountZero: refCount
      });
    }
    exports.shareReplay = shareReplay;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/single.js
var require_single = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/single.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.single = void 0;
    var EmptyError_1 = require_EmptyError();
    var SequenceError_1 = require_SequenceError();
    var NotFoundError_1 = require_NotFoundError();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function single(predicate) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var singleValue;
        var seenValue = false;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          seenValue = true;
          if (!predicate || predicate(value, index++, source)) {
            hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
            hasValue = true;
            singleValue = value;
          }
        }, function() {
          if (hasValue) {
            subscriber.next(singleValue);
            subscriber.complete();
          } else {
            subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError());
          }
        }));
      });
    }
    exports.single = single;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skip.js
var require_skip = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skip.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skip = void 0;
    var filter_1 = require_filter();
    function skip(count) {
      return filter_1.filter(function(_, index) {
        return count <= index;
      });
    }
    exports.skip = skip;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skipLast.js
var require_skipLast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skipLast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skipLast = void 0;
    var identity_1 = require_identity();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function skipLast(skipCount) {
      return skipCount <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        var ring = new Array(skipCount);
        var seen = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var valueIndex = seen++;
          if (valueIndex < skipCount) {
            ring[valueIndex] = value;
          } else {
            var index = valueIndex % skipCount;
            var oldValue = ring[index];
            ring[index] = value;
            subscriber.next(oldValue);
          }
        }));
        return function() {
          ring = null;
        };
      });
    }
    exports.skipLast = skipLast;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js
var require_skipUntil = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skipUntil = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var noop_1 = require_noop();
    function skipUntil(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var taking = false;
        var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
          taking = true;
        }, noop_1.noop);
        innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return taking && subscriber.next(value);
        }));
      });
    }
    exports.skipUntil = skipUntil;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js
var require_skipWhile = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skipWhile = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function skipWhile(predicate) {
      return lift_1.operate(function(source, subscriber) {
        var taking = false;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
        }));
      });
    }
    exports.skipWhile = skipWhile;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/startWith.js
var require_startWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/startWith.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.startWith = void 0;
    var concat_1 = require_concat();
    var args_1 = require_args();
    var lift_1 = require_lift();
    function startWith() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(values);
      return lift_1.operate(function(source, subscriber) {
        (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
      });
    }
    exports.startWith = startWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMap.js
var require_switchMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchMap = void 0;
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function switchMap(project, resultSelector) {
      return lift_1.operate(function(source, subscriber) {
        var innerSubscriber = null;
        var index = 0;
        var isComplete = false;
        var checkComplete = function() {
          return isComplete && !innerSubscriber && subscriber.complete();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
          var innerIndex = 0;
          var outerIndex = index++;
          innerFrom_1.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
            return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
          }, function() {
            innerSubscriber = null;
            checkComplete();
          }));
        }, function() {
          isComplete = true;
          checkComplete();
        }));
      });
    }
    exports.switchMap = switchMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchAll.js
var require_switchAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchAll = void 0;
    var switchMap_1 = require_switchMap();
    var identity_1 = require_identity();
    function switchAll() {
      return switchMap_1.switchMap(identity_1.identity);
    }
    exports.switchAll = switchAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js
var require_switchMapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchMapTo = void 0;
    var switchMap_1 = require_switchMap();
    var isFunction_1 = require_isFunction();
    function switchMapTo(innerObservable, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function() {
        return innerObservable;
      }, resultSelector) : switchMap_1.switchMap(function() {
        return innerObservable;
      });
    }
    exports.switchMapTo = switchMapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchScan.js
var require_switchScan = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchScan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchScan = void 0;
    var switchMap_1 = require_switchMap();
    var lift_1 = require_lift();
    function switchScan(accumulator, seed) {
      return lift_1.operate(function(source, subscriber) {
        var state = seed;
        switchMap_1.switchMap(function(value, index) {
          return accumulator(state, value, index);
        }, function(_, innerValue) {
          return state = innerValue, innerValue;
        })(source).subscribe(subscriber);
        return function() {
          state = null;
        };
      });
    }
    exports.switchScan = switchScan;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js
var require_takeUntil = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.takeUntil = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var noop_1 = require_noop();
    function takeUntil(notifier) {
      return lift_1.operate(function(source, subscriber) {
        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          return subscriber.complete();
        }, noop_1.noop));
        !subscriber.closed && source.subscribe(subscriber);
      });
    }
    exports.takeUntil = takeUntil;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js
var require_takeWhile = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.takeWhile = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function takeWhile(predicate, inclusive) {
      if (inclusive === void 0) {
        inclusive = false;
      }
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var result2 = predicate(value, index++);
          (result2 || inclusive) && subscriber.next(value);
          !result2 && subscriber.complete();
        }));
      });
    }
    exports.takeWhile = takeWhile;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/tap.js
var require_tap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/tap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tap = void 0;
    var isFunction_1 = require_isFunction();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var identity_1 = require_identity();
    function tap(observerOrNext, error, complete) {
      var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
      return tapObserver ? lift_1.operate(function(source, subscriber) {
        var _a;
        (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
        var isUnsub = true;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var _a2;
          (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
          subscriber.next(value);
        }, function() {
          var _a2;
          isUnsub = false;
          (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
          subscriber.complete();
        }, function(err) {
          var _a2;
          isUnsub = false;
          (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
          subscriber.error(err);
        }, function() {
          var _a2, _b;
          if (isUnsub) {
            (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
          }
          (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
        }));
      }) : identity_1.identity;
    }
    exports.tap = tap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/throttle.js
var require_throttle = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/throttle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throttle = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function throttle(durationSelector, config) {
      return lift_1.operate(function(source, subscriber) {
        var _a = config !== null && config !== void 0 ? config : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
        var hasValue = false;
        var sendValue = null;
        var throttled = null;
        var isComplete = false;
        var endThrottling = function() {
          throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
          throttled = null;
          if (trailing) {
            send();
            isComplete && subscriber.complete();
          }
        };
        var cleanupThrottling = function() {
          throttled = null;
          isComplete && subscriber.complete();
        };
        var startThrottle = function(value) {
          return throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
        };
        var send = function() {
          if (hasValue) {
            hasValue = false;
            var value = sendValue;
            sendValue = null;
            subscriber.next(value);
            !isComplete && startThrottle(value);
          }
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          sendValue = value;
          !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
        }, function() {
          isComplete = true;
          !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
        }));
      });
    }
    exports.throttle = throttle;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js
var require_throttleTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throttleTime = void 0;
    var async_1 = require_async();
    var throttle_1 = require_throttle();
    var timer_1 = require_timer();
    function throttleTime(duration, scheduler, config) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      var duration$ = timer_1.timer(duration, scheduler);
      return throttle_1.throttle(function() {
        return duration$;
      }, config);
    }
    exports.throttleTime = throttleTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js
var require_timeInterval = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimeInterval = exports.timeInterval = void 0;
    var async_1 = require_async();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function timeInterval(scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return lift_1.operate(function(source, subscriber) {
        var last = scheduler.now();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var now = scheduler.now();
          var interval = now - last;
          last = now;
          subscriber.next(new TimeInterval(value, interval));
        }));
      });
    }
    exports.timeInterval = timeInterval;
    var TimeInterval = function() {
      function TimeInterval2(value, interval) {
        this.value = value;
        this.interval = interval;
      }
      return TimeInterval2;
    }();
    exports.TimeInterval = TimeInterval;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js
var require_timeoutWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timeoutWith = void 0;
    var async_1 = require_async();
    var isDate_1 = require_isDate();
    var timeout_1 = require_timeout();
    function timeoutWith(due, withObservable, scheduler) {
      var first;
      var each;
      var _with;
      scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_1.async;
      if (isDate_1.isValidDate(due)) {
        first = due;
      } else if (typeof due === "number") {
        each = due;
      }
      if (withObservable) {
        _with = function() {
          return withObservable;
        };
      } else {
        throw new TypeError("No observable provided to switch to");
      }
      if (first == null && each == null) {
        throw new TypeError("No timeout provided.");
      }
      return timeout_1.timeout({
        first,
        each,
        scheduler,
        with: _with
      });
    }
    exports.timeoutWith = timeoutWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timestamp = void 0;
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var map_1 = require_map();
    function timestamp(timestampProvider) {
      if (timestampProvider === void 0) {
        timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
      }
      return map_1.map(function(value) {
        return { value, timestamp: timestampProvider.now() };
      });
    }
    exports.timestamp = timestamp;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/window.js
var require_window = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/window.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.window = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var innerFrom_1 = require_innerFrom();
    function window2(windowBoundaries) {
      return lift_1.operate(function(source, subscriber) {
        var windowSubject = new Subject_1.Subject();
        subscriber.next(windowSubject.asObservable());
        var errorHandler = function(err) {
          windowSubject.error(err);
          subscriber.error(err);
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
        }, function() {
          windowSubject.complete();
          subscriber.complete();
        }, errorHandler));
        innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          windowSubject.complete();
          subscriber.next(windowSubject = new Subject_1.Subject());
        }, noop_1.noop, errorHandler));
        return function() {
          windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
          windowSubject = null;
        };
      });
    }
    exports.window = window2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowCount.js
var require_windowCount = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowCount.js"(exports) {
    "use strict";
    var __values3 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.windowCount = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function windowCount(windowSize, startWindowEvery) {
      if (startWindowEvery === void 0) {
        startWindowEvery = 0;
      }
      var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
      return lift_1.operate(function(source, subscriber) {
        var windows = [new Subject_1.Subject()];
        var starts = [];
        var count = 0;
        subscriber.next(windows[0].asObservable());
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          try {
            for (var windows_1 = __values3(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
              var window_1 = windows_1_1.value;
              window_1.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return))
                _a.call(windows_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          var c = count - windowSize + 1;
          if (c >= 0 && c % startEvery === 0) {
            windows.shift().complete();
          }
          if (++count % startEvery === 0) {
            var window_2 = new Subject_1.Subject();
            windows.push(window_2);
            subscriber.next(window_2.asObservable());
          }
        }, function() {
          while (windows.length > 0) {
            windows.shift().complete();
          }
          subscriber.complete();
        }, function(err) {
          while (windows.length > 0) {
            windows.shift().error(err);
          }
          subscriber.error(err);
        }, function() {
          starts = null;
          windows = null;
        }));
      });
    }
    exports.windowCount = windowCount;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowTime.js
var require_windowTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.windowTime = void 0;
    var Subject_1 = require_Subject();
    var async_1 = require_async();
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    var args_1 = require_args();
    var executeSchedule_1 = require_executeSchedule();
    function windowTime(windowTimeSpan) {
      var _a, _b;
      var otherArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        otherArgs[_i - 1] = arguments[_i];
      }
      var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
      var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
      var maxWindowSize = otherArgs[1] || Infinity;
      return lift_1.operate(function(source, subscriber) {
        var windowRecords = [];
        var restartOnClose = false;
        var closeWindow = function(record) {
          var window2 = record.window, subs = record.subs;
          window2.complete();
          subs.unsubscribe();
          arrRemove_1.arrRemove(windowRecords, record);
          restartOnClose && startWindow();
        };
        var startWindow = function() {
          if (windowRecords) {
            var subs = new Subscription_1.Subscription();
            subscriber.add(subs);
            var window_1 = new Subject_1.Subject();
            var record_1 = {
              window: window_1,
              subs,
              seen: 0
            };
            windowRecords.push(record_1);
            subscriber.next(window_1.asObservable());
            executeSchedule_1.executeSchedule(subs, scheduler, function() {
              return closeWindow(record_1);
            }, windowTimeSpan);
          }
        };
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
          executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
        } else {
          restartOnClose = true;
        }
        startWindow();
        var loop = function(cb) {
          return windowRecords.slice().forEach(cb);
        };
        var terminate = function(cb) {
          loop(function(_a2) {
            var window2 = _a2.window;
            return cb(window2);
          });
          cb(subscriber);
          subscriber.unsubscribe();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          loop(function(record) {
            record.window.next(value);
            maxWindowSize <= ++record.seen && closeWindow(record);
          });
        }, function() {
          return terminate(function(consumer) {
            return consumer.complete();
          });
        }, function(err) {
          return terminate(function(consumer) {
            return consumer.error(err);
          });
        }));
        return function() {
          windowRecords = null;
        };
      });
    }
    exports.windowTime = windowTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js
var require_windowToggle = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js"(exports) {
    "use strict";
    var __values3 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.windowToggle = void 0;
    var Subject_1 = require_Subject();
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var arrRemove_1 = require_arrRemove();
    function windowToggle(openings, closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var windows = [];
        var handleError = function(err) {
          while (0 < windows.length) {
            windows.shift().error(err);
          }
          subscriber.error(err);
        };
        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
          var window2 = new Subject_1.Subject();
          windows.push(window2);
          var closingSubscription = new Subscription_1.Subscription();
          var closeWindow = function() {
            arrRemove_1.arrRemove(windows, window2);
            window2.complete();
            closingSubscription.unsubscribe();
          };
          var closingNotifier;
          try {
            closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
          } catch (err) {
            handleError(err);
            return;
          }
          subscriber.next(window2.asObservable());
          closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
        }, noop_1.noop));
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          var windowsCopy = windows.slice();
          try {
            for (var windowsCopy_1 = __values3(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
              var window_1 = windowsCopy_1_1.value;
              window_1.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return))
                _a.call(windowsCopy_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }, function() {
          while (0 < windows.length) {
            windows.shift().complete();
          }
          subscriber.complete();
        }, handleError, function() {
          while (0 < windows.length) {
            windows.shift().unsubscribe();
          }
        }));
      });
    }
    exports.windowToggle = windowToggle;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js
var require_windowWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.windowWhen = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function windowWhen(closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var window2;
        var closingSubscriber;
        var handleError = function(err) {
          window2.error(err);
          subscriber.error(err);
        };
        var openWindow = function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          window2 === null || window2 === void 0 ? void 0 : window2.complete();
          window2 = new Subject_1.Subject();
          subscriber.next(window2.asObservable());
          var closingNotifier;
          try {
            closingNotifier = innerFrom_1.innerFrom(closingSelector());
          } catch (err) {
            handleError(err);
            return;
          }
          closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
        };
        openWindow();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return window2.next(value);
        }, function() {
          window2.complete();
          subscriber.complete();
        }, handleError, function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          window2 = null;
        }));
      });
    }
    exports.windowWhen = windowWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js
var require_withLatestFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withLatestFrom = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var identity_1 = require_identity();
    var noop_1 = require_noop();
    var args_1 = require_args();
    function withLatestFrom() {
      var inputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        inputs[_i] = arguments[_i];
      }
      var project = args_1.popResultSelector(inputs);
      return lift_1.operate(function(source, subscriber) {
        var len = inputs.length;
        var otherValues = new Array(len);
        var hasValue = inputs.map(function() {
          return false;
        });
        var ready = false;
        var _loop_1 = function(i2) {
          innerFrom_1.innerFrom(inputs[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            otherValues[i2] = value;
            if (!ready && !hasValue[i2]) {
              hasValue[i2] = true;
              (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
            }
          }, noop_1.noop));
        };
        for (var i = 0; i < len; i++) {
          _loop_1(i);
        }
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (ready) {
            var values = __spreadArray2([value], __read2(otherValues));
            subscriber.next(project ? project.apply(void 0, __spreadArray2([], __read2(values))) : values);
          }
        }));
      });
    }
    exports.withLatestFrom = withLatestFrom;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/zipAll.js
var require_zipAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/zipAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zipAll = void 0;
    var zip_1 = require_zip();
    var joinAllInternals_1 = require_joinAllInternals();
    function zipAll(project) {
      return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
    }
    exports.zipAll = zipAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/zip.js
var require_zip2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/zip.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zip = void 0;
    var zip_1 = require_zip();
    var lift_1 = require_lift();
    function zip() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      return lift_1.operate(function(source, subscriber) {
        zip_1.zip.apply(void 0, __spreadArray2([source], __read2(sources))).subscribe(subscriber);
      });
    }
    exports.zip = zip;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/zipWith.js
var require_zipWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/zipWith.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zipWith = void 0;
    var zip_1 = require_zip2();
    function zipWith() {
      var otherInputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherInputs[_i] = arguments[_i];
      }
      return zip_1.zip.apply(void 0, __spreadArray2([], __read2(otherInputs)));
    }
    exports.zipWith = zipWith;
  }
});

// node_modules/rxjs/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/rxjs/dist/cjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
    exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
    exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
    exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;
    var Observable_1 = require_Observable();
    Object.defineProperty(exports, "Observable", { enumerable: true, get: function() {
      return Observable_1.Observable;
    } });
    var ConnectableObservable_1 = require_ConnectableObservable();
    Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function() {
      return ConnectableObservable_1.ConnectableObservable;
    } });
    var observable_1 = require_observable();
    Object.defineProperty(exports, "observable", { enumerable: true, get: function() {
      return observable_1.observable;
    } });
    var animationFrames_1 = require_animationFrames();
    Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function() {
      return animationFrames_1.animationFrames;
    } });
    var Subject_1 = require_Subject();
    Object.defineProperty(exports, "Subject", { enumerable: true, get: function() {
      return Subject_1.Subject;
    } });
    var BehaviorSubject_1 = require_BehaviorSubject();
    Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function() {
      return BehaviorSubject_1.BehaviorSubject;
    } });
    var ReplaySubject_1 = require_ReplaySubject();
    Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function() {
      return ReplaySubject_1.ReplaySubject;
    } });
    var AsyncSubject_1 = require_AsyncSubject();
    Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function() {
      return AsyncSubject_1.AsyncSubject;
    } });
    var asap_1 = require_asap();
    Object.defineProperty(exports, "asap", { enumerable: true, get: function() {
      return asap_1.asap;
    } });
    Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function() {
      return asap_1.asapScheduler;
    } });
    var async_1 = require_async();
    Object.defineProperty(exports, "async", { enumerable: true, get: function() {
      return async_1.async;
    } });
    Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function() {
      return async_1.asyncScheduler;
    } });
    var queue_1 = require_queue();
    Object.defineProperty(exports, "queue", { enumerable: true, get: function() {
      return queue_1.queue;
    } });
    Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function() {
      return queue_1.queueScheduler;
    } });
    var animationFrame_1 = require_animationFrame();
    Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function() {
      return animationFrame_1.animationFrame;
    } });
    Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function() {
      return animationFrame_1.animationFrameScheduler;
    } });
    var VirtualTimeScheduler_1 = require_VirtualTimeScheduler();
    Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function() {
      return VirtualTimeScheduler_1.VirtualTimeScheduler;
    } });
    Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function() {
      return VirtualTimeScheduler_1.VirtualAction;
    } });
    var Scheduler_1 = require_Scheduler();
    Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function() {
      return Scheduler_1.Scheduler;
    } });
    var Subscription_1 = require_Subscription();
    Object.defineProperty(exports, "Subscription", { enumerable: true, get: function() {
      return Subscription_1.Subscription;
    } });
    var Subscriber_1 = require_Subscriber();
    Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function() {
      return Subscriber_1.Subscriber;
    } });
    var Notification_1 = require_Notification();
    Object.defineProperty(exports, "Notification", { enumerable: true, get: function() {
      return Notification_1.Notification;
    } });
    Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function() {
      return Notification_1.NotificationKind;
    } });
    var pipe_1 = require_pipe();
    Object.defineProperty(exports, "pipe", { enumerable: true, get: function() {
      return pipe_1.pipe;
    } });
    var noop_1 = require_noop();
    Object.defineProperty(exports, "noop", { enumerable: true, get: function() {
      return noop_1.noop;
    } });
    var identity_1 = require_identity();
    Object.defineProperty(exports, "identity", { enumerable: true, get: function() {
      return identity_1.identity;
    } });
    var isObservable_1 = require_isObservable();
    Object.defineProperty(exports, "isObservable", { enumerable: true, get: function() {
      return isObservable_1.isObservable;
    } });
    var lastValueFrom_1 = require_lastValueFrom();
    Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function() {
      return lastValueFrom_1.lastValueFrom;
    } });
    var firstValueFrom_1 = require_firstValueFrom();
    Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function() {
      return firstValueFrom_1.firstValueFrom;
    } });
    var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
    Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
      return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
    } });
    var EmptyError_1 = require_EmptyError();
    Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function() {
      return EmptyError_1.EmptyError;
    } });
    var NotFoundError_1 = require_NotFoundError();
    Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function() {
      return NotFoundError_1.NotFoundError;
    } });
    var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
    Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function() {
      return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
    } });
    var SequenceError_1 = require_SequenceError();
    Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function() {
      return SequenceError_1.SequenceError;
    } });
    var timeout_1 = require_timeout();
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return timeout_1.TimeoutError;
    } });
    var UnsubscriptionError_1 = require_UnsubscriptionError();
    Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function() {
      return UnsubscriptionError_1.UnsubscriptionError;
    } });
    var bindCallback_1 = require_bindCallback();
    Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function() {
      return bindCallback_1.bindCallback;
    } });
    var bindNodeCallback_1 = require_bindNodeCallback();
    Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function() {
      return bindNodeCallback_1.bindNodeCallback;
    } });
    var combineLatest_1 = require_combineLatest();
    Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function() {
      return combineLatest_1.combineLatest;
    } });
    var concat_1 = require_concat();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var connectable_1 = require_connectable();
    Object.defineProperty(exports, "connectable", { enumerable: true, get: function() {
      return connectable_1.connectable;
    } });
    var defer_1 = require_defer();
    Object.defineProperty(exports, "defer", { enumerable: true, get: function() {
      return defer_1.defer;
    } });
    var empty_1 = require_empty();
    Object.defineProperty(exports, "empty", { enumerable: true, get: function() {
      return empty_1.empty;
    } });
    var forkJoin_1 = require_forkJoin();
    Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function() {
      return forkJoin_1.forkJoin;
    } });
    var from_1 = require_from();
    Object.defineProperty(exports, "from", { enumerable: true, get: function() {
      return from_1.from;
    } });
    var fromEvent_1 = require_fromEvent();
    Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function() {
      return fromEvent_1.fromEvent;
    } });
    var fromEventPattern_1 = require_fromEventPattern();
    Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function() {
      return fromEventPattern_1.fromEventPattern;
    } });
    var generate_1 = require_generate();
    Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
      return generate_1.generate;
    } });
    var iif_1 = require_iif();
    Object.defineProperty(exports, "iif", { enumerable: true, get: function() {
      return iif_1.iif;
    } });
    var interval_1 = require_interval();
    Object.defineProperty(exports, "interval", { enumerable: true, get: function() {
      return interval_1.interval;
    } });
    var merge_1 = require_merge2();
    Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
      return merge_1.merge;
    } });
    var never_1 = require_never();
    Object.defineProperty(exports, "never", { enumerable: true, get: function() {
      return never_1.never;
    } });
    var of_1 = require_of();
    Object.defineProperty(exports, "of", { enumerable: true, get: function() {
      return of_1.of;
    } });
    var onErrorResumeNext_1 = require_onErrorResumeNext();
    Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function() {
      return onErrorResumeNext_1.onErrorResumeNext;
    } });
    var pairs_1 = require_pairs();
    Object.defineProperty(exports, "pairs", { enumerable: true, get: function() {
      return pairs_1.pairs;
    } });
    var partition_1 = require_partition();
    Object.defineProperty(exports, "partition", { enumerable: true, get: function() {
      return partition_1.partition;
    } });
    var race_1 = require_race();
    Object.defineProperty(exports, "race", { enumerable: true, get: function() {
      return race_1.race;
    } });
    var range_1 = require_range();
    Object.defineProperty(exports, "range", { enumerable: true, get: function() {
      return range_1.range;
    } });
    var throwError_1 = require_throwError();
    Object.defineProperty(exports, "throwError", { enumerable: true, get: function() {
      return throwError_1.throwError;
    } });
    var timer_1 = require_timer();
    Object.defineProperty(exports, "timer", { enumerable: true, get: function() {
      return timer_1.timer;
    } });
    var using_1 = require_using();
    Object.defineProperty(exports, "using", { enumerable: true, get: function() {
      return using_1.using;
    } });
    var zip_1 = require_zip();
    Object.defineProperty(exports, "zip", { enumerable: true, get: function() {
      return zip_1.zip;
    } });
    var scheduled_1 = require_scheduled();
    Object.defineProperty(exports, "scheduled", { enumerable: true, get: function() {
      return scheduled_1.scheduled;
    } });
    var empty_2 = require_empty();
    Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function() {
      return empty_2.EMPTY;
    } });
    var never_2 = require_never();
    Object.defineProperty(exports, "NEVER", { enumerable: true, get: function() {
      return never_2.NEVER;
    } });
    __exportStar(require_types(), exports);
    var config_1 = require_config();
    Object.defineProperty(exports, "config", { enumerable: true, get: function() {
      return config_1.config;
    } });
    var audit_1 = require_audit();
    Object.defineProperty(exports, "audit", { enumerable: true, get: function() {
      return audit_1.audit;
    } });
    var auditTime_1 = require_auditTime();
    Object.defineProperty(exports, "auditTime", { enumerable: true, get: function() {
      return auditTime_1.auditTime;
    } });
    var buffer_1 = require_buffer3();
    Object.defineProperty(exports, "buffer", { enumerable: true, get: function() {
      return buffer_1.buffer;
    } });
    var bufferCount_1 = require_bufferCount();
    Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function() {
      return bufferCount_1.bufferCount;
    } });
    var bufferTime_1 = require_bufferTime();
    Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function() {
      return bufferTime_1.bufferTime;
    } });
    var bufferToggle_1 = require_bufferToggle();
    Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function() {
      return bufferToggle_1.bufferToggle;
    } });
    var bufferWhen_1 = require_bufferWhen();
    Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function() {
      return bufferWhen_1.bufferWhen;
    } });
    var catchError_1 = require_catchError();
    Object.defineProperty(exports, "catchError", { enumerable: true, get: function() {
      return catchError_1.catchError;
    } });
    var combineAll_1 = require_combineAll();
    Object.defineProperty(exports, "combineAll", { enumerable: true, get: function() {
      return combineAll_1.combineAll;
    } });
    var combineLatestAll_1 = require_combineLatestAll();
    Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function() {
      return combineLatestAll_1.combineLatestAll;
    } });
    var combineLatestWith_1 = require_combineLatestWith();
    Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function() {
      return combineLatestWith_1.combineLatestWith;
    } });
    var concatAll_1 = require_concatAll();
    Object.defineProperty(exports, "concatAll", { enumerable: true, get: function() {
      return concatAll_1.concatAll;
    } });
    var concatMap_1 = require_concatMap();
    Object.defineProperty(exports, "concatMap", { enumerable: true, get: function() {
      return concatMap_1.concatMap;
    } });
    var concatMapTo_1 = require_concatMapTo();
    Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function() {
      return concatMapTo_1.concatMapTo;
    } });
    var concatWith_1 = require_concatWith();
    Object.defineProperty(exports, "concatWith", { enumerable: true, get: function() {
      return concatWith_1.concatWith;
    } });
    var connect_1 = require_connect();
    Object.defineProperty(exports, "connect", { enumerable: true, get: function() {
      return connect_1.connect;
    } });
    var count_1 = require_count();
    Object.defineProperty(exports, "count", { enumerable: true, get: function() {
      return count_1.count;
    } });
    var debounce_1 = require_debounce();
    Object.defineProperty(exports, "debounce", { enumerable: true, get: function() {
      return debounce_1.debounce;
    } });
    var debounceTime_1 = require_debounceTime();
    Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function() {
      return debounceTime_1.debounceTime;
    } });
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function() {
      return defaultIfEmpty_1.defaultIfEmpty;
    } });
    var delay_1 = require_delay();
    Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
      return delay_1.delay;
    } });
    var delayWhen_1 = require_delayWhen();
    Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function() {
      return delayWhen_1.delayWhen;
    } });
    var dematerialize_1 = require_dematerialize();
    Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function() {
      return dematerialize_1.dematerialize;
    } });
    var distinct_1 = require_distinct();
    Object.defineProperty(exports, "distinct", { enumerable: true, get: function() {
      return distinct_1.distinct;
    } });
    var distinctUntilChanged_1 = require_distinctUntilChanged();
    Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function() {
      return distinctUntilChanged_1.distinctUntilChanged;
    } });
    var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
    Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function() {
      return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
    } });
    var elementAt_1 = require_elementAt();
    Object.defineProperty(exports, "elementAt", { enumerable: true, get: function() {
      return elementAt_1.elementAt;
    } });
    var endWith_1 = require_endWith();
    Object.defineProperty(exports, "endWith", { enumerable: true, get: function() {
      return endWith_1.endWith;
    } });
    var every_1 = require_every();
    Object.defineProperty(exports, "every", { enumerable: true, get: function() {
      return every_1.every;
    } });
    var exhaust_1 = require_exhaust();
    Object.defineProperty(exports, "exhaust", { enumerable: true, get: function() {
      return exhaust_1.exhaust;
    } });
    var exhaustAll_1 = require_exhaustAll();
    Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function() {
      return exhaustAll_1.exhaustAll;
    } });
    var exhaustMap_1 = require_exhaustMap();
    Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function() {
      return exhaustMap_1.exhaustMap;
    } });
    var expand_1 = require_expand();
    Object.defineProperty(exports, "expand", { enumerable: true, get: function() {
      return expand_1.expand;
    } });
    var filter_1 = require_filter();
    Object.defineProperty(exports, "filter", { enumerable: true, get: function() {
      return filter_1.filter;
    } });
    var finalize_1 = require_finalize();
    Object.defineProperty(exports, "finalize", { enumerable: true, get: function() {
      return finalize_1.finalize;
    } });
    var find_1 = require_find();
    Object.defineProperty(exports, "find", { enumerable: true, get: function() {
      return find_1.find;
    } });
    var findIndex_1 = require_findIndex();
    Object.defineProperty(exports, "findIndex", { enumerable: true, get: function() {
      return findIndex_1.findIndex;
    } });
    var first_1 = require_first();
    Object.defineProperty(exports, "first", { enumerable: true, get: function() {
      return first_1.first;
    } });
    var groupBy_1 = require_groupBy();
    Object.defineProperty(exports, "groupBy", { enumerable: true, get: function() {
      return groupBy_1.groupBy;
    } });
    var ignoreElements_1 = require_ignoreElements();
    Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function() {
      return ignoreElements_1.ignoreElements;
    } });
    var isEmpty_1 = require_isEmpty();
    Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function() {
      return isEmpty_1.isEmpty;
    } });
    var last_1 = require_last();
    Object.defineProperty(exports, "last", { enumerable: true, get: function() {
      return last_1.last;
    } });
    var map_1 = require_map();
    Object.defineProperty(exports, "map", { enumerable: true, get: function() {
      return map_1.map;
    } });
    var mapTo_1 = require_mapTo();
    Object.defineProperty(exports, "mapTo", { enumerable: true, get: function() {
      return mapTo_1.mapTo;
    } });
    var materialize_1 = require_materialize();
    Object.defineProperty(exports, "materialize", { enumerable: true, get: function() {
      return materialize_1.materialize;
    } });
    var max_1 = require_max();
    Object.defineProperty(exports, "max", { enumerable: true, get: function() {
      return max_1.max;
    } });
    var mergeAll_1 = require_mergeAll();
    Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function() {
      return mergeAll_1.mergeAll;
    } });
    var flatMap_1 = require_flatMap();
    Object.defineProperty(exports, "flatMap", { enumerable: true, get: function() {
      return flatMap_1.flatMap;
    } });
    var mergeMap_1 = require_mergeMap();
    Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function() {
      return mergeMap_1.mergeMap;
    } });
    var mergeMapTo_1 = require_mergeMapTo();
    Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function() {
      return mergeMapTo_1.mergeMapTo;
    } });
    var mergeScan_1 = require_mergeScan();
    Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function() {
      return mergeScan_1.mergeScan;
    } });
    var mergeWith_1 = require_mergeWith();
    Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function() {
      return mergeWith_1.mergeWith;
    } });
    var min_1 = require_min();
    Object.defineProperty(exports, "min", { enumerable: true, get: function() {
      return min_1.min;
    } });
    var multicast_1 = require_multicast();
    Object.defineProperty(exports, "multicast", { enumerable: true, get: function() {
      return multicast_1.multicast;
    } });
    var observeOn_1 = require_observeOn();
    Object.defineProperty(exports, "observeOn", { enumerable: true, get: function() {
      return observeOn_1.observeOn;
    } });
    var onErrorResumeNextWith_1 = require_onErrorResumeNextWith();
    Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function() {
      return onErrorResumeNextWith_1.onErrorResumeNextWith;
    } });
    var pairwise_1 = require_pairwise();
    Object.defineProperty(exports, "pairwise", { enumerable: true, get: function() {
      return pairwise_1.pairwise;
    } });
    var pluck_1 = require_pluck();
    Object.defineProperty(exports, "pluck", { enumerable: true, get: function() {
      return pluck_1.pluck;
    } });
    var publish_1 = require_publish();
    Object.defineProperty(exports, "publish", { enumerable: true, get: function() {
      return publish_1.publish;
    } });
    var publishBehavior_1 = require_publishBehavior();
    Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function() {
      return publishBehavior_1.publishBehavior;
    } });
    var publishLast_1 = require_publishLast();
    Object.defineProperty(exports, "publishLast", { enumerable: true, get: function() {
      return publishLast_1.publishLast;
    } });
    var publishReplay_1 = require_publishReplay();
    Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function() {
      return publishReplay_1.publishReplay;
    } });
    var raceWith_1 = require_raceWith();
    Object.defineProperty(exports, "raceWith", { enumerable: true, get: function() {
      return raceWith_1.raceWith;
    } });
    var reduce_1 = require_reduce();
    Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
      return reduce_1.reduce;
    } });
    var repeat_1 = require_repeat();
    Object.defineProperty(exports, "repeat", { enumerable: true, get: function() {
      return repeat_1.repeat;
    } });
    var repeatWhen_1 = require_repeatWhen();
    Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function() {
      return repeatWhen_1.repeatWhen;
    } });
    var retry_1 = require_retry();
    Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
      return retry_1.retry;
    } });
    var retryWhen_1 = require_retryWhen();
    Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function() {
      return retryWhen_1.retryWhen;
    } });
    var refCount_1 = require_refCount();
    Object.defineProperty(exports, "refCount", { enumerable: true, get: function() {
      return refCount_1.refCount;
    } });
    var sample_1 = require_sample();
    Object.defineProperty(exports, "sample", { enumerable: true, get: function() {
      return sample_1.sample;
    } });
    var sampleTime_1 = require_sampleTime();
    Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function() {
      return sampleTime_1.sampleTime;
    } });
    var scan_1 = require_scan();
    Object.defineProperty(exports, "scan", { enumerable: true, get: function() {
      return scan_1.scan;
    } });
    var sequenceEqual_1 = require_sequenceEqual();
    Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function() {
      return sequenceEqual_1.sequenceEqual;
    } });
    var share_1 = require_share();
    Object.defineProperty(exports, "share", { enumerable: true, get: function() {
      return share_1.share;
    } });
    var shareReplay_1 = require_shareReplay();
    Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function() {
      return shareReplay_1.shareReplay;
    } });
    var single_1 = require_single();
    Object.defineProperty(exports, "single", { enumerable: true, get: function() {
      return single_1.single;
    } });
    var skip_1 = require_skip();
    Object.defineProperty(exports, "skip", { enumerable: true, get: function() {
      return skip_1.skip;
    } });
    var skipLast_1 = require_skipLast();
    Object.defineProperty(exports, "skipLast", { enumerable: true, get: function() {
      return skipLast_1.skipLast;
    } });
    var skipUntil_1 = require_skipUntil();
    Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function() {
      return skipUntil_1.skipUntil;
    } });
    var skipWhile_1 = require_skipWhile();
    Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function() {
      return skipWhile_1.skipWhile;
    } });
    var startWith_1 = require_startWith();
    Object.defineProperty(exports, "startWith", { enumerable: true, get: function() {
      return startWith_1.startWith;
    } });
    var subscribeOn_1 = require_subscribeOn();
    Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function() {
      return subscribeOn_1.subscribeOn;
    } });
    var switchAll_1 = require_switchAll();
    Object.defineProperty(exports, "switchAll", { enumerable: true, get: function() {
      return switchAll_1.switchAll;
    } });
    var switchMap_1 = require_switchMap();
    Object.defineProperty(exports, "switchMap", { enumerable: true, get: function() {
      return switchMap_1.switchMap;
    } });
    var switchMapTo_1 = require_switchMapTo();
    Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function() {
      return switchMapTo_1.switchMapTo;
    } });
    var switchScan_1 = require_switchScan();
    Object.defineProperty(exports, "switchScan", { enumerable: true, get: function() {
      return switchScan_1.switchScan;
    } });
    var take_1 = require_take();
    Object.defineProperty(exports, "take", { enumerable: true, get: function() {
      return take_1.take;
    } });
    var takeLast_1 = require_takeLast();
    Object.defineProperty(exports, "takeLast", { enumerable: true, get: function() {
      return takeLast_1.takeLast;
    } });
    var takeUntil_1 = require_takeUntil();
    Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function() {
      return takeUntil_1.takeUntil;
    } });
    var takeWhile_1 = require_takeWhile();
    Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function() {
      return takeWhile_1.takeWhile;
    } });
    var tap_1 = require_tap();
    Object.defineProperty(exports, "tap", { enumerable: true, get: function() {
      return tap_1.tap;
    } });
    var throttle_1 = require_throttle();
    Object.defineProperty(exports, "throttle", { enumerable: true, get: function() {
      return throttle_1.throttle;
    } });
    var throttleTime_1 = require_throttleTime();
    Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function() {
      return throttleTime_1.throttleTime;
    } });
    var throwIfEmpty_1 = require_throwIfEmpty();
    Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function() {
      return throwIfEmpty_1.throwIfEmpty;
    } });
    var timeInterval_1 = require_timeInterval();
    Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function() {
      return timeInterval_1.timeInterval;
    } });
    var timeout_2 = require_timeout();
    Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
      return timeout_2.timeout;
    } });
    var timeoutWith_1 = require_timeoutWith();
    Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function() {
      return timeoutWith_1.timeoutWith;
    } });
    var timestamp_1 = require_timestamp();
    Object.defineProperty(exports, "timestamp", { enumerable: true, get: function() {
      return timestamp_1.timestamp;
    } });
    var toArray_1 = require_toArray();
    Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
      return toArray_1.toArray;
    } });
    var window_1 = require_window();
    Object.defineProperty(exports, "window", { enumerable: true, get: function() {
      return window_1.window;
    } });
    var windowCount_1 = require_windowCount();
    Object.defineProperty(exports, "windowCount", { enumerable: true, get: function() {
      return windowCount_1.windowCount;
    } });
    var windowTime_1 = require_windowTime();
    Object.defineProperty(exports, "windowTime", { enumerable: true, get: function() {
      return windowTime_1.windowTime;
    } });
    var windowToggle_1 = require_windowToggle();
    Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function() {
      return windowToggle_1.windowToggle;
    } });
    var windowWhen_1 = require_windowWhen();
    Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function() {
      return windowWhen_1.windowWhen;
    } });
    var withLatestFrom_1 = require_withLatestFrom();
    Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function() {
      return withLatestFrom_1.withLatestFrom;
    } });
    var zipAll_1 = require_zipAll();
    Object.defineProperty(exports, "zipAll", { enumerable: true, get: function() {
      return zipAll_1.zipAll;
    } });
    var zipWith_1 = require_zipWith();
    Object.defineProperty(exports, "zipWith", { enumerable: true, get: function() {
      return zipWith_1.zipWith;
    } });
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/partition.js
var require_partition2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/partition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.partition = void 0;
    var not_1 = require_not();
    var filter_1 = require_filter();
    function partition(predicate, thisArg) {
      return function(source) {
        return [filter_1.filter(predicate, thisArg)(source), filter_1.filter(not_1.not(predicate, thisArg))(source)];
      };
    }
    exports.partition = partition;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/race.js
var require_race2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/race.js"(exports) {
    "use strict";
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.race = void 0;
    var argsOrArgArray_1 = require_argsOrArgArray();
    var raceWith_1 = require_raceWith();
    function race() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return raceWith_1.raceWith.apply(void 0, __spreadArray2([], __read2(argsOrArgArray_1.argsOrArgArray(args))));
    }
    exports.race = race;
  }
});

// node_modules/rxjs/dist/cjs/operators/index.js
var require_operators = __commonJS({
  "node_modules/rxjs/dist/cjs/operators/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeAll = exports.merge = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.concat = exports.combineLatestWith = exports.combineLatest = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = void 0;
    exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.race = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.partition = exports.pairwise = exports.onErrorResumeNext = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = void 0;
    exports.zipWith = exports.zipAll = exports.zip = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = void 0;
    var audit_1 = require_audit();
    Object.defineProperty(exports, "audit", { enumerable: true, get: function() {
      return audit_1.audit;
    } });
    var auditTime_1 = require_auditTime();
    Object.defineProperty(exports, "auditTime", { enumerable: true, get: function() {
      return auditTime_1.auditTime;
    } });
    var buffer_1 = require_buffer3();
    Object.defineProperty(exports, "buffer", { enumerable: true, get: function() {
      return buffer_1.buffer;
    } });
    var bufferCount_1 = require_bufferCount();
    Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function() {
      return bufferCount_1.bufferCount;
    } });
    var bufferTime_1 = require_bufferTime();
    Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function() {
      return bufferTime_1.bufferTime;
    } });
    var bufferToggle_1 = require_bufferToggle();
    Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function() {
      return bufferToggle_1.bufferToggle;
    } });
    var bufferWhen_1 = require_bufferWhen();
    Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function() {
      return bufferWhen_1.bufferWhen;
    } });
    var catchError_1 = require_catchError();
    Object.defineProperty(exports, "catchError", { enumerable: true, get: function() {
      return catchError_1.catchError;
    } });
    var combineAll_1 = require_combineAll();
    Object.defineProperty(exports, "combineAll", { enumerable: true, get: function() {
      return combineAll_1.combineAll;
    } });
    var combineLatestAll_1 = require_combineLatestAll();
    Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function() {
      return combineLatestAll_1.combineLatestAll;
    } });
    var combineLatest_1 = require_combineLatest2();
    Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function() {
      return combineLatest_1.combineLatest;
    } });
    var combineLatestWith_1 = require_combineLatestWith();
    Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function() {
      return combineLatestWith_1.combineLatestWith;
    } });
    var concat_1 = require_concat2();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var concatAll_1 = require_concatAll();
    Object.defineProperty(exports, "concatAll", { enumerable: true, get: function() {
      return concatAll_1.concatAll;
    } });
    var concatMap_1 = require_concatMap();
    Object.defineProperty(exports, "concatMap", { enumerable: true, get: function() {
      return concatMap_1.concatMap;
    } });
    var concatMapTo_1 = require_concatMapTo();
    Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function() {
      return concatMapTo_1.concatMapTo;
    } });
    var concatWith_1 = require_concatWith();
    Object.defineProperty(exports, "concatWith", { enumerable: true, get: function() {
      return concatWith_1.concatWith;
    } });
    var connect_1 = require_connect();
    Object.defineProperty(exports, "connect", { enumerable: true, get: function() {
      return connect_1.connect;
    } });
    var count_1 = require_count();
    Object.defineProperty(exports, "count", { enumerable: true, get: function() {
      return count_1.count;
    } });
    var debounce_1 = require_debounce();
    Object.defineProperty(exports, "debounce", { enumerable: true, get: function() {
      return debounce_1.debounce;
    } });
    var debounceTime_1 = require_debounceTime();
    Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function() {
      return debounceTime_1.debounceTime;
    } });
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function() {
      return defaultIfEmpty_1.defaultIfEmpty;
    } });
    var delay_1 = require_delay();
    Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
      return delay_1.delay;
    } });
    var delayWhen_1 = require_delayWhen();
    Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function() {
      return delayWhen_1.delayWhen;
    } });
    var dematerialize_1 = require_dematerialize();
    Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function() {
      return dematerialize_1.dematerialize;
    } });
    var distinct_1 = require_distinct();
    Object.defineProperty(exports, "distinct", { enumerable: true, get: function() {
      return distinct_1.distinct;
    } });
    var distinctUntilChanged_1 = require_distinctUntilChanged();
    Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function() {
      return distinctUntilChanged_1.distinctUntilChanged;
    } });
    var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
    Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function() {
      return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
    } });
    var elementAt_1 = require_elementAt();
    Object.defineProperty(exports, "elementAt", { enumerable: true, get: function() {
      return elementAt_1.elementAt;
    } });
    var endWith_1 = require_endWith();
    Object.defineProperty(exports, "endWith", { enumerable: true, get: function() {
      return endWith_1.endWith;
    } });
    var every_1 = require_every();
    Object.defineProperty(exports, "every", { enumerable: true, get: function() {
      return every_1.every;
    } });
    var exhaust_1 = require_exhaust();
    Object.defineProperty(exports, "exhaust", { enumerable: true, get: function() {
      return exhaust_1.exhaust;
    } });
    var exhaustAll_1 = require_exhaustAll();
    Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function() {
      return exhaustAll_1.exhaustAll;
    } });
    var exhaustMap_1 = require_exhaustMap();
    Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function() {
      return exhaustMap_1.exhaustMap;
    } });
    var expand_1 = require_expand();
    Object.defineProperty(exports, "expand", { enumerable: true, get: function() {
      return expand_1.expand;
    } });
    var filter_1 = require_filter();
    Object.defineProperty(exports, "filter", { enumerable: true, get: function() {
      return filter_1.filter;
    } });
    var finalize_1 = require_finalize();
    Object.defineProperty(exports, "finalize", { enumerable: true, get: function() {
      return finalize_1.finalize;
    } });
    var find_1 = require_find();
    Object.defineProperty(exports, "find", { enumerable: true, get: function() {
      return find_1.find;
    } });
    var findIndex_1 = require_findIndex();
    Object.defineProperty(exports, "findIndex", { enumerable: true, get: function() {
      return findIndex_1.findIndex;
    } });
    var first_1 = require_first();
    Object.defineProperty(exports, "first", { enumerable: true, get: function() {
      return first_1.first;
    } });
    var groupBy_1 = require_groupBy();
    Object.defineProperty(exports, "groupBy", { enumerable: true, get: function() {
      return groupBy_1.groupBy;
    } });
    var ignoreElements_1 = require_ignoreElements();
    Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function() {
      return ignoreElements_1.ignoreElements;
    } });
    var isEmpty_1 = require_isEmpty();
    Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function() {
      return isEmpty_1.isEmpty;
    } });
    var last_1 = require_last();
    Object.defineProperty(exports, "last", { enumerable: true, get: function() {
      return last_1.last;
    } });
    var map_1 = require_map();
    Object.defineProperty(exports, "map", { enumerable: true, get: function() {
      return map_1.map;
    } });
    var mapTo_1 = require_mapTo();
    Object.defineProperty(exports, "mapTo", { enumerable: true, get: function() {
      return mapTo_1.mapTo;
    } });
    var materialize_1 = require_materialize();
    Object.defineProperty(exports, "materialize", { enumerable: true, get: function() {
      return materialize_1.materialize;
    } });
    var max_1 = require_max();
    Object.defineProperty(exports, "max", { enumerable: true, get: function() {
      return max_1.max;
    } });
    var merge_1 = require_merge3();
    Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
      return merge_1.merge;
    } });
    var mergeAll_1 = require_mergeAll();
    Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function() {
      return mergeAll_1.mergeAll;
    } });
    var flatMap_1 = require_flatMap();
    Object.defineProperty(exports, "flatMap", { enumerable: true, get: function() {
      return flatMap_1.flatMap;
    } });
    var mergeMap_1 = require_mergeMap();
    Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function() {
      return mergeMap_1.mergeMap;
    } });
    var mergeMapTo_1 = require_mergeMapTo();
    Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function() {
      return mergeMapTo_1.mergeMapTo;
    } });
    var mergeScan_1 = require_mergeScan();
    Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function() {
      return mergeScan_1.mergeScan;
    } });
    var mergeWith_1 = require_mergeWith();
    Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function() {
      return mergeWith_1.mergeWith;
    } });
    var min_1 = require_min();
    Object.defineProperty(exports, "min", { enumerable: true, get: function() {
      return min_1.min;
    } });
    var multicast_1 = require_multicast();
    Object.defineProperty(exports, "multicast", { enumerable: true, get: function() {
      return multicast_1.multicast;
    } });
    var observeOn_1 = require_observeOn();
    Object.defineProperty(exports, "observeOn", { enumerable: true, get: function() {
      return observeOn_1.observeOn;
    } });
    var onErrorResumeNextWith_1 = require_onErrorResumeNextWith();
    Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function() {
      return onErrorResumeNextWith_1.onErrorResumeNext;
    } });
    var pairwise_1 = require_pairwise();
    Object.defineProperty(exports, "pairwise", { enumerable: true, get: function() {
      return pairwise_1.pairwise;
    } });
    var partition_1 = require_partition2();
    Object.defineProperty(exports, "partition", { enumerable: true, get: function() {
      return partition_1.partition;
    } });
    var pluck_1 = require_pluck();
    Object.defineProperty(exports, "pluck", { enumerable: true, get: function() {
      return pluck_1.pluck;
    } });
    var publish_1 = require_publish();
    Object.defineProperty(exports, "publish", { enumerable: true, get: function() {
      return publish_1.publish;
    } });
    var publishBehavior_1 = require_publishBehavior();
    Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function() {
      return publishBehavior_1.publishBehavior;
    } });
    var publishLast_1 = require_publishLast();
    Object.defineProperty(exports, "publishLast", { enumerable: true, get: function() {
      return publishLast_1.publishLast;
    } });
    var publishReplay_1 = require_publishReplay();
    Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function() {
      return publishReplay_1.publishReplay;
    } });
    var race_1 = require_race2();
    Object.defineProperty(exports, "race", { enumerable: true, get: function() {
      return race_1.race;
    } });
    var raceWith_1 = require_raceWith();
    Object.defineProperty(exports, "raceWith", { enumerable: true, get: function() {
      return raceWith_1.raceWith;
    } });
    var reduce_1 = require_reduce();
    Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
      return reduce_1.reduce;
    } });
    var repeat_1 = require_repeat();
    Object.defineProperty(exports, "repeat", { enumerable: true, get: function() {
      return repeat_1.repeat;
    } });
    var repeatWhen_1 = require_repeatWhen();
    Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function() {
      return repeatWhen_1.repeatWhen;
    } });
    var retry_1 = require_retry();
    Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
      return retry_1.retry;
    } });
    var retryWhen_1 = require_retryWhen();
    Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function() {
      return retryWhen_1.retryWhen;
    } });
    var refCount_1 = require_refCount();
    Object.defineProperty(exports, "refCount", { enumerable: true, get: function() {
      return refCount_1.refCount;
    } });
    var sample_1 = require_sample();
    Object.defineProperty(exports, "sample", { enumerable: true, get: function() {
      return sample_1.sample;
    } });
    var sampleTime_1 = require_sampleTime();
    Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function() {
      return sampleTime_1.sampleTime;
    } });
    var scan_1 = require_scan();
    Object.defineProperty(exports, "scan", { enumerable: true, get: function() {
      return scan_1.scan;
    } });
    var sequenceEqual_1 = require_sequenceEqual();
    Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function() {
      return sequenceEqual_1.sequenceEqual;
    } });
    var share_1 = require_share();
    Object.defineProperty(exports, "share", { enumerable: true, get: function() {
      return share_1.share;
    } });
    var shareReplay_1 = require_shareReplay();
    Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function() {
      return shareReplay_1.shareReplay;
    } });
    var single_1 = require_single();
    Object.defineProperty(exports, "single", { enumerable: true, get: function() {
      return single_1.single;
    } });
    var skip_1 = require_skip();
    Object.defineProperty(exports, "skip", { enumerable: true, get: function() {
      return skip_1.skip;
    } });
    var skipLast_1 = require_skipLast();
    Object.defineProperty(exports, "skipLast", { enumerable: true, get: function() {
      return skipLast_1.skipLast;
    } });
    var skipUntil_1 = require_skipUntil();
    Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function() {
      return skipUntil_1.skipUntil;
    } });
    var skipWhile_1 = require_skipWhile();
    Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function() {
      return skipWhile_1.skipWhile;
    } });
    var startWith_1 = require_startWith();
    Object.defineProperty(exports, "startWith", { enumerable: true, get: function() {
      return startWith_1.startWith;
    } });
    var subscribeOn_1 = require_subscribeOn();
    Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function() {
      return subscribeOn_1.subscribeOn;
    } });
    var switchAll_1 = require_switchAll();
    Object.defineProperty(exports, "switchAll", { enumerable: true, get: function() {
      return switchAll_1.switchAll;
    } });
    var switchMap_1 = require_switchMap();
    Object.defineProperty(exports, "switchMap", { enumerable: true, get: function() {
      return switchMap_1.switchMap;
    } });
    var switchMapTo_1 = require_switchMapTo();
    Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function() {
      return switchMapTo_1.switchMapTo;
    } });
    var switchScan_1 = require_switchScan();
    Object.defineProperty(exports, "switchScan", { enumerable: true, get: function() {
      return switchScan_1.switchScan;
    } });
    var take_1 = require_take();
    Object.defineProperty(exports, "take", { enumerable: true, get: function() {
      return take_1.take;
    } });
    var takeLast_1 = require_takeLast();
    Object.defineProperty(exports, "takeLast", { enumerable: true, get: function() {
      return takeLast_1.takeLast;
    } });
    var takeUntil_1 = require_takeUntil();
    Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function() {
      return takeUntil_1.takeUntil;
    } });
    var takeWhile_1 = require_takeWhile();
    Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function() {
      return takeWhile_1.takeWhile;
    } });
    var tap_1 = require_tap();
    Object.defineProperty(exports, "tap", { enumerable: true, get: function() {
      return tap_1.tap;
    } });
    var throttle_1 = require_throttle();
    Object.defineProperty(exports, "throttle", { enumerable: true, get: function() {
      return throttle_1.throttle;
    } });
    var throttleTime_1 = require_throttleTime();
    Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function() {
      return throttleTime_1.throttleTime;
    } });
    var throwIfEmpty_1 = require_throwIfEmpty();
    Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function() {
      return throwIfEmpty_1.throwIfEmpty;
    } });
    var timeInterval_1 = require_timeInterval();
    Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function() {
      return timeInterval_1.timeInterval;
    } });
    var timeout_1 = require_timeout();
    Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
      return timeout_1.timeout;
    } });
    var timeoutWith_1 = require_timeoutWith();
    Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function() {
      return timeoutWith_1.timeoutWith;
    } });
    var timestamp_1 = require_timestamp();
    Object.defineProperty(exports, "timestamp", { enumerable: true, get: function() {
      return timestamp_1.timestamp;
    } });
    var toArray_1 = require_toArray();
    Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
      return toArray_1.toArray;
    } });
    var window_1 = require_window();
    Object.defineProperty(exports, "window", { enumerable: true, get: function() {
      return window_1.window;
    } });
    var windowCount_1 = require_windowCount();
    Object.defineProperty(exports, "windowCount", { enumerable: true, get: function() {
      return windowCount_1.windowCount;
    } });
    var windowTime_1 = require_windowTime();
    Object.defineProperty(exports, "windowTime", { enumerable: true, get: function() {
      return windowTime_1.windowTime;
    } });
    var windowToggle_1 = require_windowToggle();
    Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function() {
      return windowToggle_1.windowToggle;
    } });
    var windowWhen_1 = require_windowWhen();
    Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function() {
      return windowWhen_1.windowWhen;
    } });
    var withLatestFrom_1 = require_withLatestFrom();
    Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function() {
      return withLatestFrom_1.withLatestFrom;
    } });
    var zip_1 = require_zip2();
    Object.defineProperty(exports, "zip", { enumerable: true, get: function() {
      return zip_1.zip;
    } });
    var zipAll_1 = require_zipAll();
    Object.defineProperty(exports, "zipAll", { enumerable: true, get: function() {
      return zipAll_1.zipAll;
    } });
    var zipWith_1 = require_zipWith();
    Object.defineProperty(exports, "zipWith", { enumerable: true, get: function() {
      return zipWith_1.zipWith;
    } });
  }
});

// node_modules/@aries-framework/core/build/agent/EventEmitter.js
var require_EventEmitter = __commonJS({
  "node_modules/@aries-framework/core/build/agent/EventEmitter.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventEmitter = void 0;
    var rxjs_1 = require_cjs();
    var operators_1 = require_operators();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var EventEmitter = class EventEmitter {
      constructor(agentDependencies, stop$) {
        this.eventEmitter = new agentDependencies.EventEmitterClass();
        this.stop$ = stop$;
      }
      // agentContext is currently not used, but already making required as it will be used soon
      emit(agentContext, data) {
        this.eventEmitter.emit(data.type, Object.assign(Object.assign({}, data), { metadata: {
          contextCorrelationId: agentContext.contextCorrelationId
        } }));
      }
      on(event, listener) {
        this.eventEmitter.on(event, listener);
      }
      off(event, listener) {
        this.eventEmitter.off(event, listener);
      }
      observable(event) {
        return (0, rxjs_1.fromEventPattern)((handler) => this.on(event, handler), (handler) => this.off(event, handler)).pipe((0, operators_1.takeUntil)(this.stop$));
      }
    };
    EventEmitter = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.AgentDependencies)),
      __param(1, (0, plugins_1.inject)(constants_1.InjectionSymbols.Stop$)),
      __metadata("design:paramtypes", [Object, rxjs_1.Subject])
    ], EventEmitter);
    exports.EventEmitter = EventEmitter;
  }
});

// node_modules/@aries-framework/core/build/storage/RepositoryEvents.js
var require_RepositoryEvents = __commonJS({
  "node_modules/@aries-framework/core/build/storage/RepositoryEvents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RepositoryEventTypes = void 0;
    var RepositoryEventTypes;
    (function(RepositoryEventTypes2) {
      RepositoryEventTypes2["RecordSaved"] = "RecordSaved";
      RepositoryEventTypes2["RecordUpdated"] = "RecordUpdated";
      RepositoryEventTypes2["RecordDeleted"] = "RecordDeleted";
    })(RepositoryEventTypes = exports.RepositoryEventTypes || (exports.RepositoryEventTypes = {}));
  }
});

// node_modules/@aries-framework/core/build/storage/Repository.js
var require_Repository = __commonJS({
  "node_modules/@aries-framework/core/build/storage/Repository.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Repository = void 0;
    var error_1 = require_error();
    var JsonTransformer_1 = require_JsonTransformer();
    var RepositoryEvents_1 = require_RepositoryEvents();
    var Repository = class {
      constructor(recordClass, storageService, eventEmitter) {
        this.storageService = storageService;
        this.recordClass = recordClass;
        this.eventEmitter = eventEmitter;
      }
      /** @inheritDoc {StorageService#save} */
      async save(agentContext, record) {
        await this.storageService.save(agentContext, record);
        const clonedRecord = JsonTransformer_1.JsonTransformer.clone(record);
        this.eventEmitter.emit(agentContext, {
          type: RepositoryEvents_1.RepositoryEventTypes.RecordSaved,
          payload: {
            record: clonedRecord
          }
        });
      }
      /** @inheritDoc {StorageService#update} */
      async update(agentContext, record) {
        await this.storageService.update(agentContext, record);
        const clonedRecord = JsonTransformer_1.JsonTransformer.clone(record);
        this.eventEmitter.emit(agentContext, {
          type: RepositoryEvents_1.RepositoryEventTypes.RecordUpdated,
          payload: {
            record: clonedRecord
          }
        });
      }
      /** @inheritDoc {StorageService#delete} */
      async delete(agentContext, record) {
        await this.storageService.delete(agentContext, record);
        const clonedRecord = JsonTransformer_1.JsonTransformer.clone(record);
        this.eventEmitter.emit(agentContext, {
          type: RepositoryEvents_1.RepositoryEventTypes.RecordDeleted,
          payload: {
            record: clonedRecord
          }
        });
      }
      /**
       * Delete record by id. Returns null if no record is found
       * @param id the id of the record to delete
       * @returns
       */
      async deleteById(agentContext, id) {
        await this.storageService.deleteById(agentContext, this.recordClass, id);
      }
      /** @inheritDoc {StorageService#getById} */
      async getById(agentContext, id) {
        return this.storageService.getById(agentContext, this.recordClass, id);
      }
      /**
       * Find record by id. Returns null if no record is found
       * @param id the id of the record to retrieve
       * @returns
       */
      async findById(agentContext, id) {
        try {
          return await this.storageService.getById(agentContext, this.recordClass, id);
        } catch (error) {
          if (error instanceof error_1.RecordNotFoundError)
            return null;
          throw error;
        }
      }
      /** @inheritDoc {StorageService#getAll} */
      async getAll(agentContext) {
        return this.storageService.getAll(agentContext, this.recordClass);
      }
      /** @inheritDoc {StorageService#findByQuery} */
      async findByQuery(agentContext, query) {
        return this.storageService.findByQuery(agentContext, this.recordClass, query);
      }
      /**
       * Find a single record by query. Returns null if not found.
       * @param query the query
       * @returns the record, or null if not found
       * @throws {RecordDuplicateError} if multiple records are found for the given query
       */
      async findSingleByQuery(agentContext, query) {
        const records = await this.findByQuery(agentContext, query);
        if (records.length > 1) {
          throw new error_1.RecordDuplicateError(`Multiple records found for given query '${JSON.stringify(query)}'`, {
            recordType: this.recordClass.type
          });
        }
        if (records.length < 1) {
          return null;
        }
        return records[0];
      }
      /**
       * Find a single record by query. Throws if not found
       * @param query the query
       * @returns the record
       * @throws {RecordDuplicateError} if multiple records are found for the given query
       * @throws {RecordNotFoundError} if no record is found for the given query
       */
      async getSingleByQuery(agentContext, query) {
        const record = await this.findSingleByQuery(agentContext, query);
        if (!record) {
          throw new error_1.RecordNotFoundError(`No record found for given query '${JSON.stringify(query)}'`, {
            recordType: this.recordClass.type
          });
        }
        return record;
      }
    };
    exports.Repository = Repository;
  }
});

// node_modules/@aries-framework/core/build/storage/BaseRecord.js
var require_BaseRecord = __commonJS({
  "node_modules/@aries-framework/core/build/storage/BaseRecord.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseRecord = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var JsonTransformer_1 = require_JsonTransformer();
    var transformers_1 = require_transformers();
    var Metadata_1 = require_Metadata();
    var BaseRecord = class {
      constructor() {
        this._tags = {};
        this.type = BaseRecord.type;
        this.metadata = new Metadata_1.Metadata({});
      }
      /**
       * Set the value for a tag
       * @param name name of the tag
       * @param value value of the tag
       */
      setTag(name, value) {
        this._tags[name] = value;
      }
      /**
       * Get the value for a tag
       * @param name name of the tag
       * @returns The tag value, or undefined if not found
       */
      getTag(name) {
        return this.getTags()[name];
      }
      /**
       * Set custom tags. This will merge the tags object with passed in tag properties
       *
       * @param tags the tags to set
       */
      setTags(tags) {
        this._tags = Object.assign(Object.assign({}, this._tags), tags);
      }
      /**
       * Replace tags. This will replace the whole tags object.
       * Default tags will still be overridden when retrieving tags
       *
       * @param tags the tags to set
       */
      replaceTags(tags) {
        this._tags = tags;
      }
      toJSON() {
        return JsonTransformer_1.JsonTransformer.toJSON(this);
      }
    };
    BaseRecord.type = "BaseRecord";
    __decorate([
      (0, transformers_1.DateTransformer)(),
      __metadata("design:type", Date)
    ], BaseRecord.prototype, "createdAt", void 0);
    __decorate([
      (0, transformers_1.DateTransformer)(),
      __metadata("design:type", Date)
    ], BaseRecord.prototype, "updatedAt", void 0);
    __decorate([
      (0, class_transformer_1.Exclude)(),
      __metadata("design:type", Object)
    ], BaseRecord.prototype, "type", void 0);
    __decorate([
      (0, transformers_1.MetadataTransformer)(),
      __metadata("design:type", Metadata_1.Metadata)
    ], BaseRecord.prototype, "metadata", void 0);
    exports.BaseRecord = BaseRecord;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/DidRegistrar.js
var require_DidRegistrar = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/DidRegistrar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/DidResolver.js
var require_DidResolver = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/DidResolver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/dids/domain/index.js
var require_domain = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/domain/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_service(), exports);
    __exportStar(require_verificationMethod(), exports);
    __exportStar(require_DidDocument(), exports);
    __exportStar(require_DidDocumentBuilder(), exports);
    __exportStar(require_DidDocumentRole(), exports);
    __exportStar(require_DidRegistrar(), exports);
    __exportStar(require_DidResolver(), exports);
    __exportStar(require_key_type(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/dids/repository/didRecordMetadataTypes.js
var require_didRecordMetadataTypes = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/repository/didRecordMetadataTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidRecordMetadataKeys = void 0;
    var DidRecordMetadataKeys;
    (function(DidRecordMetadataKeys2) {
      DidRecordMetadataKeys2["LegacyDid"] = "_internal/legacyDid";
    })(DidRecordMetadataKeys = exports.DidRecordMetadataKeys || (exports.DidRecordMetadataKeys = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/dids/repository/DidRecord.js
var require_DidRecord = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/repository/DidRecord.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidRecord = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var BaseRecord_1 = require_BaseRecord();
    var uuid_1 = require_uuid();
    var domain_1 = require_domain();
    var DidDocumentRole_1 = require_DidDocumentRole();
    var parse_1 = require_parse();
    var didRecordMetadataTypes_1 = require_didRecordMetadataTypes();
    var DidRecord = class extends BaseRecord_1.BaseRecord {
      constructor(props) {
        var _a, _b, _c;
        super();
        this.type = DidRecord.type;
        if (props) {
          this.id = (_a = props.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.did = props.did;
          this.role = props.role;
          this.didDocument = props.didDocument;
          this.createdAt = (_b = props.createdAt) !== null && _b !== void 0 ? _b : /* @__PURE__ */ new Date();
          this._tags = (_c = props.tags) !== null && _c !== void 0 ? _c : {};
        }
      }
      getTags() {
        const did = (0, parse_1.parseDid)(this.did);
        const legacyDid = this.metadata.get(didRecordMetadataTypes_1.DidRecordMetadataKeys.LegacyDid);
        return Object.assign(Object.assign({}, this._tags), { role: this.role, method: did.method, legacyUnqualifiedDid: legacyDid === null || legacyDid === void 0 ? void 0 : legacyDid.unqualifiedDid, did: this.did, methodSpecificIdentifier: did.id });
      }
    };
    DidRecord.type = "DidRecord";
    __decorate([
      (0, class_transformer_1.Type)(() => domain_1.DidDocument),
      (0, class_validator_1.ValidateNested)(),
      __metadata("design:type", domain_1.DidDocument)
    ], DidRecord.prototype, "didDocument", void 0);
    __decorate([
      (0, class_validator_1.IsEnum)(DidDocumentRole_1.DidDocumentRole),
      __metadata("design:type", String)
    ], DidRecord.prototype, "role", void 0);
    exports.DidRecord = DidRecord;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/repository/DidRepository.js
var require_DidRepository = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/repository/DidRepository.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidRepository = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var Repository_1 = require_Repository();
    var DidDocumentRole_1 = require_DidDocumentRole();
    var DidRecord_1 = require_DidRecord();
    var DidRepository = class DidRepository extends Repository_1.Repository {
      constructor(storageService, eventEmitter) {
        super(DidRecord_1.DidRecord, storageService, eventEmitter);
      }
      /**
       * Finds a {@link DidRecord}, containing the specified recipientKey that was received by this agent.
       * To find a {@link DidRecord} that was created by this agent, use {@link DidRepository.findCreatedDidByRecipientKey}.
       */
      findReceivedDidByRecipientKey(agentContext, recipientKey) {
        return this.findSingleByQuery(agentContext, {
          recipientKeyFingerprints: [recipientKey.fingerprint],
          role: DidDocumentRole_1.DidDocumentRole.Received
        });
      }
      /**
       * Finds a {@link DidRecord}, containing the specified recipientKey that was created by this agent.
       * To find a {@link DidRecord} that was received by this agent, use {@link DidRepository.findReceivedDidByRecipientKey}.
       */
      findCreatedDidByRecipientKey(agentContext, recipientKey) {
        return this.findSingleByQuery(agentContext, {
          recipientKeyFingerprints: [recipientKey.fingerprint],
          role: DidDocumentRole_1.DidDocumentRole.Created
        });
      }
      findAllByRecipientKey(agentContext, recipientKey) {
        return this.findByQuery(agentContext, { recipientKeyFingerprints: [recipientKey.fingerprint] });
      }
      findAllByDid(agentContext, did) {
        return this.findByQuery(agentContext, { did });
      }
      findReceivedDid(agentContext, receivedDid) {
        return this.findSingleByQuery(agentContext, { did: receivedDid, role: DidDocumentRole_1.DidDocumentRole.Received });
      }
      findCreatedDid(agentContext, createdDid) {
        return this.findSingleByQuery(agentContext, { did: createdDid, role: DidDocumentRole_1.DidDocumentRole.Created });
      }
      getCreatedDids(agentContext, { method }) {
        return this.findByQuery(agentContext, {
          role: DidDocumentRole_1.DidDocumentRole.Created,
          method
        });
      }
    };
    DidRepository = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.StorageService)),
      __metadata("design:paramtypes", [Object, EventEmitter_1.EventEmitter])
    ], DidRepository);
    exports.DidRepository = DidRepository;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/repository/index.js
var require_repository = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/repository/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_DidRepository(), exports);
    __exportStar(require_DidRecord(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/dids/methods/key/KeyDidRegistrar.js
var require_KeyDidRegistrar = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/methods/key/KeyDidRegistrar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyDidRegistrar = void 0;
    var DidDocumentRole_1 = require_DidDocumentRole();
    var repository_1 = require_repository();
    var DidKey_1 = require_DidKey();
    var KeyDidRegistrar = class {
      constructor() {
        this.supportedMethods = ["key"];
      }
      async create(agentContext, options) {
        var _a, _b;
        const didRepository = agentContext.dependencyManager.resolve(repository_1.DidRepository);
        const keyType = options.options.keyType;
        const seed = (_a = options.secret) === null || _a === void 0 ? void 0 : _a.seed;
        if (!keyType) {
          return {
            didDocumentMetadata: {},
            didRegistrationMetadata: {},
            didState: {
              state: "failed",
              reason: "Missing key type"
            }
          };
        }
        if (seed && (typeof seed !== "string" || seed.length !== 32)) {
          return {
            didDocumentMetadata: {},
            didRegistrationMetadata: {},
            didState: {
              state: "failed",
              reason: "Invalid seed provided"
            }
          };
        }
        try {
          const key = await agentContext.wallet.createKey({
            keyType,
            seed
          });
          const didKey = new DidKey_1.DidKey(key);
          const didRecord = new repository_1.DidRecord({
            did: didKey.did,
            role: DidDocumentRole_1.DidDocumentRole.Created
          });
          await didRepository.save(agentContext, didRecord);
          return {
            didDocumentMetadata: {},
            didRegistrationMetadata: {},
            didState: {
              state: "finished",
              did: didKey.did,
              didDocument: didKey.didDocument,
              secret: {
                // FIXME: the uni-registrar creates the seed in the registrar method
                // if it doesn't exist so the seed can always be returned. Currently
                // we can only return it if the seed was passed in by the user. Once
                // we have a secure method for generating seeds we should use the same
                // approach
                seed: (_b = options.secret) === null || _b === void 0 ? void 0 : _b.seed
              }
            }
          };
        } catch (error) {
          return {
            didDocumentMetadata: {},
            didRegistrationMetadata: {},
            didState: {
              state: "failed",
              reason: `unknownError: ${error.message}`
            }
          };
        }
      }
      async update() {
        return {
          didDocumentMetadata: {},
          didRegistrationMetadata: {},
          didState: {
            state: "failed",
            reason: `notSupported: cannot update did:key did`
          }
        };
      }
      async deactivate() {
        return {
          didDocumentMetadata: {},
          didRegistrationMetadata: {},
          didState: {
            state: "failed",
            reason: `notSupported: cannot deactivate did:key did`
          }
        };
      }
    };
    exports.KeyDidRegistrar = KeyDidRegistrar;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/methods/key/KeyDidResolver.js
var require_KeyDidResolver = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/methods/key/KeyDidResolver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyDidResolver = void 0;
    var DidKey_1 = require_DidKey();
    var KeyDidResolver = class {
      constructor() {
        this.supportedMethods = ["key"];
      }
      async resolve(agentContext, did) {
        const didDocumentMetadata = {};
        try {
          const didDocument = DidKey_1.DidKey.fromDid(did).didDocument;
          return {
            didDocument,
            didDocumentMetadata,
            didResolutionMetadata: { contentType: "application/did+ld+json" }
          };
        } catch (error) {
          return {
            didDocument: null,
            didDocumentMetadata,
            didResolutionMetadata: {
              error: "notFound",
              message: `resolver_error: Unable to resolve did '${did}': ${error}`
            }
          };
        }
      }
    };
    exports.KeyDidResolver = KeyDidResolver;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/methods/key/index.js
var require_key = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/methods/key/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidKey = void 0;
    var DidKey_1 = require_DidKey();
    Object.defineProperty(exports, "DidKey", { enumerable: true, get: function() {
      return DidKey_1.DidKey;
    } });
    __exportStar(require_KeyDidRegistrar(), exports);
    __exportStar(require_KeyDidResolver(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/dids/helpers.js
var require_helpers = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verkeyToInstanceOfKey = exports.didKeyToInstanceOfKey = exports.verkeyToDidKey = exports.didKeyToVerkey = exports.isDidKey = void 0;
    var crypto_1 = require_crypto();
    var key_1 = require_key();
    function isDidKey(key) {
      return key.startsWith("did:key");
    }
    exports.isDidKey = isDidKey;
    function didKeyToVerkey(key) {
      if (isDidKey(key)) {
        const publicKeyBase58 = key_1.DidKey.fromDid(key).key.publicKeyBase58;
        return publicKeyBase58;
      }
      return key;
    }
    exports.didKeyToVerkey = didKeyToVerkey;
    function verkeyToDidKey(key) {
      if (isDidKey(key)) {
        return key;
      }
      const publicKeyBase58 = key;
      const ed25519Key = crypto_1.Key.fromPublicKeyBase58(publicKeyBase58, crypto_1.KeyType.Ed25519);
      const didKey = new key_1.DidKey(ed25519Key);
      return didKey.did;
    }
    exports.verkeyToDidKey = verkeyToDidKey;
    function didKeyToInstanceOfKey(key) {
      const didKey = key_1.DidKey.fromDid(key);
      return didKey.key;
    }
    exports.didKeyToInstanceOfKey = didKeyToInstanceOfKey;
    function verkeyToInstanceOfKey(verkey) {
      const ed25519Key = crypto_1.Key.fromPublicKeyBase58(verkey, crypto_1.KeyType.Ed25519);
      return ed25519Key;
    }
    exports.verkeyToInstanceOfKey = verkeyToInstanceOfKey;
  }
});

// node_modules/@aries-framework/core/build/decorators/service/ServiceDecorator.js
var require_ServiceDecorator = __commonJS({
  "node_modules/@aries-framework/core/build/decorators/service/ServiceDecorator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServiceDecorator = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var helpers_1 = require_helpers();
    var uuid_1 = require_uuid();
    var ServiceDecorator = class {
      constructor(options) {
        if (options) {
          this.recipientKeys = options.recipientKeys;
          this.routingKeys = options.routingKeys;
          this.serviceEndpoint = options.serviceEndpoint;
        }
      }
      get resolvedDidCommService() {
        var _a, _b;
        return {
          id: (0, uuid_1.uuid)(),
          recipientKeys: this.recipientKeys.map(helpers_1.verkeyToInstanceOfKey),
          routingKeys: (_b = (_a = this.routingKeys) === null || _a === void 0 ? void 0 : _a.map(helpers_1.verkeyToInstanceOfKey)) !== null && _b !== void 0 ? _b : [],
          serviceEndpoint: this.serviceEndpoint
        };
      }
    };
    __decorate([
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.IsString)({ each: true }),
      __metadata("design:type", Array)
    ], ServiceDecorator.prototype, "recipientKeys", void 0);
    __decorate([
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.IsString)({ each: true }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], ServiceDecorator.prototype, "routingKeys", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], ServiceDecorator.prototype, "serviceEndpoint", void 0);
    exports.ServiceDecorator = ServiceDecorator;
  }
});

// node_modules/@aries-framework/core/build/decorators/service/ServiceDecoratorExtension.js
var require_ServiceDecoratorExtension = __commonJS({
  "node_modules/@aries-framework/core/build/decorators/service/ServiceDecoratorExtension.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServiceDecorated = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var ServiceDecorator_1 = require_ServiceDecorator();
    function ServiceDecorated(Base) {
      class ServiceDecoratorExtension extends Base {
        setService(serviceData) {
          this.service = new ServiceDecorator_1.ServiceDecorator(serviceData);
        }
      }
      __decorate([
        (0, class_transformer_1.Expose)({ name: "~service" }),
        (0, class_transformer_1.Type)(() => ServiceDecorator_1.ServiceDecorator),
        (0, class_validator_1.IsOptional)(),
        (0, class_validator_1.ValidateNested)(),
        __metadata("design:type", ServiceDecorator_1.ServiceDecorator)
      ], ServiceDecoratorExtension.prototype, "service", void 0);
      return ServiceDecoratorExtension;
    }
    exports.ServiceDecorated = ServiceDecorated;
  }
});

// node_modules/@aries-framework/core/build/agent/BaseMessage.js
var require_BaseMessage = __commonJS({
  "node_modules/@aries-framework/core/build/agent/BaseMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseMessage = exports.MessageTypeRegExp = exports.MessageIdRegExp = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var uuid_1 = require_uuid();
    exports.MessageIdRegExp = /[-_./a-zA-Z0-9]{8,64}/;
    exports.MessageTypeRegExp = /(.*?)([a-zA-Z0-9._-]+)\/(\d[^/]*)\/([a-zA-Z0-9._-]+)$/;
    var BaseMessage = class {
      generateId() {
        return (0, uuid_1.uuid)();
      }
    };
    __decorate([
      (0, class_validator_1.Matches)(exports.MessageIdRegExp),
      (0, class_transformer_1.Expose)({ name: "@id" }),
      __metadata("design:type", String)
    ], BaseMessage.prototype, "id", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "@type" }),
      (0, class_validator_1.Matches)(exports.MessageTypeRegExp),
      __metadata("design:type", String)
    ], BaseMessage.prototype, "type", void 0);
    exports.BaseMessage = BaseMessage;
  }
});

// node_modules/@aries-framework/core/build/decorators/thread/ThreadDecorator.js
var require_ThreadDecorator = __commonJS({
  "node_modules/@aries-framework/core/build/decorators/thread/ThreadDecorator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ThreadDecorator = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var BaseMessage_1 = require_BaseMessage();
    var ThreadDecorator = class {
      constructor(partial) {
        this.threadId = partial === null || partial === void 0 ? void 0 : partial.threadId;
        this.parentThreadId = partial === null || partial === void 0 ? void 0 : partial.parentThreadId;
        this.senderOrder = partial === null || partial === void 0 ? void 0 : partial.senderOrder;
        this.receivedOrders = partial === null || partial === void 0 ? void 0 : partial.receivedOrders;
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "thid" }),
      (0, class_validator_1.Matches)(BaseMessage_1.MessageIdRegExp),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], ThreadDecorator.prototype, "threadId", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "pthid" }),
      (0, class_validator_1.Matches)(BaseMessage_1.MessageIdRegExp),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], ThreadDecorator.prototype, "parentThreadId", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "sender_order" }),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsInt)(),
      __metadata("design:type", Number)
    ], ThreadDecorator.prototype, "senderOrder", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "received_orders" }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Object)
    ], ThreadDecorator.prototype, "receivedOrders", void 0);
    exports.ThreadDecorator = ThreadDecorator;
  }
});

// node_modules/@aries-framework/core/build/decorators/thread/ThreadDecoratorExtension.js
var require_ThreadDecoratorExtension = __commonJS({
  "node_modules/@aries-framework/core/build/decorators/thread/ThreadDecoratorExtension.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ThreadDecorated = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var ThreadDecorator_1 = require_ThreadDecorator();
    function ThreadDecorated(Base) {
      class ThreadDecoratorExtension extends Base {
        get threadId() {
          var _a, _b;
          return (_b = (_a = this.thread) === null || _a === void 0 ? void 0 : _a.threadId) !== null && _b !== void 0 ? _b : this.id;
        }
        setThread(options) {
          this.thread = new ThreadDecorator_1.ThreadDecorator(options);
        }
      }
      __decorate([
        (0, class_transformer_1.Expose)({ name: "~thread" }),
        (0, class_validator_1.IsOptional)(),
        (0, class_transformer_1.Type)(() => ThreadDecorator_1.ThreadDecorator),
        (0, class_validator_1.ValidateNested)(),
        (0, class_validator_1.IsInstance)(ThreadDecorator_1.ThreadDecorator),
        __metadata("design:type", ThreadDecorator_1.ThreadDecorator)
      ], ThreadDecoratorExtension.prototype, "thread", void 0);
      return ThreadDecoratorExtension;
    }
    exports.ThreadDecorated = ThreadDecorated;
  }
});

// node_modules/@aries-framework/core/build/decorators/timing/TimingDecorator.js
var require_TimingDecorator = __commonJS({
  "node_modules/@aries-framework/core/build/decorators/timing/TimingDecorator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimingDecorator = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var TimingDecorator = class {
      constructor(partial) {
        this.inTime = partial === null || partial === void 0 ? void 0 : partial.inTime;
        this.outTime = partial === null || partial === void 0 ? void 0 : partial.outTime;
        this.staleTime = partial === null || partial === void 0 ? void 0 : partial.staleTime;
        this.expiresTime = partial === null || partial === void 0 ? void 0 : partial.expiresTime;
        this.delayMilli = partial === null || partial === void 0 ? void 0 : partial.delayMilli;
        this.waitUntilTime = partial === null || partial === void 0 ? void 0 : partial.waitUntilTime;
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "in_time" }),
      (0, class_transformer_1.Type)(() => Date),
      (0, class_validator_1.IsDate)(),
      (0, class_validator_1.IsOptional)(),
      __metadata(
        "design:type",
        Date
        /**
         * The timestamp when the message was emitted. At least millisecond precision is preferred, though second precision is acceptable.
         */
      )
    ], TimingDecorator.prototype, "inTime", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "out_time" }),
      (0, class_transformer_1.Type)(() => Date),
      (0, class_validator_1.IsDate)(),
      (0, class_validator_1.IsOptional)(),
      __metadata(
        "design:type",
        Date
        /**
         * Ideally, the decorated message should be processed by the the specified timestamp. After that, the message may become irrelevant or less meaningful than intended.
         * This is a hint only.
         */
      )
    ], TimingDecorator.prototype, "outTime", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "stale_time" }),
      (0, class_transformer_1.Type)(() => Date),
      (0, class_validator_1.IsDate)(),
      (0, class_validator_1.IsOptional)(),
      __metadata(
        "design:type",
        Date
        /**
         * The decorated message should be considered invalid or expired if encountered after the specified timestamp.
         * This is a much stronger claim than the one for `stale_time`; it says that the receiver should cancel attempts to process it once the deadline is past,
         * because the sender won't stand behind it any longer. While processing of the received message should stop,
         * the thread of the message should be retained as the sender may send an updated/replacement message.
         * In the case that the sender does not follow up, the policy of the receiver agent related to abandoned threads would presumably be used to eventually delete the thread.
         */
      )
    ], TimingDecorator.prototype, "staleTime", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "expires_time" }),
      (0, class_transformer_1.Type)(() => Date),
      (0, class_validator_1.IsDate)(),
      (0, class_validator_1.IsOptional)(),
      __metadata(
        "design:type",
        Date
        /**
         * Wait at least this many milliseconds before processing the message. This may be useful to defeat temporal correlation.
         * It is recommended that agents supporting this field should not honor requests for delays longer than 10 minutes (600,000 milliseconds).
         */
      )
    ], TimingDecorator.prototype, "expiresTime", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "delay_milli" }),
      (0, class_validator_1.IsNumber)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Number)
    ], TimingDecorator.prototype, "delayMilli", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "wait_until_time" }),
      (0, class_transformer_1.Type)(() => Date),
      (0, class_validator_1.IsDate)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Date)
    ], TimingDecorator.prototype, "waitUntilTime", void 0);
    exports.TimingDecorator = TimingDecorator;
  }
});

// node_modules/@aries-framework/core/build/decorators/timing/TimingDecoratorExtension.js
var require_TimingDecoratorExtension = __commonJS({
  "node_modules/@aries-framework/core/build/decorators/timing/TimingDecoratorExtension.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimingDecorated = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var TimingDecorator_1 = require_TimingDecorator();
    function TimingDecorated(Base) {
      class TimingDecoratorExtension extends Base {
        setTiming(options) {
          this.timing = new TimingDecorator_1.TimingDecorator(options);
        }
      }
      __decorate([
        (0, class_transformer_1.Expose)({ name: "~timing" }),
        (0, class_transformer_1.Type)(() => TimingDecorator_1.TimingDecorator),
        (0, class_validator_1.ValidateNested)(),
        (0, class_validator_1.IsInstance)(TimingDecorator_1.TimingDecorator),
        (0, class_validator_1.IsOptional)(),
        __metadata("design:type", TimingDecorator_1.TimingDecorator)
      ], TimingDecoratorExtension.prototype, "timing", void 0);
      return TimingDecoratorExtension;
    }
    exports.TimingDecorated = TimingDecorated;
  }
});

// node_modules/@aries-framework/core/build/decorators/transport/TransportDecorator.js
var require_TransportDecorator = __commonJS({
  "node_modules/@aries-framework/core/build/decorators/transport/TransportDecorator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TransportDecorator = exports.ReturnRouteTypes = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var BaseMessage_1 = require_BaseMessage();
    var ReturnRouteTypes;
    (function(ReturnRouteTypes2) {
      ReturnRouteTypes2["none"] = "none";
      ReturnRouteTypes2["all"] = "all";
      ReturnRouteTypes2["thread"] = "thread";
    })(ReturnRouteTypes = exports.ReturnRouteTypes || (exports.ReturnRouteTypes = {}));
    var TransportDecorator = class {
      constructor(partial) {
        this.returnRoute = partial === null || partial === void 0 ? void 0 : partial.returnRoute;
        this.returnRouteThread = partial === null || partial === void 0 ? void 0 : partial.returnRouteThread;
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "return_route" }),
      (0, class_validator_1.IsEnum)(ReturnRouteTypes),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], TransportDecorator.prototype, "returnRoute", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "return_route_thread" }),
      (0, class_validator_1.ValidateIf)((o) => o.returnRoute === ReturnRouteTypes.thread),
      (0, class_validator_1.Matches)(BaseMessage_1.MessageIdRegExp),
      __metadata("design:type", String)
    ], TransportDecorator.prototype, "returnRouteThread", void 0);
    exports.TransportDecorator = TransportDecorator;
  }
});

// node_modules/@aries-framework/core/build/decorators/transport/TransportDecoratorExtension.js
var require_TransportDecoratorExtension = __commonJS({
  "node_modules/@aries-framework/core/build/decorators/transport/TransportDecoratorExtension.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TransportDecorated = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var TransportDecorator_1 = require_TransportDecorator();
    function TransportDecorated(Base) {
      class TransportDecoratorExtension extends Base {
        setReturnRouting(type, thread) {
          this.transport = new TransportDecorator_1.TransportDecorator({
            returnRoute: type,
            returnRouteThread: thread
          });
        }
        hasReturnRouting(threadId) {
          if (!this.transport || !this.transport.returnRoute || this.transport.returnRoute === TransportDecorator_1.ReturnRouteTypes.none) {
            return false;
          } else if (this.transport.returnRoute === TransportDecorator_1.ReturnRouteTypes.all)
            return true;
          else if (this.transport.returnRoute === TransportDecorator_1.ReturnRouteTypes.thread && this.transport.returnRouteThread === threadId)
            return true;
          return false;
        }
        hasAnyReturnRoute() {
          var _a;
          const returnRoute = (_a = this.transport) === null || _a === void 0 ? void 0 : _a.returnRoute;
          return returnRoute === TransportDecorator_1.ReturnRouteTypes.all || returnRoute === TransportDecorator_1.ReturnRouteTypes.thread;
        }
      }
      __decorate([
        (0, class_transformer_1.Expose)({ name: "~transport" }),
        (0, class_transformer_1.Type)(() => TransportDecorator_1.TransportDecorator),
        (0, class_validator_1.ValidateNested)(),
        (0, class_validator_1.IsOptional)(),
        (0, class_validator_1.IsInstance)(TransportDecorator_1.TransportDecorator),
        __metadata("design:type", TransportDecorator_1.TransportDecorator)
      ], TransportDecoratorExtension.prototype, "transport", void 0);
      return TransportDecoratorExtension;
    }
    exports.TransportDecorated = TransportDecorated;
  }
});

// node_modules/@aries-framework/core/build/agent/AgentMessage.js
var require_AgentMessage = __commonJS({
  "node_modules/@aries-framework/core/build/agent/AgentMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentMessage = void 0;
    var AckDecoratorExtension_1 = require_AckDecoratorExtension();
    var AttachmentExtension_1 = require_AttachmentExtension();
    var L10nDecoratorExtension_1 = require_L10nDecoratorExtension();
    var ServiceDecoratorExtension_1 = require_ServiceDecoratorExtension();
    var ThreadDecoratorExtension_1 = require_ThreadDecoratorExtension();
    var TimingDecoratorExtension_1 = require_TimingDecoratorExtension();
    var TransportDecoratorExtension_1 = require_TransportDecoratorExtension();
    var JsonTransformer_1 = require_JsonTransformer();
    var messageType_1 = require_messageType();
    var BaseMessage_1 = require_BaseMessage();
    var Decorated = (0, ThreadDecoratorExtension_1.ThreadDecorated)((0, L10nDecoratorExtension_1.L10nDecorated)((0, TransportDecoratorExtension_1.TransportDecorated)((0, TimingDecoratorExtension_1.TimingDecorated)((0, AckDecoratorExtension_1.AckDecorated)((0, AttachmentExtension_1.AttachmentDecorated)((0, ServiceDecoratorExtension_1.ServiceDecorated)(BaseMessage_1.BaseMessage)))))));
    var AgentMessage = class extends Decorated {
      toJSON({ useLegacyDidSovPrefix = false } = {}) {
        const json = JsonTransformer_1.JsonTransformer.toJSON(this);
        if (useLegacyDidSovPrefix) {
          (0, messageType_1.replaceNewDidCommPrefixWithLegacyDidSovOnMessage)(json);
        }
        return json;
      }
      is(Class) {
        return this.type === Class.type.messageTypeUri;
      }
    };
    exports.AgentMessage = AgentMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/messages/ConnectionInvitationMessage.js
var require_ConnectionInvitationMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/messages/ConnectionInvitationMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionInvitationMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var query_string_1 = require_query_string();
    var AgentMessage_1 = require_AgentMessage();
    var error_1 = require_error();
    var JsonEncoder_1 = require_JsonEncoder();
    var JsonTransformer_1 = require_JsonTransformer();
    var messageType_1 = require_messageType();
    var ConnectionInvitationMessage = class extends AgentMessage_1.AgentMessage {
      /**
       * Create new ConnectionInvitationMessage instance.
       * @param options
       */
      constructor(options) {
        super();
        this.type = ConnectionInvitationMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.label = options.label;
          this.imageUrl = options.imageUrl;
          this.appendedAttachments = options.appendedAttachments;
          if (isDidInvitation(options)) {
            this.did = options.did;
          } else {
            this.recipientKeys = options.recipientKeys;
            this.serviceEndpoint = options.serviceEndpoint;
            this.routingKeys = options.routingKeys;
          }
          if (options.did && (options.recipientKeys || options.routingKeys || options.serviceEndpoint)) {
            throw new error_1.AriesFrameworkError("either the did or the recipientKeys/serviceEndpoint/routingKeys must be set, but not both");
          }
        }
      }
      /**
       * Create an invitation url from this instance
       *
       * @param domain domain name to use for invitation url
       * @returns invitation url with base64 encoded invitation
       */
      toUrl({ domain, useLegacyDidSovPrefix = false }) {
        const invitationJson = this.toJSON({ useLegacyDidSovPrefix });
        const encodedInvitation = JsonEncoder_1.JsonEncoder.toBase64URL(invitationJson);
        const invitationUrl = `${domain}?c_i=${encodedInvitation}`;
        return invitationUrl;
      }
      /**
       * Create a `ConnectionInvitationMessage` instance from the `c_i` or `d_m` parameter of an URL
       *
       * @param invitationUrl invitation url containing c_i or d_m parameter
       *
       * @throws Error when the url can not be decoded to JSON, or decoded message is not a valid 'ConnectionInvitationMessage'
       */
      static fromUrl(invitationUrl) {
        var _a;
        const parsedUrl = (0, query_string_1.parseUrl)(invitationUrl).query;
        const encodedInvitation = (_a = parsedUrl["c_i"]) !== null && _a !== void 0 ? _a : parsedUrl["d_m"];
        if (typeof encodedInvitation === "string") {
          const invitationJson = JsonEncoder_1.JsonEncoder.fromBase64(encodedInvitation);
          const invitation = JsonTransformer_1.JsonTransformer.fromJSON(invitationJson, ConnectionInvitationMessage);
          return invitation;
        } else {
          throw new error_1.AriesFrameworkError("InvitationUrl is invalid. Needs to be encoded with either c_i, d_m, or oob");
        }
      }
    };
    ConnectionInvitationMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/connections/1.0/invitation");
    __decorate([
      (0, messageType_1.IsValidMessageType)(ConnectionInvitationMessage.type),
      (0, class_transformer_1.Transform)(({ value }) => (0, messageType_1.replaceLegacyDidSovPrefix)(value), {
        toClassOnly: true
      }),
      __metadata("design:type", Object)
    ], ConnectionInvitationMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], ConnectionInvitationMessage.prototype, "label", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.ValidateIf)((o) => o.recipientKeys === void 0),
      __metadata("design:type", String)
    ], ConnectionInvitationMessage.prototype, "did", void 0);
    __decorate([
      (0, class_validator_1.IsString)({
        each: true
      }),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateIf)((o) => o.did === void 0),
      (0, class_validator_1.ArrayNotEmpty)(),
      __metadata("design:type", Array)
    ], ConnectionInvitationMessage.prototype, "recipientKeys", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.ValidateIf)((o) => o.did === void 0),
      __metadata("design:type", String)
    ], ConnectionInvitationMessage.prototype, "serviceEndpoint", void 0);
    __decorate([
      (0, class_validator_1.IsString)({
        each: true
      }),
      (0, class_validator_1.ValidateIf)((o) => o.did === void 0),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], ConnectionInvitationMessage.prototype, "routingKeys", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsUrl)(),
      __metadata("design:type", String)
    ], ConnectionInvitationMessage.prototype, "imageUrl", void 0);
    exports.ConnectionInvitationMessage = ConnectionInvitationMessage;
    function isDidInvitation(invitation) {
      return invitation.did !== void 0;
    }
  }
});

// node_modules/@aries-framework/core/build/modules/connections/models/did/publicKey/PublicKey.js
var require_PublicKey = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/models/did/publicKey/PublicKey.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PublicKey = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var PublicKey = class {
      constructor(options) {
        if (options) {
          this.id = options.id;
          this.controller = options.controller;
          this.type = options.type;
          this.value = options.value;
        }
      }
    };
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], PublicKey.prototype, "id", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], PublicKey.prototype, "controller", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], PublicKey.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], PublicKey.prototype, "value", void 0);
    exports.PublicKey = PublicKey;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/models/did/publicKey/Ed25119Sig2018.js
var require_Ed25119Sig2018 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/models/did/publicKey/Ed25119Sig2018.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Ed25119Sig2018 = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var PublicKey_1 = require_PublicKey();
    var Ed25119Sig2018 = class extends PublicKey_1.PublicKey {
      constructor(options) {
        super(Object.assign(Object.assign({}, options), { type: "Ed25519VerificationKey2018" }));
        this.type = "Ed25519VerificationKey2018";
        if (options) {
          this.value = options.publicKeyBase58;
        }
      }
    };
    __decorate([
      (0, class_validator_1.Equals)("Ed25519VerificationKey2018"),
      __metadata("design:type", Object)
    ], Ed25119Sig2018.prototype, "type", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "publicKeyBase58" }),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], Ed25119Sig2018.prototype, "value", void 0);
    exports.Ed25119Sig2018 = Ed25119Sig2018;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/models/did/publicKey/EddsaSaSigSecp256k1.js
var require_EddsaSaSigSecp256k1 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/models/did/publicKey/EddsaSaSigSecp256k1.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EddsaSaSigSecp256k1 = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var PublicKey_1 = require_PublicKey();
    var EddsaSaSigSecp256k1 = class extends PublicKey_1.PublicKey {
      constructor(options) {
        super(Object.assign(Object.assign({}, options), { type: "Secp256k1VerificationKey2018" }));
        this.type = "Secp256k1VerificationKey2018";
        if (options) {
          this.value = options.publicKeyHex;
        }
      }
    };
    __decorate([
      (0, class_validator_1.Equals)("Secp256k1VerificationKey2018"),
      __metadata("design:type", Object)
    ], EddsaSaSigSecp256k1.prototype, "type", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "publicKeyHex" }),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], EddsaSaSigSecp256k1.prototype, "value", void 0);
    exports.EddsaSaSigSecp256k1 = EddsaSaSigSecp256k1;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/models/did/publicKey/RsaSig2018.js
var require_RsaSig2018 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/models/did/publicKey/RsaSig2018.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RsaSig2018 = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var PublicKey_1 = require_PublicKey();
    var RsaSig2018 = class extends PublicKey_1.PublicKey {
      constructor(options) {
        super(Object.assign(Object.assign({}, options), { type: "RsaVerificationKey2018" }));
        this.type = "RsaVerificationKey2018";
        if (options) {
          this.value = options.publicKeyPem;
        }
      }
    };
    __decorate([
      (0, class_validator_1.Equals)("RsaVerificationKey2018"),
      __metadata("design:type", Object)
    ], RsaSig2018.prototype, "type", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "publicKeyPem" }),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], RsaSig2018.prototype, "value", void 0);
    exports.RsaSig2018 = RsaSig2018;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/models/did/publicKey/index.js
var require_publicKey = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/models/did/publicKey/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RsaSig2018 = exports.EddsaSaSigSecp256k1 = exports.PublicKey = exports.Ed25119Sig2018 = exports.PublicKeyTransformer = exports.publicKeyTypes = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var Ed25119Sig2018_1 = require_Ed25119Sig2018();
    Object.defineProperty(exports, "Ed25119Sig2018", { enumerable: true, get: function() {
      return Ed25119Sig2018_1.Ed25119Sig2018;
    } });
    var EddsaSaSigSecp256k1_1 = require_EddsaSaSigSecp256k1();
    Object.defineProperty(exports, "EddsaSaSigSecp256k1", { enumerable: true, get: function() {
      return EddsaSaSigSecp256k1_1.EddsaSaSigSecp256k1;
    } });
    var PublicKey_1 = require_PublicKey();
    Object.defineProperty(exports, "PublicKey", { enumerable: true, get: function() {
      return PublicKey_1.PublicKey;
    } });
    var RsaSig2018_1 = require_RsaSig2018();
    Object.defineProperty(exports, "RsaSig2018", { enumerable: true, get: function() {
      return RsaSig2018_1.RsaSig2018;
    } });
    exports.publicKeyTypes = {
      RsaVerificationKey2018: RsaSig2018_1.RsaSig2018,
      Ed25519VerificationKey2018: Ed25119Sig2018_1.Ed25119Sig2018,
      Secp256k1VerificationKey2018: EddsaSaSigSecp256k1_1.EddsaSaSigSecp256k1
    };
    function PublicKeyTransformer() {
      return (0, class_transformer_1.Transform)(({ value }) => {
        return value.map((publicKeyJson) => {
          var _a;
          const publicKeyClass = (_a = exports.publicKeyTypes[publicKeyJson.type]) !== null && _a !== void 0 ? _a : PublicKey_1.PublicKey;
          const publicKey = (0, class_transformer_1.plainToInstance)(publicKeyClass, publicKeyJson);
          return publicKey;
        });
      }, {
        toClassOnly: true
      });
    }
    exports.PublicKeyTransformer = PublicKeyTransformer;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/models/did/authentication/Authentication.js
var require_Authentication = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/models/did/authentication/Authentication.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Authentication = void 0;
    var Authentication = class {
    };
    exports.Authentication = Authentication;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/models/did/authentication/EmbeddedAuthentication.js
var require_EmbeddedAuthentication = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/models/did/authentication/EmbeddedAuthentication.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmbeddedAuthentication = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var PublicKey_1 = require_PublicKey();
    var Authentication_1 = require_Authentication();
    var EmbeddedAuthentication = class extends Authentication_1.Authentication {
      constructor(publicKey) {
        super();
        this.publicKey = publicKey;
      }
    };
    __decorate([
      (0, class_validator_1.IsNotEmpty)(),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsInstance)(PublicKey_1.PublicKey),
      __metadata("design:type", PublicKey_1.PublicKey)
    ], EmbeddedAuthentication.prototype, "publicKey", void 0);
    exports.EmbeddedAuthentication = EmbeddedAuthentication;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/models/did/authentication/ReferencedAuthentication.js
var require_ReferencedAuthentication = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/models/did/authentication/ReferencedAuthentication.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReferencedAuthentication = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var PublicKey_1 = require_PublicKey();
    var Authentication_1 = require_Authentication();
    var ReferencedAuthentication = class extends Authentication_1.Authentication {
      constructor(publicKey, type) {
        super();
        this.publicKey = publicKey;
        this.type = type;
      }
    };
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], ReferencedAuthentication.prototype, "type", void 0);
    __decorate([
      (0, class_transformer_1.Transform)(({ value }) => value.id, {
        toPlainOnly: true
      }),
      __metadata("design:type", PublicKey_1.PublicKey)
    ], ReferencedAuthentication.prototype, "publicKey", void 0);
    exports.ReferencedAuthentication = ReferencedAuthentication;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/models/did/authentication/index.js
var require_authentication = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/models/did/authentication/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReferencedAuthentication = exports.EmbeddedAuthentication = exports.Authentication = exports.AuthenticationTransformer = exports.authenticationTypes = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var error_1 = require_error();
    var publicKey_1 = require_publicKey();
    var Authentication_1 = require_Authentication();
    Object.defineProperty(exports, "Authentication", { enumerable: true, get: function() {
      return Authentication_1.Authentication;
    } });
    var EmbeddedAuthentication_1 = require_EmbeddedAuthentication();
    Object.defineProperty(exports, "EmbeddedAuthentication", { enumerable: true, get: function() {
      return EmbeddedAuthentication_1.EmbeddedAuthentication;
    } });
    var ReferencedAuthentication_1 = require_ReferencedAuthentication();
    Object.defineProperty(exports, "ReferencedAuthentication", { enumerable: true, get: function() {
      return ReferencedAuthentication_1.ReferencedAuthentication;
    } });
    exports.authenticationTypes = {
      RsaVerificationKey2018: "RsaSignatureAuthentication2018",
      Ed25519VerificationKey2018: "Ed25519SignatureAuthentication2018",
      Secp256k1VerificationKey2018: "Secp256k1SignatureAuthenticationKey2018"
    };
    function AuthenticationTransformer() {
      return (0, class_transformer_1.Transform)(({ value, obj, type }) => {
        if (type === class_transformer_1.TransformationType.PLAIN_TO_CLASS) {
          return value.map((auth) => {
            var _a, _b;
            if (auth.publicKey) {
              const publicKeyJson = obj.publicKey.find((publicKey2) => publicKey2.id === auth.publicKey);
              if (!publicKeyJson) {
                throw new error_1.AriesFrameworkError(`Invalid public key referenced ${auth.publicKey}`);
              }
              const publicKeyClass = (_a = publicKey_1.publicKeyTypes[publicKeyJson.type]) !== null && _a !== void 0 ? _a : publicKey_1.PublicKey;
              const publicKey = (0, class_transformer_1.plainToInstance)(publicKeyClass, publicKeyJson);
              return new ReferencedAuthentication_1.ReferencedAuthentication(publicKey, auth.type);
            } else {
              const publicKeyClass = (_b = publicKey_1.publicKeyTypes[auth.type]) !== null && _b !== void 0 ? _b : publicKey_1.PublicKey;
              const publicKey = (0, class_transformer_1.plainToInstance)(publicKeyClass, auth);
              return new EmbeddedAuthentication_1.EmbeddedAuthentication(publicKey);
            }
          });
        } else {
          return value.map((auth) => auth instanceof EmbeddedAuthentication_1.EmbeddedAuthentication ? (0, class_transformer_1.instanceToPlain)(auth.publicKey) : auth);
        }
      });
    }
    exports.AuthenticationTransformer = AuthenticationTransformer;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/models/did/DidDoc.js
var require_DidDoc = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/models/did/DidDoc.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidDoc = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var service_1 = require_service();
    var authentication_1 = require_authentication();
    var publicKey_1 = require_publicKey();
    var DidDoc = class {
      constructor(options) {
        this.context = "https://w3id.org/did/v1";
        this.publicKey = [];
        this.service = [];
        this.authentication = [];
        if (options) {
          this.id = options.id;
          this.publicKey = options.publicKey;
          this.service = options.service;
          this.authentication = options.authentication;
        }
      }
      /**
       * Gets the matching public key for a given key id
       *
       * @param id fully qualified key id
       */
      getPublicKey(id) {
        return this.publicKey.find((item) => item.id === id);
      }
      /**
       * Returns all of the service endpoints matching the given type.
       *
       * @param type The type of service(s) to query.
       */
      getServicesByType(type) {
        return this.service.filter((service) => service.type === type);
      }
      /**
       * Returns all of the service endpoints matching the given class
       *
       * @param classType The class to query services.
       */
      getServicesByClassType(classType) {
        return this.service.filter((service) => service instanceof classType);
      }
      /**
       * Get all DIDComm services ordered by priority descending. This means the highest
       * priority will be the first entry.
       */
      get didCommServices() {
        const didCommServiceTypes = [service_1.IndyAgentService.type, service_1.DidCommV1Service.type];
        const services = this.service.filter((service) => didCommServiceTypes.includes(service.type));
        return services.sort((a, b) => b.priority - a.priority);
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "@context" }),
      (0, class_validator_1.Equals)("https://w3id.org/did/v1"),
      __metadata("design:type", Object)
    ], DidDoc.prototype, "context", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], DidDoc.prototype, "id", void 0);
    __decorate([
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)(),
      (0, publicKey_1.PublicKeyTransformer)(),
      __metadata("design:type", Array)
    ], DidDoc.prototype, "publicKey", void 0);
    __decorate([
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)(),
      (0, service_1.ServiceTransformer)(),
      __metadata("design:type", Array)
    ], DidDoc.prototype, "service", void 0);
    __decorate([
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)(),
      (0, authentication_1.AuthenticationTransformer)(),
      __metadata("design:type", Array)
    ], DidDoc.prototype, "authentication", void 0);
    exports.DidDoc = DidDoc;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/models/Connection.js
var require_Connection = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/models/Connection.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Connection = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var DidDoc_1 = require_DidDoc();
    var Connection = class {
      constructor(options) {
        if (options) {
          this.did = options.did;
          this.didDoc = options.didDoc;
        }
      }
    };
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_transformer_1.Expose)({ name: "DID" }),
      __metadata("design:type", String)
    ], Connection.prototype, "did", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "DIDDoc" }),
      (0, class_transformer_1.Type)(() => DidDoc_1.DidDoc),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsInstance)(DidDoc_1.DidDoc),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", DidDoc_1.DidDoc)
    ], Connection.prototype, "didDoc", void 0);
    exports.Connection = Connection;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/models/ConnectionRole.js
var require_ConnectionRole = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/models/ConnectionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionRole = void 0;
    var ConnectionRole;
    (function(ConnectionRole2) {
      ConnectionRole2["Inviter"] = "inviter";
      ConnectionRole2["Invitee"] = "invitee";
    })(ConnectionRole = exports.ConnectionRole || (exports.ConnectionRole = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/connections/models/DidExchangeState.js
var require_DidExchangeState = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/models/DidExchangeState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidExchangeState = void 0;
    var DidExchangeState;
    (function(DidExchangeState2) {
      DidExchangeState2["Start"] = "start";
      DidExchangeState2["InvitationSent"] = "invitation-sent";
      DidExchangeState2["InvitationReceived"] = "invitation-received";
      DidExchangeState2["RequestSent"] = "request-sent";
      DidExchangeState2["RequestReceived"] = "request-received";
      DidExchangeState2["ResponseSent"] = "response-sent";
      DidExchangeState2["ResponseReceived"] = "response-received";
      DidExchangeState2["Abandoned"] = "abandoned";
      DidExchangeState2["Completed"] = "completed";
    })(DidExchangeState = exports.DidExchangeState || (exports.DidExchangeState = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/connections/models/ConnectionState.js
var require_ConnectionState = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/models/ConnectionState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rfc0160StateFromDidExchangeState = exports.ConnectionState = void 0;
    var DidExchangeState_1 = require_DidExchangeState();
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2["Null"] = "null";
      ConnectionState2["Invited"] = "invited";
      ConnectionState2["Requested"] = "requested";
      ConnectionState2["Responded"] = "responded";
      ConnectionState2["Complete"] = "complete";
    })(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));
    function rfc0160StateFromDidExchangeState(didExchangeState) {
      const stateMapping = {
        [DidExchangeState_1.DidExchangeState.Start]: ConnectionState.Null,
        [DidExchangeState_1.DidExchangeState.Abandoned]: ConnectionState.Null,
        [DidExchangeState_1.DidExchangeState.InvitationReceived]: ConnectionState.Invited,
        [DidExchangeState_1.DidExchangeState.InvitationSent]: ConnectionState.Invited,
        [DidExchangeState_1.DidExchangeState.RequestReceived]: ConnectionState.Requested,
        [DidExchangeState_1.DidExchangeState.RequestSent]: ConnectionState.Requested,
        [DidExchangeState_1.DidExchangeState.ResponseReceived]: ConnectionState.Responded,
        [DidExchangeState_1.DidExchangeState.ResponseSent]: ConnectionState.Responded,
        [DidExchangeState_1.DidExchangeState.Completed]: ConnectionState.Complete
      };
      return stateMapping[didExchangeState];
    }
    exports.rfc0160StateFromDidExchangeState = rfc0160StateFromDidExchangeState;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/models/DidExchangeRole.js
var require_DidExchangeRole = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/models/DidExchangeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidExchangeRole = void 0;
    var DidExchangeRole;
    (function(DidExchangeRole2) {
      DidExchangeRole2["Requester"] = "requester";
      DidExchangeRole2["Responder"] = "responder";
    })(DidExchangeRole = exports.DidExchangeRole || (exports.DidExchangeRole = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/connections/models/HandshakeProtocol.js
var require_HandshakeProtocol = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/models/HandshakeProtocol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HandshakeProtocol = void 0;
    var HandshakeProtocol;
    (function(HandshakeProtocol2) {
      HandshakeProtocol2["Connections"] = "https://didcomm.org/connections/1.0";
      HandshakeProtocol2["DidExchange"] = "https://didcomm.org/didexchange/1.0";
    })(HandshakeProtocol = exports.HandshakeProtocol || (exports.HandshakeProtocol = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/connections/models/did/index.js
var require_did = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/models/did/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_DidDoc(), exports);
    __exportStar(require_publicKey(), exports);
    __exportStar(require_authentication(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/connections/models/ConnectionType.js
var require_ConnectionType = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/models/ConnectionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionType = void 0;
    var ConnectionType;
    (function(ConnectionType2) {
      ConnectionType2["Mediator"] = "mediator";
    })(ConnectionType = exports.ConnectionType || (exports.ConnectionType = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/connections/models/index.js
var require_models = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/models/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_Connection(), exports);
    __exportStar(require_ConnectionRole(), exports);
    __exportStar(require_ConnectionState(), exports);
    __exportStar(require_DidExchangeState(), exports);
    __exportStar(require_DidExchangeRole(), exports);
    __exportStar(require_HandshakeProtocol(), exports);
    __exportStar(require_did(), exports);
    __exportStar(require_ConnectionType(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/connections/messages/ConnectionRequestMessage.js
var require_ConnectionRequestMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/messages/ConnectionRequestMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionRequestMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var models_1 = require_models();
    var ConnectionRequestMessage = class extends AgentMessage_1.AgentMessage {
      /**
       * Create new ConnectionRequestMessage instance.
       * @param options
       */
      constructor(options) {
        super();
        this.type = ConnectionRequestMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.label = options.label;
          this.imageUrl = options.imageUrl;
          this.connection = new models_1.Connection({
            did: options.did,
            didDoc: options.didDoc
          });
        }
      }
    };
    ConnectionRequestMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/connections/1.0/request");
    __decorate([
      (0, messageType_1.IsValidMessageType)(ConnectionRequestMessage.type),
      __metadata("design:type", Object)
    ], ConnectionRequestMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], ConnectionRequestMessage.prototype, "label", void 0);
    __decorate([
      (0, class_transformer_1.Type)(() => models_1.Connection),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsInstance)(models_1.Connection),
      __metadata("design:type", models_1.Connection)
    ], ConnectionRequestMessage.prototype, "connection", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsUrl)(),
      __metadata("design:type", String)
    ], ConnectionRequestMessage.prototype, "imageUrl", void 0);
    exports.ConnectionRequestMessage = ConnectionRequestMessage;
  }
});

// node_modules/@aries-framework/core/build/decorators/signature/SignatureDecorator.js
var require_SignatureDecorator = __commonJS({
  "node_modules/@aries-framework/core/build/decorators/signature/SignatureDecorator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignatureDecorator = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var BaseMessage_1 = require_BaseMessage();
    var messageType_1 = require_messageType();
    var SignatureDecorator = class {
      constructor(options) {
        if (options) {
          this.signatureType = options.signatureType;
          this.signatureData = options.signatureData;
          this.signer = options.signer;
          this.signature = options.signature;
        }
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "@type" }),
      (0, class_transformer_1.Transform)(({ value }) => (0, messageType_1.replaceLegacyDidSovPrefix)(value), {
        toClassOnly: true
      }),
      (0, class_validator_1.Matches)(BaseMessage_1.MessageTypeRegExp),
      __metadata("design:type", String)
    ], SignatureDecorator.prototype, "signatureType", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "sig_data" }),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], SignatureDecorator.prototype, "signatureData", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "signer" }),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], SignatureDecorator.prototype, "signer", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "signature" }),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], SignatureDecorator.prototype, "signature", void 0);
    exports.SignatureDecorator = SignatureDecorator;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/messages/ConnectionResponseMessage.js
var require_ConnectionResponseMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/messages/ConnectionResponseMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionResponseMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var SignatureDecorator_1 = require_SignatureDecorator();
    var messageType_1 = require_messageType();
    var ConnectionResponseMessage = class extends AgentMessage_1.AgentMessage {
      /**
       * Create new ConnectionResponseMessage instance.
       * @param options
       */
      constructor(options) {
        super();
        this.type = ConnectionResponseMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.connectionSig = options.connectionSig;
          this.setThread({ threadId: options.threadId });
        }
      }
    };
    ConnectionResponseMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/connections/1.0/response");
    __decorate([
      (0, messageType_1.IsValidMessageType)(ConnectionResponseMessage.type),
      __metadata("design:type", Object)
    ], ConnectionResponseMessage.prototype, "type", void 0);
    __decorate([
      (0, class_transformer_1.Type)(() => SignatureDecorator_1.SignatureDecorator),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsInstance)(SignatureDecorator_1.SignatureDecorator),
      (0, class_transformer_1.Expose)({ name: "connection~sig" }),
      __metadata("design:type", SignatureDecorator_1.SignatureDecorator)
    ], ConnectionResponseMessage.prototype, "connectionSig", void 0);
    exports.ConnectionResponseMessage = ConnectionResponseMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/messages/TrustPingMessage.js
var require_TrustPingMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/messages/TrustPingMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TrustPingMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var TrustPingMessage = class extends AgentMessage_1.AgentMessage {
      /**
       * Create new TrustPingMessage instance.
       * responseRequested will be true if not passed
       * @param options
       */
      constructor(options) {
        super();
        this.type = TrustPingMessage.type.messageTypeUri;
        this.responseRequested = true;
        if (options) {
          this.id = options.id || this.generateId();
          this.comment = options.comment;
          this.responseRequested = options.responseRequested !== void 0 ? options.responseRequested : true;
          if (options.timing) {
            this.setTiming({
              outTime: options.timing.outTime,
              expiresTime: options.timing.expiresTime,
              delayMilli: options.timing.delayMilli
            });
          }
        }
      }
    };
    TrustPingMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/trust_ping/1.0/ping");
    __decorate([
      (0, messageType_1.IsValidMessageType)(TrustPingMessage.type),
      __metadata("design:type", Object)
    ], TrustPingMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], TrustPingMessage.prototype, "comment", void 0);
    __decorate([
      (0, class_validator_1.IsBoolean)(),
      (0, class_transformer_1.Expose)({ name: "response_requested" }),
      __metadata("design:type", Object)
    ], TrustPingMessage.prototype, "responseRequested", void 0);
    exports.TrustPingMessage = TrustPingMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/messages/TrustPingResponseMessage.js
var require_TrustPingResponseMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/messages/TrustPingResponseMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TrustPingResponseMessage = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var TrustPingResponseMessage = class extends AgentMessage_1.AgentMessage {
      /**
       * Create new TrustPingResponseMessage instance.
       * responseRequested will be true if not passed
       * @param options
       */
      constructor(options) {
        super();
        this.type = TrustPingResponseMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.comment = options.comment;
          this.setThread({
            threadId: options.threadId
          });
          if (options.timing) {
            this.setTiming({
              inTime: options.timing.inTime,
              outTime: options.timing.outTime
            });
          }
        }
      }
    };
    TrustPingResponseMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/trust_ping/1.0/ping_response");
    __decorate([
      (0, messageType_1.IsValidMessageType)(TrustPingResponseMessage.type),
      __metadata("design:type", Object)
    ], TrustPingResponseMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], TrustPingResponseMessage.prototype, "comment", void 0);
    exports.TrustPingResponseMessage = TrustPingResponseMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/problem-reports/messages/ProblemReportMessage.js
var require_ProblemReportMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/problem-reports/messages/ProblemReportMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProblemReportMessage = exports.OtherStatus = exports.WhereStatus = exports.ImpactStatus = exports.WhoRetriesStatus = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var WhoRetriesStatus;
    (function(WhoRetriesStatus2) {
      WhoRetriesStatus2["You"] = "YOU";
      WhoRetriesStatus2["Me"] = "ME";
      WhoRetriesStatus2["Both"] = "BOTH";
      WhoRetriesStatus2["None"] = "NONE";
    })(WhoRetriesStatus = exports.WhoRetriesStatus || (exports.WhoRetriesStatus = {}));
    var ImpactStatus;
    (function(ImpactStatus2) {
      ImpactStatus2["Message"] = "MESSAGE";
      ImpactStatus2["Thread"] = "THREAD";
      ImpactStatus2["Connection"] = "CONNECTION";
    })(ImpactStatus = exports.ImpactStatus || (exports.ImpactStatus = {}));
    var WhereStatus;
    (function(WhereStatus2) {
      WhereStatus2["Cloud"] = "CLOUD";
      WhereStatus2["Edge"] = "EDGE";
      WhereStatus2["Wire"] = "WIRE";
      WhereStatus2["Agency"] = "AGENCY";
    })(WhereStatus = exports.WhereStatus || (exports.WhereStatus = {}));
    var OtherStatus;
    (function(OtherStatus2) {
      OtherStatus2["You"] = "YOU";
      OtherStatus2["Me"] = "ME";
      OtherStatus2["Other"] = "OTHER";
    })(OtherStatus = exports.OtherStatus || (exports.OtherStatus = {}));
    var ProblemReportMessage = class extends AgentMessage_1.AgentMessage {
      /**
       * Create new ReportProblem instance.
       * @param options
       */
      constructor(options) {
        super();
        this.type = ProblemReportMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.description = options.description;
          this.problemItems = options.problemItems;
          this.whoRetries = options.whoRetries;
          this.fixHint = options.fixHint;
          this.impact = options.impact;
          this.where = options.where;
          this.noticedTime = options.noticedTime;
          this.trackingUri = options.trackingUri;
          this.escalationUri = options.escalationUri;
        }
      }
    };
    ProblemReportMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/notification/1.0/problem-report");
    __decorate([
      (0, messageType_1.IsValidMessageType)(ProblemReportMessage.type),
      __metadata("design:type", String)
    ], ProblemReportMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_transformer_1.Expose)({ name: "problem_items" }),
      __metadata("design:type", Array)
    ], ProblemReportMessage.prototype, "problemItems", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsEnum)(WhoRetriesStatus),
      (0, class_transformer_1.Expose)({ name: "who_retries" }),
      __metadata("design:type", String)
    ], ProblemReportMessage.prototype, "whoRetries", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_transformer_1.Expose)({ name: "fix_hint" }),
      __metadata("design:type", Object)
    ], ProblemReportMessage.prototype, "fixHint", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsEnum)(WhereStatus),
      __metadata("design:type", String)
    ], ProblemReportMessage.prototype, "where", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsEnum)(ImpactStatus),
      __metadata("design:type", String)
    ], ProblemReportMessage.prototype, "impact", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      (0, class_transformer_1.Expose)({ name: "noticed_time" }),
      __metadata("design:type", String)
    ], ProblemReportMessage.prototype, "noticedTime", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      (0, class_transformer_1.Expose)({ name: "tracking_uri" }),
      __metadata("design:type", String)
    ], ProblemReportMessage.prototype, "trackingUri", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      (0, class_transformer_1.Expose)({ name: "escalation_uri" }),
      __metadata("design:type", String)
    ], ProblemReportMessage.prototype, "escalationUri", void 0);
    exports.ProblemReportMessage = ProblemReportMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/messages/ConnectionProblemReportMessage.js
var require_ConnectionProblemReportMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/messages/ConnectionProblemReportMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionProblemReportMessage = void 0;
    var messageType_1 = require_messageType();
    var ProblemReportMessage_1 = require_ProblemReportMessage();
    var ConnectionProblemReportMessage = class extends ProblemReportMessage_1.ProblemReportMessage {
      /**
       * Create new ConnectionProblemReportMessage instance.
       * @param options
       */
      constructor(options) {
        super(options);
        this.type = ConnectionProblemReportMessage.type.messageTypeUri;
      }
    };
    ConnectionProblemReportMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/connection/1.0/problem-report");
    __decorate([
      (0, messageType_1.IsValidMessageType)(ConnectionProblemReportMessage.type),
      __metadata("design:type", Object)
    ], ConnectionProblemReportMessage.prototype, "type", void 0);
    exports.ConnectionProblemReportMessage = ConnectionProblemReportMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/messages/DidExchangeRequestMessage.js
var require_DidExchangeRequestMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/messages/DidExchangeRequestMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidExchangeRequestMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var Attachment_1 = require_Attachment();
    var messageType_1 = require_messageType();
    var DidExchangeRequestMessage = class extends AgentMessage_1.AgentMessage {
      /**
       * Create new DidExchangeRequestMessage instance.
       * @param options
       */
      constructor(options) {
        super();
        this.type = DidExchangeRequestMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.label = options.label;
          this.goalCode = options.goalCode;
          this.goal = options.goal;
          this.did = options.did;
          this.setThread({
            threadId: this.id,
            parentThreadId: options.parentThreadId
          });
        }
      }
    };
    DidExchangeRequestMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/didexchange/1.0/request");
    __decorate([
      (0, messageType_1.IsValidMessageType)(DidExchangeRequestMessage.type),
      __metadata("design:type", Object)
    ], DidExchangeRequestMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], DidExchangeRequestMessage.prototype, "label", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "goal_code" }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], DidExchangeRequestMessage.prototype, "goalCode", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], DidExchangeRequestMessage.prototype, "goal", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], DidExchangeRequestMessage.prototype, "did", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "did_doc~attach" }),
      (0, class_transformer_1.Type)(() => Attachment_1.Attachment),
      (0, class_validator_1.ValidateNested)(),
      __metadata("design:type", Attachment_1.Attachment)
    ], DidExchangeRequestMessage.prototype, "didDoc", void 0);
    exports.DidExchangeRequestMessage = DidExchangeRequestMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/messages/DidExchangeResponseMessage.js
var require_DidExchangeResponseMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/messages/DidExchangeResponseMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidExchangeResponseMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var Attachment_1 = require_Attachment();
    var messageType_1 = require_messageType();
    var DidExchangeResponseMessage = class extends AgentMessage_1.AgentMessage {
      /**
       * Create new DidExchangeResponseMessage instance.
       * @param options
       */
      constructor(options) {
        super();
        this.type = DidExchangeResponseMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.did = options.did;
          this.setThread({
            threadId: options.threadId
          });
        }
      }
    };
    DidExchangeResponseMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/didexchange/1.0/response");
    __decorate([
      (0, messageType_1.IsValidMessageType)(DidExchangeResponseMessage.type),
      __metadata("design:type", Object)
    ], DidExchangeResponseMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], DidExchangeResponseMessage.prototype, "did", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "did_doc~attach" }),
      (0, class_transformer_1.Type)(() => Attachment_1.Attachment),
      (0, class_validator_1.ValidateNested)(),
      __metadata("design:type", Attachment_1.Attachment)
    ], DidExchangeResponseMessage.prototype, "didDoc", void 0);
    exports.DidExchangeResponseMessage = DidExchangeResponseMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/messages/DidExchangeCompleteMessage.js
var require_DidExchangeCompleteMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/messages/DidExchangeCompleteMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidExchangeCompleteMessage = void 0;
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var DidExchangeCompleteMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a;
        super();
        this.type = DidExchangeCompleteMessage.type.messageTypeUri;
        if (options) {
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.setThread({
            threadId: options.threadId,
            parentThreadId: options.parentThreadId
          });
        }
      }
    };
    DidExchangeCompleteMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/didexchange/1.0/complete");
    __decorate([
      (0, messageType_1.IsValidMessageType)(DidExchangeCompleteMessage.type),
      __metadata("design:type", Object)
    ], DidExchangeCompleteMessage.prototype, "type", void 0);
    exports.DidExchangeCompleteMessage = DidExchangeCompleteMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/messages/DidExchangeProblemReportMessage.js
var require_DidExchangeProblemReportMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/messages/DidExchangeProblemReportMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidExchangeProblemReportMessage = void 0;
    var messageType_1 = require_messageType();
    var ProblemReportMessage_1 = require_ProblemReportMessage();
    var DidExchangeProblemReportMessage = class extends ProblemReportMessage_1.ProblemReportMessage {
      constructor(options) {
        super(options);
        this.type = DidExchangeProblemReportMessage.type.messageTypeUri;
      }
    };
    DidExchangeProblemReportMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/didexchange/1.0/problem-report");
    __decorate([
      (0, messageType_1.IsValidMessageType)(DidExchangeProblemReportMessage.type),
      __metadata("design:type", Object)
    ], DidExchangeProblemReportMessage.prototype, "type", void 0);
    exports.DidExchangeProblemReportMessage = DidExchangeProblemReportMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/messages/index.js
var require_messages = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/messages/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ConnectionInvitationMessage(), exports);
    __exportStar(require_ConnectionRequestMessage(), exports);
    __exportStar(require_ConnectionResponseMessage(), exports);
    __exportStar(require_TrustPingMessage(), exports);
    __exportStar(require_TrustPingResponseMessage(), exports);
    __exportStar(require_ConnectionProblemReportMessage(), exports);
    __exportStar(require_DidExchangeRequestMessage(), exports);
    __exportStar(require_DidExchangeResponseMessage(), exports);
    __exportStar(require_DidExchangeCompleteMessage(), exports);
    __exportStar(require_DidExchangeProblemReportMessage(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/connections/repository/ConnectionRecord.js
var require_ConnectionRecord = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/repository/ConnectionRecord.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionRecord = void 0;
    var error_1 = require_error();
    var BaseRecord_1 = require_BaseRecord();
    var uuid_1 = require_uuid();
    var models_1 = require_models();
    var ConnectionRecord = class extends BaseRecord_1.BaseRecord {
      constructor(props) {
        var _a, _b, _c, _d;
        super();
        this.connectionTypes = [];
        this.type = ConnectionRecord.type;
        if (props) {
          this.id = (_a = props.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.createdAt = (_b = props.createdAt) !== null && _b !== void 0 ? _b : /* @__PURE__ */ new Date();
          this.did = props.did;
          this.invitationDid = props.invitationDid;
          this.theirDid = props.theirDid;
          this.theirLabel = props.theirLabel;
          this.state = props.state;
          this.role = props.role;
          this.alias = props.alias;
          this.autoAcceptConnection = props.autoAcceptConnection;
          this._tags = (_c = props.tags) !== null && _c !== void 0 ? _c : {};
          this.threadId = props.threadId;
          this.imageUrl = props.imageUrl;
          this.mediatorId = props.mediatorId;
          this.errorMessage = props.errorMessage;
          this.protocol = props.protocol;
          this.outOfBandId = props.outOfBandId;
          this.connectionTypes = (_d = props.connectionTypes) !== null && _d !== void 0 ? _d : [];
        }
      }
      getTags() {
        return Object.assign(Object.assign({}, this._tags), { state: this.state, role: this.role, threadId: this.threadId, mediatorId: this.mediatorId, did: this.did, theirDid: this.theirDid, outOfBandId: this.outOfBandId, invitationDid: this.invitationDid, connectionTypes: this.connectionTypes });
      }
      get isRequester() {
        return this.role === models_1.DidExchangeRole.Requester;
      }
      get rfc0160State() {
        return (0, models_1.rfc0160StateFromDidExchangeState)(this.state);
      }
      get isReady() {
        return this.state && [models_1.DidExchangeState.Completed, models_1.DidExchangeState.ResponseSent].includes(this.state);
      }
      assertReady() {
        if (!this.isReady) {
          throw new error_1.AriesFrameworkError(`Connection record is not ready to be used. Expected ${models_1.DidExchangeState.ResponseSent}, ${models_1.DidExchangeState.ResponseReceived} or ${models_1.DidExchangeState.Completed}, found invalid state ${this.state}`);
        }
      }
      assertState(expectedStates) {
        if (!Array.isArray(expectedStates)) {
          expectedStates = [expectedStates];
        }
        if (!expectedStates.includes(this.state)) {
          throw new error_1.AriesFrameworkError(`Connection record is in invalid state ${this.state}. Valid states are: ${expectedStates.join(", ")}.`);
        }
      }
      assertRole(expectedRole) {
        if (this.role !== expectedRole) {
          throw new error_1.AriesFrameworkError(`Connection record has invalid role ${this.role}. Expected role ${expectedRole}.`);
        }
      }
    };
    exports.ConnectionRecord = ConnectionRecord;
    ConnectionRecord.type = "ConnectionRecord";
  }
});

// node_modules/@aries-framework/core/build/modules/connections/repository/ConnectionRepository.js
var require_ConnectionRepository = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/repository/ConnectionRepository.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionRepository = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var Repository_1 = require_Repository();
    var ConnectionRecord_1 = require_ConnectionRecord();
    var ConnectionRepository = class ConnectionRepository extends Repository_1.Repository {
      constructor(storageService, eventEmitter) {
        super(ConnectionRecord_1.ConnectionRecord, storageService, eventEmitter);
      }
      async findByDids(agentContext, { ourDid, theirDid }) {
        return this.findSingleByQuery(agentContext, {
          did: ourDid,
          theirDid
        });
      }
      getByThreadId(agentContext, threadId) {
        return this.getSingleByQuery(agentContext, { threadId });
      }
      getByRoleAndThreadId(agentContext, role, threadId) {
        return this.getSingleByQuery(agentContext, { threadId, role });
      }
    };
    ConnectionRepository = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.StorageService)),
      __metadata("design:paramtypes", [Object, EventEmitter_1.EventEmitter])
    ], ConnectionRepository);
    exports.ConnectionRepository = ConnectionRepository;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/repository/index.js
var require_repository2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/repository/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ConnectionRecord(), exports);
    __exportStar(require_ConnectionRepository(), exports);
  }
});

// node_modules/@aries-framework/core/build/agent/Events.js
var require_Events = __commonJS({
  "node_modules/@aries-framework/core/build/agent/Events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentEventTypes = exports.filterContextCorrelationId = void 0;
    var rxjs_1 = require_cjs();
    function filterContextCorrelationId(contextCorrelationId) {
      return (source) => {
        return source.pipe((0, rxjs_1.filter)((event) => event.metadata.contextCorrelationId === contextCorrelationId));
      };
    }
    exports.filterContextCorrelationId = filterContextCorrelationId;
    var AgentEventTypes;
    (function(AgentEventTypes2) {
      AgentEventTypes2["AgentMessageReceived"] = "AgentMessageReceived";
      AgentEventTypes2["AgentMessageProcessed"] = "AgentMessageProcessed";
      AgentEventTypes2["AgentMessageSent"] = "AgentMessageSent";
    })(AgentEventTypes = exports.AgentEventTypes || (exports.AgentEventTypes = {}));
  }
});

// node_modules/@aries-framework/core/build/utils/timestamp.js
var require_timestamp2 = __commonJS({
  "node_modules/@aries-framework/core/build/utils/timestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function timestamp() {
      let time = Date.now();
      const bytes = [];
      for (let i = 0; i < 8; i++) {
        const byte = time & 255;
        bytes.push(byte);
        time = (time - byte) / 256;
      }
      return Uint8Array.from(bytes).reverse();
    }
    exports.default = timestamp;
  }
});

// node_modules/@aries-framework/core/build/decorators/signature/SignatureDecoratorUtils.js
var require_SignatureDecoratorUtils = __commonJS({
  "node_modules/@aries-framework/core/build/decorators/signature/SignatureDecoratorUtils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signData = exports.unpackAndVerifySignatureDecorator = void 0;
    var crypto_1 = require_crypto();
    var error_1 = require_error();
    var JsonEncoder_1 = require_JsonEncoder();
    var TypedArrayEncoder_1 = require_TypedArrayEncoder();
    var buffer_1 = require_buffer2();
    var timestamp_1 = __importDefault(require_timestamp2());
    var SignatureDecorator_1 = require_SignatureDecorator();
    async function unpackAndVerifySignatureDecorator(decorator, wallet) {
      const signerVerkey = decorator.signer;
      const key = crypto_1.Key.fromPublicKeyBase58(signerVerkey, crypto_1.KeyType.Ed25519);
      const signedData = TypedArrayEncoder_1.TypedArrayEncoder.fromBase64(decorator.signatureData);
      const signature = TypedArrayEncoder_1.TypedArrayEncoder.fromBase64(decorator.signature);
      const isValid = await wallet.verify({ signature, data: signedData, key });
      if (!isValid) {
        throw new error_1.AriesFrameworkError("Signature is not valid");
      }
      return JsonEncoder_1.JsonEncoder.fromBuffer(signedData.slice(8));
    }
    exports.unpackAndVerifySignatureDecorator = unpackAndVerifySignatureDecorator;
    async function signData(data, wallet, signerKey) {
      const dataBuffer = buffer_1.Buffer.concat([(0, timestamp_1.default)(), JsonEncoder_1.JsonEncoder.toBuffer(data)]);
      const key = crypto_1.Key.fromPublicKeyBase58(signerKey, crypto_1.KeyType.Ed25519);
      const signatureBuffer = await wallet.sign({ key, data: dataBuffer });
      const signatureDecorator = new SignatureDecorator_1.SignatureDecorator({
        signatureType: "https://didcomm.org/signature/1.0/ed25519Sha512_single",
        signature: TypedArrayEncoder_1.TypedArrayEncoder.toBase64URL(signatureBuffer),
        signatureData: TypedArrayEncoder_1.TypedArrayEncoder.toBase64URL(dataBuffer),
        signer: signerKey
      });
      return signatureDecorator;
    }
    exports.signData = signData;
  }
});

// node_modules/@aries-framework/core/build/utils/did.js
var require_did2 = __commonJS({
  "node_modules/@aries-framework/core/build/utils/did.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getIndyDidFromVerificationMethod = exports.isDidIdentifier = exports.isDid = exports.isVerkey = exports.isAbbreviatedVerkey = exports.isFullVerkey = exports.didFromRevocationRegistryDefinitionId = exports.didFromCredentialDefinitionId = exports.didFromSchemaId = exports.getFullVerkey = exports.indyDidFromPublicKeyBase58 = exports.isSelfCertifiedDid = exports.DID_IDENTIFIER_REGEX = exports.DID_REGEX = exports.VERKEY_REGEX = exports.ABBREVIATED_VERKEY_REGEX = exports.FULL_VERKEY_REGEX = void 0;
    var TypedArrayEncoder_1 = require_TypedArrayEncoder();
    var buffer_1 = require_buffer2();
    exports.FULL_VERKEY_REGEX = /^[1-9A-HJ-NP-Za-km-z]{43,44}$/;
    exports.ABBREVIATED_VERKEY_REGEX = /^~[1-9A-HJ-NP-Za-km-z]{21,22}$/;
    exports.VERKEY_REGEX = new RegExp(`${exports.FULL_VERKEY_REGEX.source}|${exports.ABBREVIATED_VERKEY_REGEX.source}`);
    exports.DID_REGEX = /^did:([a-z]+):([a-zA-z\d]+)/;
    exports.DID_IDENTIFIER_REGEX = /^[a-zA-z\d-]+$/;
    function isSelfCertifiedDid(did, verkey) {
      if (isAbbreviatedVerkey(verkey)) {
        return true;
      }
      const didFromVerkey = indyDidFromPublicKeyBase58(verkey);
      if (didFromVerkey === did) {
        return true;
      }
      return false;
    }
    exports.isSelfCertifiedDid = isSelfCertifiedDid;
    function indyDidFromPublicKeyBase58(publicKeyBase58) {
      const buffer = TypedArrayEncoder_1.TypedArrayEncoder.fromBase58(publicKeyBase58);
      const did = TypedArrayEncoder_1.TypedArrayEncoder.toBase58(buffer.slice(0, 16));
      return did;
    }
    exports.indyDidFromPublicKeyBase58 = indyDidFromPublicKeyBase58;
    function getFullVerkey(did, verkey) {
      var _a;
      if (isFullVerkey(verkey))
        return verkey;
      const id = (_a = did.split(":").pop()) !== null && _a !== void 0 ? _a : did;
      const verkeyWithoutTilde = verkey.slice(1);
      return TypedArrayEncoder_1.TypedArrayEncoder.toBase58(buffer_1.Buffer.concat([
        // Take did identifier (16 bytes)
        TypedArrayEncoder_1.TypedArrayEncoder.fromBase58(id),
        // Concat the abbreviated verkey (16 bytes)
        TypedArrayEncoder_1.TypedArrayEncoder.fromBase58(verkeyWithoutTilde)
      ]));
    }
    exports.getFullVerkey = getFullVerkey;
    function didFromSchemaId(schemaId) {
      const [did] = schemaId.split(":");
      return did;
    }
    exports.didFromSchemaId = didFromSchemaId;
    function didFromCredentialDefinitionId(credentialDefinitionId) {
      const [did] = credentialDefinitionId.split(":");
      return did;
    }
    exports.didFromCredentialDefinitionId = didFromCredentialDefinitionId;
    function didFromRevocationRegistryDefinitionId(revocationRegistryId) {
      const [did] = revocationRegistryId.split(":");
      return did;
    }
    exports.didFromRevocationRegistryDefinitionId = didFromRevocationRegistryDefinitionId;
    function isFullVerkey(verkey) {
      return exports.FULL_VERKEY_REGEX.test(verkey);
    }
    exports.isFullVerkey = isFullVerkey;
    function isAbbreviatedVerkey(verkey) {
      return exports.ABBREVIATED_VERKEY_REGEX.test(verkey);
    }
    exports.isAbbreviatedVerkey = isAbbreviatedVerkey;
    function isVerkey(verkey) {
      return exports.VERKEY_REGEX.test(verkey);
    }
    exports.isVerkey = isVerkey;
    function isDid(did) {
      return exports.DID_REGEX.test(did);
    }
    exports.isDid = isDid;
    function isDidIdentifier(identifier) {
      return exports.DID_IDENTIFIER_REGEX.test(identifier);
    }
    exports.isDidIdentifier = isDidIdentifier;
    function getIndyDidFromVerificationMethod(verificationMethod) {
      if (!(verificationMethod === null || verificationMethod === void 0 ? void 0 : verificationMethod.publicKeyBase58)) {
        throw new Error(`Unable to get publicKeyBase58 from verification method`);
      }
      const buffer = TypedArrayEncoder_1.TypedArrayEncoder.fromBase58(verificationMethod.publicKeyBase58);
      const did = TypedArrayEncoder_1.TypedArrayEncoder.toBase58(buffer.slice(0, 16));
      return did;
    }
    exports.getIndyDidFromVerificationMethod = getIndyDidFromVerificationMethod;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/types.js
var require_types2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/logger/Logger.js
var require_Logger = __commonJS({
  "node_modules/@aries-framework/core/build/logger/Logger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LogLevel = void 0;
    var LogLevel;
    (function(LogLevel2) {
      LogLevel2[LogLevel2["test"] = 0] = "test";
      LogLevel2[LogLevel2["trace"] = 1] = "trace";
      LogLevel2[LogLevel2["debug"] = 2] = "debug";
      LogLevel2[LogLevel2["info"] = 3] = "info";
      LogLevel2[LogLevel2["warn"] = 4] = "warn";
      LogLevel2[LogLevel2["error"] = 5] = "error";
      LogLevel2[LogLevel2["fatal"] = 6] = "fatal";
      LogLevel2[LogLevel2["off"] = 7] = "off";
    })(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
  }
});

// node_modules/@aries-framework/core/build/logger/BaseLogger.js
var require_BaseLogger = __commonJS({
  "node_modules/@aries-framework/core/build/logger/BaseLogger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseLogger = void 0;
    var Logger_1 = require_Logger();
    var BaseLogger = class {
      constructor(logLevel = Logger_1.LogLevel.off) {
        this.logLevel = logLevel;
      }
      isEnabled(logLevel) {
        return logLevel >= this.logLevel;
      }
    };
    exports.BaseLogger = BaseLogger;
  }
});

// node_modules/@aries-framework/core/build/logger/replaceError.js
var require_replaceError = __commonJS({
  "node_modules/@aries-framework/core/build/logger/replaceError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.replaceError = void 0;
    function replaceError(_, value) {
      if (value instanceof Error) {
        const newValue = Object.getOwnPropertyNames(value).reduce((obj, propName) => {
          obj[propName] = value[propName];
          return obj;
        }, { name: value.name });
        return newValue;
      }
      return value;
    }
    exports.replaceError = replaceError;
  }
});

// node_modules/@aries-framework/core/build/logger/ConsoleLogger.js
var require_ConsoleLogger = __commonJS({
  "node_modules/@aries-framework/core/build/logger/ConsoleLogger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConsoleLogger = void 0;
    var BaseLogger_1 = require_BaseLogger();
    var Logger_1 = require_Logger();
    var replaceError_1 = require_replaceError();
    var ConsoleLogger = class extends BaseLogger_1.BaseLogger {
      constructor() {
        super(...arguments);
        this.consoleLogMap = {
          [Logger_1.LogLevel.test]: "log",
          [Logger_1.LogLevel.trace]: "log",
          [Logger_1.LogLevel.debug]: "debug",
          [Logger_1.LogLevel.info]: "info",
          [Logger_1.LogLevel.warn]: "warn",
          [Logger_1.LogLevel.error]: "error",
          [Logger_1.LogLevel.fatal]: "error"
        };
      }
      log(level, message, data) {
        const consoleLevel = this.consoleLogMap[level];
        const prefix = Logger_1.LogLevel[level].toUpperCase();
        if (!this.isEnabled(level))
          return;
        if (data) {
          console[consoleLevel](`${prefix}: ${message}`, JSON.stringify(data, replaceError_1.replaceError, 2));
        } else {
          console[consoleLevel](`${prefix}: ${message}`);
        }
      }
      test(message, data) {
        this.log(Logger_1.LogLevel.test, message, data);
      }
      trace(message, data) {
        this.log(Logger_1.LogLevel.trace, message, data);
      }
      debug(message, data) {
        this.log(Logger_1.LogLevel.debug, message, data);
      }
      info(message, data) {
        this.log(Logger_1.LogLevel.info, message, data);
      }
      warn(message, data) {
        this.log(Logger_1.LogLevel.warn, message, data);
      }
      error(message, data) {
        this.log(Logger_1.LogLevel.error, message, data);
      }
      fatal(message, data) {
        this.log(Logger_1.LogLevel.fatal, message, data);
      }
    };
    exports.ConsoleLogger = ConsoleLogger;
  }
});

// node_modules/@aries-framework/core/build/logger/index.js
var require_logger = __commonJS({
  "node_modules/@aries-framework/core/build/logger/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ConsoleLogger(), exports);
    __exportStar(require_BaseLogger(), exports);
    __exportStar(require_Logger(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/models/CredentialAutoAcceptType.js
var require_CredentialAutoAcceptType = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/models/CredentialAutoAcceptType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AutoAcceptCredential = void 0;
    var AutoAcceptCredential;
    (function(AutoAcceptCredential2) {
      AutoAcceptCredential2["Always"] = "always";
      AutoAcceptCredential2["ContentApproved"] = "contentApproved";
      AutoAcceptCredential2["Never"] = "never";
    })(AutoAcceptCredential = exports.AutoAcceptCredential || (exports.AutoAcceptCredential = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/models/ProofAutoAcceptType.js
var require_ProofAutoAcceptType = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/models/ProofAutoAcceptType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AutoAcceptProof = void 0;
    var AutoAcceptProof;
    (function(AutoAcceptProof2) {
      AutoAcceptProof2["Always"] = "always";
      AutoAcceptProof2["ContentApproved"] = "contentApproved";
      AutoAcceptProof2["Never"] = "never";
    })(AutoAcceptProof = exports.AutoAcceptProof || (exports.AutoAcceptProof = {}));
  }
});

// node_modules/@aries-framework/core/build/types.js
var require_types3 = __commonJS({
  "node_modules/@aries-framework/core/build/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidCommMimeType = exports.KeyDerivationMethod = void 0;
    var KeyDerivationMethod;
    (function(KeyDerivationMethod2) {
      KeyDerivationMethod2["Argon2IMod"] = "ARGON2I_MOD";
      KeyDerivationMethod2["Argon2IInt"] = "ARGON2I_INT";
      KeyDerivationMethod2["Raw"] = "RAW";
    })(KeyDerivationMethod = exports.KeyDerivationMethod || (exports.KeyDerivationMethod = {}));
    var DidCommMimeType;
    (function(DidCommMimeType2) {
      DidCommMimeType2["V0"] = "application/ssi-agent-wire";
      DidCommMimeType2["V1"] = "application/didcomm-envelope-enc";
    })(DidCommMimeType = exports.DidCommMimeType || (exports.DidCommMimeType = {}));
  }
});

// node_modules/@aries-framework/core/build/agent/AgentConfig.js
var require_AgentConfig = __commonJS({
  "node_modules/@aries-framework/core/build/agent/AgentConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentConfig = void 0;
    var constants_1 = require_constants();
    var error_1 = require_error();
    var logger_1 = require_logger();
    var CredentialAutoAcceptType_1 = require_CredentialAutoAcceptType();
    var ProofAutoAcceptType_1 = require_ProofAutoAcceptType();
    var types_1 = require_types3();
    var AgentConfig = class {
      constructor(initConfig, agentDependencies) {
        var _a;
        this.initConfig = initConfig;
        this.label = initConfig.label;
        this.logger = (_a = initConfig.logger) !== null && _a !== void 0 ? _a : new logger_1.ConsoleLogger(logger_1.LogLevel.off);
        this.agentDependencies = agentDependencies;
        const { mediatorConnectionsInvite, clearDefaultMediator, defaultMediatorId } = this.initConfig;
        const allowOne = [mediatorConnectionsInvite, clearDefaultMediator, defaultMediatorId].filter((e) => e !== void 0);
        if (allowOne.length > 1) {
          throw new error_1.AriesFrameworkError(`Only one of 'mediatorConnectionsInvite', 'clearDefaultMediator' and 'defaultMediatorId' can be set as they negate each other`);
        }
      }
      /**
       * @deprecated use connectToIndyLedgersOnStartup from the `LedgerModuleConfig` class
       */
      get connectToIndyLedgersOnStartup() {
        var _a;
        return (_a = this.initConfig.connectToIndyLedgersOnStartup) !== null && _a !== void 0 ? _a : true;
      }
      /**
       * @deprecated The public did functionality of the wallet has been deprecated in favour of the DidsModule, which can be
       * used to create and resolve dids. Currently the global agent public did functionality is still used by the `LedgerModule`, but
       * will be removed once the `LedgerModule` has been deprecated. Do not use this property for new functionality, but rather
       * use the `DidsModule`.
       */
      get publicDidSeed() {
        return this.initConfig.publicDidSeed;
      }
      /**
       * @deprecated use indyLedgers from the `LedgerModuleConfig` class
       */
      get indyLedgers() {
        var _a;
        return (_a = this.initConfig.indyLedgers) !== null && _a !== void 0 ? _a : [];
      }
      /**
       * @todo move to context configuration
       */
      get walletConfig() {
        return this.initConfig.walletConfig;
      }
      /**
       * @deprecated use autoAcceptConnections from the `ConnectionsModuleConfig` class
       */
      get autoAcceptConnections() {
        var _a;
        return (_a = this.initConfig.autoAcceptConnections) !== null && _a !== void 0 ? _a : false;
      }
      /**
       * @deprecated use autoAcceptProofs from the `ProofsModuleConfig` class
       */
      get autoAcceptProofs() {
        var _a;
        return (_a = this.initConfig.autoAcceptProofs) !== null && _a !== void 0 ? _a : ProofAutoAcceptType_1.AutoAcceptProof.Never;
      }
      /**
       * @deprecated use autoAcceptCredentials from the `CredentialsModuleConfig` class
       */
      get autoAcceptCredentials() {
        var _a;
        return (_a = this.initConfig.autoAcceptCredentials) !== null && _a !== void 0 ? _a : CredentialAutoAcceptType_1.AutoAcceptCredential.Never;
      }
      get didCommMimeType() {
        var _a;
        return (_a = this.initConfig.didCommMimeType) !== null && _a !== void 0 ? _a : types_1.DidCommMimeType.V0;
      }
      /**
       * @deprecated use mediatorPollingInterval from the `RecipientModuleConfig` class
       */
      get mediatorPollingInterval() {
        var _a;
        return (_a = this.initConfig.mediatorPollingInterval) !== null && _a !== void 0 ? _a : 5e3;
      }
      /**
       * @deprecated use mediatorPickupStrategy from the `RecipientModuleConfig` class
       */
      get mediatorPickupStrategy() {
        return this.initConfig.mediatorPickupStrategy;
      }
      /**
       * @deprecated use maximumMessagePickup from the `RecipientModuleConfig` class
       */
      get maximumMessagePickup() {
        var _a;
        return (_a = this.initConfig.maximumMessagePickup) !== null && _a !== void 0 ? _a : 10;
      }
      /**
       * @deprecated use baseMediatorReconnectionIntervalMs from the `RecipientModuleConfig` class
       */
      get baseMediatorReconnectionIntervalMs() {
        var _a;
        return (_a = this.initConfig.baseMediatorReconnectionIntervalMs) !== null && _a !== void 0 ? _a : 100;
      }
      /**
       * @deprecated use maximumMediatorReconnectionIntervalMs from the `RecipientModuleConfig` class
       */
      get maximumMediatorReconnectionIntervalMs() {
        var _a;
        return (_a = this.initConfig.maximumMediatorReconnectionIntervalMs) !== null && _a !== void 0 ? _a : Number.POSITIVE_INFINITY;
      }
      /**
       * Encode keys in did:key format instead of 'naked' keys, as stated in Aries RFC 0360.
       *
       * This setting will not be taken into account if the other party has previously used naked keys
       * in a given protocol (i.e. it does not support Aries RFC 0360).
       */
      get useDidKeyInProtocols() {
        var _a;
        return (_a = this.initConfig.useDidKeyInProtocols) !== null && _a !== void 0 ? _a : true;
      }
      get endpoints() {
        if (!this.initConfig.endpoints || this.initConfig.endpoints.length === 0) {
          return [constants_1.DID_COMM_TRANSPORT_QUEUE];
        }
        return this.initConfig.endpoints;
      }
      /**
       * @deprecated use mediatorInvitationUrl from the `RecipientModuleConfig` class
       */
      get mediatorConnectionsInvite() {
        return this.initConfig.mediatorConnectionsInvite;
      }
      /**
       * @deprecated use autoAcceptMediationRequests from the `MediatorModuleConfig` class
       */
      get autoAcceptMediationRequests() {
        var _a;
        return (_a = this.initConfig.autoAcceptMediationRequests) !== null && _a !== void 0 ? _a : false;
      }
      /**
       * @deprecated you can use `RecipientApi.setDefaultMediator` to set the default mediator.
       */
      get defaultMediatorId() {
        return this.initConfig.defaultMediatorId;
      }
      /**
       * @deprecated you can set the `default` tag to `false` (or remove it completely) to clear the default mediator.
       */
      get clearDefaultMediator() {
        var _a;
        return (_a = this.initConfig.clearDefaultMediator) !== null && _a !== void 0 ? _a : false;
      }
      get useLegacyDidSovPrefix() {
        var _a;
        return (_a = this.initConfig.useLegacyDidSovPrefix) !== null && _a !== void 0 ? _a : false;
      }
      /**
       * @todo move to context configuration
       */
      get connectionImageUrl() {
        return this.initConfig.connectionImageUrl;
      }
      get autoUpdateStorageOnStartup() {
        var _a;
        return (_a = this.initConfig.autoUpdateStorageOnStartup) !== null && _a !== void 0 ? _a : false;
      }
      extend(config) {
        return new AgentConfig(Object.assign(Object.assign(Object.assign({}, this.initConfig), { logger: this.logger, label: this.label }), config), this.agentDependencies);
      }
      toJSON() {
        var _a, _b, _c, _d;
        return Object.assign(Object.assign({}, this.initConfig), { walletConfig: Object.assign(Object.assign({}, this.walletConfig), { key: ((_a = this.walletConfig) === null || _a === void 0 ? void 0 : _a.key) ? "[*****]" : void 0, storage: Object.assign(Object.assign({}, (_b = this.walletConfig) === null || _b === void 0 ? void 0 : _b.storage), { credentials: ((_d = (_c = this.walletConfig) === null || _c === void 0 ? void 0 : _c.storage) === null || _d === void 0 ? void 0 : _d.credentials) ? "[*****]" : void 0 }) }), logger: this.logger.logLevel, agentDependencies: Boolean(this.agentDependencies), label: this.label });
      }
    };
    exports.AgentConfig = AgentConfig;
  }
});

// node_modules/@aries-framework/core/build/agent/context/AgentContext.js
var require_AgentContext = __commonJS({
  "node_modules/@aries-framework/core/build/agent/context/AgentContext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentContext = void 0;
    var constants_1 = require_constants();
    var AgentConfig_1 = require_AgentConfig();
    var AgentContext = class {
      constructor({ dependencyManager, contextCorrelationId }) {
        this.dependencyManager = dependencyManager;
        this.contextCorrelationId = contextCorrelationId;
      }
      /**
       * Convenience method to access the agent config for the current context.
       */
      get config() {
        return this.dependencyManager.resolve(AgentConfig_1.AgentConfig);
      }
      /**
       * Convenience method to access the wallet for the current context.
       */
      get wallet() {
        return this.dependencyManager.resolve(constants_1.InjectionSymbols.Wallet);
      }
      /**
       * End session the current agent context
       */
      async endSession() {
        const agentContextProvider = this.dependencyManager.resolve(constants_1.InjectionSymbols.AgentContextProvider);
        await agentContextProvider.endSessionForAgentContext(this);
      }
      toJSON() {
        return {
          contextCorrelationId: this.contextCorrelationId
        };
      }
    };
    exports.AgentContext = AgentContext;
  }
});

// node_modules/@aries-framework/core/build/agent/context/AgentContextProvider.js
var require_AgentContextProvider = __commonJS({
  "node_modules/@aries-framework/core/build/agent/context/AgentContextProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/agent/context/DefaultAgentContextProvider.js
var require_DefaultAgentContextProvider = __commonJS({
  "node_modules/@aries-framework/core/build/agent/context/DefaultAgentContextProvider.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultAgentContextProvider = void 0;
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var AgentContext_1 = require_AgentContext();
    var DefaultAgentContextProvider = class DefaultAgentContextProvider {
      constructor(agentContext) {
        this.agentContext = agentContext;
      }
      async getAgentContextForContextCorrelationId(contextCorrelationId) {
        if (contextCorrelationId !== this.agentContext.contextCorrelationId) {
          throw new error_1.AriesFrameworkError(`Could not get agent context for contextCorrelationId '${contextCorrelationId}'. Only contextCorrelationId '${this.agentContext.contextCorrelationId}' is supported.`);
        }
        return this.agentContext;
      }
      async getContextForInboundMessage(_, options) {
        if (options === null || options === void 0 ? void 0 : options.contextCorrelationId) {
          return this.getAgentContextForContextCorrelationId(options.contextCorrelationId);
        }
        return this.agentContext;
      }
      async endSessionForAgentContext(agentContext) {
        if (agentContext.contextCorrelationId !== this.agentContext.contextCorrelationId) {
          throw new error_1.AriesFrameworkError(`Could not end session for agent context with contextCorrelationId '${agentContext.contextCorrelationId}'. Only contextCorrelationId '${this.agentContext.contextCorrelationId}' is provided by this provider.`);
        }
      }
    };
    DefaultAgentContextProvider = __decorate([
      (0, plugins_1.injectable)(),
      __metadata("design:paramtypes", [AgentContext_1.AgentContext])
    ], DefaultAgentContextProvider);
    exports.DefaultAgentContextProvider = DefaultAgentContextProvider;
  }
});

// node_modules/@aries-framework/core/build/agent/context/index.js
var require_context = __commonJS({
  "node_modules/@aries-framework/core/build/agent/context/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_AgentContext(), exports);
    __exportStar(require_AgentContextProvider(), exports);
    __exportStar(require_DefaultAgentContextProvider(), exports);
  }
});

// node_modules/@aries-framework/core/build/agent/index.js
var require_agent = __commonJS({
  "node_modules/@aries-framework/core/build/agent/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_context(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/dids/methods/peer/didPeer.js
var require_didPeer = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/methods/peer/didPeer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNumAlgoFromPeerDid = exports.PeerDidNumAlgo = exports.isValidPeerDid = void 0;
    var PEER_DID_REGEX = new RegExp("^did:peer:(([01](z)([1-9a-km-zA-HJ-NP-Z]{5,200}))|(2((.[AEVID](z)([1-9a-km-zA-HJ-NP-Z]{5,200}))+(.(S)[0-9a-zA-Z=]*)?)))$");
    function isValidPeerDid(did) {
      const isValid = PEER_DID_REGEX.test(did);
      return isValid;
    }
    exports.isValidPeerDid = isValidPeerDid;
    var PeerDidNumAlgo;
    (function(PeerDidNumAlgo2) {
      PeerDidNumAlgo2[PeerDidNumAlgo2["InceptionKeyWithoutDoc"] = 0] = "InceptionKeyWithoutDoc";
      PeerDidNumAlgo2[PeerDidNumAlgo2["GenesisDoc"] = 1] = "GenesisDoc";
      PeerDidNumAlgo2[PeerDidNumAlgo2["MultipleInceptionKeyWithoutDoc"] = 2] = "MultipleInceptionKeyWithoutDoc";
    })(PeerDidNumAlgo = exports.PeerDidNumAlgo || (exports.PeerDidNumAlgo = {}));
    function getNumAlgoFromPeerDid(did) {
      const numAlgo = Number(did[9]);
      if (numAlgo !== PeerDidNumAlgo.InceptionKeyWithoutDoc && numAlgo !== PeerDidNumAlgo.GenesisDoc && numAlgo !== PeerDidNumAlgo.MultipleInceptionKeyWithoutDoc) {
        throw new Error(`Invalid peer did numAlgo: ${numAlgo}`);
      }
      return numAlgo;
    }
    exports.getNumAlgoFromPeerDid = getNumAlgoFromPeerDid;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/methods/peer/peerDidNumAlgo0.js
var require_peerDidNumAlgo0 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/methods/peer/peerDidNumAlgo0.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.didToNumAlgo0DidDocument = exports.keyToNumAlgo0DidDocument = void 0;
    var crypto_1 = require_crypto();
    var keyDidDocument_1 = require_keyDidDocument();
    var parse_1 = require_parse();
    var didPeer_1 = require_didPeer();
    function keyToNumAlgo0DidDocument(key) {
      const did = `did:peer:0${key.fingerprint}`;
      return (0, keyDidDocument_1.getDidDocumentForKey)(did, key);
    }
    exports.keyToNumAlgo0DidDocument = keyToNumAlgo0DidDocument;
    function didToNumAlgo0DidDocument(did) {
      const parsed = (0, parse_1.parseDid)(did);
      const numAlgo = (0, didPeer_1.getNumAlgoFromPeerDid)(did);
      if (!(0, didPeer_1.isValidPeerDid)(did)) {
        throw new Error(`Invalid peer did '${did}'`);
      }
      if (numAlgo !== didPeer_1.PeerDidNumAlgo.InceptionKeyWithoutDoc) {
        throw new Error(`Invalid numAlgo ${numAlgo}, expected ${didPeer_1.PeerDidNumAlgo.InceptionKeyWithoutDoc}`);
      }
      const key = crypto_1.Key.fromFingerprint(parsed.id.substring(1));
      return (0, keyDidDocument_1.getDidDocumentForKey)(did, key);
    }
    exports.didToNumAlgo0DidDocument = didToNumAlgo0DidDocument;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/methods/peer/peerDidNumAlgo1.js
var require_peerDidNumAlgo1 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/methods/peer/peerDidNumAlgo1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.didDocumentJsonToNumAlgo1Did = void 0;
    var utils_1 = require_utils();
    function didDocumentJsonToNumAlgo1Did(didDocumentJson) {
      const didDocumentBuffer = utils_1.JsonEncoder.toBuffer(Object.assign(Object.assign({}, didDocumentJson), { id: void 0 }));
      const didIdentifier = utils_1.MultiBaseEncoder.encode(utils_1.MultiHashEncoder.encode(didDocumentBuffer, "sha2-256"), "base58btc");
      const did = `did:peer:1${didIdentifier}`;
      return did;
    }
    exports.didDocumentJsonToNumAlgo1Did = didDocumentJsonToNumAlgo1Did;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/methods/peer/peerDidNumAlgo2.js
var require_peerDidNumAlgo2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/methods/peer/peerDidNumAlgo2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.outOfBandServiceToNumAlgo2Did = exports.didDocumentToNumAlgo2Did = exports.didToNumAlgo2DidDocument = void 0;
    var crypto_1 = require_crypto();
    var utils_1 = require_utils();
    var domain_1 = require_domain();
    var DidDocumentBuilder_1 = require_DidDocumentBuilder();
    var key_type_1 = require_key_type();
    var parse_1 = require_parse();
    var key_1 = require_key();
    var DidPeerPurpose;
    (function(DidPeerPurpose2) {
      DidPeerPurpose2["Assertion"] = "A";
      DidPeerPurpose2["Encryption"] = "E";
      DidPeerPurpose2["Verification"] = "V";
      DidPeerPurpose2["CapabilityInvocation"] = "I";
      DidPeerPurpose2["CapabilityDelegation"] = "D";
      DidPeerPurpose2["Service"] = "S";
    })(DidPeerPurpose || (DidPeerPurpose = {}));
    function isDidPeerKeyPurpose(purpose) {
      return purpose !== DidPeerPurpose.Service && Object.values(DidPeerPurpose).includes(purpose);
    }
    var didPeerAbbreviations = {
      type: "t",
      DIDCommMessaging: "dm",
      serviceEndpoint: "s",
      routingKeys: "r",
      accept: "a"
    };
    var didPeerExpansions = {
      t: "type",
      dm: "DIDCommMessaging",
      s: "serviceEndpoint",
      r: "routingKeys",
      a: "accept"
    };
    function didToNumAlgo2DidDocument(did) {
      const parsed = (0, parse_1.parseDid)(did);
      const identifierWithoutNumAlgo = parsed.id.substring(2);
      const entries = identifierWithoutNumAlgo.split(".");
      const didDocument = new DidDocumentBuilder_1.DidDocumentBuilder(did);
      let serviceIndex = 0;
      for (const entry of entries) {
        const entryContent = entry.substring(1);
        const purpose = entry[0];
        if (purpose === DidPeerPurpose.Service) {
          let services = utils_1.JsonEncoder.fromBase64(entryContent);
          services = Array.isArray(services) ? services : [services];
          for (let service of services) {
            service = expandServiceAbbreviations(service);
            service.id = `${did}#${service.type.toLowerCase()}-${serviceIndex++}`;
            didDocument.addService(utils_1.JsonTransformer.fromJSON(service, domain_1.DidDocumentService));
          }
        } else {
          const key = crypto_1.Key.fromFingerprint(entryContent);
          const { getVerificationMethods } = (0, key_type_1.getKeyDidMappingByKeyType)(key.keyType);
          const verificationMethods = getVerificationMethods(did, key);
          for (const verificationMethod of verificationMethods) {
            verificationMethod.id = verificationMethod.id.replace("#z", "#");
            addVerificationMethodToDidDocument(didDocument, verificationMethod, purpose);
          }
        }
      }
      return didDocument.build();
    }
    exports.didToNumAlgo2DidDocument = didToNumAlgo2DidDocument;
    function didDocumentToNumAlgo2Did(didDocument) {
      const purposeMapping = {
        [DidPeerPurpose.Assertion]: didDocument.assertionMethod,
        [DidPeerPurpose.Encryption]: didDocument.keyAgreement,
        // FIXME: should verification be authentication or verificationMethod
        // verificationMethod is general so it doesn't make a lot of sense to add
        // it to the verificationMethod list
        [DidPeerPurpose.Verification]: didDocument.authentication,
        [DidPeerPurpose.CapabilityInvocation]: didDocument.capabilityInvocation,
        [DidPeerPurpose.CapabilityDelegation]: didDocument.capabilityDelegation
      };
      let did = "did:peer:2";
      for (const [purpose, entries] of Object.entries(purposeMapping)) {
        if (entries === void 0)
          continue;
        const dereferenced = entries.map((entry) => typeof entry === "string" ? didDocument.dereferenceVerificationMethod(entry) : entry);
        const encoded = dereferenced.map((entry) => {
          const { getKeyFromVerificationMethod } = (0, key_type_1.getKeyDidMappingByVerificationMethod)(entry);
          const key = getKeyFromVerificationMethod(entry);
          const encoded2 = `.${purpose}${key.fingerprint}`;
          return encoded2;
        });
        did += encoded.join("");
      }
      if (didDocument.service && didDocument.service.length > 0) {
        const abbreviatedServices = didDocument.service.map((service) => {
          const serviceJson = utils_1.JsonTransformer.toJSON(service);
          delete serviceJson.id;
          return abbreviateServiceJson(serviceJson);
        });
        const encodedServices = utils_1.JsonEncoder.toBase64URL(
          // If array length is 1, encode as json object. Otherwise as array
          // This is how it's done in the python peer did implementation.
          abbreviatedServices.length === 1 ? abbreviatedServices[0] : abbreviatedServices
        );
        did += `.${DidPeerPurpose.Service}${encodedServices}`;
      }
      return did;
    }
    exports.didDocumentToNumAlgo2Did = didDocumentToNumAlgo2Did;
    function outOfBandServiceToNumAlgo2Did(service) {
      var _a;
      const didDocument = new DidDocumentBuilder_1.DidDocumentBuilder("").addService(new domain_1.DidCommV1Service({
        id: service.id,
        serviceEndpoint: service.serviceEndpoint,
        accept: service.accept,
        // FIXME: this should actually be local key references, not did:key:123#456 references
        recipientKeys: service.recipientKeys.map((recipientKey) => {
          const did2 = key_1.DidKey.fromDid(recipientKey);
          return `${did2.did}#${did2.key.fingerprint}`;
        }),
        // Map did:key:xxx to actual did:key:xxx#123
        routingKeys: (_a = service.routingKeys) === null || _a === void 0 ? void 0 : _a.map((routingKey) => {
          const did2 = key_1.DidKey.fromDid(routingKey);
          return `${did2.did}#${did2.key.fingerprint}`;
        })
      })).build();
      const did = didDocumentToNumAlgo2Did(didDocument);
      return did;
    }
    exports.outOfBandServiceToNumAlgo2Did = outOfBandServiceToNumAlgo2Did;
    function expandServiceAbbreviations(service) {
      const expand = (abbreviated) => {
        var _a;
        return (_a = didPeerExpansions[abbreviated]) !== null && _a !== void 0 ? _a : abbreviated;
      };
      const fullService = Object.entries(service).reduce((serviceBody, [key, value]) => Object.assign(Object.assign({}, serviceBody), { [expand(key)]: expand(value) }), {});
      return fullService;
    }
    function abbreviateServiceJson(service) {
      const abbreviate = (expanded) => {
        var _a;
        return (_a = didPeerAbbreviations[expanded]) !== null && _a !== void 0 ? _a : expanded;
      };
      const abbreviatedService = Object.entries(service).reduce((serviceBody, [key, value]) => Object.assign(Object.assign({}, serviceBody), { [abbreviate(key)]: abbreviate(value) }), {});
      return abbreviatedService;
    }
    function addVerificationMethodToDidDocument(didDocument, verificationMethod, purpose) {
      const purposeMapping = {
        [DidPeerPurpose.Assertion]: didDocument.addAssertionMethod.bind(didDocument),
        [DidPeerPurpose.Encryption]: didDocument.addKeyAgreement.bind(didDocument),
        // FIXME: should verification be authentication or verificationMethod
        // verificationMethod is general so it doesn't make a lot of sense to add
        // it to the verificationMethod list
        [DidPeerPurpose.Verification]: didDocument.addAuthentication.bind(didDocument),
        [DidPeerPurpose.CapabilityInvocation]: didDocument.addCapabilityInvocation.bind(didDocument),
        [DidPeerPurpose.CapabilityDelegation]: didDocument.addCapabilityDelegation.bind(didDocument)
      };
      if (isDidPeerKeyPurpose(purpose)) {
        const addVerificationMethod = purposeMapping[purpose];
        addVerificationMethod(verificationMethod);
      } else {
        throw new Error(`Unsupported peer did purpose '${purpose}'`);
      }
    }
  }
});

// node_modules/@aries-framework/core/build/modules/dids/methods/peer/PeerDidRegistrar.js
var require_PeerDidRegistrar = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/methods/peer/PeerDidRegistrar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PeerDidRegistrar = void 0;
    var utils_1 = require_utils();
    var domain_1 = require_domain();
    var DidDocumentRole_1 = require_DidDocumentRole();
    var repository_1 = require_repository();
    var didPeer_1 = require_didPeer();
    var peerDidNumAlgo0_1 = require_peerDidNumAlgo0();
    var peerDidNumAlgo1_1 = require_peerDidNumAlgo1();
    var peerDidNumAlgo2_1 = require_peerDidNumAlgo2();
    var PeerDidRegistrar = class {
      constructor() {
        this.supportedMethods = ["peer"];
      }
      async create(agentContext, options) {
        var _a, _b;
        const didRepository = agentContext.dependencyManager.resolve(repository_1.DidRepository);
        let didDocument;
        try {
          if (isPeerDidNumAlgo0CreateOptions(options)) {
            const keyType = options.options.keyType;
            const seed = (_a = options.secret) === null || _a === void 0 ? void 0 : _a.seed;
            if (!keyType) {
              return {
                didDocumentMetadata: {},
                didRegistrationMetadata: {},
                didState: {
                  state: "failed",
                  reason: "Missing key type"
                }
              };
            }
            if (seed && (typeof seed !== "string" || seed.length !== 32)) {
              return {
                didDocumentMetadata: {},
                didRegistrationMetadata: {},
                didState: {
                  state: "failed",
                  reason: "Invalid seed provided"
                }
              };
            }
            const key = await agentContext.wallet.createKey({
              keyType,
              seed
            });
            didDocument = (0, peerDidNumAlgo0_1.keyToNumAlgo0DidDocument)(key);
          } else if (isPeerDidNumAlgo1CreateOptions(options)) {
            const didDocumentJson = options.didDocument.toJSON();
            const did = (0, peerDidNumAlgo1_1.didDocumentJsonToNumAlgo1Did)(didDocumentJson);
            didDocument = utils_1.JsonTransformer.fromJSON(Object.assign(Object.assign({}, didDocumentJson), { id: did }), domain_1.DidDocument);
          } else if (isPeerDidNumAlgo2CreateOptions(options)) {
            const didDocumentJson = options.didDocument.toJSON();
            const did = (0, peerDidNumAlgo2_1.didDocumentToNumAlgo2Did)(options.didDocument);
            didDocument = utils_1.JsonTransformer.fromJSON(Object.assign(Object.assign({}, didDocumentJson), { id: did }), domain_1.DidDocument);
          } else {
            return {
              didDocumentMetadata: {},
              didRegistrationMetadata: {},
              didState: {
                state: "failed",
                reason: `Missing or incorrect numAlgo provided`
              }
            };
          }
          const didRecord = new repository_1.DidRecord({
            did: didDocument.id,
            role: DidDocumentRole_1.DidDocumentRole.Created,
            didDocument: isPeerDidNumAlgo1CreateOptions(options) ? didDocument : void 0,
            tags: {
              // We need to save the recipientKeys, so we can find the associated did
              // of a key when we receive a message from another connection.
              recipientKeyFingerprints: didDocument.recipientKeys.map((key) => key.fingerprint)
            }
          });
          await didRepository.save(agentContext, didRecord);
          return {
            didDocumentMetadata: {},
            didRegistrationMetadata: {},
            didState: {
              state: "finished",
              did: didDocument.id,
              didDocument,
              secret: {
                // FIXME: the uni-registrar creates the seed in the registrar method
                // if it doesn't exist so the seed can always be returned. Currently
                // we can only return it if the seed was passed in by the user. Once
                // we have a secure method for generating seeds we should use the same
                // approach
                seed: (_b = options.secret) === null || _b === void 0 ? void 0 : _b.seed
              }
            }
          };
        } catch (error) {
          return {
            didDocumentMetadata: {},
            didRegistrationMetadata: {},
            didState: {
              state: "failed",
              reason: `unknown error: ${error.message}`
            }
          };
        }
      }
      async update() {
        return {
          didDocumentMetadata: {},
          didRegistrationMetadata: {},
          didState: {
            state: "failed",
            reason: `notImplemented: updating did:peer not implemented yet`
          }
        };
      }
      async deactivate() {
        return {
          didDocumentMetadata: {},
          didRegistrationMetadata: {},
          didState: {
            state: "failed",
            reason: `notImplemented: deactivating did:peer not implemented yet`
          }
        };
      }
    };
    exports.PeerDidRegistrar = PeerDidRegistrar;
    function isPeerDidNumAlgo1CreateOptions(options) {
      return options.options.numAlgo === didPeer_1.PeerDidNumAlgo.GenesisDoc;
    }
    function isPeerDidNumAlgo0CreateOptions(options) {
      return options.options.numAlgo === didPeer_1.PeerDidNumAlgo.InceptionKeyWithoutDoc;
    }
    function isPeerDidNumAlgo2CreateOptions(options) {
      return options.options.numAlgo === didPeer_1.PeerDidNumAlgo.MultipleInceptionKeyWithoutDoc;
    }
  }
});

// node_modules/@aries-framework/core/build/modules/dids/methods/peer/PeerDidResolver.js
var require_PeerDidResolver = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/methods/peer/PeerDidResolver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PeerDidResolver = void 0;
    var error_1 = require_error();
    var repository_1 = require_repository();
    var didPeer_1 = require_didPeer();
    var peerDidNumAlgo0_1 = require_peerDidNumAlgo0();
    var peerDidNumAlgo2_1 = require_peerDidNumAlgo2();
    var PeerDidResolver = class {
      constructor() {
        this.supportedMethods = ["peer"];
      }
      async resolve(agentContext, did) {
        const didRepository = agentContext.dependencyManager.resolve(repository_1.DidRepository);
        const didDocumentMetadata = {};
        try {
          let didDocument;
          if (!(0, didPeer_1.isValidPeerDid)(did)) {
            throw new error_1.AriesFrameworkError(`did ${did} is not a valid peer did`);
          }
          const numAlgo = (0, didPeer_1.getNumAlgoFromPeerDid)(did);
          if (numAlgo === didPeer_1.PeerDidNumAlgo.InceptionKeyWithoutDoc) {
            didDocument = (0, peerDidNumAlgo0_1.didToNumAlgo0DidDocument)(did);
          } else if (numAlgo === didPeer_1.PeerDidNumAlgo.GenesisDoc) {
            const [didDocumentRecord] = await didRepository.findAllByDid(agentContext, did);
            if (!didDocumentRecord) {
              throw new error_1.AriesFrameworkError(`No did record found for peer did ${did}.`);
            }
            if (!didDocumentRecord.didDocument) {
              throw new error_1.AriesFrameworkError(`Found did record for method 1 peer did (${did}), but no did document.`);
            }
            didDocument = didDocumentRecord.didDocument;
          } else {
            didDocument = (0, peerDidNumAlgo2_1.didToNumAlgo2DidDocument)(did);
          }
          return {
            didDocument,
            didDocumentMetadata,
            didResolutionMetadata: { contentType: "application/did+ld+json" }
          };
        } catch (error) {
          return {
            didDocument: null,
            didDocumentMetadata,
            didResolutionMetadata: {
              error: "notFound",
              message: `resolver_error: Unable to resolve did '${did}': ${error}`
            }
          };
        }
      }
    };
    exports.PeerDidResolver = PeerDidResolver;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/methods/peer/createPeerDidDocumentFromServices.js
var require_createPeerDidDocumentFromServices = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/methods/peer/createPeerDidDocumentFromServices.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPeerDidDocumentFromServices = void 0;
    var ed25519_1 = require_ed25519();
    var crypto_1 = require_crypto();
    var error_1 = require_error();
    var uuid_1 = require_uuid();
    var DidDocumentBuilder_1 = require_DidDocumentBuilder();
    var ed25519_2 = require_ed255192();
    var x25519_1 = require_x25519();
    var DidCommV1Service_1 = require_DidCommV1Service();
    var key_1 = require_key();
    function createPeerDidDocumentFromServices(services) {
      const didDocumentBuilder = new DidDocumentBuilder_1.DidDocumentBuilder("");
      const recipientKeyIdMapping = {};
      services.forEach((service, index) => {
        var _a;
        const recipientKeys = service.recipientKeys.map((recipientKey) => {
          if (recipientKeyIdMapping[recipientKey.fingerprint])
            return recipientKeyIdMapping[recipientKey.fingerprint];
          if (recipientKey.keyType !== crypto_1.KeyType.Ed25519) {
            throw new error_1.AriesFrameworkError(`Unable to create did document from services. recipient key type ${recipientKey.keyType} is not supported. Supported key types are ${crypto_1.KeyType.Ed25519}`);
          }
          const x25519Key = crypto_1.Key.fromPublicKey((0, ed25519_1.convertPublicKeyToX25519)(recipientKey.publicKey), crypto_1.KeyType.X25519);
          const ed25519VerificationMethod = (0, ed25519_2.getEd25519VerificationMethod)({
            id: `#${(0, uuid_1.uuid)()}`,
            key: recipientKey,
            controller: "#id"
          });
          const x25519VerificationMethod = (0, x25519_1.getX25519VerificationMethod)({
            id: `#${(0, uuid_1.uuid)()}`,
            key: x25519Key,
            controller: "#id"
          });
          recipientKeyIdMapping[recipientKey.fingerprint] = ed25519VerificationMethod.id;
          didDocumentBuilder.addAuthentication(ed25519VerificationMethod).addKeyAgreement(x25519VerificationMethod);
          return recipientKeyIdMapping[recipientKey.fingerprint];
        });
        const routingKeys = (_a = service.routingKeys) === null || _a === void 0 ? void 0 : _a.map((key) => {
          const didKey = new key_1.DidKey(key);
          return `${didKey.did}#${key.fingerprint}`;
        });
        didDocumentBuilder.addService(new DidCommV1Service_1.DidCommV1Service({
          id: service.id,
          priority: index,
          serviceEndpoint: service.serviceEndpoint,
          recipientKeys,
          routingKeys
        }));
      });
      return didDocumentBuilder.build();
    }
    exports.createPeerDidDocumentFromServices = createPeerDidDocumentFromServices;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/methods/peer/index.js
var require_peer = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/methods/peer/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_PeerDidRegistrar(), exports);
    __exportStar(require_PeerDidResolver(), exports);
    __exportStar(require_didPeer(), exports);
    __exportStar(require_createPeerDidDocumentFromServices(), exports);
  }
});

// node_modules/@aries-framework/core/build/utils/indyError.js
var require_indyError = __commonJS({
  "node_modules/@aries-framework/core/build/utils/indyError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isIndyError = exports.indyErrors = void 0;
    var error_1 = require_error();
    exports.indyErrors = {
      100: "CommonInvalidParam1",
      101: "CommonInvalidParam2",
      102: "CommonInvalidParam3",
      103: "CommonInvalidParam4",
      104: "CommonInvalidParam5",
      105: "CommonInvalidParam6",
      106: "CommonInvalidParam7",
      107: "CommonInvalidParam8",
      108: "CommonInvalidParam9",
      109: "CommonInvalidParam10",
      110: "CommonInvalidParam11",
      111: "CommonInvalidParam12",
      112: "CommonInvalidState",
      113: "CommonInvalidStructure",
      114: "CommonIOError",
      115: "CommonInvalidParam13",
      116: "CommonInvalidParam14",
      200: "WalletInvalidHandle",
      201: "WalletUnknownTypeError",
      202: "WalletTypeAlreadyRegisteredError",
      203: "WalletAlreadyExistsError",
      204: "WalletNotFoundError",
      205: "WalletIncompatiblePoolError",
      206: "WalletAlreadyOpenedError",
      207: "WalletAccessFailed",
      208: "WalletInputError",
      209: "WalletDecodingError",
      210: "WalletStorageError",
      211: "WalletEncryptionError",
      212: "WalletItemNotFound",
      213: "WalletItemAlreadyExists",
      214: "WalletQueryError",
      300: "PoolLedgerNotCreatedError",
      301: "PoolLedgerInvalidPoolHandle",
      302: "PoolLedgerTerminated",
      303: "LedgerNoConsensusError",
      304: "LedgerInvalidTransaction",
      305: "LedgerSecurityError",
      306: "PoolLedgerConfigAlreadyExistsError",
      307: "PoolLedgerTimeout",
      308: "PoolIncompatibleProtocolVersion",
      309: "LedgerNotFound",
      400: "AnoncredsRevocationRegistryFullError",
      401: "AnoncredsInvalidUserRevocId",
      404: "AnoncredsMasterSecretDuplicateNameError",
      405: "AnoncredsProofRejected",
      406: "AnoncredsCredentialRevoked",
      407: "AnoncredsCredDefAlreadyExistsError",
      500: "UnknownCryptoTypeError",
      600: "DidAlreadyExistsError",
      700: "PaymentUnknownMethodError",
      701: "PaymentIncompatibleMethodsError",
      702: "PaymentInsufficientFundsError",
      703: "PaymentSourceDoesNotExistError",
      704: "PaymentOperationNotSupportedError",
      705: "PaymentExtraFundsError",
      706: "TransactionNotAllowedError"
    };
    function isIndyError(error, errorName) {
      if (typeof error !== "object" || error === null)
        return false;
      const indyError = error.name === "IndyError";
      if (!indyError || !errorName)
        return indyError;
      if (!error.indyName) {
        const errorCode = Number(error.message);
        if (!isNaN(errorCode) && Object.prototype.hasOwnProperty.call(exports.indyErrors, errorCode)) {
          return errorName === exports.indyErrors[errorCode];
        }
        throw new error_1.AriesFrameworkError(`Could not determine errorName of indyError ${error.message}`);
      }
      return error.indyName === errorName;
    }
    exports.isIndyError = isIndyError;
  }
});

// node_modules/@aries-framework/core/build/utils/error.js
var require_error2 = __commonJS({
  "node_modules/@aries-framework/core/build/utils/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isError = void 0;
    var isError = (value) => value instanceof Error;
    exports.isError = isError;
  }
});

// node_modules/@aries-framework/core/build/wallet/error/WalletDuplicateError.js
var require_WalletDuplicateError = __commonJS({
  "node_modules/@aries-framework/core/build/wallet/error/WalletDuplicateError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletDuplicateError = void 0;
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var WalletDuplicateError = class extends AriesFrameworkError_1.AriesFrameworkError {
      constructor(message, { walletType, cause }) {
        super(`${walletType}: ${message}`, { cause });
      }
    };
    exports.WalletDuplicateError = WalletDuplicateError;
  }
});

// node_modules/@aries-framework/core/build/wallet/error/WalletNotFoundError.js
var require_WalletNotFoundError = __commonJS({
  "node_modules/@aries-framework/core/build/wallet/error/WalletNotFoundError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletNotFoundError = void 0;
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var WalletNotFoundError = class extends AriesFrameworkError_1.AriesFrameworkError {
      constructor(message, { walletType, cause }) {
        super(`${walletType}: ${message}`, { cause });
      }
    };
    exports.WalletNotFoundError = WalletNotFoundError;
  }
});

// node_modules/@aries-framework/core/build/wallet/error/WalletInvalidKeyError.js
var require_WalletInvalidKeyError = __commonJS({
  "node_modules/@aries-framework/core/build/wallet/error/WalletInvalidKeyError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletInvalidKeyError = void 0;
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var WalletInvalidKeyError = class extends AriesFrameworkError_1.AriesFrameworkError {
      constructor(message, { walletType, cause }) {
        super(`${walletType}: ${message}`, { cause });
      }
    };
    exports.WalletInvalidKeyError = WalletInvalidKeyError;
  }
});

// node_modules/@aries-framework/core/build/wallet/error/WalletError.js
var require_WalletError = __commonJS({
  "node_modules/@aries-framework/core/build/wallet/error/WalletError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletError = void 0;
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var WalletError = class extends AriesFrameworkError_1.AriesFrameworkError {
      constructor(message, { cause } = {}) {
        super(message, { cause });
      }
    };
    exports.WalletError = WalletError;
  }
});

// node_modules/@aries-framework/core/build/wallet/error/index.js
var require_error3 = __commonJS({
  "node_modules/@aries-framework/core/build/wallet/error/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletError = exports.WalletInvalidKeyError = exports.WalletNotFoundError = exports.WalletDuplicateError = void 0;
    var WalletDuplicateError_1 = require_WalletDuplicateError();
    Object.defineProperty(exports, "WalletDuplicateError", { enumerable: true, get: function() {
      return WalletDuplicateError_1.WalletDuplicateError;
    } });
    var WalletNotFoundError_1 = require_WalletNotFoundError();
    Object.defineProperty(exports, "WalletNotFoundError", { enumerable: true, get: function() {
      return WalletNotFoundError_1.WalletNotFoundError;
    } });
    var WalletInvalidKeyError_1 = require_WalletInvalidKeyError();
    Object.defineProperty(exports, "WalletInvalidKeyError", { enumerable: true, get: function() {
      return WalletInvalidKeyError_1.WalletInvalidKeyError;
    } });
    var WalletError_1 = require_WalletError();
    Object.defineProperty(exports, "WalletError", { enumerable: true, get: function() {
      return WalletError_1.WalletError;
    } });
  }
});

// node_modules/@aries-framework/core/build/wallet/IndyWallet.js
var require_IndyWallet = __commonJS({
  "node_modules/@aries-framework/core/build/wallet/IndyWallet.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyWallet = void 0;
    var tsyringe_1 = (init_esm53(), __toCommonJS(esm5_exports3));
    var constants_1 = require_constants();
    var crypto_1 = require_crypto();
    var Key_1 = require_Key();
    var SigningProviderRegistry_1 = require_SigningProviderRegistry();
    var error_1 = require_error();
    var utils_1 = require_utils();
    var JsonEncoder_1 = require_JsonEncoder();
    var error_2 = require_error2();
    var indyError_1 = require_indyError();
    var error_3 = require_error3();
    var WalletInvalidKeyError_1 = require_WalletInvalidKeyError();
    var IndyWallet = class IndyWallet {
      constructor(agentDependencies, logger, signingKeyProviderRegistry) {
        this.logger = logger;
        this.signingKeyProviderRegistry = signingKeyProviderRegistry;
        this.indy = agentDependencies.indy;
      }
      get isProvisioned() {
        return this.walletConfig !== void 0;
      }
      get isInitialized() {
        return this.walletHandle !== void 0;
      }
      /**
       * @deprecated The public did functionality of the wallet has been deprecated in favour of the DidsModule, which can be
       * used to create and resolve dids. Currently the global agent public did functionality is still used by the `LedgerModule`, but
       * will be removed once the `LedgerModule` has been deprecated. Do not use this property for new functionality, but rather
       * use the `DidsModule`.
       */
      get publicDid() {
        return this.publicDidInfo;
      }
      get handle() {
        if (!this.walletHandle) {
          throw new error_1.AriesFrameworkError("Wallet has not been initialized yet. Make sure to await agent.initialize() before using the agent.");
        }
        return this.walletHandle;
      }
      get masterSecretId() {
        var _a, _b, _c, _d;
        if (!this.isInitialized || !(((_a = this.walletConfig) === null || _a === void 0 ? void 0 : _a.id) || ((_b = this.walletConfig) === null || _b === void 0 ? void 0 : _b.masterSecretId))) {
          throw new error_1.AriesFrameworkError("Wallet has not been initialized yet. Make sure to await agent.initialize() before using the agent.");
        }
        return (_d = (_c = this.walletConfig) === null || _c === void 0 ? void 0 : _c.masterSecretId) !== null && _d !== void 0 ? _d : this.walletConfig.id;
      }
      /**
       * Dispose method is called when an agent context is disposed.
       */
      async dispose() {
        if (this.isInitialized) {
          await this.close();
        }
      }
      walletStorageConfig(walletConfig) {
        var _a, _b, _c;
        const walletStorageConfig = {
          id: walletConfig.id,
          storage_type: (_a = walletConfig.storage) === null || _a === void 0 ? void 0 : _a.type
        };
        if ((_b = walletConfig.storage) === null || _b === void 0 ? void 0 : _b.config) {
          walletStorageConfig.storage_config = (_c = walletConfig.storage) === null || _c === void 0 ? void 0 : _c.config;
        }
        return walletStorageConfig;
      }
      walletCredentials(walletConfig, rekey, rekeyDerivation) {
        var _a, _b;
        const walletCredentials = {
          key: walletConfig.key,
          key_derivation_method: walletConfig.keyDerivationMethod
        };
        if (rekey) {
          walletCredentials.rekey = rekey;
        }
        if (rekeyDerivation) {
          walletCredentials.rekey_derivation_method = rekeyDerivation;
        }
        if ((_a = walletConfig.storage) === null || _a === void 0 ? void 0 : _a.credentials) {
          walletCredentials.storage_credentials = (_b = walletConfig.storage) === null || _b === void 0 ? void 0 : _b.credentials;
        }
        return walletCredentials;
      }
      /**
       * @throws {WalletDuplicateError} if the wallet already exists
       * @throws {WalletError} if another error occurs
       */
      async create(walletConfig) {
        await this.createAndOpen(walletConfig);
        await this.close();
      }
      /**
       * @throws {WalletDuplicateError} if the wallet already exists
       * @throws {WalletError} if another error occurs
       */
      async createAndOpen(walletConfig) {
        this.logger.debug(`Creating wallet '${walletConfig.id}' using SQLite storage`);
        try {
          await this.indy.createWallet(this.walletStorageConfig(walletConfig), this.walletCredentials(walletConfig));
          this.walletConfig = walletConfig;
          await this.open(walletConfig);
          await this.createMasterSecret(this.handle, this.masterSecretId);
        } catch (error) {
          if (this.isInitialized)
            await this.close();
          if ((0, indyError_1.isIndyError)(error, "WalletAlreadyExistsError")) {
            const errorMessage = `Wallet '${walletConfig.id}' already exists`;
            this.logger.debug(errorMessage);
            throw new error_3.WalletDuplicateError(errorMessage, {
              walletType: "IndyWallet",
              cause: error
            });
          } else {
            if (!(0, error_2.isError)(error)) {
              throw new error_1.AriesFrameworkError("Attempted to throw error, but it was not of type Error");
            }
            const errorMessage = `Error creating wallet '${walletConfig.id}'`;
            this.logger.error(errorMessage, {
              error,
              errorMessage: error.message
            });
            throw new error_3.WalletError(errorMessage, { cause: error });
          }
        }
        this.logger.debug(`Successfully created wallet '${walletConfig.id}'`);
      }
      /**
       * @throws {WalletNotFoundError} if the wallet does not exist
       * @throws {WalletError} if another error occurs
       */
      async open(walletConfig) {
        await this._open(walletConfig);
      }
      /**
       * @throws {WalletNotFoundError} if the wallet does not exist
       * @throws {WalletError} if another error occurs
       */
      async rotateKey(walletConfig) {
        if (!walletConfig.rekey) {
          throw new error_3.WalletError("Wallet rekey undefined!. Please specify the new wallet key");
        }
        await this._open({
          id: walletConfig.id,
          key: walletConfig.key,
          keyDerivationMethod: walletConfig.keyDerivationMethod
        }, walletConfig.rekey, walletConfig.rekeyDerivationMethod);
      }
      /**
       * @throws {WalletNotFoundError} if the wallet does not exist
       * @throws {WalletError} if another error occurs
       */
      async _open(walletConfig, rekey, rekeyDerivation) {
        if (this.walletHandle) {
          throw new error_3.WalletError("Wallet instance already opened. Close the currently opened wallet before re-opening the wallet");
        }
        try {
          this.walletHandle = await this.indy.openWallet(this.walletStorageConfig(walletConfig), this.walletCredentials(walletConfig, rekey, rekeyDerivation));
          if (rekey) {
            this.walletConfig = Object.assign(Object.assign({}, walletConfig), { key: rekey, keyDerivationMethod: rekeyDerivation });
          } else {
            this.walletConfig = walletConfig;
          }
        } catch (error) {
          if ((0, indyError_1.isIndyError)(error, "WalletNotFoundError")) {
            const errorMessage = `Wallet '${walletConfig.id}' not found`;
            this.logger.debug(errorMessage);
            throw new error_3.WalletNotFoundError(errorMessage, {
              walletType: "IndyWallet",
              cause: error
            });
          } else if ((0, indyError_1.isIndyError)(error, "WalletAccessFailed")) {
            const errorMessage = `Incorrect key for wallet '${walletConfig.id}'`;
            this.logger.debug(errorMessage);
            throw new WalletInvalidKeyError_1.WalletInvalidKeyError(errorMessage, {
              walletType: "IndyWallet",
              cause: error
            });
          } else {
            if (!(0, error_2.isError)(error)) {
              throw new error_1.AriesFrameworkError("Attempted to throw error, but it was not of type Error");
            }
            const errorMessage = `Error opening wallet '${walletConfig.id}': ${error.message}`;
            this.logger.error(errorMessage, {
              error,
              errorMessage: error.message
            });
            throw new error_3.WalletError(errorMessage, { cause: error });
          }
        }
        this.logger.debug(`Wallet '${walletConfig.id}' opened with handle '${this.handle}'`);
      }
      /**
       * @throws {WalletNotFoundError} if the wallet does not exist
       * @throws {WalletError} if another error occurs
       */
      async delete() {
        if (!this.walletConfig) {
          throw new error_3.WalletError("Can not delete wallet that does not have wallet config set. Make sure to call create wallet before deleting the wallet");
        }
        this.logger.info(`Deleting wallet '${this.walletConfig.id}'`);
        if (this.walletHandle) {
          await this.close();
        }
        try {
          await this.indy.deleteWallet(this.walletStorageConfig(this.walletConfig), this.walletCredentials(this.walletConfig));
        } catch (error) {
          if ((0, indyError_1.isIndyError)(error, "WalletNotFoundError")) {
            const errorMessage = `Error deleting wallet: wallet '${this.walletConfig.id}' not found`;
            this.logger.debug(errorMessage);
            throw new error_3.WalletNotFoundError(errorMessage, {
              walletType: "IndyWallet",
              cause: error
            });
          } else {
            if (!(0, error_2.isError)(error)) {
              throw new error_1.AriesFrameworkError("Attempted to throw error, but it was not of type Error");
            }
            const errorMessage = `Error deleting wallet '${this.walletConfig.id}': ${error.message}`;
            this.logger.error(errorMessage, {
              error,
              errorMessage: error.message
            });
            throw new error_3.WalletError(errorMessage, { cause: error });
          }
        }
      }
      async export(exportConfig) {
        var _a;
        try {
          this.logger.debug(`Exporting wallet ${(_a = this.walletConfig) === null || _a === void 0 ? void 0 : _a.id} to path ${exportConfig.path}`);
          await this.indy.exportWallet(this.handle, exportConfig);
        } catch (error) {
          if (!(0, error_2.isError)(error)) {
            throw new error_1.AriesFrameworkError("Attempted to throw error, but it was not of type Error");
          }
          const errorMessage = `Error exporting wallet: ${error.message}`;
          this.logger.error(errorMessage, {
            error
          });
          throw new error_3.WalletError(errorMessage, { cause: error });
        }
      }
      async import(walletConfig, importConfig) {
        try {
          this.logger.debug(`Importing wallet ${walletConfig.id} from path ${importConfig.path}`);
          await this.indy.importWallet({ id: walletConfig.id }, { key: walletConfig.key, key_derivation_method: walletConfig.keyDerivationMethod }, importConfig);
        } catch (error) {
          if (!(0, error_2.isError)(error)) {
            throw new error_1.AriesFrameworkError("Attempted to throw error, but it was not of type Error");
          }
          const errorMessage = `Error importing wallet': ${error.message}`;
          this.logger.error(errorMessage, {
            error
          });
          throw new error_3.WalletError(errorMessage, { cause: error });
        }
      }
      /**
       * @throws {WalletError} if the wallet is already closed or another error occurs
       */
      async close() {
        var _a;
        this.logger.debug(`Closing wallet ${(_a = this.walletConfig) === null || _a === void 0 ? void 0 : _a.id}`);
        if (!this.walletHandle) {
          throw new error_3.WalletError("Wallet is in invalid state, you are trying to close wallet that has no `walletHandle`.");
        }
        try {
          await this.indy.closeWallet(this.walletHandle);
          this.walletHandle = void 0;
          this.publicDidInfo = void 0;
        } catch (error) {
          if ((0, indyError_1.isIndyError)(error, "WalletInvalidHandle")) {
            const errorMessage = `Error closing wallet: wallet already closed`;
            this.logger.debug(errorMessage);
            throw new error_3.WalletError(errorMessage, {
              cause: error
            });
          } else {
            if (!(0, error_2.isError)(error)) {
              throw new error_1.AriesFrameworkError("Attempted to throw error, but it was not of type Error");
            }
            const errorMessage = `Error closing wallet': ${error.message}`;
            this.logger.error(errorMessage, {
              error,
              errorMessage: error.message
            });
            throw new error_3.WalletError(errorMessage, { cause: error });
          }
        }
      }
      /**
       * Create master secret with specified id in currently opened wallet.
       *
       * If a master secret by this id already exists in the current wallet, the method
       * will return without doing anything.
       *
       * @throws {WalletError} if an error occurs
       */
      async createMasterSecret(walletHandle, masterSecretId) {
        this.logger.debug(`Creating master secret with id '${masterSecretId}' in wallet with handle '${walletHandle}'`);
        try {
          await this.indy.proverCreateMasterSecret(walletHandle, masterSecretId);
          return masterSecretId;
        } catch (error) {
          if ((0, indyError_1.isIndyError)(error, "AnoncredsMasterSecretDuplicateNameError")) {
            this.logger.debug(`Master secret with id '${masterSecretId}' already exists in wallet with handle '${walletHandle}'`, {
              indyError: "AnoncredsMasterSecretDuplicateNameError"
            });
            return masterSecretId;
          } else {
            if (!(0, indyError_1.isIndyError)(error)) {
              throw new error_1.AriesFrameworkError("Attempted to throw Indy error, but it was not an Indy error");
            }
            this.logger.error(`Error creating master secret with id ${masterSecretId}`, {
              indyError: error.indyName,
              error
            });
            throw new error_3.WalletError(`Error creating master secret with id ${masterSecretId} in wallet with handle '${walletHandle}'`, { cause: error });
          }
        }
      }
      /**
       * @deprecated The public did functionality of the wallet has been deprecated in favour of the DidsModule, which can be
       * used to create and resolve dids. Currently the global agent public did functionality is still used by the `LedgerModule`, but
       * will be removed once the `LedgerModule` has been deprecated. Do not use this property for new functionality, but rather
       * use the `DidsModule`.
       */
      async initPublicDid(didConfig) {
        try {
          const [did, verkey] = await this.indy.createAndStoreMyDid(this.handle, didConfig || {});
          this.publicDidInfo = {
            did,
            verkey
          };
        } catch (error) {
          if (!(0, error_2.isError)(error)) {
            throw new error_1.AriesFrameworkError("Attempted to throw error, but it was not of type Error");
          }
          throw new error_3.WalletError("Error creating Did", { cause: error });
        }
      }
      /**
       * Create a key with an optional seed and keyType.
       * The keypair is also automatically stored in the wallet afterwards
       *
       * Bls12381g1g2 and X25519 are not supported.
       *
       * @param seed string The seed for creating a key
       * @param keyType KeyType the type of key that should be created
       *
       * @returns a Key instance with a publicKeyBase58
       *
       * @throws {WalletError} When an unsupported keytype is requested
       * @throws {WalletError} When the key could not be created
       */
      async createKey({ seed, keyType }) {
        try {
          if (keyType === crypto_1.KeyType.Ed25519) {
            const verkey = await this.indy.createKey(this.handle, { seed, crypto_type: "ed25519" });
            return Key_1.Key.fromPublicKeyBase58(verkey, keyType);
          }
          if (this.signingKeyProviderRegistry.hasProviderForKeyType(keyType)) {
            const signingKeyProvider = this.signingKeyProviderRegistry.getProviderForKeyType(keyType);
            const keyPair = await signingKeyProvider.createKeyPair({ seed });
            await this.storeKeyPair(keyPair);
            return Key_1.Key.fromPublicKeyBase58(keyPair.publicKeyBase58, keyType);
          }
        } catch (error) {
          if (!(0, error_2.isError)(error)) {
            throw new error_1.AriesFrameworkError("Attempted to throw error, but it was not of type Error");
          }
          throw new error_3.WalletError(`Error creating key with key type '${keyType}': ${error.message}`, { cause: error });
        }
        throw new error_3.WalletError(`Unsupported key type: '${keyType}' for wallet IndyWallet`);
      }
      /**
       * sign a Buffer with an instance of a Key class
       *
       * Bls12381g1g2, Bls12381g1 and X25519 are not supported.
       *
       * @param data Buffer The data that needs to be signed
       * @param key Key The key that is used to sign the data
       *
       * @returns A signature for the data
       */
      async sign({ data, key }) {
        try {
          if (key.keyType === crypto_1.KeyType.Ed25519) {
            if (!utils_1.TypedArrayEncoder.isTypedArray(data)) {
              throw new error_3.WalletError(`${crypto_1.KeyType.Ed25519} does not support multiple singing of multiple messages`);
            }
            return await this.indy.cryptoSign(this.handle, key.publicKeyBase58, data);
          }
          if (this.signingKeyProviderRegistry.hasProviderForKeyType(key.keyType)) {
            const signingKeyProvider = this.signingKeyProviderRegistry.getProviderForKeyType(key.keyType);
            const keyPair = await this.retrieveKeyPair(key.publicKeyBase58);
            const signed = await signingKeyProvider.sign({
              data,
              privateKeyBase58: keyPair.privateKeyBase58,
              publicKeyBase58: key.publicKeyBase58
            });
            return signed;
          }
        } catch (error) {
          if (!(0, error_2.isError)(error)) {
            throw new error_1.AriesFrameworkError("Attempted to throw error, but it was not of type Error");
          }
          throw new error_3.WalletError(`Error signing data with verkey ${key.publicKeyBase58}`, { cause: error });
        }
        throw new error_3.WalletError(`Unsupported keyType: ${key.keyType}`);
      }
      /**
       * Verify the signature with the data and the used key
       *
       * Bls12381g1g2, Bls12381g1 and X25519 are not supported.
       *
       * @param data Buffer The data that has to be confirmed to be signed
       * @param key Key The key that was used in the signing process
       * @param signature Buffer The signature that was created by the signing process
       *
       * @returns A boolean whether the signature was created with the supplied data and key
       *
       * @throws {WalletError} When it could not do the verification
       * @throws {WalletError} When an unsupported keytype is used
       */
      async verify({ data, key, signature }) {
        try {
          if (key.keyType === crypto_1.KeyType.Ed25519) {
            if (!utils_1.TypedArrayEncoder.isTypedArray(data)) {
              throw new error_3.WalletError(`${crypto_1.KeyType.Ed25519} does not support multiple singing of multiple messages`);
            }
            return await this.indy.cryptoVerify(key.publicKeyBase58, data, signature);
          }
          if (this.signingKeyProviderRegistry.hasProviderForKeyType(key.keyType)) {
            const signingKeyProvider = this.signingKeyProviderRegistry.getProviderForKeyType(key.keyType);
            const signed = await signingKeyProvider.verify({
              data,
              signature,
              publicKeyBase58: key.publicKeyBase58
            });
            return signed;
          }
        } catch (error) {
          if (!(0, error_2.isError)(error)) {
            throw new error_1.AriesFrameworkError("Attempted to throw error, but it was not of type Error");
          }
          throw new error_3.WalletError(`Error verifying signature of data signed with verkey ${key.publicKeyBase58}`, {
            cause: error
          });
        }
        throw new error_3.WalletError(`Unsupported keyType: ${key.keyType}`);
      }
      async pack(payload, recipientKeys, senderVerkey) {
        try {
          const messageRaw = JsonEncoder_1.JsonEncoder.toBuffer(payload);
          const packedMessage = await this.indy.packMessage(this.handle, messageRaw, recipientKeys, senderVerkey !== null && senderVerkey !== void 0 ? senderVerkey : null);
          return JsonEncoder_1.JsonEncoder.fromBuffer(packedMessage);
        } catch (error) {
          if (!(0, error_2.isError)(error)) {
            throw new error_1.AriesFrameworkError("Attempted to throw error, but it was not of type Error");
          }
          throw new error_3.WalletError("Error packing message", { cause: error });
        }
      }
      async unpack(messagePackage) {
        try {
          const unpackedMessageBuffer = await this.indy.unpackMessage(this.handle, JsonEncoder_1.JsonEncoder.toBuffer(messagePackage));
          const unpackedMessage = JsonEncoder_1.JsonEncoder.fromBuffer(unpackedMessageBuffer);
          return {
            senderKey: unpackedMessage.sender_verkey,
            recipientKey: unpackedMessage.recipient_verkey,
            plaintextMessage: JsonEncoder_1.JsonEncoder.fromString(unpackedMessage.message)
          };
        } catch (error) {
          if (!(0, error_2.isError)(error)) {
            throw new error_1.AriesFrameworkError("Attempted to throw error, but it was not of type Error");
          }
          throw new error_3.WalletError("Error unpacking message", { cause: error });
        }
      }
      async generateNonce() {
        try {
          return await this.indy.generateNonce();
        } catch (error) {
          if (!(0, error_2.isError)(error)) {
            throw new error_1.AriesFrameworkError("Attempted to throw error, but it was not of type Error");
          }
          throw new error_3.WalletError("Error generating nonce", { cause: error });
        }
      }
      async retrieveKeyPair(publicKeyBase58) {
        try {
          const { value } = await this.indy.getWalletRecord(this.handle, "KeyPairRecord", `key-${publicKeyBase58}`, {});
          if (value) {
            return JsonEncoder_1.JsonEncoder.fromString(value);
          } else {
            throw new error_3.WalletError(`No content found for record with public key: ${publicKeyBase58}`);
          }
        } catch (error) {
          if ((0, indyError_1.isIndyError)(error, "WalletItemNotFound")) {
            throw new error_1.RecordNotFoundError(`KeyPairRecord not found for public key: ${publicKeyBase58}.`, {
              recordType: "KeyPairRecord",
              cause: error
            });
          }
          throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
      }
      async storeKeyPair(keyPair) {
        try {
          await this.indy.addWalletRecord(this.handle, "KeyPairRecord", `key-${keyPair.publicKeyBase58}`, JSON.stringify(keyPair), {
            keyType: keyPair.keyType
          });
        } catch (error) {
          if ((0, indyError_1.isIndyError)(error, "WalletItemAlreadyExists")) {
            throw new error_1.RecordDuplicateError(`Record already exists`, { recordType: "KeyPairRecord" });
          }
          throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
      }
      async generateWalletKey() {
        try {
          return await this.indy.generateWalletKey();
        } catch (error) {
          throw new error_3.WalletError("Error generating wallet key", { cause: error });
        }
      }
    };
    IndyWallet = __decorate([
      (0, tsyringe_1.injectable)(),
      __param(0, (0, tsyringe_1.inject)(constants_1.InjectionSymbols.AgentDependencies)),
      __param(1, (0, tsyringe_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [Object, Object, SigningProviderRegistry_1.SigningProviderRegistry])
    ], IndyWallet);
    exports.IndyWallet = IndyWallet;
  }
});

// node_modules/@aries-framework/core/build/wallet/util/assertIndyWallet.js
var require_assertIndyWallet = __commonJS({
  "node_modules/@aries-framework/core/build/wallet/util/assertIndyWallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertIndyWallet = void 0;
    var error_1 = require_error();
    var IndyWallet_1 = require_IndyWallet();
    function assertIndyWallet(wallet) {
      var _a, _b;
      if (!(wallet instanceof IndyWallet_1.IndyWallet)) {
        const walletClassName = (_b = (_a = wallet.constructor) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "unknown";
        throw new error_1.AriesFrameworkError(`Expected wallet to be instance of IndyWallet, found ${walletClassName}`);
      }
    }
    exports.assertIndyWallet = assertIndyWallet;
  }
});

// node_modules/@aries-framework/core/build/utils/path.js
var require_path = __commonJS({
  "node_modules/@aries-framework/core/build/utils/path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDirFromFilePath = void 0;
    function getDirFromFilePath(path) {
      return path.substring(0, Math.max(path.lastIndexOf("/"), path.lastIndexOf("\\")));
    }
    exports.getDirFromFilePath = getDirFromFilePath;
  }
});

// node_modules/@aries-framework/core/build/modules/indy/services/IndyUtilitiesService.js
var require_IndyUtilitiesService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/indy/services/IndyUtilitiesService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyUtilitiesService = void 0;
    var constants_1 = require_constants();
    var error_1 = require_error();
    var IndySdkError_1 = require_IndySdkError();
    var plugins_1 = require_plugins();
    var indyError_1 = require_indyError();
    var path_1 = require_path();
    var IndyUtilitiesService = class IndyUtilitiesService {
      constructor(logger, fileSystem, agentDependencies) {
        this.indy = agentDependencies.indy;
        this.logger = logger;
        this.fileSystem = fileSystem;
      }
      /**
       * Get a handler for the blob storage tails file reader.
       *
       * @param tailsFilePath The path of the tails file
       * @returns The blob storage reader handle
       */
      async createTailsReader(tailsFilePath) {
        try {
          this.logger.debug(`Opening tails reader at path ${tailsFilePath}`);
          const tailsFileExists = await this.fileSystem.exists(tailsFilePath);
          const dirname = (0, path_1.getDirFromFilePath)(tailsFilePath);
          if (!tailsFileExists) {
            throw new error_1.AriesFrameworkError(`Tails file does not exist at path ${tailsFilePath}`);
          }
          const tailsReaderConfig = {
            base_dir: dirname
          };
          const tailsReader = await this.indy.openBlobStorageReader("default", tailsReaderConfig);
          this.logger.debug(`Opened tails reader at path ${tailsFilePath}`);
          return tailsReader;
        } catch (error) {
          if ((0, indyError_1.isIndyError)(error)) {
            throw new IndySdkError_1.IndySdkError(error);
          }
          throw error;
        }
      }
      async downloadTails(hash, tailsLocation) {
        try {
          this.logger.debug(`Checking to see if tails file for URL ${tailsLocation} has been stored in the FileSystem`);
          const filePath = `${this.fileSystem.basePath}/afj/tails/${hash}`;
          const tailsExists = await this.fileSystem.exists(filePath);
          this.logger.debug(`Tails file for ${tailsLocation} ${tailsExists ? "is stored" : "is not stored"} at ${filePath}`);
          if (!tailsExists) {
            this.logger.debug(`Retrieving tails file from URL ${tailsLocation}`);
            await this.fileSystem.downloadToFile(tailsLocation, filePath);
            this.logger.debug(`Saved tails file to FileSystem at path ${filePath}`);
          }
          this.logger.debug(`Tails file for URL ${tailsLocation} is stored in the FileSystem, opening tails reader`);
          return this.createTailsReader(filePath);
        } catch (error) {
          this.logger.error(`Error while retrieving tails file from URL ${tailsLocation}`, {
            error
          });
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
    };
    IndyUtilitiesService = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __param(1, (0, plugins_1.inject)(constants_1.InjectionSymbols.FileSystem)),
      __param(2, (0, plugins_1.inject)(constants_1.InjectionSymbols.AgentDependencies)),
      __metadata("design:paramtypes", [Object, Object, Object])
    ], IndyUtilitiesService);
    exports.IndyUtilitiesService = IndyUtilitiesService;
  }
});

// node_modules/@aries-framework/core/build/modules/indy/services/IndyIssuerService.js
var require_IndyIssuerService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/indy/services/IndyIssuerService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyIssuerService = void 0;
    var constants_1 = require_constants();
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var IndySdkError_1 = require_IndySdkError();
    var plugins_1 = require_plugins();
    var indyError_1 = require_indyError();
    var assertIndyWallet_1 = require_assertIndyWallet();
    var IndyUtilitiesService_1 = require_IndyUtilitiesService();
    var IndyIssuerService = class IndyIssuerService {
      constructor(indyUtilitiesService, agentDependencies) {
        this.indy = agentDependencies.indy;
        this.indyUtilitiesService = indyUtilitiesService;
      }
      /**
       * Create a new credential schema.
       *
       * @returns the schema.
       */
      async createSchema(agentContext, { originDid, name, version: version2, attributes }) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
          const [, schema] = await this.indy.issuerCreateSchema(originDid, name, version2, attributes);
          return schema;
        } catch (error) {
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      /**
       * Create a new credential definition and store it in the wallet.
       *
       * @returns the credential definition.
       */
      async createCredentialDefinition(agentContext, { issuerDid, schema, tag = "default", signatureType = "CL", supportRevocation = false }) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
          const [, credentialDefinition] = await this.indy.issuerCreateAndStoreCredentialDef(agentContext.wallet.handle, issuerDid, schema, tag, signatureType, {
            support_revocation: supportRevocation
          });
          return credentialDefinition;
        } catch (error) {
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      /**
       * Create a credential offer for the given credential definition id.
       *
       * @param credentialDefinitionId The credential definition to create an offer for
       * @returns The created credential offer
       */
      async createCredentialOffer(agentContext, credentialDefinitionId) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
          return await this.indy.issuerCreateCredentialOffer(agentContext.wallet.handle, credentialDefinitionId);
        } catch (error) {
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      /**
       * Create a credential.
       *
       * @returns Credential and revocation id
       */
      async createCredential(agentContext, { credentialOffer, credentialRequest, credentialValues, revocationRegistryId, tailsFilePath }) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
          const tailsReaderHandle = tailsFilePath ? await this.indyUtilitiesService.createTailsReader(tailsFilePath) : 0;
          if (revocationRegistryId || tailsFilePath) {
            throw new AriesFrameworkError_1.AriesFrameworkError("Revocation not supported yet");
          }
          const [credential, credentialRevocationId] = await this.indy.issuerCreateCredential(agentContext.wallet.handle, credentialOffer, credentialRequest, credentialValues, revocationRegistryId !== null && revocationRegistryId !== void 0 ? revocationRegistryId : null, tailsReaderHandle);
          return [credential, credentialRevocationId];
        } catch (error) {
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
    };
    IndyIssuerService = __decorate([
      (0, plugins_1.injectable)(),
      __param(1, (0, plugins_1.inject)(constants_1.InjectionSymbols.AgentDependencies)),
      __metadata("design:paramtypes", [IndyUtilitiesService_1.IndyUtilitiesService, Object])
    ], IndyIssuerService);
    exports.IndyIssuerService = IndyIssuerService;
  }
});

// node_modules/lru_map/dist/lru.js
var require_lru = __commonJS({
  "node_modules/lru_map/dist/lru.js"(exports, module) {
    !function(g, c) {
      typeof exports == "object" && typeof module != "undefined" ? c(exports) : typeof define == "function" && define.amd ? define(["exports"], c) : c((g = g || self).lru_map = g.lru_map || {});
    }(exports, function(g) {
      const c = Symbol("newer"), e = Symbol("older");
      class n {
        constructor(a, b) {
          typeof a !== "number" && (b = a, a = 0), this.size = 0, this.limit = a, this.oldest = this.newest = void 0, this._keymap = /* @__PURE__ */ new Map(), b && (this.assign(b), a < 1 && (this.limit = this.size));
        }
        _markEntryAsUsed(a) {
          if (a === this.newest)
            return;
          a[c] && (a === this.oldest && (this.oldest = a[c]), a[c][e] = a[e]), a[e] && (a[e][c] = a[c]), a[c] = void 0, a[e] = this.newest, this.newest && (this.newest[c] = a), this.newest = a;
        }
        assign(a) {
          let b, d = this.limit || Number.MAX_VALUE;
          this._keymap.clear();
          let m = a[Symbol.iterator]();
          for (let h = m.next(); !h.done; h = m.next()) {
            let f2 = new l(h.value[0], h.value[1]);
            this._keymap.set(f2.key, f2), b ? (b[c] = f2, f2[e] = b) : this.oldest = f2, b = f2;
            if (d-- == 0)
              throw new Error("overflow");
          }
          this.newest = b, this.size = this._keymap.size;
        }
        get(a) {
          var b = this._keymap.get(a);
          return b ? (this._markEntryAsUsed(b), b.value) : void 0;
        }
        set(a, b) {
          var d = this._keymap.get(a);
          return d ? (d.value = b, this._markEntryAsUsed(d), this) : (this._keymap.set(a, d = new l(a, b)), this.newest ? (this.newest[c] = d, d[e] = this.newest) : this.oldest = d, this.newest = d, ++this.size, this.size > this.limit && this.shift(), this);
        }
        shift() {
          var a = this.oldest;
          if (a)
            return this.oldest[c] ? (this.oldest = this.oldest[c], this.oldest[e] = void 0) : (this.oldest = void 0, this.newest = void 0), a[c] = a[e] = void 0, this._keymap.delete(a.key), --this.size, [a.key, a.value];
        }
        find(a) {
          let b = this._keymap.get(a);
          return b ? b.value : void 0;
        }
        has(a) {
          return this._keymap.has(a);
        }
        delete(a) {
          var b = this._keymap.get(a);
          return b ? (this._keymap.delete(b.key), b[c] && b[e] ? (b[e][c] = b[c], b[c][e] = b[e]) : b[c] ? (b[c][e] = void 0, this.oldest = b[c]) : b[e] ? (b[e][c] = void 0, this.newest = b[e]) : this.oldest = this.newest = void 0, this.size--, b.value) : void 0;
        }
        clear() {
          this.oldest = this.newest = void 0, this.size = 0, this._keymap.clear();
        }
        keys() {
          return new j(this.oldest);
        }
        values() {
          return new k(this.oldest);
        }
        entries() {
          return this;
        }
        [Symbol.iterator]() {
          return new i(this.oldest);
        }
        forEach(a, b) {
          typeof b !== "object" && (b = this);
          let d = this.oldest;
          for (; d; )
            a.call(b, d.value, d.key, this), d = d[c];
        }
        toJSON() {
          for (var a = new Array(this.size), b = 0, d = this.oldest; d; )
            a[b++] = { key: d.key, value: d.value }, d = d[c];
          return a;
        }
        toString() {
          for (var a = "", b = this.oldest; b; )
            a += String(b.key) + ":" + b.value, b = b[c], b && (a += " < ");
          return a;
        }
      }
      g.LRUMap = n;
      function l(a, b) {
        this.key = a, this.value = b, this[c] = void 0, this[e] = void 0;
      }
      function i(a) {
        this.entry = a;
      }
      i.prototype[Symbol.iterator] = function() {
        return this;
      }, i.prototype.next = function() {
        let a = this.entry;
        return a ? (this.entry = a[c], { done: false, value: [a.key, a.value] }) : { done: true, value: void 0 };
      };
      function j(a) {
        this.entry = a;
      }
      j.prototype[Symbol.iterator] = function() {
        return this;
      }, j.prototype.next = function() {
        let a = this.entry;
        return a ? (this.entry = a[c], { done: false, value: a.key }) : { done: true, value: void 0 };
      };
      function k(a) {
        this.entry = a;
      }
      k.prototype[Symbol.iterator] = function() {
        return this;
      }, k.prototype.next = function() {
        let a = this.entry;
        return a ? (this.entry = a[c], { done: false, value: a.value }) : { done: true, value: void 0 };
      };
    });
  }
});

// node_modules/@aries-framework/core/build/cache/CacheRecord.js
var require_CacheRecord = __commonJS({
  "node_modules/@aries-framework/core/build/cache/CacheRecord.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CacheRecord = void 0;
    var BaseRecord_1 = require_BaseRecord();
    var uuid_1 = require_uuid();
    var CacheRecord = class extends BaseRecord_1.BaseRecord {
      constructor(props) {
        var _a, _b, _c;
        super();
        this.type = CacheRecord.type;
        if (props) {
          this.id = (_a = props.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.createdAt = (_b = props.createdAt) !== null && _b !== void 0 ? _b : /* @__PURE__ */ new Date();
          this.entries = props.entries;
          this._tags = (_c = props.tags) !== null && _c !== void 0 ? _c : {};
        }
      }
      getTags() {
        return Object.assign({}, this._tags);
      }
    };
    exports.CacheRecord = CacheRecord;
    CacheRecord.type = "CacheRecord";
  }
});

// node_modules/@aries-framework/core/build/cache/PersistedLruCache.js
var require_PersistedLruCache = __commonJS({
  "node_modules/@aries-framework/core/build/cache/PersistedLruCache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PersistedLruCache = void 0;
    var lru_map_1 = require_lru();
    var CacheRecord_1 = require_CacheRecord();
    var PersistedLruCache = class {
      constructor(cacheId, limit2, cacheRepository) {
        this.cacheId = cacheId;
        this.limit = limit2;
        this.cacheRepository = cacheRepository;
      }
      async get(agentContext, key) {
        const cache = await this.getCache(agentContext);
        return cache.get(key);
      }
      async set(agentContext, key, value) {
        const cache = await this.getCache(agentContext);
        cache.set(key, value);
        await this.persistCache(agentContext);
      }
      async getCache(agentContext) {
        if (!this._cache) {
          const cacheRecord = await this.fetchCacheRecord(agentContext);
          this._cache = this.lruFromRecord(cacheRecord);
        }
        return this._cache;
      }
      lruFromRecord(cacheRecord) {
        return new lru_map_1.LRUMap(this.limit, cacheRecord.entries.map((e) => [e.key, e.value]));
      }
      async fetchCacheRecord(agentContext) {
        let cacheRecord = await this.cacheRepository.findById(agentContext, this.cacheId);
        if (!cacheRecord) {
          cacheRecord = new CacheRecord_1.CacheRecord({
            id: this.cacheId,
            entries: []
          });
          await this.cacheRepository.save(agentContext, cacheRecord);
        }
        return cacheRecord;
      }
      async persistCache(agentContext) {
        const cache = await this.getCache(agentContext);
        await this.cacheRepository.update(agentContext, new CacheRecord_1.CacheRecord({
          entries: cache.toJSON(),
          id: this.cacheId
        }));
      }
    };
    exports.PersistedLruCache = PersistedLruCache;
  }
});

// node_modules/@aries-framework/core/build/cache/CacheRepository.js
var require_CacheRepository = __commonJS({
  "node_modules/@aries-framework/core/build/cache/CacheRepository.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CacheRepository = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var Repository_1 = require_Repository();
    var CacheRecord_1 = require_CacheRecord();
    var CacheRepository = class CacheRepository extends Repository_1.Repository {
      constructor(storageService, eventEmitter) {
        super(CacheRecord_1.CacheRecord, storageService, eventEmitter);
      }
    };
    CacheRepository = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.StorageService)),
      __metadata("design:paramtypes", [Object, EventEmitter_1.EventEmitter])
    ], CacheRepository);
    exports.CacheRepository = CacheRepository;
  }
});

// node_modules/@aries-framework/core/build/cache/index.js
var require_cache = __commonJS({
  "node_modules/@aries-framework/core/build/cache/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_PersistedLruCache(), exports);
    __exportStar(require_CacheRecord(), exports);
    __exportStar(require_CacheRepository(), exports);
  }
});

// node_modules/@aries-framework/core/build/utils/promises.js
var require_promises = __commonJS({
  "node_modules/@aries-framework/core/build/utils/promises.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.onlyRejected = exports.onlyFulfilled = exports.allSettled = void 0;
    function allSettled(promises) {
      return Promise.all(promises.map((p) => p.then((value) => ({
        status: "fulfilled",
        value
      })).catch((reason) => ({
        status: "rejected",
        reason
      }))));
    }
    exports.allSettled = allSettled;
    function onlyFulfilled(entries) {
      return entries.filter((e) => e.status === "fulfilled");
    }
    exports.onlyFulfilled = onlyFulfilled;
    function onlyRejected(entries) {
      return entries.filter((e) => e.status === "rejected");
    }
    exports.onlyRejected = onlyRejected;
  }
});

// node_modules/@aries-framework/core/build/modules/ledger/error/LedgerError.js
var require_LedgerError = __commonJS({
  "node_modules/@aries-framework/core/build/modules/ledger/error/LedgerError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LedgerError = void 0;
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var LedgerError = class extends AriesFrameworkError_1.AriesFrameworkError {
      constructor(message, { cause } = {}) {
        super(message, { cause });
      }
    };
    exports.LedgerError = LedgerError;
  }
});

// node_modules/@aries-framework/core/build/modules/ledger/ledgerUtil.js
var require_ledgerUtil = __commonJS({
  "node_modules/@aries-framework/core/build/modules/ledger/ledgerUtil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isLedgerReqnackResponse = exports.isLedgerRejectResponse = void 0;
    function isLedgerRejectResponse(response) {
      return response.op === "REJECT";
    }
    exports.isLedgerRejectResponse = isLedgerRejectResponse;
    function isLedgerReqnackResponse(response) {
      return response.op === "REQNACK";
    }
    exports.isLedgerReqnackResponse = isLedgerReqnackResponse;
  }
});

// node_modules/@aries-framework/core/build/modules/ledger/IndyPool.js
var require_IndyPool = __commonJS({
  "node_modules/@aries-framework/core/build/modules/ledger/IndyPool.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyPool = void 0;
    var error_1 = require_error();
    var indyError_1 = require_indyError();
    var LedgerError_1 = require_LedgerError();
    var ledgerUtil_1 = require_ledgerUtil();
    var IndyPool = class {
      constructor(poolConfig, agentDependencies, logger, stop$, fileSystem) {
        this.indy = agentDependencies.indy;
        this.fileSystem = fileSystem;
        this.poolConfig = poolConfig;
        this.logger = logger;
        stop$.subscribe(async () => {
          if (this._poolHandle) {
            await this.close();
          }
        });
      }
      get didIndyNamespace() {
        return this.didIndyNamespace;
      }
      get id() {
        return this.poolConfig.id;
      }
      get config() {
        return this.poolConfig;
      }
      async close() {
        const poolHandle = this._poolHandle;
        if (!poolHandle) {
          return;
        }
        this._poolHandle = void 0;
        this.poolConnected = void 0;
        await this.indy.closePoolLedger(poolHandle);
      }
      async delete() {
        if (this._poolHandle) {
          await this.close();
        }
        await this.indy.deletePoolLedgerConfig(this.poolConfig.id);
      }
      async connect() {
        if (!this.poolConnected) {
          this.poolConnected = this.connectToLedger();
          this.poolConnected.catch((error) => {
            this.poolConnected = void 0;
            this.logger.error("Connection to pool: " + this.poolConfig.genesisPath + " failed.", { error });
          });
          return this.poolConnected;
        } else {
          throw new error_1.AriesFrameworkError("Cannot attempt connection to ledger, already connecting.");
        }
      }
      async connectToLedger() {
        const poolName = this.poolConfig.id;
        const genesisPath = await this.getGenesisPath();
        if (!genesisPath) {
          throw new error_1.AriesFrameworkError("Cannot connect to ledger without genesis file");
        }
        this.logger.debug(`Connecting to ledger pool '${poolName}'`, { genesisPath });
        await this.indy.setProtocolVersion(2);
        try {
          this._poolHandle = await this.indy.openPoolLedger(poolName);
          return this._poolHandle;
        } catch (error) {
          if (!(0, indyError_1.isIndyError)(error, "PoolLedgerNotCreatedError")) {
            throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
          }
        }
        this.logger.debug(`Pool '${poolName}' does not exist yet, creating.`, {
          indyError: "PoolLedgerNotCreatedError"
        });
        try {
          await this.indy.createPoolLedgerConfig(poolName, { genesis_txn: genesisPath });
          this._poolHandle = await this.indy.openPoolLedger(poolName);
          return this._poolHandle;
        } catch (error) {
          throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
      }
      async submitRequest(request) {
        return this.indy.submitRequest(await this.getPoolHandle(), request);
      }
      async submitReadRequest(request) {
        const response = await this.submitRequest(request);
        if ((0, ledgerUtil_1.isLedgerRejectResponse)(response) || (0, ledgerUtil_1.isLedgerReqnackResponse)(response)) {
          throw new LedgerError_1.LedgerError(`Ledger '${this.id}' rejected read transaction request: ${response.reason}`);
        }
        return response;
      }
      async submitWriteRequest(request) {
        const response = await this.submitRequest(request);
        if ((0, ledgerUtil_1.isLedgerRejectResponse)(response) || (0, ledgerUtil_1.isLedgerReqnackResponse)(response)) {
          throw new LedgerError_1.LedgerError(`Ledger '${this.id}' rejected write transaction request: ${response.reason}`);
        }
        return response;
      }
      async getPoolHandle() {
        if (this.poolConnected) {
          try {
            await this.poolConnected;
          } catch (error) {
            this.logger.error("Connection to pool: " + this.poolConfig.genesisPath + " failed.", { error });
          }
        }
        if (!this._poolHandle) {
          return this.connect();
        }
        return this._poolHandle;
      }
      async getGenesisPath() {
        if (this.poolConfig.genesisPath)
          return this.poolConfig.genesisPath;
        const genesisPath = this.fileSystem.basePath + `/afj/genesis-${this.poolConfig.id}.txn`;
        if (this.poolConfig.genesisTransactions) {
          await this.fileSystem.write(genesisPath, this.poolConfig.genesisTransactions);
          this.poolConfig.genesisPath = genesisPath;
          return genesisPath;
        }
        return null;
      }
    };
    exports.IndyPool = IndyPool;
  }
});

// node_modules/@aries-framework/core/build/modules/ledger/error/LedgerNotConfiguredError.js
var require_LedgerNotConfiguredError = __commonJS({
  "node_modules/@aries-framework/core/build/modules/ledger/error/LedgerNotConfiguredError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LedgerNotConfiguredError = void 0;
    var LedgerError_1 = require_LedgerError();
    var LedgerNotConfiguredError = class extends LedgerError_1.LedgerError {
      constructor(message, { cause } = {}) {
        super(message, { cause });
      }
    };
    exports.LedgerNotConfiguredError = LedgerNotConfiguredError;
  }
});

// node_modules/@aries-framework/core/build/modules/ledger/error/LedgerNotFoundError.js
var require_LedgerNotFoundError = __commonJS({
  "node_modules/@aries-framework/core/build/modules/ledger/error/LedgerNotFoundError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LedgerNotFoundError = void 0;
    var LedgerError_1 = require_LedgerError();
    var LedgerNotFoundError = class extends LedgerError_1.LedgerError {
      constructor(message, { cause } = {}) {
        super(message, { cause });
      }
    };
    exports.LedgerNotFoundError = LedgerNotFoundError;
  }
});

// node_modules/@aries-framework/core/build/modules/ledger/services/IndyPoolService.js
var require_IndyPoolService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/ledger/services/IndyPoolService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyPoolService = exports.DID_POOL_CACHE_LIMIT = exports.DID_POOL_CACHE_ID = void 0;
    var rxjs_1 = require_cjs();
    var cache_1 = require_cache();
    var constants_1 = require_constants();
    var IndySdkError_1 = require_IndySdkError();
    var plugins_1 = require_plugins();
    var did_1 = require_did2();
    var indyError_1 = require_indyError();
    var promises_1 = require_promises();
    var assertIndyWallet_1 = require_assertIndyWallet();
    var IndyPool_1 = require_IndyPool();
    var LedgerError_1 = require_LedgerError();
    var LedgerNotConfiguredError_1 = require_LedgerNotConfiguredError();
    var LedgerNotFoundError_1 = require_LedgerNotFoundError();
    exports.DID_POOL_CACHE_ID = "DID_POOL_CACHE";
    exports.DID_POOL_CACHE_LIMIT = 500;
    var IndyPoolService = class IndyPoolService {
      constructor(cacheRepository, agentDependencies, logger, stop$, fileSystem) {
        this.pools = [];
        this.logger = logger;
        this.indy = agentDependencies.indy;
        this.agentDependencies = agentDependencies;
        this.fileSystem = fileSystem;
        this.stop$ = stop$;
        this.didCache = new cache_1.PersistedLruCache(exports.DID_POOL_CACHE_ID, exports.DID_POOL_CACHE_LIMIT, cacheRepository);
      }
      setPools(poolConfigs) {
        this.pools = poolConfigs.map((poolConfig) => new IndyPool_1.IndyPool(poolConfig, this.agentDependencies, this.logger, this.stop$, this.fileSystem));
      }
      /**
       * Create connections to all ledger pools
       */
      async connectToPools() {
        const handleArray = [];
        for (const pool of this.pools) {
          this.logger.debug(`Connecting to pool: ${pool.id}`);
          const poolHandle = await pool.connect();
          this.logger.debug(`Finished connection to pool: ${pool.id}`);
          handleArray.push(poolHandle);
        }
        return handleArray;
      }
      /**
       * @deprecated use instead getPoolForNamespace
       * Get the pool used for writing to the ledger. For now we always use the first pool
       *  as the pool that writes to the ledger
       */
      get ledgerWritePool() {
        if (this.pools.length === 0) {
          throw new LedgerNotConfiguredError_1.LedgerNotConfiguredError("No indy ledgers configured. Provide at least one pool configuration in the 'indyLedgers' agent configuration");
        }
        return this.pools[0];
      }
      /**
       * Get the most appropriate pool for the given did. The algorithm is based on the approach as described in this document:
       * https://docs.google.com/document/d/109C_eMsuZnTnYe2OAd02jAts1vC4axwEKIq7_4dnNVA/edit
       */
      async getPoolForDid(agentContext, did) {
        var _a;
        const pools = this.pools;
        if (pools.length === 0) {
          throw new LedgerNotConfiguredError_1.LedgerNotConfiguredError("No indy ledgers configured. Provide at least one pool configuration in the 'indyLedgers' agent configuration");
        }
        const cachedNymResponse = await this.didCache.get(agentContext, did);
        const pool = this.pools.find((pool2) => pool2.id === (cachedNymResponse === null || cachedNymResponse === void 0 ? void 0 : cachedNymResponse.poolId));
        if (cachedNymResponse && pool) {
          this.logger.trace(`Found ledger id '${pool.id}' for did '${did}' in cache`);
          return { did: cachedNymResponse.nymResponse, pool };
        }
        const { successful, rejected } = await this.getSettledDidResponsesFromPools(did, pools);
        if (successful.length === 0) {
          const allNotFound = rejected.every((e) => e.reason instanceof LedgerNotFoundError_1.LedgerNotFoundError);
          const rejectedOtherThanNotFound = rejected.filter((e) => !(e.reason instanceof LedgerNotFoundError_1.LedgerNotFoundError));
          if (allNotFound) {
            throw new LedgerNotFoundError_1.LedgerNotFoundError(`Did '${did}' not found on any of the ledgers (total ${this.pools.length}).`);
          }
          throw new LedgerError_1.LedgerError(`Unknown error retrieving did '${did}' from '${rejectedOtherThanNotFound.length}' of '${pools.length}' ledgers`, { cause: rejectedOtherThanNotFound[0].reason });
        }
        let value = (_a = successful.find((response) => (0, did_1.isSelfCertifiedDid)(response.value.did.did, response.value.did.verkey))) === null || _a === void 0 ? void 0 : _a.value;
        if (!value) {
          const production = successful.filter((s) => s.value.pool.config.isProduction);
          const nonProduction = successful.filter((s) => !s.value.pool.config.isProduction);
          const productionOrNonProduction = production.length >= 1 ? production : nonProduction;
          value = productionOrNonProduction[0].value;
        }
        await this.didCache.set(agentContext, did, {
          nymResponse: value.did,
          poolId: value.pool.id
        });
        return { pool: value.pool, did: value.did };
      }
      async getSettledDidResponsesFromPools(did, pools) {
        this.logger.trace(`Retrieving did '${did}' from ${pools.length} ledgers`);
        const didResponses = await (0, promises_1.allSettled)(pools.map((pool) => this.getDidFromPool(did, pool)));
        const successful = (0, promises_1.onlyFulfilled)(didResponses);
        this.logger.trace(`Retrieved ${successful.length} responses from ledgers for did '${did}'`);
        const rejected = (0, promises_1.onlyRejected)(didResponses);
        return {
          rejected,
          successful
        };
      }
      /**
       * Get the most appropriate pool for the given indyNamespace
       */
      getPoolForNamespace(indyNamespace) {
        if (this.pools.length === 0) {
          throw new LedgerNotConfiguredError_1.LedgerNotConfiguredError("No indy ledgers configured. Provide at least one pool configuration in the 'indyLedgers' agent configuration");
        }
        if (!indyNamespace) {
          this.logger.warn("Not passing the indyNamespace is deprecated and will be removed in the future version.");
          return this.pools[0];
        }
        const pool = this.pools.find((pool2) => pool2.didIndyNamespace === indyNamespace);
        if (!pool) {
          throw new LedgerNotFoundError_1.LedgerNotFoundError(`No ledgers found for IndyNamespace '${indyNamespace}'.`);
        }
        return pool;
      }
      async submitWriteRequest(agentContext, pool, request, signDid) {
        try {
          const requestWithTaa = await this.appendTaa(pool, request);
          const signedRequestWithTaa = await this.signRequest(agentContext, signDid, requestWithTaa);
          const response = await pool.submitWriteRequest(signedRequestWithTaa);
          return response;
        } catch (error) {
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      async submitReadRequest(pool, request) {
        try {
          const response = await pool.submitReadRequest(request);
          return response;
        } catch (error) {
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      async signRequest(agentContext, did, request) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
          return this.indy.signRequest(agentContext.wallet.handle, did, request);
        } catch (error) {
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      async appendTaa(pool, request) {
        try {
          const authorAgreement = await this.getTransactionAuthorAgreement(pool);
          const taa = pool.config.transactionAuthorAgreement;
          if (authorAgreement == null) {
            return request;
          }
          if (!taa) {
            throw new LedgerError_1.LedgerError(`Please, specify a transaction author agreement with version and acceptance mechanism. ${JSON.stringify(authorAgreement)}`);
          }
          if (authorAgreement.version !== taa.version || !(taa.acceptanceMechanism in authorAgreement.acceptanceMechanisms.aml)) {
            const errMessage = `Unable to satisfy matching TAA with mechanism ${JSON.stringify(taa.acceptanceMechanism)} and version ${JSON.stringify(taa.version)} in pool.
 Found ${JSON.stringify(Object.keys(authorAgreement.acceptanceMechanisms.aml))} and version ${authorAgreement.version} in pool.`;
            throw new LedgerError_1.LedgerError(errMessage);
          }
          const requestWithTaa = await this.indy.appendTxnAuthorAgreementAcceptanceToRequest(
            request,
            authorAgreement.text,
            taa.version,
            authorAgreement.digest,
            taa.acceptanceMechanism,
            // Current time since epoch
            // We can't use ratification_ts, as it must be greater than 1499906902
            Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3)
          );
          return requestWithTaa;
        } catch (error) {
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      async getTransactionAuthorAgreement(pool) {
        try {
          if (pool.authorAgreement !== void 0) {
            return pool.authorAgreement;
          }
          const taaRequest = await this.indy.buildGetTxnAuthorAgreementRequest(null);
          const taaResponse = await this.submitReadRequest(pool, taaRequest);
          const acceptanceMechanismRequest = await this.indy.buildGetAcceptanceMechanismsRequest(null);
          const acceptanceMechanismResponse = await this.submitReadRequest(pool, acceptanceMechanismRequest);
          if (taaResponse.result.data == null) {
            pool.authorAgreement = null;
            return null;
          }
          const authorAgreement = taaResponse.result.data;
          const acceptanceMechanisms = acceptanceMechanismResponse.result.data;
          pool.authorAgreement = Object.assign(Object.assign({}, authorAgreement), { acceptanceMechanisms });
          return pool.authorAgreement;
        } catch (error) {
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      async getDidFromPool(did, pool) {
        try {
          this.logger.trace(`Get public did '${did}' from ledger '${pool.id}'`);
          const request = await this.indy.buildGetNymRequest(null, did);
          this.logger.trace(`Submitting get did request for did '${did}' to ledger '${pool.id}'`);
          const response = await pool.submitReadRequest(request);
          const result2 = await this.indy.parseGetNymResponse(response);
          this.logger.trace(`Retrieved did '${did}' from ledger '${pool.id}'`, result2);
          return {
            did: result2,
            pool,
            response
          };
        } catch (error) {
          this.logger.trace(`Error retrieving did '${did}' from ledger '${pool.id}'`, {
            error,
            did
          });
          if ((0, indyError_1.isIndyError)(error, "LedgerNotFound")) {
            throw new LedgerNotFoundError_1.LedgerNotFoundError(`Did '${did}' not found on ledger ${pool.id}`);
          } else {
            throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
          }
        }
      }
    };
    IndyPoolService = __decorate([
      (0, plugins_1.injectable)(),
      __param(1, (0, plugins_1.inject)(constants_1.InjectionSymbols.AgentDependencies)),
      __param(2, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __param(3, (0, plugins_1.inject)(constants_1.InjectionSymbols.Stop$)),
      __param(4, (0, plugins_1.inject)(constants_1.InjectionSymbols.FileSystem)),
      __metadata("design:paramtypes", [cache_1.CacheRepository, Object, Object, rxjs_1.Subject, Object])
    ], IndyPoolService);
    exports.IndyPoolService = IndyPoolService;
  }
});

// node_modules/@aries-framework/core/build/modules/ledger/services/IndyLedgerService.js
var require_IndyLedgerService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/ledger/services/IndyLedgerService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyLedgerService = void 0;
    var constants_1 = require_constants();
    var IndySdkError_1 = require_IndySdkError();
    var plugins_1 = require_plugins();
    var did_1 = require_did2();
    var indyError_1 = require_indyError();
    var IndyIssuerService_1 = require_IndyIssuerService();
    var IndyPoolService_1 = require_IndyPoolService();
    var IndyLedgerService = class IndyLedgerService {
      constructor(agentDependencies, logger, indyIssuer, indyPoolService) {
        this.indy = agentDependencies.indy;
        this.logger = logger;
        this.indyIssuer = indyIssuer;
        this.indyPoolService = indyPoolService;
      }
      setPools(poolConfigs) {
        return this.indyPoolService.setPools(poolConfigs);
      }
      /**
       * @deprecated
       */
      getDidIndyWriteNamespace() {
        return this.indyPoolService.ledgerWritePool.config.indyNamespace;
      }
      async connectToPools() {
        return this.indyPoolService.connectToPools();
      }
      /**
       * @deprecated
       */
      async registerPublicDid(agentContext, submitterDid, targetDid, verkey, alias, role) {
        const pool = this.indyPoolService.getPoolForNamespace();
        try {
          this.logger.debug(`Register public did '${targetDid}' on ledger '${pool.id}'`);
          const request = await this.indy.buildNymRequest(submitterDid, targetDid, verkey, alias, role || null);
          const response = await this.indyPoolService.submitWriteRequest(agentContext, pool, request, submitterDid);
          this.logger.debug(`Registered public did '${targetDid}' on ledger '${pool.id}'`, {
            response
          });
          return targetDid;
        } catch (error) {
          this.logger.error(`Error registering public did '${targetDid}' on ledger '${pool.id}'`, {
            error,
            submitterDid,
            targetDid,
            verkey,
            alias,
            role,
            pool: pool.id
          });
          throw error;
        }
      }
      /**
       * @deprecated
       */
      async getPublicDid(agentContext, did) {
        const { did: didResponse } = await this.indyPoolService.getPoolForDid(agentContext, did);
        return didResponse;
      }
      /**
       * @deprecated
       */
      async setEndpointsForDid(agentContext, did, endpoints) {
        const pool = this.indyPoolService.getPoolForNamespace();
        try {
          this.logger.debug(`Set endpoints for did '${did}' on ledger '${pool.id}'`, endpoints);
          const request = await this.indy.buildAttribRequest(did, did, null, { endpoint: endpoints }, null);
          const response = await this.indyPoolService.submitWriteRequest(agentContext, pool, request, did);
          this.logger.debug(`Successfully set endpoints for did '${did}' on ledger '${pool.id}'`, {
            response,
            endpoints
          });
        } catch (error) {
          this.logger.error(`Error setting endpoints for did '${did}' on ledger '${pool.id}'`, {
            error,
            did,
            endpoints
          });
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      /**
       * @deprecated
       */
      async getEndpointsForDid(agentContext, did) {
        var _a;
        const { pool } = await this.indyPoolService.getPoolForDid(agentContext, did);
        try {
          this.logger.debug(`Get endpoints for did '${did}' from ledger '${pool.id}'`);
          const request = await this.indy.buildGetAttribRequest(null, did, "endpoint", null, null);
          this.logger.debug(`Submitting get endpoint ATTRIB request for did '${did}' to ledger '${pool.id}'`);
          const response = await this.indyPoolService.submitReadRequest(pool, request);
          if (!response.result.data)
            return {};
          const endpoints = (_a = JSON.parse(response.result.data)) === null || _a === void 0 ? void 0 : _a.endpoint;
          this.logger.debug(`Got endpoints '${JSON.stringify(endpoints)}' for did '${did}' from ledger '${pool.id}'`, {
            response,
            endpoints
          });
          return endpoints !== null && endpoints !== void 0 ? endpoints : {};
        } catch (error) {
          this.logger.error(`Error retrieving endpoints for did '${did}' from ledger '${pool.id}'`, {
            error
          });
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      async registerSchema(agentContext, did, schemaTemplate) {
        const pool = this.indyPoolService.getPoolForNamespace();
        try {
          this.logger.debug(`Register schema on ledger '${pool.id}' with did '${did}'`, schemaTemplate);
          const { name, attributes, version: version2 } = schemaTemplate;
          const schema = await this.indyIssuer.createSchema(agentContext, { originDid: did, name, version: version2, attributes });
          const request = await this.indy.buildSchemaRequest(did, schema);
          const response = await this.indyPoolService.submitWriteRequest(agentContext, pool, request, did);
          this.logger.debug(`Registered schema '${schema.id}' on ledger '${pool.id}'`, {
            response,
            schema
          });
          schema.seqNo = response.result.txnMetadata.seqNo;
          return schema;
        } catch (error) {
          this.logger.error(`Error registering schema for did '${did}' on ledger '${pool.id}'`, {
            error,
            did,
            schemaTemplate
          });
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      async getSchema(agentContext, schemaId) {
        const did = (0, did_1.didFromSchemaId)(schemaId);
        const { pool } = await this.indyPoolService.getPoolForDid(agentContext, did);
        try {
          this.logger.debug(`Getting schema '${schemaId}' from ledger '${pool.id}'`);
          const request = await this.indy.buildGetSchemaRequest(null, schemaId);
          this.logger.trace(`Submitting get schema request for schema '${schemaId}' to ledger '${pool.id}'`);
          const response = await this.indyPoolService.submitReadRequest(pool, request);
          this.logger.trace(`Got un-parsed schema '${schemaId}' from ledger '${pool.id}'`, {
            response
          });
          const [, schema] = await this.indy.parseGetSchemaResponse(response);
          this.logger.debug(`Got schema '${schemaId}' from ledger '${pool.id}'`, {
            schema
          });
          return schema;
        } catch (error) {
          this.logger.error(`Error retrieving schema '${schemaId}' from ledger '${pool.id}'`, {
            error,
            schemaId
          });
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      async registerCredentialDefinition(agentContext, did, credentialDefinitionTemplate) {
        const pool = this.indyPoolService.getPoolForNamespace();
        try {
          this.logger.debug(`Registering credential definition on ledger '${pool.id}' with did '${did}'`, credentialDefinitionTemplate);
          const { schema, tag, signatureType, supportRevocation } = credentialDefinitionTemplate;
          const credentialDefinition = await this.indyIssuer.createCredentialDefinition(agentContext, {
            issuerDid: did,
            schema,
            tag,
            signatureType,
            supportRevocation
          });
          const request = await this.indy.buildCredDefRequest(did, credentialDefinition);
          const response = await this.indyPoolService.submitWriteRequest(agentContext, pool, request, did);
          this.logger.debug(`Registered credential definition '${credentialDefinition.id}' on ledger '${pool.id}'`, {
            response,
            credentialDefinition
          });
          return credentialDefinition;
        } catch (error) {
          this.logger.error(`Error registering credential definition for schema '${credentialDefinitionTemplate.schema.id}' on ledger '${pool.id}'`, {
            error,
            did,
            credentialDefinitionTemplate
          });
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      async getCredentialDefinition(agentContext, credentialDefinitionId) {
        const did = (0, did_1.didFromCredentialDefinitionId)(credentialDefinitionId);
        const { pool } = await this.indyPoolService.getPoolForDid(agentContext, did);
        this.logger.debug(`Using ledger '${pool.id}' to retrieve credential definition '${credentialDefinitionId}'`);
        try {
          const request = await this.indy.buildGetCredDefRequest(null, credentialDefinitionId);
          this.logger.trace(`Submitting get credential definition request for credential definition '${credentialDefinitionId}' to ledger '${pool.id}'`);
          const response = await this.indyPoolService.submitReadRequest(pool, request);
          this.logger.trace(`Got un-parsed credential definition '${credentialDefinitionId}' from ledger '${pool.id}'`, {
            response
          });
          const [, credentialDefinition] = await this.indy.parseGetCredDefResponse(response);
          this.logger.debug(`Got credential definition '${credentialDefinitionId}' from ledger '${pool.id}'`, {
            credentialDefinition
          });
          return credentialDefinition;
        } catch (error) {
          this.logger.error(`Error retrieving credential definition '${credentialDefinitionId}' from ledger '${pool.id}'`, {
            error,
            credentialDefinitionId,
            pool: pool.id
          });
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      async getRevocationRegistryDefinition(agentContext, revocationRegistryDefinitionId) {
        const did = (0, did_1.didFromRevocationRegistryDefinitionId)(revocationRegistryDefinitionId);
        const { pool } = await this.indyPoolService.getPoolForDid(agentContext, did);
        this.logger.debug(`Using ledger '${pool.id}' to retrieve revocation registry definition '${revocationRegistryDefinitionId}'`);
        try {
          this.logger.trace(`Revocation Registry Definition '${revocationRegistryDefinitionId}' not cached, retrieving from ledger`);
          const request = await this.indy.buildGetRevocRegDefRequest(null, revocationRegistryDefinitionId);
          this.logger.trace(`Submitting get revocation registry definition request for revocation registry definition '${revocationRegistryDefinitionId}' to ledger`);
          const response = await this.indyPoolService.submitReadRequest(pool, request);
          this.logger.trace(`Got un-parsed revocation registry definition '${revocationRegistryDefinitionId}' from ledger '${pool.id}'`, {
            response
          });
          const [, revocationRegistryDefinition] = await this.indy.parseGetRevocRegDefResponse(response);
          this.logger.debug(`Got revocation registry definition '${revocationRegistryDefinitionId}' from ledger`, {
            revocationRegistryDefinition
          });
          return { revocationRegistryDefinition, revocationRegistryDefinitionTxnTime: response.result.txnTime };
        } catch (error) {
          this.logger.error(`Error retrieving revocation registry definition '${revocationRegistryDefinitionId}' from ledger`, {
            error,
            revocationRegistryDefinitionId,
            pool: pool.id
          });
          throw error;
        }
      }
      // Retrieves the accumulated state of a revocation registry by id given a revocation interval from & to (used primarily for proof creation)
      async getRevocationRegistryDelta(agentContext, revocationRegistryDefinitionId, to = (/* @__PURE__ */ new Date()).getTime(), from = 0) {
        const did = (0, did_1.didFromRevocationRegistryDefinitionId)(revocationRegistryDefinitionId);
        const { pool } = await this.indyPoolService.getPoolForDid(agentContext, did);
        this.logger.debug(`Using ledger '${pool.id}' to retrieve revocation registry delta with revocation registry definition id: '${revocationRegistryDefinitionId}'`, {
          to,
          from
        });
        try {
          const request = await this.indy.buildGetRevocRegDeltaRequest(null, revocationRegistryDefinitionId, from, to);
          this.logger.trace(`Submitting get revocation registry delta request for revocation registry '${revocationRegistryDefinitionId}' to ledger`);
          const response = await this.indyPoolService.submitReadRequest(pool, request);
          this.logger.trace(`Got revocation registry delta unparsed-response '${revocationRegistryDefinitionId}' from ledger`, {
            response
          });
          const [, revocationRegistryDelta, deltaTimestamp] = await this.indy.parseGetRevocRegDeltaResponse(response);
          this.logger.debug(`Got revocation registry delta '${revocationRegistryDefinitionId}' from ledger`, {
            revocationRegistryDelta,
            deltaTimestamp,
            to,
            from
          });
          return { revocationRegistryDelta, deltaTimestamp };
        } catch (error) {
          this.logger.error(`Error retrieving revocation registry delta '${revocationRegistryDefinitionId}' from ledger, potentially revocation interval ends before revocation registry creation?"`, {
            error,
            revocationRegistryId: revocationRegistryDefinitionId,
            pool: pool.id
          });
          throw error;
        }
      }
      // Retrieves the accumulated state of a revocation registry by id given a timestamp (used primarily for verification)
      async getRevocationRegistry(agentContext, revocationRegistryDefinitionId, timestamp) {
        const did = (0, did_1.didFromRevocationRegistryDefinitionId)(revocationRegistryDefinitionId);
        const { pool } = await this.indyPoolService.getPoolForDid(agentContext, did);
        this.logger.debug(`Using ledger '${pool.id}' to retrieve revocation registry accumulated state with revocation registry definition id: '${revocationRegistryDefinitionId}'`, {
          timestamp
        });
        try {
          const request = await this.indy.buildGetRevocRegRequest(null, revocationRegistryDefinitionId, timestamp);
          this.logger.trace(`Submitting get revocation registry request for revocation registry '${revocationRegistryDefinitionId}' to ledger`);
          const response = await this.indyPoolService.submitReadRequest(pool, request);
          this.logger.trace(`Got un-parsed revocation registry '${revocationRegistryDefinitionId}' from ledger '${pool.id}'`, {
            response
          });
          const [, revocationRegistry, ledgerTimestamp] = await this.indy.parseGetRevocRegResponse(response);
          this.logger.debug(`Got revocation registry '${revocationRegistryDefinitionId}' from ledger`, {
            ledgerTimestamp,
            revocationRegistry
          });
          return { revocationRegistry, ledgerTimestamp };
        } catch (error) {
          this.logger.error(`Error retrieving revocation registry '${revocationRegistryDefinitionId}' from ledger`, {
            error,
            revocationRegistryId: revocationRegistryDefinitionId,
            pool: pool.id
          });
          throw error;
        }
      }
    };
    IndyLedgerService = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.AgentDependencies)),
      __param(1, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [
        Object,
        Object,
        IndyIssuerService_1.IndyIssuerService,
        IndyPoolService_1.IndyPoolService
      ])
    ], IndyLedgerService);
    exports.IndyLedgerService = IndyLedgerService;
  }
});

// node_modules/@aries-framework/core/build/modules/ledger/services/index.js
var require_services = __commonJS({
  "node_modules/@aries-framework/core/build/modules/ledger/services/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_IndyLedgerService(), exports);
    __exportStar(require_IndyPoolService(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/indy/repository/AnonCredsCredentialDefinitionRecord.js
var require_AnonCredsCredentialDefinitionRecord = __commonJS({
  "node_modules/@aries-framework/core/build/modules/indy/repository/AnonCredsCredentialDefinitionRecord.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnonCredsCredentialDefinitionRecord = void 0;
    var BaseRecord_1 = require_BaseRecord();
    var uuid_1 = require_uuid();
    var AnonCredsCredentialDefinitionRecord = class extends BaseRecord_1.BaseRecord {
      constructor(props) {
        super();
        this.type = AnonCredsCredentialDefinitionRecord.type;
        if (props) {
          this.id = (0, uuid_1.uuid)();
          this.credentialDefinition = props.credentialDefinition;
        }
      }
      getTags() {
        return Object.assign(Object.assign({}, this._tags), { credentialDefinitionId: this.credentialDefinition.id });
      }
    };
    exports.AnonCredsCredentialDefinitionRecord = AnonCredsCredentialDefinitionRecord;
    AnonCredsCredentialDefinitionRecord.type = "AnonCredsCredentialDefinitionRecord";
  }
});

// node_modules/@aries-framework/core/build/modules/indy/repository/AnonCredsCredentialDefinitionRepository.js
var require_AnonCredsCredentialDefinitionRepository = __commonJS({
  "node_modules/@aries-framework/core/build/modules/indy/repository/AnonCredsCredentialDefinitionRepository.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnonCredsCredentialDefinitionRepository = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var Repository_1 = require_Repository();
    var AnonCredsCredentialDefinitionRecord_1 = require_AnonCredsCredentialDefinitionRecord();
    var AnonCredsCredentialDefinitionRepository = class AnonCredsCredentialDefinitionRepository extends Repository_1.Repository {
      constructor(storageService, eventEmitter) {
        super(AnonCredsCredentialDefinitionRecord_1.AnonCredsCredentialDefinitionRecord, storageService, eventEmitter);
      }
      async getByCredentialDefinitionId(agentContext, credentialDefinitionId) {
        return this.getSingleByQuery(agentContext, { credentialDefinitionId });
      }
      async findByCredentialDefinitionId(agentContext, credentialDefinitionId) {
        return this.findSingleByQuery(agentContext, { credentialDefinitionId });
      }
    };
    AnonCredsCredentialDefinitionRepository = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.StorageService)),
      __metadata("design:paramtypes", [Object, EventEmitter_1.EventEmitter])
    ], AnonCredsCredentialDefinitionRepository);
    exports.AnonCredsCredentialDefinitionRepository = AnonCredsCredentialDefinitionRepository;
  }
});

// node_modules/@aries-framework/core/build/modules/indy/repository/AnonCredsSchemaRecord.js
var require_AnonCredsSchemaRecord = __commonJS({
  "node_modules/@aries-framework/core/build/modules/indy/repository/AnonCredsSchemaRecord.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnonCredsSchemaRecord = void 0;
    var BaseRecord_1 = require_BaseRecord();
    var did_1 = require_did2();
    var uuid_1 = require_uuid();
    var AnonCredsSchemaRecord = class extends BaseRecord_1.BaseRecord {
      constructor(props) {
        var _a;
        super();
        this.type = AnonCredsSchemaRecord.type;
        if (props) {
          this.id = (_a = props.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.schema = props.schema;
        }
      }
      getTags() {
        return Object.assign(Object.assign({}, this._tags), { schemaId: this.schema.id, schemaIssuerDid: (0, did_1.didFromSchemaId)(this.schema.id), schemaName: this.schema.name, schemaVersion: this.schema.version });
      }
    };
    exports.AnonCredsSchemaRecord = AnonCredsSchemaRecord;
    AnonCredsSchemaRecord.type = "AnonCredsSchemaRecord";
  }
});

// node_modules/@aries-framework/core/build/modules/indy/repository/AnonCredsSchemaRepository.js
var require_AnonCredsSchemaRepository = __commonJS({
  "node_modules/@aries-framework/core/build/modules/indy/repository/AnonCredsSchemaRepository.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnonCredsSchemaRepository = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var Repository_1 = require_Repository();
    var AnonCredsSchemaRecord_1 = require_AnonCredsSchemaRecord();
    var AnonCredsSchemaRepository = class AnonCredsSchemaRepository extends Repository_1.Repository {
      constructor(storageService, eventEmitter) {
        super(AnonCredsSchemaRecord_1.AnonCredsSchemaRecord, storageService, eventEmitter);
      }
      async getBySchemaId(agentContext, schemaId) {
        return this.getSingleByQuery(agentContext, { schemaId });
      }
      async findBySchemaId(agentContext, schemaId) {
        return await this.findSingleByQuery(agentContext, { schemaId });
      }
    };
    AnonCredsSchemaRepository = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.StorageService)),
      __metadata("design:paramtypes", [Object, EventEmitter_1.EventEmitter])
    ], AnonCredsSchemaRepository);
    exports.AnonCredsSchemaRepository = AnonCredsSchemaRepository;
  }
});

// node_modules/@aries-framework/core/build/modules/ledger/LedgerModuleConfig.js
var require_LedgerModuleConfig = __commonJS({
  "node_modules/@aries-framework/core/build/modules/ledger/LedgerModuleConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LedgerModuleConfig = void 0;
    var LedgerModuleConfig = class {
      constructor(options) {
        this.options = options !== null && options !== void 0 ? options : {};
      }
      /** See {@link LedgerModuleConfigOptions.connectToIndyLedgersOnStartup} */
      get connectToIndyLedgersOnStartup() {
        var _a;
        return (_a = this.options.connectToIndyLedgersOnStartup) !== null && _a !== void 0 ? _a : true;
      }
      /** See {@link LedgerModuleConfigOptions.indyLedgers} */
      get indyLedgers() {
        var _a;
        return (_a = this.options.indyLedgers) !== null && _a !== void 0 ? _a : [];
      }
    };
    exports.LedgerModuleConfig = LedgerModuleConfig;
  }
});

// node_modules/@aries-framework/core/build/modules/ledger/LedgerApi.js
var require_LedgerApi = __commonJS({
  "node_modules/@aries-framework/core/build/modules/ledger/LedgerApi.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LedgerApi = void 0;
    var agent_1 = require_agent();
    var error_1 = require_error();
    var IndySdkError_1 = require_IndySdkError();
    var plugins_1 = require_plugins();
    var indyError_1 = require_indyError();
    var indyIdentifiers_1 = require_indyIdentifiers();
    var AnonCredsCredentialDefinitionRecord_1 = require_AnonCredsCredentialDefinitionRecord();
    var AnonCredsCredentialDefinitionRepository_1 = require_AnonCredsCredentialDefinitionRepository();
    var AnonCredsSchemaRecord_1 = require_AnonCredsSchemaRecord();
    var AnonCredsSchemaRepository_1 = require_AnonCredsSchemaRepository();
    var LedgerModuleConfig_1 = require_LedgerModuleConfig();
    var services_1 = require_services();
    var LedgerApi = class LedgerApi {
      constructor(ledgerService, agentContext, anonCredsCredentialDefinitionRepository, anonCredsSchemaRepository, config) {
        this.ledgerService = ledgerService;
        this.agentContext = agentContext;
        this.anonCredsCredentialDefinitionRepository = anonCredsCredentialDefinitionRepository;
        this.anonCredsSchemaRepository = anonCredsSchemaRepository;
        this.config = config;
      }
      setPools(poolConfigs) {
        return this.ledgerService.setPools(poolConfigs);
      }
      /**
       * Connect to all the ledger pools
       */
      async connectToPools() {
        await this.ledgerService.connectToPools();
      }
      /**
       * @deprecated use agent.dids.create instead
       */
      async registerPublicDid(did, verkey, alias, role) {
        var _a;
        const myPublicDid = (_a = this.agentContext.wallet.publicDid) === null || _a === void 0 ? void 0 : _a.did;
        if (!myPublicDid) {
          throw new error_1.AriesFrameworkError("Agent has no public DID.");
        }
        return this.ledgerService.registerPublicDid(this.agentContext, myPublicDid, did, verkey, alias, role);
      }
      /**
       * @deprecated use agent.dids.resolve instead
       */
      async getPublicDid(did) {
        return this.ledgerService.getPublicDid(this.agentContext, did);
      }
      async getSchema(id) {
        return this.ledgerService.getSchema(this.agentContext, id);
      }
      async registerSchema(schema) {
        var _a;
        const did = (_a = this.agentContext.wallet.publicDid) === null || _a === void 0 ? void 0 : _a.did;
        if (!did) {
          throw new error_1.AriesFrameworkError("Agent has no public DID.");
        }
        const schemaId = (0, indyIdentifiers_1.getLegacySchemaId)(did, schema.name, schema.version);
        const qualifiedIdentifier = (0, indyIdentifiers_1.getQualifiedIndySchemaId)(this.ledgerService.getDidIndyWriteNamespace(), schemaId);
        const schemaRecord = await this.anonCredsSchemaRepository.findById(this.agentContext, qualifiedIdentifier);
        if (schemaRecord) {
          return Object.assign(Object.assign({}, schemaRecord.schema), { id: schemaId });
        }
        const schemaFromLedger = await this.findBySchemaIdOnLedger(schemaId);
        if (schemaFromLedger)
          return schemaFromLedger;
        const createdSchema = await this.ledgerService.registerSchema(this.agentContext, did, schema);
        const anonCredsSchema = new AnonCredsSchemaRecord_1.AnonCredsSchemaRecord({
          schema: Object.assign(Object.assign({}, createdSchema), { id: qualifiedIdentifier })
        });
        await this.anonCredsSchemaRepository.save(this.agentContext, anonCredsSchema);
        return createdSchema;
      }
      async findBySchemaIdOnLedger(schemaId) {
        try {
          return await this.ledgerService.getSchema(this.agentContext, schemaId);
        } catch (e) {
          if (e instanceof IndySdkError_1.IndySdkError && (0, indyError_1.isIndyError)(e.cause, "LedgerNotFound"))
            return null;
          throw e;
        }
      }
      async findByCredentialDefinitionIdOnLedger(credentialDefinitionId) {
        try {
          return await this.ledgerService.getCredentialDefinition(this.agentContext, credentialDefinitionId);
        } catch (e) {
          if (e instanceof IndySdkError_1.IndySdkError && (0, indyError_1.isIndyError)(e.cause, "LedgerNotFound"))
            return null;
          throw e;
        }
      }
      async registerCredentialDefinition(credentialDefinitionTemplate) {
        var _a;
        const did = (_a = this.agentContext.wallet.publicDid) === null || _a === void 0 ? void 0 : _a.did;
        if (!did) {
          throw new error_1.AriesFrameworkError("Agent has no public DID.");
        }
        const credentialDefinitionId = (0, indyIdentifiers_1.getLegacyCredentialDefinitionId)(did, credentialDefinitionTemplate.schema.seqNo, credentialDefinitionTemplate.tag);
        const qualifiedIdentifier = (0, indyIdentifiers_1.getQualifiedIndyCredentialDefinitionId)(this.ledgerService.getDidIndyWriteNamespace(), credentialDefinitionId);
        const credentialDefinitionRecord = await this.anonCredsCredentialDefinitionRepository.findById(this.agentContext, qualifiedIdentifier);
        if (credentialDefinitionRecord) {
          return Object.assign(Object.assign({}, credentialDefinitionRecord.credentialDefinition), { id: credentialDefinitionId });
        }
        const credentialDefinitionOnLedger = await this.findByCredentialDefinitionIdOnLedger(credentialDefinitionId);
        if (credentialDefinitionOnLedger) {
          throw new error_1.AriesFrameworkError(`No credential definition record found and credential definition ${credentialDefinitionId} already exists on the ledger.`);
        }
        const registeredDefinition = await this.ledgerService.registerCredentialDefinition(this.agentContext, did, Object.assign(Object.assign({}, credentialDefinitionTemplate), { signatureType: "CL" }));
        const anonCredCredential = new AnonCredsCredentialDefinitionRecord_1.AnonCredsCredentialDefinitionRecord({
          credentialDefinition: Object.assign(Object.assign({}, registeredDefinition), { id: qualifiedIdentifier })
        });
        await this.anonCredsCredentialDefinitionRepository.save(this.agentContext, anonCredCredential);
        return registeredDefinition;
      }
      async getCredentialDefinition(id) {
        return this.ledgerService.getCredentialDefinition(this.agentContext, id);
      }
      async getRevocationRegistryDefinition(revocationRegistryDefinitionId) {
        return this.ledgerService.getRevocationRegistryDefinition(this.agentContext, revocationRegistryDefinitionId);
      }
      async getRevocationRegistryDelta(revocationRegistryDefinitionId, fromSeconds = 0, toSeconds = (/* @__PURE__ */ new Date()).getTime()) {
        return this.ledgerService.getRevocationRegistryDelta(this.agentContext, revocationRegistryDefinitionId, fromSeconds, toSeconds);
      }
    };
    LedgerApi = __decorate([
      (0, plugins_1.injectable)(),
      __metadata("design:paramtypes", [
        services_1.IndyLedgerService,
        agent_1.AgentContext,
        AnonCredsCredentialDefinitionRepository_1.AnonCredsCredentialDefinitionRepository,
        AnonCredsSchemaRepository_1.AnonCredsSchemaRepository,
        LedgerModuleConfig_1.LedgerModuleConfig
      ])
    ], LedgerApi);
    exports.LedgerApi = LedgerApi;
  }
});

// node_modules/@aries-framework/core/build/modules/ledger/LedgerModule.js
var require_LedgerModule = __commonJS({
  "node_modules/@aries-framework/core/build/modules/ledger/LedgerModule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LedgerModule = void 0;
    var AnonCredsCredentialDefinitionRepository_1 = require_AnonCredsCredentialDefinitionRepository();
    var AnonCredsSchemaRepository_1 = require_AnonCredsSchemaRepository();
    var LedgerApi_1 = require_LedgerApi();
    var LedgerModuleConfig_1 = require_LedgerModuleConfig();
    var services_1 = require_services();
    var LedgerModule = class {
      constructor(config) {
        this.api = LedgerApi_1.LedgerApi;
        this.config = new LedgerModuleConfig_1.LedgerModuleConfig(config);
      }
      /**
       * Registers the dependencies of the ledger module on the dependency manager.
       */
      register(dependencyManager) {
        dependencyManager.registerContextScoped(LedgerApi_1.LedgerApi);
        dependencyManager.registerInstance(LedgerModuleConfig_1.LedgerModuleConfig, this.config);
        dependencyManager.registerSingleton(services_1.IndyLedgerService);
        dependencyManager.registerSingleton(services_1.IndyPoolService);
        dependencyManager.registerSingleton(AnonCredsCredentialDefinitionRepository_1.AnonCredsCredentialDefinitionRepository);
        dependencyManager.registerSingleton(AnonCredsSchemaRepository_1.AnonCredsSchemaRepository);
      }
    };
    exports.LedgerModule = LedgerModule;
  }
});

// node_modules/@aries-framework/core/build/modules/ledger/index.js
var require_ledger = __commonJS({
  "node_modules/@aries-framework/core/build/modules/ledger/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_services(), exports);
    __exportStar(require_LedgerApi(), exports);
    __exportStar(require_IndyPool(), exports);
    __exportStar(require_LedgerModule(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/dids/methods/sov/util.js
var require_util2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/methods/sov/util.js"(exports) {
    "use strict";
    var __rest2 = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addServicesFromEndpointsAttrib = exports.sovDidDocumentFromDid = void 0;
    var utils_1 = require_utils();
    var did_1 = require_did2();
    var constants_1 = require_constants2();
    var constants_2 = require_constants3();
    var domain_1 = require_domain();
    var ed25519_1 = require_ed255192();
    function sovDidDocumentFromDid(fullDid, verkey) {
      const verificationMethodId = `${fullDid}#key-1`;
      const keyAgreementId = `${fullDid}#key-agreement-1`;
      const publicKeyBase58 = (0, did_1.getFullVerkey)(fullDid, verkey);
      const publicKeyX25519 = utils_1.TypedArrayEncoder.toBase58((0, ed25519_1.convertPublicKeyToX25519)(utils_1.TypedArrayEncoder.fromBase58(publicKeyBase58)));
      const builder = new domain_1.DidDocumentBuilder(fullDid).addContext(constants_2.ED25519_SUITE_CONTEXT_URL_2018).addContext(constants_1.SECURITY_X25519_CONTEXT_URL).addVerificationMethod({
        controller: fullDid,
        id: verificationMethodId,
        publicKeyBase58,
        type: "Ed25519VerificationKey2018"
      }).addVerificationMethod({
        controller: fullDid,
        id: keyAgreementId,
        publicKeyBase58: publicKeyX25519,
        type: "X25519KeyAgreementKey2019"
      }).addAuthentication(verificationMethodId).addAssertionMethod(verificationMethodId).addKeyAgreement(keyAgreementId);
      return builder;
    }
    exports.sovDidDocumentFromDid = sovDidDocumentFromDid;
    function processEndpointTypes(types) {
      const expectedTypes = ["endpoint", "did-communication", "DIDComm"];
      const defaultTypes = ["endpoint", "did-communication"];
      if (!types || types.length <= 0) {
        return defaultTypes;
      }
      for (const type of types) {
        if (!expectedTypes.includes(type)) {
          return defaultTypes;
        }
      }
      return types;
    }
    function addServicesFromEndpointsAttrib(builder, did, endpoints, keyAgreementId) {
      const { endpoint, routingKeys, types } = endpoints, otherEndpoints = __rest2(endpoints, ["endpoint", "routingKeys", "types"]);
      if (endpoint) {
        const processedTypes = processEndpointTypes(types);
        if (processedTypes.includes("endpoint")) {
          builder.addService(new domain_1.DidDocumentService({
            id: `${did}#endpoint`,
            serviceEndpoint: endpoint,
            type: "endpoint"
          }));
        }
        if (processedTypes.includes("did-communication")) {
          builder.addService(new domain_1.DidCommV1Service({
            id: `${did}#did-communication`,
            serviceEndpoint: endpoint,
            priority: 0,
            routingKeys: routingKeys !== null && routingKeys !== void 0 ? routingKeys : [],
            recipientKeys: [keyAgreementId],
            accept: ["didcomm/aip2;env=rfc19"]
          }));
          if (processedTypes.includes("DIDComm")) {
            builder.addService(new domain_1.DidCommV2Service({
              id: `${did}#didcomm-1`,
              serviceEndpoint: endpoint,
              routingKeys: routingKeys !== null && routingKeys !== void 0 ? routingKeys : [],
              accept: ["didcomm/v2"]
            })).addContext("https://didcomm.org/messaging/contexts/v2");
          }
        }
      }
      for (const [type, endpoint2] of Object.entries(otherEndpoints)) {
        builder.addService(new domain_1.DidDocumentService({
          id: `${did}#${type}`,
          serviceEndpoint: endpoint2,
          type
        }));
      }
    }
    exports.addServicesFromEndpointsAttrib = addServicesFromEndpointsAttrib;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/methods/sov/IndySdkSovDidRegistrar.js
var require_IndySdkSovDidRegistrar = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/methods/sov/IndySdkSovDidRegistrar.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndySdkSovDidRegistrar = void 0;
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var indyError_1 = require_indyError();
    var assertIndyWallet_1 = require_assertIndyWallet();
    var ledger_1 = require_ledger();
    var DidDocumentRole_1 = require_DidDocumentRole();
    var repository_1 = require_repository();
    var util_1 = require_util2();
    var IndySdkSovDidRegistrar = class IndySdkSovDidRegistrar {
      constructor() {
        this.supportedMethods = ["sov"];
      }
      async create(agentContext, options) {
        var _a, _b;
        const indy = agentContext.config.agentDependencies.indy;
        const indyPoolService = agentContext.dependencyManager.resolve(ledger_1.IndyPoolService);
        const didRepository = agentContext.dependencyManager.resolve(repository_1.DidRepository);
        const { alias, role, submitterDid, indyNamespace } = options.options;
        const seed = (_a = options.secret) === null || _a === void 0 ? void 0 : _a.seed;
        if (seed && (typeof seed !== "string" || seed.length !== 32)) {
          return {
            didDocumentMetadata: {},
            didRegistrationMetadata: {},
            didState: {
              state: "failed",
              reason: "Invalid seed provided"
            }
          };
        }
        if (!submitterDid.startsWith("did:sov:")) {
          return {
            didDocumentMetadata: {},
            didRegistrationMetadata: {},
            didState: {
              state: "failed",
              reason: "Submitter did must be a valid did:sov did"
            }
          };
        }
        try {
          (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
          const [unqualifiedIndyDid, verkey] = await indy.createAndStoreMyDid(agentContext.wallet.handle, {
            seed
          });
          const qualifiedSovDid = `did:sov:${unqualifiedIndyDid}`;
          const unqualifiedSubmitterDid = submitterDid.replace("did:sov:", "");
          const pool = indyPoolService.getPoolForNamespace(indyNamespace);
          await this.registerPublicDid(agentContext, unqualifiedSubmitterDid, unqualifiedIndyDid, verkey, alias, pool, role);
          const didDocumentBuilder = (0, util_1.sovDidDocumentFromDid)(qualifiedSovDid, verkey);
          if (options.options.endpoints) {
            await this.setEndpointsForDid(agentContext, unqualifiedIndyDid, options.options.endpoints, pool);
            (0, util_1.addServicesFromEndpointsAttrib)(didDocumentBuilder, qualifiedSovDid, options.options.endpoints, `${qualifiedSovDid}#key-agreement-1`);
          }
          const didDocument = didDocumentBuilder.build();
          const didIndyNamespace = pool.config.indyNamespace;
          const qualifiedIndyDid = `did:indy:${didIndyNamespace}:${unqualifiedIndyDid}`;
          const didRecord = new repository_1.DidRecord({
            did: qualifiedSovDid,
            role: DidDocumentRole_1.DidDocumentRole.Created,
            tags: {
              recipientKeyFingerprints: didDocument.recipientKeys.map((key) => key.fingerprint),
              qualifiedIndyDid
            }
          });
          await didRepository.save(agentContext, didRecord);
          return {
            didDocumentMetadata: {
              qualifiedIndyDid
            },
            didRegistrationMetadata: {
              didIndyNamespace
            },
            didState: {
              state: "finished",
              did: qualifiedSovDid,
              didDocument,
              secret: {
                // FIXME: the uni-registrar creates the seed in the registrar method
                // if it doesn't exist so the seed can always be returned. Currently
                // we can only return it if the seed was passed in by the user. Once
                // we have a secure method for generating seeds we should use the same
                // approach
                seed: (_b = options.secret) === null || _b === void 0 ? void 0 : _b.seed
              }
            }
          };
        } catch (error) {
          return {
            didDocumentMetadata: {},
            didRegistrationMetadata: {},
            didState: {
              state: "failed",
              reason: `unknownError: ${error.message}`
            }
          };
        }
      }
      async update() {
        return {
          didDocumentMetadata: {},
          didRegistrationMetadata: {},
          didState: {
            state: "failed",
            reason: `notImplemented: updating did:sov not implemented yet`
          }
        };
      }
      async deactivate() {
        return {
          didDocumentMetadata: {},
          didRegistrationMetadata: {},
          didState: {
            state: "failed",
            reason: `notImplemented: deactivating did:sov not implemented yet`
          }
        };
      }
      async registerPublicDid(agentContext, submitterDid, targetDid, verkey, alias, pool, role) {
        const indyPoolService = agentContext.dependencyManager.resolve(ledger_1.IndyPoolService);
        const indy = agentContext.config.agentDependencies.indy;
        try {
          agentContext.config.logger.debug(`Register public did '${targetDid}' on ledger '${pool.id}'`);
          const request = await indy.buildNymRequest(submitterDid, targetDid, verkey, alias, role || null);
          const response = await indyPoolService.submitWriteRequest(agentContext, pool, request, submitterDid);
          agentContext.config.logger.debug(`Registered public did '${targetDid}' on ledger '${pool.id}'`, {
            response
          });
          return targetDid;
        } catch (error) {
          agentContext.config.logger.error(`Error registering public did '${targetDid}' on ledger '${pool.id}'`, {
            error,
            submitterDid,
            targetDid,
            verkey,
            alias,
            role,
            pool: pool.id
          });
          throw error;
        }
      }
      async setEndpointsForDid(agentContext, did, endpoints, pool) {
        const indyPoolService = agentContext.dependencyManager.resolve(ledger_1.IndyPoolService);
        const indy = agentContext.config.agentDependencies.indy;
        try {
          agentContext.config.logger.debug(`Set endpoints for did '${did}' on ledger '${pool.id}'`, endpoints);
          const request = await indy.buildAttribRequest(did, did, null, { endpoint: endpoints }, null);
          const response = await indyPoolService.submitWriteRequest(agentContext, pool, request, did);
          agentContext.config.logger.debug(`Successfully set endpoints for did '${did}' on ledger '${pool.id}'`, {
            response,
            endpoints
          });
        } catch (error) {
          agentContext.config.logger.error(`Error setting endpoints for did '${did}' on ledger '${pool.id}'`, {
            error,
            did,
            endpoints
          });
          throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
      }
    };
    IndySdkSovDidRegistrar = __decorate([
      (0, plugins_1.injectable)()
    ], IndySdkSovDidRegistrar);
    exports.IndySdkSovDidRegistrar = IndySdkSovDidRegistrar;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/methods/sov/IndySdkSovDidResolver.js
var require_IndySdkSovDidResolver = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/methods/sov/IndySdkSovDidResolver.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndySdkSovDidResolver = void 0;
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var indyError_1 = require_indyError();
    var ledger_1 = require_ledger();
    var util_1 = require_util2();
    var IndySdkSovDidResolver = class IndySdkSovDidResolver {
      constructor() {
        this.supportedMethods = ["sov"];
      }
      async resolve(agentContext, did, parsed) {
        const didDocumentMetadata = {};
        try {
          const nym = await this.getPublicDid(agentContext, parsed.id);
          const endpoints = await this.getEndpointsForDid(agentContext, parsed.id);
          const keyAgreementId = `${parsed.did}#key-agreement-1`;
          const builder = (0, util_1.sovDidDocumentFromDid)(parsed.did, nym.verkey);
          (0, util_1.addServicesFromEndpointsAttrib)(builder, parsed.did, endpoints, keyAgreementId);
          return {
            didDocument: builder.build(),
            didDocumentMetadata,
            didResolutionMetadata: { contentType: "application/did+ld+json" }
          };
        } catch (error) {
          return {
            didDocument: null,
            didDocumentMetadata,
            didResolutionMetadata: {
              error: "notFound",
              message: `resolver_error: Unable to resolve did '${did}': ${error}`
            }
          };
        }
      }
      async getPublicDid(agentContext, did) {
        const indyPoolService = agentContext.dependencyManager.resolve(ledger_1.IndyPoolService);
        const { did: didResponse } = await indyPoolService.getPoolForDid(agentContext, did);
        return didResponse;
      }
      async getEndpointsForDid(agentContext, did) {
        var _a;
        const indyPoolService = agentContext.dependencyManager.resolve(ledger_1.IndyPoolService);
        const indy = agentContext.config.agentDependencies.indy;
        const { pool } = await indyPoolService.getPoolForDid(agentContext, did);
        try {
          agentContext.config.logger.debug(`Get endpoints for did '${did}' from ledger '${pool.id}'`);
          const request = await indy.buildGetAttribRequest(null, did, "endpoint", null, null);
          agentContext.config.logger.debug(`Submitting get endpoint ATTRIB request for did '${did}' to ledger '${pool.id}'`);
          const response = await indyPoolService.submitReadRequest(pool, request);
          if (!response.result.data)
            return {};
          const endpoints = (_a = JSON.parse(response.result.data)) === null || _a === void 0 ? void 0 : _a.endpoint;
          agentContext.config.logger.debug(`Got endpoints '${JSON.stringify(endpoints)}' for did '${did}' from ledger '${pool.id}'`, {
            response,
            endpoints
          });
          return endpoints !== null && endpoints !== void 0 ? endpoints : {};
        } catch (error) {
          agentContext.config.logger.error(`Error retrieving endpoints for did '${did}' from ledger '${pool.id}'`, {
            error
          });
          throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
      }
    };
    IndySdkSovDidResolver = __decorate([
      (0, plugins_1.injectable)()
    ], IndySdkSovDidResolver);
    exports.IndySdkSovDidResolver = IndySdkSovDidResolver;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/methods/sov/index.js
var require_sov = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/methods/sov/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_IndySdkSovDidRegistrar(), exports);
    __exportStar(require_IndySdkSovDidResolver(), exports);
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var global2 = typeof self !== "undefined" ? self : exports;
    var __self__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F.prototype = global2;
      return new F();
    }();
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request2(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request2) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request2.prototype.clone = function() {
          return new Request2(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request2.prototype);
        function Response2(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response2.prototype);
        Response2.prototype.clone = function() {
          return new Response2(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response2.error = function() {
          var response = new Response2(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response2.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response2(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request2(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response2(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch;
          self2.Headers = Headers;
          self2.Request = Request2;
          self2.Response = Response2;
        }
        exports2.Headers = Headers;
        exports2.Request = Request2;
        exports2.Response = Response2;
        exports2.fetch = fetch;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/web-did-resolver/lib/resolver.cjs
var require_resolver2 = __commonJS({
  "node_modules/web-did-resolver/lib/resolver.cjs"(exports) {
    var fetch = require_browser_ponyfill();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var fetch__default = _interopDefaultLegacy(fetch);
    function _catch(body, recover) {
      try {
        var result2 = body();
      } catch (e) {
        return recover(e);
      }
      if (result2 && result2.then) {
        return result2.then(void 0, recover);
      }
      return result2;
    }
    var get = function(url) {
      try {
        return Promise.resolve(fetch__default["default"](url, {
          mode: "cors"
        })).then(function(res) {
          if (res.status >= 400) {
            throw new Error(`Bad response ${res.statusText}`);
          }
          return res.json();
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };
    function _settle(pact, state, value) {
      if (!pact.s) {
        if (value instanceof _Pact) {
          if (value.s) {
            if (state & 1) {
              state = value.s;
            }
            value = value.v;
          } else {
            value.o = _settle.bind(null, pact, state);
            return;
          }
        }
        if (value && value.then) {
          value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
          return;
        }
        pact.s = state;
        pact.v = value;
        const observer = pact.o;
        if (observer) {
          observer(pact);
        }
      }
    }
    var DOC_PATH = "/.well-known/did.json";
    var _Pact = function() {
      function _Pact2() {
      }
      _Pact2.prototype.then = function(onFulfilled, onRejected) {
        const result2 = new _Pact2();
        const state = this.s;
        if (state) {
          const callback = state & 1 ? onFulfilled : onRejected;
          if (callback) {
            try {
              _settle(result2, 1, callback(this.v));
            } catch (e) {
              _settle(result2, 2, e);
            }
            return result2;
          } else {
            return this;
          }
        }
        this.o = function(_this) {
          try {
            const value = _this.v;
            if (_this.s & 1) {
              _settle(result2, 1, onFulfilled ? onFulfilled(value) : value);
            } else if (onRejected) {
              _settle(result2, 1, onRejected(value));
            } else {
              _settle(result2, 2, value);
            }
          } catch (e) {
            _settle(result2, 2, e);
          }
        };
        return result2;
      };
      return _Pact2;
    }();
    function _isSettledPact(thenable) {
      return thenable instanceof _Pact && thenable.s & 1;
    }
    function _do(body, test) {
      var awaitBody;
      do {
        var result2 = body();
        if (result2 && result2.then) {
          if (_isSettledPact(result2)) {
            result2 = result2.v;
          } else {
            awaitBody = true;
            break;
          }
        }
        var shouldContinue = test();
        if (_isSettledPact(shouldContinue)) {
          shouldContinue = shouldContinue.v;
        }
        if (!shouldContinue) {
          return result2;
        }
      } while (!shouldContinue.then);
      const pact = new _Pact();
      const reject = _settle.bind(null, pact, 2);
      (awaitBody ? result2.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);
      return pact;
      function _resumeAfterBody(value) {
        result2 = value;
        for (; ; ) {
          shouldContinue = test();
          if (_isSettledPact(shouldContinue)) {
            shouldContinue = shouldContinue.v;
          }
          if (!shouldContinue) {
            break;
          }
          if (shouldContinue.then) {
            shouldContinue.then(_resumeAfterTest).then(void 0, reject);
            return;
          }
          result2 = body();
          if (result2 && result2.then) {
            if (_isSettledPact(result2)) {
              result2 = result2.v;
            } else {
              result2.then(_resumeAfterBody).then(void 0, reject);
              return;
            }
          }
        }
        _settle(pact, 1, result2);
      }
      function _resumeAfterTest(shouldContinue2) {
        if (shouldContinue2) {
          do {
            result2 = body();
            if (result2 && result2.then) {
              if (_isSettledPact(result2)) {
                result2 = result2.v;
              } else {
                result2.then(_resumeAfterBody).then(void 0, reject);
                return;
              }
            }
            shouldContinue2 = test();
            if (_isSettledPact(shouldContinue2)) {
              shouldContinue2 = shouldContinue2.v;
            }
            if (!shouldContinue2) {
              _settle(pact, 1, result2);
              return;
            }
          } while (!shouldContinue2.then);
          shouldContinue2.then(_resumeAfterTest).then(void 0, reject);
        } else {
          _settle(pact, 1, result2);
        }
      }
    }
    function getResolver() {
      const resolve = function(did, parsed) {
        try {
          let _temp42 = function() {
            const contentType = typeof (didDocument == null ? void 0 : didDocument["@context"]) !== "undefined" ? "application/did+ld+json" : "application/did+json";
            if (err) {
              return {
                didDocument,
                didDocumentMetadata,
                didResolutionMetadata: {
                  error: "notFound",
                  message: err
                }
              };
            } else {
              return {
                didDocument,
                didDocumentMetadata,
                didResolutionMetadata: {
                  contentType
                }
              };
            }
          };
          var _temp4 = _temp42;
          let _interrupt;
          let err = null;
          let path = decodeURIComponent(parsed.id) + DOC_PATH;
          const id = parsed.id.split(":");
          if (id.length > 1) {
            path = id.map(decodeURIComponent).join("/") + "/did.json";
          }
          const url = `https://${path}`;
          const didDocumentMetadata = {};
          let didDocument = null;
          const _temp3 = _do(function() {
            function _temp2() {
              if (!_interrupt) {
                const docIdMatchesDid = (didDocument == null ? void 0 : didDocument.id) === did;
                if (!docIdMatchesDid) {
                  err = "resolver_error: DID document id does not match requested did";
                }
              }
            }
            const _temp = _catch(function() {
              return Promise.resolve(get(url)).then(function(_get) {
                didDocument = _get;
              });
            }, function(error) {
              err = `resolver_error: DID must resolve to a valid https URL containing a JSON document: ${error}`;
              _interrupt = 1;
            });
            return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);
          }, function() {
            return !_interrupt && false;
          });
          return Promise.resolve(_temp3 && _temp3.then ? _temp3.then(_temp42) : _temp42(_temp3));
        } catch (e) {
          return Promise.reject(e);
        }
      };
      return {
        web: resolve
      };
    }
    exports.getResolver = getResolver;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/methods/web/WebDidResolver.js
var require_WebDidResolver = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/methods/web/WebDidResolver.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebDidResolver = void 0;
    var did_resolver_1 = require_resolver();
    var didWeb = __importStar(require_resolver2());
    var JsonTransformer_1 = require_JsonTransformer();
    var domain_1 = require_domain();
    var WebDidResolver = class {
      constructor() {
        this._resolverInstance = new did_resolver_1.Resolver();
        this.resolver = didWeb.getResolver();
        this.supportedMethods = Object.keys(this.resolver);
      }
      async resolve(agentContext, did, parsed, didResolutionOptions) {
        const result2 = await this.resolver[parsed.method](did, parsed, this._resolverInstance, didResolutionOptions);
        let didDocument = null;
        if (result2.didDocument) {
          didDocument = JsonTransformer_1.JsonTransformer.fromJSON(result2.didDocument, domain_1.DidDocument);
        }
        return Object.assign(Object.assign({}, result2), { didDocument });
      }
    };
    exports.WebDidResolver = WebDidResolver;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/methods/web/index.js
var require_web = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/methods/web/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_WebDidResolver(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/dids/methods/index.js
var require_methods = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/methods/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_key(), exports);
    __exportStar(require_peer(), exports);
    __exportStar(require_sov(), exports);
    __exportStar(require_web(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/dids/DidsModuleConfig.js
var require_DidsModuleConfig = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/DidsModuleConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidsModuleConfig = void 0;
    var methods_1 = require_methods();
    var DidsModuleConfig = class {
      constructor(options) {
        this.options = options !== null && options !== void 0 ? options : {};
      }
      /** See {@link DidsModuleConfigOptions.registrars} */
      get registrars() {
        var _a;
        if (this._registrars)
          return this._registrars;
        let registrars = (_a = this.options.registrars) !== null && _a !== void 0 ? _a : [
          new methods_1.KeyDidRegistrar(),
          new methods_1.IndySdkSovDidRegistrar(),
          new methods_1.PeerDidRegistrar()
        ];
        if (!registrars.find((registrar) => registrar instanceof methods_1.PeerDidRegistrar)) {
          registrars = [...registrars, new methods_1.PeerDidRegistrar()];
        }
        this._registrars = registrars;
        return registrars;
      }
      addRegistrar(registrar) {
        this.registrars.push(registrar);
      }
      /** See {@link DidsModuleConfigOptions.resolvers} */
      get resolvers() {
        var _a;
        if (this._resolvers)
          return this._resolvers;
        let resolvers = (_a = this.options.resolvers) !== null && _a !== void 0 ? _a : [
          new methods_1.IndySdkSovDidResolver(),
          new methods_1.WebDidResolver(),
          new methods_1.KeyDidResolver(),
          new methods_1.PeerDidResolver()
        ];
        if (!resolvers.find((resolver) => resolver instanceof methods_1.PeerDidResolver)) {
          resolvers = [...resolvers, new methods_1.PeerDidResolver()];
        }
        this._resolvers = resolvers;
        return resolvers;
      }
      addResolver(resolver) {
        this.resolvers.push(resolver);
      }
    };
    exports.DidsModuleConfig = DidsModuleConfig;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/services/DidResolverService.js
var require_DidResolverService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/services/DidResolverService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidResolverService = void 0;
    var constants_1 = require_constants();
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var DidsModuleConfig_1 = require_DidsModuleConfig();
    var parse_1 = require_parse();
    var DidResolverService = class DidResolverService {
      constructor(logger, didsModuleConfig) {
        this.logger = logger;
        this.didsModuleConfig = didsModuleConfig;
      }
      async resolve(agentContext, didUrl, options = {}) {
        this.logger.debug(`resolving didUrl ${didUrl}`);
        const result2 = {
          didResolutionMetadata: {},
          didDocument: null,
          didDocumentMetadata: {}
        };
        let parsed;
        try {
          parsed = (0, parse_1.parseDid)(didUrl);
        } catch (error) {
          return Object.assign(Object.assign({}, result2), { didResolutionMetadata: { error: "invalidDid" } });
        }
        const resolver = this.findResolver(parsed);
        if (!resolver) {
          return Object.assign(Object.assign({}, result2), { didResolutionMetadata: { error: "unsupportedDidMethod" } });
        }
        return resolver.resolve(agentContext, parsed.did, parsed, options);
      }
      async resolveDidDocument(agentContext, did) {
        const { didDocument, didResolutionMetadata: { error, message } } = await this.resolve(agentContext, did);
        if (!didDocument) {
          throw new error_1.AriesFrameworkError(`Unable to resolve did document for did '${did}': ${error} ${message}`);
        }
        return didDocument;
      }
      findResolver(parsed) {
        var _a;
        return (_a = this.didsModuleConfig.resolvers.find((r) => r.supportedMethods.includes(parsed.method))) !== null && _a !== void 0 ? _a : null;
      }
    };
    DidResolverService = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [Object, DidsModuleConfig_1.DidsModuleConfig])
    ], DidResolverService);
    exports.DidResolverService = DidResolverService;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/services/DidRegistrarService.js
var require_DidRegistrarService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/services/DidRegistrarService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidRegistrarService = void 0;
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var DidsModuleConfig_1 = require_DidsModuleConfig();
    var parse_1 = require_parse();
    var DidRegistrarService = class DidRegistrarService {
      constructor(logger, didsModuleConfig) {
        this.logger = logger;
        this.didsModuleConfig = didsModuleConfig;
      }
      async create(agentContext, options) {
        var _a, _b, _c;
        this.logger.debug(`creating did ${(_a = options.did) !== null && _a !== void 0 ? _a : options.method}`);
        const errorResult = {
          didDocumentMetadata: {},
          didRegistrationMetadata: {},
          didState: {
            state: "failed",
            did: options.did
          }
        };
        if (!options.did && !options.method || options.did && options.method) {
          return Object.assign(Object.assign({}, errorResult), { didState: Object.assign(Object.assign({}, errorResult.didState), { reason: "Either did OR method must be specified" }) });
        }
        const method = (_b = options.method) !== null && _b !== void 0 ? _b : (_c = (0, parse_1.tryParseDid)(options.did)) === null || _c === void 0 ? void 0 : _c.method;
        if (!method) {
          return Object.assign(Object.assign({}, errorResult), { didState: Object.assign(Object.assign({}, errorResult.didState), { reason: `Could not extract method from did ${options.did}` }) });
        }
        const registrar = this.findRegistrarForMethod(method);
        if (!registrar) {
          return Object.assign(Object.assign({}, errorResult), { didState: Object.assign(Object.assign({}, errorResult.didState), { reason: `Unsupported did method: '${method}'` }) });
        }
        return await registrar.create(agentContext, options);
      }
      async update(agentContext, options) {
        var _a;
        this.logger.debug(`updating did ${options.did}`);
        const method = (_a = (0, parse_1.tryParseDid)(options.did)) === null || _a === void 0 ? void 0 : _a.method;
        const errorResult = {
          didDocumentMetadata: {},
          didRegistrationMetadata: {},
          didState: {
            state: "failed",
            did: options.did
          }
        };
        if (!method) {
          return Object.assign(Object.assign({}, errorResult), { didState: Object.assign(Object.assign({}, errorResult.didState), { reason: `Could not extract method from did ${options.did}` }) });
        }
        const registrar = this.findRegistrarForMethod(method);
        if (!registrar) {
          return Object.assign(Object.assign({}, errorResult), { didState: Object.assign(Object.assign({}, errorResult.didState), { reason: `Unsupported did method: '${method}'` }) });
        }
        return await registrar.update(agentContext, options);
      }
      async deactivate(agentContext, options) {
        var _a;
        this.logger.debug(`deactivating did ${options.did}`);
        const errorResult = {
          didDocumentMetadata: {},
          didRegistrationMetadata: {},
          didState: {
            state: "failed",
            did: options.did
          }
        };
        const method = (_a = (0, parse_1.tryParseDid)(options.did)) === null || _a === void 0 ? void 0 : _a.method;
        if (!method) {
          return Object.assign(Object.assign({}, errorResult), { didState: Object.assign(Object.assign({}, errorResult.didState), { reason: `Could not extract method from did ${options.did}` }) });
        }
        const registrar = this.findRegistrarForMethod(method);
        if (!registrar) {
          return Object.assign(Object.assign({}, errorResult), { didState: Object.assign(Object.assign({}, errorResult.didState), { reason: `Unsupported did method: '${method}'` }) });
        }
        return await registrar.deactivate(agentContext, options);
      }
      findRegistrarForMethod(method) {
        var _a;
        return (_a = this.didsModuleConfig.registrars.find((r) => r.supportedMethods.includes(method))) !== null && _a !== void 0 ? _a : null;
      }
    };
    DidRegistrarService = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [Object, DidsModuleConfig_1.DidsModuleConfig])
    ], DidRegistrarService);
    exports.DidRegistrarService = DidRegistrarService;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/services/index.js
var require_services2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/services/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_DidResolverService(), exports);
    __exportStar(require_DidRegistrarService(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/dids/DidsApi.js
var require_DidsApi = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/DidsApi.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidsApi = void 0;
    var agent_1 = require_agent();
    var plugins_1 = require_plugins();
    var DidsModuleConfig_1 = require_DidsModuleConfig();
    var repository_1 = require_repository();
    var services_1 = require_services2();
    var DidsApi = class DidsApi {
      constructor(didResolverService, didRegistrarService, didRepository, agentContext, config) {
        this.didResolverService = didResolverService;
        this.didRegistrarService = didRegistrarService;
        this.didRepository = didRepository;
        this.agentContext = agentContext;
        this.config = config;
      }
      /**
       * Resolve a did to a did document.
       *
       * Follows the interface as defined in https://w3c-ccg.github.io/did-resolution/
       */
      resolve(didUrl, options) {
        return this.didResolverService.resolve(this.agentContext, didUrl, options);
      }
      /**
       * Create, register and store a did and did document.
       *
       * Follows the interface as defined in https://identity.foundation/did-registration
       */
      create(options) {
        return this.didRegistrarService.create(this.agentContext, options);
      }
      /**
       * Update an existing did document.
       *
       * Follows the interface as defined in https://identity.foundation/did-registration
       */
      update(options) {
        return this.didRegistrarService.update(this.agentContext, options);
      }
      /**
       * Deactivate an existing did.
       *
       * Follows the interface as defined in https://identity.foundation/did-registration
       */
      deactivate(options) {
        return this.didRegistrarService.deactivate(this.agentContext, options);
      }
      /**
       * Resolve a did to a did document. This won't return the associated metadata as defined
       * in the did resolution specification, and will throw an error if the did document could not
       * be resolved.
       */
      resolveDidDocument(didUrl) {
        return this.didResolverService.resolveDidDocument(this.agentContext, didUrl);
      }
      /**
       * Get a list of all dids created by the agent. This will return a list of {@link DidRecord} objects.
       * Each document will have an id property with the value of the did. Optionally, it will contain a did document,
       * but this is only for documents that can't be resolved from the did itself or remotely.
       *
       * You can call `${@link DidsModule.resolve} to resolve the did document based on the did itself.
       */
      getCreatedDids({ method } = {}) {
        return this.didRepository.getCreatedDids(this.agentContext, { method });
      }
    };
    DidsApi = __decorate([
      (0, plugins_1.injectable)(),
      __metadata("design:paramtypes", [
        services_1.DidResolverService,
        services_1.DidRegistrarService,
        repository_1.DidRepository,
        agent_1.AgentContext,
        DidsModuleConfig_1.DidsModuleConfig
      ])
    ], DidsApi);
    exports.DidsApi = DidsApi;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/DidsModule.js
var require_DidsModule = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/DidsModule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidsModule = void 0;
    var DidsApi_1 = require_DidsApi();
    var DidsModuleConfig_1 = require_DidsModuleConfig();
    var repository_1 = require_repository();
    var services_1 = require_services2();
    var DidsModule = class {
      constructor(config) {
        this.api = DidsApi_1.DidsApi;
        this.config = new DidsModuleConfig_1.DidsModuleConfig(config);
      }
      /**
       * Registers the dependencies of the dids module module on the dependency manager.
       */
      register(dependencyManager) {
        dependencyManager.registerContextScoped(DidsApi_1.DidsApi);
        dependencyManager.registerInstance(DidsModuleConfig_1.DidsModuleConfig, this.config);
        dependencyManager.registerSingleton(services_1.DidResolverService);
        dependencyManager.registerSingleton(services_1.DidRegistrarService);
        dependencyManager.registerSingleton(repository_1.DidRepository);
      }
    };
    exports.DidsModule = DidsModule;
  }
});

// node_modules/@aries-framework/core/build/modules/dids/index.js
var require_dids = __commonJS({
  "node_modules/@aries-framework/core/build/modules/dids/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types2(), exports);
    __exportStar(require_domain(), exports);
    __exportStar(require_DidsApi(), exports);
    __exportStar(require_repository(), exports);
    __exportStar(require_services2(), exports);
    __exportStar(require_DidsModule(), exports);
    __exportStar(require_methods(), exports);
    __exportStar(require_DidsModuleConfig(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/oob/domain/OutOfBandRole.js
var require_OutOfBandRole = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/domain/OutOfBandRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutOfBandRole = void 0;
    var OutOfBandRole;
    (function(OutOfBandRole2) {
      OutOfBandRole2["Sender"] = "sender";
      OutOfBandRole2["Receiver"] = "receiver";
    })(OutOfBandRole = exports.OutOfBandRole || (exports.OutOfBandRole = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/oob/domain/OutOfBandState.js
var require_OutOfBandState = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/domain/OutOfBandState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutOfBandState = void 0;
    var OutOfBandState;
    (function(OutOfBandState2) {
      OutOfBandState2["Initial"] = "initial";
      OutOfBandState2["AwaitResponse"] = "await-response";
      OutOfBandState2["PrepareResponse"] = "prepare-response";
      OutOfBandState2["Done"] = "done";
    })(OutOfBandState = exports.OutOfBandState || (exports.OutOfBandState = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/connections/ConnectionEvents.js
var require_ConnectionEvents = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/ConnectionEvents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionEventTypes = void 0;
    var ConnectionEventTypes;
    (function(ConnectionEventTypes2) {
      ConnectionEventTypes2["ConnectionStateChanged"] = "ConnectionStateChanged";
    })(ConnectionEventTypes = exports.ConnectionEventTypes || (exports.ConnectionEventTypes = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/problem-reports/errors/ProblemReportError.js
var require_ProblemReportError = __commonJS({
  "node_modules/@aries-framework/core/build/modules/problem-reports/errors/ProblemReportError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProblemReportError = void 0;
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var ProblemReportMessage_1 = require_ProblemReportMessage();
    var ProblemReportError = class extends AriesFrameworkError_1.AriesFrameworkError {
      constructor(message, { problemCode }) {
        super(message);
        this.problemReport = new ProblemReportMessage_1.ProblemReportMessage({
          description: {
            en: message,
            code: problemCode
          }
        });
      }
    };
    exports.ProblemReportError = ProblemReportError;
  }
});

// node_modules/@aries-framework/core/build/modules/problem-reports/errors/index.js
var require_errors = __commonJS({
  "node_modules/@aries-framework/core/build/modules/problem-reports/errors/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ProblemReportError(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/problem-reports/messages/index.js
var require_messages2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/problem-reports/messages/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ProblemReportMessage(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/problem-reports/models/ProblemReportReason.js
var require_ProblemReportReason = __commonJS({
  "node_modules/@aries-framework/core/build/modules/problem-reports/models/ProblemReportReason.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProblemReportReason = void 0;
    var ProblemReportReason;
    (function(ProblemReportReason2) {
      ProblemReportReason2["MessageParseFailure"] = "message-parse-failure";
    })(ProblemReportReason = exports.ProblemReportReason || (exports.ProblemReportReason = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/problem-reports/models/index.js
var require_models2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/problem-reports/models/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ProblemReportReason(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/problem-reports/index.js
var require_problem_reports = __commonJS({
  "node_modules/@aries-framework/core/build/modules/problem-reports/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_errors(), exports);
    __exportStar(require_messages2(), exports);
    __exportStar(require_models2(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/connections/errors/ConnectionProblemReportError.js
var require_ConnectionProblemReportError = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/errors/ConnectionProblemReportError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionProblemReportError = void 0;
    var problem_reports_1 = require_problem_reports();
    var messages_1 = require_messages();
    var ConnectionProblemReportError = class extends problem_reports_1.ProblemReportError {
      constructor(message, { problemCode }) {
        super(message, { problemCode });
        this.message = message;
        this.problemReport = new messages_1.ConnectionProblemReportMessage({
          description: {
            en: message,
            code: problemCode
          }
        });
      }
    };
    exports.ConnectionProblemReportError = ConnectionProblemReportError;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/errors/ConnectionProblemReportReason.js
var require_ConnectionProblemReportReason = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/errors/ConnectionProblemReportReason.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionProblemReportReason = void 0;
    var ConnectionProblemReportReason;
    (function(ConnectionProblemReportReason2) {
      ConnectionProblemReportReason2["RequestNotAccepted"] = "request_not_accepted";
      ConnectionProblemReportReason2["RequestProcessingError"] = "request_processing_error";
      ConnectionProblemReportReason2["ResponseNotAccepted"] = "response_not_accepted";
      ConnectionProblemReportReason2["ResponseProcessingError"] = "response_processing_error";
    })(ConnectionProblemReportReason = exports.ConnectionProblemReportReason || (exports.ConnectionProblemReportReason = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/connections/errors/DidExchangeProblemReportError.js
var require_DidExchangeProblemReportError = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/errors/DidExchangeProblemReportError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidExchangeProblemReportError = void 0;
    var problem_reports_1 = require_problem_reports();
    var messages_1 = require_messages();
    var DidExchangeProblemReportError = class extends problem_reports_1.ProblemReportError {
      constructor(message, { problemCode }) {
        super(message, { problemCode });
        this.message = message;
        this.problemReport = new messages_1.DidExchangeProblemReportMessage({
          description: {
            en: message,
            code: problemCode
          }
        });
      }
    };
    exports.DidExchangeProblemReportError = DidExchangeProblemReportError;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/errors/DidExchangeProblemReportReason.js
var require_DidExchangeProblemReportReason = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/errors/DidExchangeProblemReportReason.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidExchangeProblemReportReason = void 0;
    var DidExchangeProblemReportReason;
    (function(DidExchangeProblemReportReason2) {
      DidExchangeProblemReportReason2["RequestNotAccepted"] = "request_not_accepted";
      DidExchangeProblemReportReason2["RequestProcessingError"] = "request_processing_error";
      DidExchangeProblemReportReason2["ResponseNotAccepted"] = "response_not_accepted";
      DidExchangeProblemReportReason2["ResponseProcessingError"] = "response_processing_error";
      DidExchangeProblemReportReason2["CompleteRejected"] = "complete_rejected";
    })(DidExchangeProblemReportReason = exports.DidExchangeProblemReportReason || (exports.DidExchangeProblemReportReason = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/connections/errors/index.js
var require_errors2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/errors/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ConnectionProblemReportError(), exports);
    __exportStar(require_ConnectionProblemReportReason(), exports);
    __exportStar(require_DidExchangeProblemReportError(), exports);
    __exportStar(require_DidExchangeProblemReportReason(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/connections/services/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/services/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertToNewDidDocument = void 0;
    var crypto_1 = require_crypto();
    var error_1 = require_error();
    var dids_1 = require_dids();
    var ed25519_1 = require_ed255192();
    var peerDidNumAlgo1_1 = require_peerDidNumAlgo1();
    var models_1 = require_models();
    function convertToNewDidDocument(didDoc) {
      const didDocumentBuilder = new dids_1.DidDocumentBuilder("");
      const oldIdNewIdMapping = {};
      didDoc.authentication.forEach((auth) => {
        const { publicKey: pk } = auth;
        if (pk.type === "Ed25519VerificationKey2018" && pk.value) {
          const ed25519VerificationMethod = convertPublicKeyToVerificationMethod(pk);
          const oldKeyId = normalizeId(pk.id);
          oldIdNewIdMapping[oldKeyId] = ed25519VerificationMethod.id;
          didDocumentBuilder.addAuthentication(ed25519VerificationMethod.id);
          if (auth instanceof models_1.EmbeddedAuthentication) {
            didDocumentBuilder.addVerificationMethod(ed25519VerificationMethod);
          }
        }
      });
      didDoc.publicKey.forEach((pk) => {
        if (pk.type === "Ed25519VerificationKey2018" && pk.value) {
          const ed25519VerificationMethod = convertPublicKeyToVerificationMethod(pk);
          const oldKeyId = normalizeId(pk.id);
          oldIdNewIdMapping[oldKeyId] = ed25519VerificationMethod.id;
          didDocumentBuilder.addVerificationMethod(ed25519VerificationMethod);
        }
      });
      didDoc.didCommServices.forEach((service) => {
        const serviceId = normalizeId(service.id);
        if (service instanceof dids_1.DidCommV1Service) {
          const recipientKeys = service.recipientKeys.map((keyId) => {
            const oldKeyId = normalizeId(keyId);
            return oldIdNewIdMapping[oldKeyId];
          });
          service = new dids_1.DidCommV1Service({
            id: serviceId,
            recipientKeys,
            serviceEndpoint: service.serviceEndpoint,
            routingKeys: service.routingKeys,
            accept: service.accept,
            priority: service.priority
          });
        } else if (service instanceof dids_1.IndyAgentService) {
          service = new dids_1.IndyAgentService({
            id: serviceId,
            recipientKeys: service.recipientKeys,
            serviceEndpoint: service.serviceEndpoint,
            routingKeys: service.routingKeys,
            priority: service.priority
          });
        }
        didDocumentBuilder.addService(service);
      });
      const didDocument = didDocumentBuilder.build();
      const peerDid = (0, peerDidNumAlgo1_1.didDocumentJsonToNumAlgo1Did)(didDocument.toJSON());
      didDocument.id = peerDid;
      return didDocument;
    }
    exports.convertToNewDidDocument = convertToNewDidDocument;
    function normalizeId(fullId) {
      if (!fullId.includes("#") && fullId.includes(";")) {
        const [, ...ids2] = fullId.split(";");
        return `#${ids2.join(";")}`;
      }
      const [, ...ids] = fullId.split("#");
      return `#${ids.length ? ids.join("#") : fullId}`;
    }
    function convertPublicKeyToVerificationMethod(publicKey) {
      if (!publicKey.value) {
        throw new error_1.AriesFrameworkError(`Public key ${publicKey.id} does not have value property`);
      }
      const publicKeyBase58 = publicKey.value;
      const ed25519Key = crypto_1.Key.fromPublicKeyBase58(publicKeyBase58, crypto_1.KeyType.Ed25519);
      return (0, ed25519_1.getEd25519VerificationMethod)({
        id: `#${publicKeyBase58.slice(0, 8)}`,
        key: ed25519Key,
        controller: "#id"
      });
    }
  }
});

// node_modules/@aries-framework/core/build/modules/connections/services/ConnectionService.js
var require_ConnectionService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/services/ConnectionService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionService = void 0;
    var rxjs_1 = require_cjs();
    var operators_1 = require_operators();
    var EventEmitter_1 = require_EventEmitter();
    var Events_1 = require_Events();
    var constants_1 = require_constants();
    var crypto_1 = require_crypto();
    var SignatureDecoratorUtils_1 = require_SignatureDecoratorUtils();
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var JsonTransformer_1 = require_JsonTransformer();
    var did_1 = require_did2();
    var dids_1 = require_dids();
    var DidDocumentRole_1 = require_DidDocumentRole();
    var helpers_1 = require_helpers();
    var peerDidNumAlgo1_1 = require_peerDidNumAlgo1();
    var repository_1 = require_repository();
    var didRecordMetadataTypes_1 = require_didRecordMetadataTypes();
    var OutOfBandRole_1 = require_OutOfBandRole();
    var OutOfBandState_1 = require_OutOfBandState();
    var ConnectionEvents_1 = require_ConnectionEvents();
    var errors_1 = require_errors2();
    var messages_1 = require_messages();
    var models_1 = require_models();
    var ConnectionRecord_1 = require_ConnectionRecord();
    var ConnectionRepository_1 = require_ConnectionRepository();
    var helpers_2 = require_helpers2();
    var ConnectionService = class ConnectionService {
      constructor(logger, connectionRepository, didRepository, didRegistrarService, eventEmitter) {
        this.connectionRepository = connectionRepository;
        this.didRepository = didRepository;
        this.didRegistrarService = didRegistrarService;
        this.eventEmitter = eventEmitter;
        this.logger = logger;
      }
      /**
       * Create a connection request message for a given out-of-band.
       *
       * @param outOfBandRecord out-of-band record for which to create a connection request
       * @param config config for creation of connection request
       * @returns outbound message containing connection request
       */
      async createRequest(agentContext, outOfBandRecord, config) {
        this.logger.debug(`Create message ${messages_1.ConnectionRequestMessage.type.messageTypeUri} start`, outOfBandRecord);
        outOfBandRecord.assertRole(OutOfBandRole_1.OutOfBandRole.Receiver);
        outOfBandRecord.assertState(OutOfBandState_1.OutOfBandState.PrepareResponse);
        const { outOfBandInvitation } = outOfBandRecord;
        const { mediatorId } = config.routing;
        const didDoc = this.createDidDoc(config.routing);
        const [invitationDid] = outOfBandInvitation.invitationDids;
        const { did: peerDid } = await this.createDid(agentContext, {
          role: DidDocumentRole_1.DidDocumentRole.Created,
          didDoc
        });
        const { label, imageUrl } = config;
        const connectionRequest = new messages_1.ConnectionRequestMessage({
          label: label !== null && label !== void 0 ? label : agentContext.config.label,
          did: didDoc.id,
          didDoc,
          imageUrl: imageUrl !== null && imageUrl !== void 0 ? imageUrl : agentContext.config.connectionImageUrl
        });
        connectionRequest.setThread({
          threadId: connectionRequest.id,
          parentThreadId: outOfBandInvitation.id
        });
        const connectionRecord = await this.createConnection(agentContext, {
          protocol: models_1.HandshakeProtocol.Connections,
          role: models_1.DidExchangeRole.Requester,
          state: models_1.DidExchangeState.InvitationReceived,
          theirLabel: outOfBandInvitation.label,
          alias: config === null || config === void 0 ? void 0 : config.alias,
          did: peerDid,
          mediatorId,
          autoAcceptConnection: config === null || config === void 0 ? void 0 : config.autoAcceptConnection,
          outOfBandId: outOfBandRecord.id,
          invitationDid,
          imageUrl: outOfBandInvitation.imageUrl,
          threadId: connectionRequest.id
        });
        await this.updateState(agentContext, connectionRecord, models_1.DidExchangeState.RequestSent);
        return {
          connectionRecord,
          message: connectionRequest
        };
      }
      async processRequest(messageContext, outOfBandRecord) {
        this.logger.debug(`Process message ${messages_1.ConnectionRequestMessage.type.messageTypeUri} start`, {
          message: messageContext.message
        });
        outOfBandRecord.assertRole(OutOfBandRole_1.OutOfBandRole.Sender);
        outOfBandRecord.assertState(OutOfBandState_1.OutOfBandState.AwaitResponse);
        const { message } = messageContext;
        if (!message.connection.didDoc) {
          throw new errors_1.ConnectionProblemReportError("Public DIDs are not supported yet", {
            problemCode: errors_1.ConnectionProblemReportReason.RequestNotAccepted
          });
        }
        const { did: peerDid } = await this.createDid(messageContext.agentContext, {
          role: DidDocumentRole_1.DidDocumentRole.Received,
          didDoc: message.connection.didDoc
        });
        const connectionRecord = await this.createConnection(messageContext.agentContext, {
          protocol: models_1.HandshakeProtocol.Connections,
          role: models_1.DidExchangeRole.Responder,
          state: models_1.DidExchangeState.RequestReceived,
          alias: outOfBandRecord.alias,
          theirLabel: message.label,
          imageUrl: message.imageUrl,
          outOfBandId: outOfBandRecord.id,
          theirDid: peerDid,
          threadId: message.threadId,
          mediatorId: outOfBandRecord.mediatorId,
          autoAcceptConnection: outOfBandRecord.autoAcceptConnection
        });
        await this.connectionRepository.update(messageContext.agentContext, connectionRecord);
        this.emitStateChangedEvent(messageContext.agentContext, connectionRecord, null);
        this.logger.debug(`Process message ${messages_1.ConnectionRequestMessage.type.messageTypeUri} end`, connectionRecord);
        return connectionRecord;
      }
      /**
       * Create a connection response message for the connection with the specified connection id.
       *
       * @param connectionRecord the connection for which to create a connection response
       * @returns outbound message containing connection response
       */
      async createResponse(agentContext, connectionRecord, outOfBandRecord, routing) {
        this.logger.debug(`Create message ${messages_1.ConnectionResponseMessage.type.messageTypeUri} start`, connectionRecord);
        connectionRecord.assertState(models_1.DidExchangeState.RequestReceived);
        connectionRecord.assertRole(models_1.DidExchangeRole.Responder);
        const didDoc = routing ? this.createDidDoc(routing) : this.createDidDocFromOutOfBandDidCommServices(outOfBandRecord.outOfBandInvitation.getInlineServices());
        const { did: peerDid } = await this.createDid(agentContext, {
          role: DidDocumentRole_1.DidDocumentRole.Created,
          didDoc
        });
        const connection = new models_1.Connection({
          did: didDoc.id,
          didDoc
        });
        const connectionJson = JsonTransformer_1.JsonTransformer.toJSON(connection);
        if (!connectionRecord.threadId) {
          throw new error_1.AriesFrameworkError(`Connection record with id ${connectionRecord.id} does not have a thread id`);
        }
        const signingKey = crypto_1.Key.fromFingerprint(outOfBandRecord.getTags().recipientKeyFingerprints[0]).publicKeyBase58;
        const connectionResponse = new messages_1.ConnectionResponseMessage({
          threadId: connectionRecord.threadId,
          connectionSig: await (0, SignatureDecoratorUtils_1.signData)(connectionJson, agentContext.wallet, signingKey)
        });
        connectionRecord.did = peerDid;
        await this.updateState(agentContext, connectionRecord, models_1.DidExchangeState.ResponseSent);
        this.logger.debug(`Create message ${messages_1.ConnectionResponseMessage.type.messageTypeUri} end`, {
          connectionRecord,
          message: connectionResponse
        });
        return {
          connectionRecord,
          message: connectionResponse
        };
      }
      /**
       * Process a received connection response message. This will not accept the connection request
       * or send a connection acknowledgement message. It will only update the existing connection record
       * with all the new information from the connection response message. Use {@link ConnectionService.createTrustPing}
       * after calling this function to create a trust ping message.
       *
       * @param messageContext the message context containing a connection response message
       * @returns updated connection record
       */
      async processResponse(messageContext, outOfBandRecord) {
        this.logger.debug(`Process message ${messages_1.ConnectionResponseMessage.type.messageTypeUri} start`, {
          message: messageContext.message
        });
        const { connection: connectionRecord, message, recipientKey, senderKey } = messageContext;
        if (!recipientKey || !senderKey) {
          throw new error_1.AriesFrameworkError("Unable to process connection request without senderKey or recipientKey");
        }
        if (!connectionRecord) {
          throw new error_1.AriesFrameworkError("No connection record in message context.");
        }
        connectionRecord.assertState(models_1.DidExchangeState.RequestSent);
        connectionRecord.assertRole(models_1.DidExchangeRole.Requester);
        let connectionJson = null;
        try {
          connectionJson = await (0, SignatureDecoratorUtils_1.unpackAndVerifySignatureDecorator)(message.connectionSig, messageContext.agentContext.wallet);
        } catch (error) {
          if (error instanceof error_1.AriesFrameworkError) {
            throw new errors_1.ConnectionProblemReportError(error.message, {
              problemCode: errors_1.ConnectionProblemReportReason.ResponseProcessingError
            });
          }
          throw error;
        }
        const connection = JsonTransformer_1.JsonTransformer.fromJSON(connectionJson, models_1.Connection);
        const signerVerkey = message.connectionSig.signer;
        const invitationKey = crypto_1.Key.fromFingerprint(outOfBandRecord.getTags().recipientKeyFingerprints[0]).publicKeyBase58;
        if (signerVerkey !== invitationKey) {
          throw new errors_1.ConnectionProblemReportError(`Connection object in connection response message is not signed with same key as recipient key in invitation expected='${invitationKey}' received='${signerVerkey}'`, { problemCode: errors_1.ConnectionProblemReportReason.ResponseNotAccepted });
        }
        if (!connection.didDoc) {
          throw new error_1.AriesFrameworkError("DID Document is missing.");
        }
        const { did: peerDid } = await this.createDid(messageContext.agentContext, {
          role: DidDocumentRole_1.DidDocumentRole.Received,
          didDoc: connection.didDoc
        });
        connectionRecord.theirDid = peerDid;
        connectionRecord.threadId = message.threadId;
        await this.updateState(messageContext.agentContext, connectionRecord, models_1.DidExchangeState.ResponseReceived);
        return connectionRecord;
      }
      /**
       * Create a trust ping message for the connection with the specified connection id.
       *
       * By default a trust ping message should elicit a response. If this is not desired the
       * `config.responseRequested` property can be set to `false`.
       *
       * @param connectionRecord the connection for which to create a trust ping message
       * @param config the config for the trust ping message
       * @returns outbound message containing trust ping message
       */
      async createTrustPing(agentContext, connectionRecord, config = {}) {
        connectionRecord.assertState([models_1.DidExchangeState.ResponseReceived, models_1.DidExchangeState.Completed]);
        const trustPing = new messages_1.TrustPingMessage(config);
        if (connectionRecord.state !== models_1.DidExchangeState.Completed) {
          await this.updateState(agentContext, connectionRecord, models_1.DidExchangeState.Completed);
        }
        return {
          connectionRecord,
          message: trustPing
        };
      }
      /**
       * Process a received ack message. This will update the state of the connection
       * to Completed if this is not already the case.
       *
       * @param messageContext the message context containing an ack message
       * @returns updated connection record
       */
      async processAck(messageContext) {
        const { connection, recipientKey } = messageContext;
        if (!connection) {
          throw new error_1.AriesFrameworkError(`Unable to process connection ack: connection for recipient key ${recipientKey === null || recipientKey === void 0 ? void 0 : recipientKey.fingerprint} not found`);
        }
        if (connection.state === models_1.DidExchangeState.ResponseSent && connection.role === models_1.DidExchangeRole.Responder) {
          await this.updateState(messageContext.agentContext, connection, models_1.DidExchangeState.Completed);
        }
        return connection;
      }
      /**
       * Process a received {@link ProblemReportMessage}.
       *
       * @param messageContext The message context containing a connection problem report message
       * @returns connection record associated with the connection problem report message
       *
       */
      async processProblemReport(messageContext) {
        var _a;
        const { message: connectionProblemReportMessage, recipientKey, senderKey } = messageContext;
        this.logger.debug(`Processing connection problem report for verkey ${recipientKey === null || recipientKey === void 0 ? void 0 : recipientKey.fingerprint}`);
        if (!recipientKey) {
          throw new error_1.AriesFrameworkError("Unable to process connection problem report without recipientKey");
        }
        const ourDidRecord = await this.didRepository.findCreatedDidByRecipientKey(messageContext.agentContext, recipientKey);
        if (!ourDidRecord) {
          throw new error_1.AriesFrameworkError(`Unable to process connection problem report: created did record for recipient key ${recipientKey.fingerprint} not found`);
        }
        const connectionRecord = await this.findByOurDid(messageContext.agentContext, ourDidRecord.did);
        if (!connectionRecord) {
          throw new error_1.AriesFrameworkError(`Unable to process connection problem report: connection for recipient key ${recipientKey.fingerprint} not found`);
        }
        const theirDidRecord = connectionRecord.theirDid && await this.didRepository.findReceivedDid(messageContext.agentContext, connectionRecord.theirDid);
        if (!theirDidRecord) {
          throw new error_1.AriesFrameworkError(`Received did record for did ${connectionRecord.theirDid} not found.`);
        }
        if (senderKey) {
          if (!((_a = theirDidRecord === null || theirDidRecord === void 0 ? void 0 : theirDidRecord.getTags().recipientKeyFingerprints) === null || _a === void 0 ? void 0 : _a.includes(senderKey.fingerprint))) {
            throw new error_1.AriesFrameworkError("Sender key doesn't match key of connection record");
          }
        }
        connectionRecord.errorMessage = `${connectionProblemReportMessage.description.code} : ${connectionProblemReportMessage.description.en}`;
        await this.update(messageContext.agentContext, connectionRecord);
        return connectionRecord;
      }
      /**
       * Assert that an inbound message either has a connection associated with it,
       * or has everything correctly set up for connection-less exchange.
       *
       * @param messageContext - the inbound message context
       * @param previousRespondence - previous sent and received message to determine if a valid service decorator is present
       */
      assertConnectionOrServiceDecorator(messageContext, { previousSentMessage, previousReceivedMessage } = {}) {
        const { connection, message } = messageContext;
        if (connection) {
          connection.assertReady();
          this.logger.debug(`Processing message with id ${message.id} and connection id ${connection.id}`, {
            type: message.type
          });
        } else {
          this.logger.debug(`Processing connection-less message with id ${message.id}`, {
            type: message.type
          });
          const recipientKey = messageContext.recipientKey && messageContext.recipientKey.publicKeyBase58;
          const senderKey = messageContext.senderKey && messageContext.senderKey.publicKeyBase58;
          if (previousSentMessage) {
            if (!recipientKey) {
              throw new error_1.AriesFrameworkError("Cannot verify service without recipientKey on incoming message (received unpacked message)");
            }
            if (!(previousSentMessage === null || previousSentMessage === void 0 ? void 0 : previousSentMessage.service) || !previousSentMessage.service.recipientKeys.includes(recipientKey)) {
              throw new error_1.AriesFrameworkError("Previously sent message ~service recipientKeys does not include current received message recipient key");
            }
          }
          if (previousReceivedMessage) {
            if (!senderKey) {
              throw new error_1.AriesFrameworkError("Cannot verify service without senderKey on incoming message (received AnonCrypt or unpacked message)");
            }
            if (!previousReceivedMessage.service || !previousReceivedMessage.service.recipientKeys.includes(senderKey)) {
              throw new error_1.AriesFrameworkError("Previously received message ~service recipientKeys does not include current received message sender key");
            }
          }
          if (!message.service && !recipientKey) {
            throw new error_1.AriesFrameworkError("Message recipientKey must have ~service decorator");
          }
        }
      }
      async updateState(agentContext, connectionRecord, newState) {
        const previousState = connectionRecord.state;
        connectionRecord.state = newState;
        await this.connectionRepository.update(agentContext, connectionRecord);
        this.emitStateChangedEvent(agentContext, connectionRecord, previousState);
      }
      emitStateChangedEvent(agentContext, connectionRecord, previousState) {
        const clonedConnection = JsonTransformer_1.JsonTransformer.clone(connectionRecord);
        this.eventEmitter.emit(agentContext, {
          type: ConnectionEvents_1.ConnectionEventTypes.ConnectionStateChanged,
          payload: {
            connectionRecord: clonedConnection,
            previousState
          }
        });
      }
      update(agentContext, connectionRecord) {
        return this.connectionRepository.update(agentContext, connectionRecord);
      }
      /**
       * Retrieve all connections records
       *
       * @returns List containing all connection records
       */
      getAll(agentContext) {
        return this.connectionRepository.getAll(agentContext);
      }
      /**
       * Retrieve a connection record by id
       *
       * @param connectionId The connection record id
       * @throws {RecordNotFoundError} If no record is found
       * @return The connection record
       *
       */
      getById(agentContext, connectionId) {
        return this.connectionRepository.getById(agentContext, connectionId);
      }
      /**
       * Find a connection record by id
       *
       * @param connectionId the connection record id
       * @returns The connection record or null if not found
       */
      findById(agentContext, connectionId) {
        return this.connectionRepository.findById(agentContext, connectionId);
      }
      /**
       * Delete a connection record by id
       *
       * @param connectionId the connection record id
       */
      async deleteById(agentContext, connectionId) {
        const connectionRecord = await this.getById(agentContext, connectionId);
        return this.connectionRepository.delete(agentContext, connectionRecord);
      }
      async findByDids(agentContext, query) {
        return this.connectionRepository.findByDids(agentContext, query);
      }
      /**
       * Retrieve a connection record by thread id
       *
       * @param threadId The thread id
       * @throws {RecordNotFoundError} If no record is found
       * @throws {RecordDuplicateError} If multiple records are found
       * @returns The connection record
       */
      async getByThreadId(agentContext, threadId) {
        return this.connectionRepository.getByThreadId(agentContext, threadId);
      }
      async getByRoleAndThreadId(agentContext, role, threadId) {
        return this.connectionRepository.getByRoleAndThreadId(agentContext, role, threadId);
      }
      async findByTheirDid(agentContext, theirDid) {
        return this.connectionRepository.findSingleByQuery(agentContext, { theirDid });
      }
      async findByOurDid(agentContext, ourDid) {
        return this.connectionRepository.findSingleByQuery(agentContext, { did: ourDid });
      }
      async findAllByOutOfBandId(agentContext, outOfBandId) {
        return this.connectionRepository.findByQuery(agentContext, { outOfBandId });
      }
      async findAllByConnectionTypes(agentContext, connectionTypes) {
        return this.connectionRepository.findByQuery(agentContext, { connectionTypes });
      }
      async findByInvitationDid(agentContext, invitationDid) {
        return this.connectionRepository.findByQuery(agentContext, { invitationDid });
      }
      async findByKeys(agentContext, { senderKey, recipientKey }) {
        const theirDidRecord = await this.didRepository.findReceivedDidByRecipientKey(agentContext, senderKey);
        if (theirDidRecord) {
          const ourDidRecord = await this.didRepository.findCreatedDidByRecipientKey(agentContext, recipientKey);
          if (ourDidRecord) {
            const connectionRecord = await this.findByDids(agentContext, {
              ourDid: ourDidRecord.did,
              theirDid: theirDidRecord.did
            });
            if (connectionRecord && connectionRecord.isReady)
              return connectionRecord;
          }
        }
        this.logger.debug(`No connection record found for encrypted message with recipient key ${recipientKey.fingerprint} and sender key ${senderKey.fingerprint}`);
        return null;
      }
      async findAllByQuery(agentContext, query) {
        return this.connectionRepository.findByQuery(agentContext, query);
      }
      async createConnection(agentContext, options) {
        const connectionRecord = new ConnectionRecord_1.ConnectionRecord(options);
        await this.connectionRepository.save(agentContext, connectionRecord);
        return connectionRecord;
      }
      async addConnectionType(agentContext, connectionRecord, type) {
        const connectionTypes = connectionRecord.connectionTypes || [];
        connectionRecord.connectionTypes = [type, ...connectionTypes];
        await this.update(agentContext, connectionRecord);
      }
      async removeConnectionType(agentContext, connectionRecord, type) {
        connectionRecord.connectionTypes = connectionRecord.connectionTypes.filter((value) => value !== type);
        await this.update(agentContext, connectionRecord);
      }
      async getConnectionTypes(connectionRecord) {
        return connectionRecord.connectionTypes || [];
      }
      async createDid(agentContext, { role, didDoc }) {
        const didDocument = (0, helpers_2.convertToNewDidDocument)(didDoc);
        const peerDid = (0, peerDidNumAlgo1_1.didDocumentJsonToNumAlgo1Did)(didDocument.toJSON());
        didDocument.id = peerDid;
        const didRecord = new repository_1.DidRecord({
          did: peerDid,
          role,
          didDocument,
          tags: {
            // We need to save the recipientKeys, so we can find the associated did
            // of a key when we receive a message from another connection.
            recipientKeyFingerprints: didDocument.recipientKeys.map((key) => key.fingerprint)
          }
        });
        didRecord.metadata.set(didRecordMetadataTypes_1.DidRecordMetadataKeys.LegacyDid, {
          unqualifiedDid: didDoc.id,
          didDocumentString: JsonTransformer_1.JsonTransformer.serialize(didDoc)
        });
        this.logger.debug("Saving DID record", {
          id: didRecord.id,
          did: didRecord.did,
          role: didRecord.role,
          tags: didRecord.getTags(),
          didDocument: "omitted..."
        });
        await this.didRepository.save(agentContext, didRecord);
        this.logger.debug("Did record created.", didRecord);
        return { did: peerDid, didDocument };
      }
      createDidDoc(routing) {
        const indyDid = (0, did_1.indyDidFromPublicKeyBase58)(routing.recipientKey.publicKeyBase58);
        const publicKey = new models_1.Ed25119Sig2018({
          id: `${indyDid}#1`,
          controller: indyDid,
          publicKeyBase58: routing.recipientKey.publicKeyBase58
        });
        const auth = new models_1.ReferencedAuthentication(publicKey, models_1.authenticationTypes.Ed25519VerificationKey2018);
        const services = routing.endpoints.map((endpoint, index) => new dids_1.IndyAgentService({
          id: `${indyDid}#IndyAgentService`,
          serviceEndpoint: endpoint,
          recipientKeys: [routing.recipientKey.publicKeyBase58],
          routingKeys: routing.routingKeys.map((key) => key.publicKeyBase58),
          // Order of endpoint determines priority
          priority: index
        }));
        return new models_1.DidDoc({
          id: indyDid,
          authentication: [auth],
          service: services,
          publicKey: [publicKey]
        });
      }
      createDidDocFromOutOfBandDidCommServices(services) {
        const [recipientDidKey] = services[0].recipientKeys;
        const recipientKey = dids_1.DidKey.fromDid(recipientDidKey).key;
        const did = (0, did_1.indyDidFromPublicKeyBase58)(recipientKey.publicKeyBase58);
        const publicKey = new models_1.Ed25119Sig2018({
          id: `${did}#1`,
          controller: did,
          publicKeyBase58: recipientKey.publicKeyBase58
        });
        const auth = new models_1.ReferencedAuthentication(publicKey, models_1.authenticationTypes.Ed25519VerificationKey2018);
        const service = services.map((service2, index) => {
          var _a;
          return new dids_1.IndyAgentService({
            id: `${did}#IndyAgentService`,
            serviceEndpoint: service2.serviceEndpoint,
            recipientKeys: [recipientKey.publicKeyBase58],
            routingKeys: (_a = service2.routingKeys) === null || _a === void 0 ? void 0 : _a.map(helpers_1.didKeyToVerkey),
            priority: index
          });
        });
        return new models_1.DidDoc({
          id: did,
          authentication: [auth],
          service,
          publicKey: [publicKey]
        });
      }
      async returnWhenIsConnected(agentContext, connectionId, timeoutMs = 2e4) {
        const isConnected = (connection2) => {
          return connection2.id === connectionId && connection2.state === models_1.DidExchangeState.Completed;
        };
        const observable = this.eventEmitter.observable(ConnectionEvents_1.ConnectionEventTypes.ConnectionStateChanged);
        const subject = new rxjs_1.ReplaySubject(1);
        observable.pipe(
          (0, Events_1.filterContextCorrelationId)(agentContext.contextCorrelationId),
          (0, operators_1.map)((e) => e.payload.connectionRecord),
          (0, operators_1.first)(isConnected),
          // Do not wait for longer than specified timeout
          (0, operators_1.timeout)(timeoutMs)
        ).subscribe(subject);
        const connection = await this.getById(agentContext, connectionId);
        if (isConnected(connection)) {
          subject.next(connection);
        }
        return (0, rxjs_1.firstValueFrom)(subject);
      }
    };
    ConnectionService = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [
        Object,
        ConnectionRepository_1.ConnectionRepository,
        repository_1.DidRepository,
        dids_1.DidRegistrarService,
        EventEmitter_1.EventEmitter
      ])
    ], ConnectionService);
    exports.ConnectionService = ConnectionService;
  }
});

// node_modules/@aries-framework/core/build/agent/models/features/Feature.js
var require_Feature = __commonJS({
  "node_modules/@aries-framework/core/build/agent/models/features/Feature.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Feature = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var error_1 = require_error();
    var JsonTransformer_1 = require_JsonTransformer();
    var Feature = class {
      constructor(props) {
        if (props) {
          this.id = props.id;
          this.type = props.type;
        }
      }
      /**
       * Combine this feature with another one, provided both are from the same type
       * and have the same id
       *
       * @param feature object to combine with this one
       * @returns a new object resulting from the combination between this and feature
       */
      combine(feature) {
        if (feature.id !== this.id) {
          throw new error_1.AriesFrameworkError("Can only combine with a feature with the same id");
        }
        const obj1 = JsonTransformer_1.JsonTransformer.toJSON(this);
        const obj2 = JsonTransformer_1.JsonTransformer.toJSON(feature);
        for (const key in obj2) {
          try {
            if (Array.isArray(obj2[key])) {
              obj1[key] = [.../* @__PURE__ */ new Set([...obj1[key], ...obj2[key]])];
            } else {
              obj1[key] = obj2[key];
            }
          } catch (e) {
            obj1[key] = obj2[key];
          }
        }
        return JsonTransformer_1.JsonTransformer.fromJSON(obj1, Feature);
      }
      toJSON() {
        return JsonTransformer_1.JsonTransformer.toJSON(this);
      }
    };
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_transformer_1.Expose)({ name: "feature-type" }),
      __metadata("design:type", String)
    ], Feature.prototype, "type", void 0);
    exports.Feature = Feature;
  }
});

// node_modules/@aries-framework/core/build/agent/models/features/FeatureQuery.js
var require_FeatureQuery = __commonJS({
  "node_modules/@aries-framework/core/build/agent/models/features/FeatureQuery.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FeatureQuery = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var FeatureQuery = class {
      constructor(options) {
        if (options) {
          this.featureType = options.featureType;
          this.match = options.match;
        }
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "feature-type" }),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], FeatureQuery.prototype, "featureType", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], FeatureQuery.prototype, "match", void 0);
    exports.FeatureQuery = FeatureQuery;
  }
});

// node_modules/@aries-framework/core/build/agent/models/features/GoalCode.js
var require_GoalCode = __commonJS({
  "node_modules/@aries-framework/core/build/agent/models/features/GoalCode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GoalCode = void 0;
    var Feature_1 = require_Feature();
    var GoalCode = class extends Feature_1.Feature {
      constructor(props) {
        super(Object.assign(Object.assign({}, props), { type: GoalCode.type }));
      }
    };
    exports.GoalCode = GoalCode;
    GoalCode.type = "goal-code";
  }
});

// node_modules/@aries-framework/core/build/agent/models/features/GovernanceFramework.js
var require_GovernanceFramework = __commonJS({
  "node_modules/@aries-framework/core/build/agent/models/features/GovernanceFramework.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GovernanceFramework = void 0;
    var Feature_1 = require_Feature();
    var GovernanceFramework = class extends Feature_1.Feature {
      constructor(props) {
        super(Object.assign(Object.assign({}, props), { type: GovernanceFramework.type }));
      }
    };
    exports.GovernanceFramework = GovernanceFramework;
    GovernanceFramework.type = "gov-fw";
  }
});

// node_modules/@aries-framework/core/build/agent/models/features/Protocol.js
var require_Protocol = __commonJS({
  "node_modules/@aries-framework/core/build/agent/models/features/Protocol.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Protocol = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var Feature_1 = require_Feature();
    var Protocol = class extends Feature_1.Feature {
      constructor(props) {
        super(Object.assign(Object.assign({}, props), { type: Protocol.type }));
        if (props) {
          this.roles = props.roles;
        }
      }
    };
    Protocol.type = "protocol";
    __decorate([
      (0, class_validator_1.IsString)({ each: true }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], Protocol.prototype, "roles", void 0);
    exports.Protocol = Protocol;
  }
});

// node_modules/@aries-framework/core/build/agent/models/features/index.js
var require_features = __commonJS({
  "node_modules/@aries-framework/core/build/agent/models/features/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_Feature(), exports);
    __exportStar(require_FeatureQuery(), exports);
    __exportStar(require_GoalCode(), exports);
    __exportStar(require_GovernanceFramework(), exports);
    __exportStar(require_Protocol(), exports);
  }
});

// node_modules/@aries-framework/core/build/agent/models/InboundMessageContext.js
var require_InboundMessageContext = __commonJS({
  "node_modules/@aries-framework/core/build/agent/models/InboundMessageContext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InboundMessageContext = void 0;
    var error_1 = require_error();
    var InboundMessageContext = class {
      constructor(message, context2) {
        this.message = message;
        this.recipientKey = context2.recipientKey;
        this.senderKey = context2.senderKey;
        this.connection = context2.connection;
        this.sessionId = context2.sessionId;
        this.agentContext = context2.agentContext;
      }
      /**
       * Assert the inbound message has a ready connection associated with it.
       *
       * @throws {AriesFrameworkError} if there is no connection or the connection is not ready
       */
      assertReadyConnection() {
        if (!this.connection) {
          throw new error_1.AriesFrameworkError(`No connection associated with incoming message ${this.message.type}`);
        }
        this.connection.assertReady();
        return this.connection;
      }
      toJSON() {
        var _a, _b;
        return {
          message: this.message,
          recipientKey: (_a = this.recipientKey) === null || _a === void 0 ? void 0 : _a.fingerprint,
          senderKey: (_b = this.senderKey) === null || _b === void 0 ? void 0 : _b.fingerprint,
          sessionId: this.sessionId,
          agentContext: this.agentContext.toJSON()
        };
      }
    };
    exports.InboundMessageContext = InboundMessageContext;
  }
});

// node_modules/@aries-framework/core/build/agent/models/OutboundMessageContext.js
var require_OutboundMessageContext = __commonJS({
  "node_modules/@aries-framework/core/build/agent/models/OutboundMessageContext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutboundMessageContext = void 0;
    var error_1 = require_error();
    var OutboundMessageContext = class {
      constructor(message, context2) {
        this.message = message;
        this.connection = context2.connection;
        this.sessionId = context2.sessionId;
        this.outOfBand = context2.outOfBand;
        this.serviceParams = context2.serviceParams;
        this.associatedRecord = context2.associatedRecord;
        this.agentContext = context2.agentContext;
      }
      /**
       * Assert the outbound message has a ready connection associated with it.
       *
       * @throws {AriesFrameworkError} if there is no connection or the connection is not ready
       */
      assertReadyConnection() {
        if (!this.connection) {
          throw new error_1.AriesFrameworkError(`No connection associated with outgoing message ${this.message.type}`);
        }
        this.connection.assertReady();
        return this.connection;
      }
      isOutboundServiceMessage() {
        var _a;
        return ((_a = this.serviceParams) === null || _a === void 0 ? void 0 : _a.service) !== void 0;
      }
      toJSON() {
        return {
          message: this.message,
          outOfBand: this.outOfBand,
          associatedRecord: this.associatedRecord,
          sessionId: this.sessionId,
          serviceParams: this.serviceParams,
          agentContext: this.agentContext.toJSON(),
          connection: this.connection
        };
      }
    };
    exports.OutboundMessageContext = OutboundMessageContext;
  }
});

// node_modules/@aries-framework/core/build/agent/models/OutboundMessageSendStatus.js
var require_OutboundMessageSendStatus = __commonJS({
  "node_modules/@aries-framework/core/build/agent/models/OutboundMessageSendStatus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutboundMessageSendStatus = void 0;
    var OutboundMessageSendStatus;
    (function(OutboundMessageSendStatus2) {
      OutboundMessageSendStatus2["SentToSession"] = "SentToSession";
      OutboundMessageSendStatus2["SentToTransport"] = "SentToTransport";
      OutboundMessageSendStatus2["QueuedForPickup"] = "QueuedForPickup";
      OutboundMessageSendStatus2["Undeliverable"] = "Undeliverable";
    })(OutboundMessageSendStatus = exports.OutboundMessageSendStatus || (exports.OutboundMessageSendStatus = {}));
  }
});

// node_modules/@aries-framework/core/build/agent/models/index.js
var require_models3 = __commonJS({
  "node_modules/@aries-framework/core/build/agent/models/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_features(), exports);
    __exportStar(require_InboundMessageContext(), exports);
    __exportStar(require_OutboundMessageContext(), exports);
    __exportStar(require_OutboundMessageSendStatus(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/connections/TrustPingEvents.js
var require_TrustPingEvents = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/TrustPingEvents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TrustPingEventTypes = void 0;
    var TrustPingEventTypes;
    (function(TrustPingEventTypes2) {
      TrustPingEventTypes2["TrustPingReceivedEvent"] = "TrustPingReceivedEvent";
      TrustPingEventTypes2["TrustPingResponseReceivedEvent"] = "TrustPingResponseReceivedEvent";
    })(TrustPingEventTypes = exports.TrustPingEventTypes || (exports.TrustPingEventTypes = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/connections/services/TrustPingService.js
var require_TrustPingService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/services/TrustPingService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TrustPingService = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var models_1 = require_models3();
    var plugins_1 = require_plugins();
    var TrustPingEvents_1 = require_TrustPingEvents();
    var messages_1 = require_messages();
    var TrustPingService = class TrustPingService {
      constructor(eventEmitter) {
        this.eventEmitter = eventEmitter;
      }
      processPing({ message, agentContext }, connection) {
        this.eventEmitter.emit(agentContext, {
          type: TrustPingEvents_1.TrustPingEventTypes.TrustPingReceivedEvent,
          payload: {
            connectionRecord: connection,
            message
          }
        });
        if (message.responseRequested) {
          const response = new messages_1.TrustPingResponseMessage({
            threadId: message.id
          });
          return new models_1.OutboundMessageContext(response, { agentContext, connection });
        }
      }
      processPingResponse(inboundMessage) {
        const { agentContext, message } = inboundMessage;
        const connection = inboundMessage.assertReadyConnection();
        this.eventEmitter.emit(agentContext, {
          type: TrustPingEvents_1.TrustPingEventTypes.TrustPingResponseReceivedEvent,
          payload: {
            connectionRecord: connection,
            message
          }
        });
      }
    };
    TrustPingService = __decorate([
      (0, plugins_1.injectable)(),
      __metadata("design:paramtypes", [EventEmitter_1.EventEmitter])
    ], TrustPingService);
    exports.TrustPingService = TrustPingService;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/services/index.js
var require_services3 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/services/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ConnectionService(), exports);
    __exportStar(require_TrustPingService(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/didcomm/types.js
var require_types4 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/didcomm/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/didcomm/util/matchingEd25519Key.js
var require_matchingEd25519Key = __commonJS({
  "node_modules/@aries-framework/core/build/modules/didcomm/util/matchingEd25519Key.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findMatchingEd25519Key = void 0;
    var crypto_1 = require_crypto();
    var dids_1 = require_dids();
    var ed25519_1 = require_ed255192();
    function findMatchingEd25519Key(x25519Key, didDocument) {
      var _a, _b, _c;
      if (x25519Key.keyType !== crypto_1.KeyType.X25519)
        return void 0;
      const verificationMethods = (_a = didDocument.verificationMethod) !== null && _a !== void 0 ? _a : [];
      const keyAgreements = (_b = didDocument.keyAgreement) !== null && _b !== void 0 ? _b : [];
      const authentications = (_c = didDocument.authentication) !== null && _c !== void 0 ? _c : [];
      const allKeyReferences = [
        ...verificationMethods,
        ...authentications.filter((keyAgreement) => typeof keyAgreement !== "string"),
        ...keyAgreements.filter((keyAgreement) => typeof keyAgreement !== "string")
      ];
      return allKeyReferences.map((keyReference) => (0, dids_1.keyReferenceToKey)(didDocument, keyReference.id)).filter((key) => (key === null || key === void 0 ? void 0 : key.keyType) === crypto_1.KeyType.Ed25519).find((keyEd25519) => {
        const keyX25519 = crypto_1.Key.fromPublicKey((0, ed25519_1.convertPublicKeyToX25519)(keyEd25519.publicKey), crypto_1.KeyType.X25519);
        return keyX25519.publicKeyBase58 === x25519Key.publicKeyBase58;
      });
    }
    exports.findMatchingEd25519Key = findMatchingEd25519Key;
  }
});

// node_modules/@aries-framework/core/build/modules/didcomm/services/DidCommDocumentService.js
var require_DidCommDocumentService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/didcomm/services/DidCommDocumentService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidCommDocumentService = void 0;
    var AgentConfig_1 = require_AgentConfig();
    var crypto_1 = require_crypto();
    var plugins_1 = require_plugins();
    var dids_1 = require_dids();
    var domain_1 = require_domain();
    var helpers_1 = require_helpers();
    var matchingEd25519Key_1 = require_matchingEd25519Key();
    var DidCommDocumentService = class DidCommDocumentService {
      constructor(agentConfig, didResolverService) {
        this.logger = agentConfig.logger;
        this.didResolverService = didResolverService;
      }
      async resolveServicesFromDid(agentContext, did) {
        var _a, _b;
        const didDocument = await this.didResolverService.resolveDidDocument(agentContext, did);
        const didCommServices = [];
        for (const didCommService of didDocument.didCommServices) {
          if (didCommService instanceof domain_1.IndyAgentService) {
            didCommServices.push({
              id: didCommService.id,
              recipientKeys: didCommService.recipientKeys.map(helpers_1.verkeyToInstanceOfKey),
              routingKeys: ((_a = didCommService.routingKeys) === null || _a === void 0 ? void 0 : _a.map(helpers_1.verkeyToInstanceOfKey)) || [],
              serviceEndpoint: didCommService.serviceEndpoint
            });
          } else if (didCommService instanceof domain_1.DidCommV1Service) {
            const routingKeys = [];
            for (const routingKey of (_b = didCommService.routingKeys) !== null && _b !== void 0 ? _b : []) {
              const routingDidDocument = await this.didResolverService.resolveDidDocument(agentContext, routingKey);
              routingKeys.push((0, domain_1.keyReferenceToKey)(routingDidDocument, routingKey));
            }
            const recipientKeys = didCommService.recipientKeys.map((recipientKeyReference) => {
              const key = (0, domain_1.keyReferenceToKey)(didDocument, recipientKeyReference);
              if (key.keyType === crypto_1.KeyType.X25519) {
                const matchingEd25519Key = (0, matchingEd25519Key_1.findMatchingEd25519Key)(key, didDocument);
                if (matchingEd25519Key)
                  return matchingEd25519Key;
              }
              return key;
            });
            didCommServices.push({
              id: didCommService.id,
              recipientKeys,
              routingKeys,
              serviceEndpoint: didCommService.serviceEndpoint
            });
          }
        }
        return didCommServices;
      }
    };
    DidCommDocumentService = __decorate([
      (0, plugins_1.injectable)(),
      __metadata("design:paramtypes", [AgentConfig_1.AgentConfig, dids_1.DidResolverService])
    ], DidCommDocumentService);
    exports.DidCommDocumentService = DidCommDocumentService;
  }
});

// node_modules/@aries-framework/core/build/modules/didcomm/services/index.js
var require_services4 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/didcomm/services/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_DidCommDocumentService(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/didcomm/index.js
var require_didcomm = __commonJS({
  "node_modules/@aries-framework/core/build/modules/didcomm/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types4(), exports);
    __exportStar(require_services4(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/routing/messages/ForwardMessage.js
var require_ForwardMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/messages/ForwardMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ForwardMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var ForwardMessage = class extends AgentMessage_1.AgentMessage {
      /**
       * Create new ForwardMessage instance.
       *
       * @param options
       */
      constructor(options) {
        super();
        this.type = ForwardMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.to = options.to;
          this.message = options.message;
        }
      }
    };
    ForwardMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/routing/1.0/forward");
    __decorate([
      (0, messageType_1.IsValidMessageType)(ForwardMessage.type),
      __metadata("design:type", Object)
    ], ForwardMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], ForwardMessage.prototype, "to", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "msg" }),
      (0, class_validator_1.IsObject)(),
      __metadata("design:type", Object)
    ], ForwardMessage.prototype, "message", void 0);
    exports.ForwardMessage = ForwardMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/messages/KeylistUpdateMessage.js
var require_KeylistUpdateMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/messages/KeylistUpdateMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeylistUpdateMessage = exports.KeylistUpdate = exports.KeylistUpdateAction = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var KeylistUpdateAction;
    (function(KeylistUpdateAction2) {
      KeylistUpdateAction2["add"] = "add";
      KeylistUpdateAction2["remove"] = "remove";
    })(KeylistUpdateAction = exports.KeylistUpdateAction || (exports.KeylistUpdateAction = {}));
    var KeylistUpdate = class {
      constructor(options) {
        if (options) {
          this.recipientKey = options.recipientKey;
          this.action = options.action;
        }
      }
    };
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_transformer_1.Expose)({ name: "recipient_key" }),
      __metadata("design:type", String)
    ], KeylistUpdate.prototype, "recipientKey", void 0);
    __decorate([
      (0, class_validator_1.IsEnum)(KeylistUpdateAction),
      __metadata("design:type", String)
    ], KeylistUpdate.prototype, "action", void 0);
    exports.KeylistUpdate = KeylistUpdate;
    var KeylistUpdateMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        super();
        this.type = KeylistUpdateMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.updates = options.updates;
        }
      }
    };
    KeylistUpdateMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/coordinate-mediation/1.0/keylist-update");
    __decorate([
      (0, messageType_1.IsValidMessageType)(KeylistUpdateMessage.type),
      __metadata("design:type", Object)
    ], KeylistUpdateMessage.prototype, "type", void 0);
    __decorate([
      (0, class_transformer_1.Type)(() => KeylistUpdate),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsInstance)(KeylistUpdate, { each: true }),
      __metadata("design:type", Array)
    ], KeylistUpdateMessage.prototype, "updates", void 0);
    exports.KeylistUpdateMessage = KeylistUpdateMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/messages/KeylistUpdateResponseMessage.js
var require_KeylistUpdateResponseMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/messages/KeylistUpdateResponseMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeylistUpdateResponseMessage = exports.KeylistUpdated = exports.KeylistUpdateResult = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var KeylistUpdateMessage_1 = require_KeylistUpdateMessage();
    var KeylistUpdateResult;
    (function(KeylistUpdateResult2) {
      KeylistUpdateResult2["ClientError"] = "client_error";
      KeylistUpdateResult2["ServerError"] = "server_error";
      KeylistUpdateResult2["NoChange"] = "no_change";
      KeylistUpdateResult2["Success"] = "success";
    })(KeylistUpdateResult = exports.KeylistUpdateResult || (exports.KeylistUpdateResult = {}));
    var KeylistUpdated = class {
      constructor(options) {
        if (options) {
          this.recipientKey = options.recipientKey;
          this.action = options.action;
          this.result = options.result;
        }
      }
    };
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_transformer_1.Expose)({ name: "recipient_key" }),
      __metadata("design:type", String)
    ], KeylistUpdated.prototype, "recipientKey", void 0);
    __decorate([
      (0, class_validator_1.IsEnum)(KeylistUpdateMessage_1.KeylistUpdateAction),
      __metadata("design:type", String)
    ], KeylistUpdated.prototype, "action", void 0);
    __decorate([
      (0, class_validator_1.IsEnum)(KeylistUpdateResult),
      __metadata("design:type", String)
    ], KeylistUpdated.prototype, "result", void 0);
    exports.KeylistUpdated = KeylistUpdated;
    var KeylistUpdateResponseMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        super();
        this.type = KeylistUpdateResponseMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.updated = options.keylist;
          this.setThread({
            threadId: options.threadId
          });
        }
      }
    };
    KeylistUpdateResponseMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/coordinate-mediation/1.0/keylist-update-response");
    __decorate([
      (0, messageType_1.IsValidMessageType)(KeylistUpdateResponseMessage.type),
      __metadata("design:type", Object)
    ], KeylistUpdateResponseMessage.prototype, "type", void 0);
    __decorate([
      (0, class_transformer_1.Type)(() => KeylistUpdated),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsInstance)(KeylistUpdated, { each: true }),
      __metadata("design:type", Array)
    ], KeylistUpdateResponseMessage.prototype, "updated", void 0);
    exports.KeylistUpdateResponseMessage = KeylistUpdateResponseMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/messages/MediationGrantMessage.js
var require_MediationGrantMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/messages/MediationGrantMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MediationGrantMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var MediationGrantMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a;
        super();
        this.type = MediationGrantMessage.type.messageTypeUri;
        if (options) {
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.endpoint = options.endpoint;
          this.routingKeys = options.routingKeys;
          this.setThread({
            threadId: options.threadId
          });
        }
      }
    };
    MediationGrantMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/coordinate-mediation/1.0/mediate-grant");
    __decorate([
      (0, messageType_1.IsValidMessageType)(MediationGrantMessage.type),
      __metadata("design:type", Object)
    ], MediationGrantMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsNotEmpty)(),
      (0, class_validator_1.IsArray)(),
      (0, class_transformer_1.Expose)({ name: "routing_keys" }),
      __metadata("design:type", Array)
    ], MediationGrantMessage.prototype, "routingKeys", void 0);
    __decorate([
      (0, class_validator_1.IsNotEmpty)(),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], MediationGrantMessage.prototype, "endpoint", void 0);
    exports.MediationGrantMessage = MediationGrantMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/messages/MediationDenyMessage.js
var require_MediationDenyMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/messages/MediationDenyMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MediationDenyMessage = void 0;
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var MediationDenyMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        super();
        this.type = MediationDenyMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id;
        }
      }
    };
    MediationDenyMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/coordinate-mediation/1.0/mediate-deny");
    __decorate([
      (0, messageType_1.IsValidMessageType)(MediationDenyMessage.type),
      __metadata("design:type", Object)
    ], MediationDenyMessage.prototype, "type", void 0);
    exports.MediationDenyMessage = MediationDenyMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/messages/MediationRequestMessage.js
var require_MediationRequestMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/messages/MediationRequestMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MediationRequestMessage = void 0;
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var MediationRequestMessage = class extends AgentMessage_1.AgentMessage {
      /**
       * Create new BasicMessage instance.
       * sentTime will be assigned to new Date if not passed, id will be assigned to uuid/v4 if not passed
       * @param options
       */
      constructor(options) {
        super();
        this.type = MediationRequestMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.addLocale(options.locale || "en");
        }
      }
    };
    MediationRequestMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/coordinate-mediation/1.0/mediate-request");
    __decorate([
      (0, messageType_1.IsValidMessageType)(MediationRequestMessage.type),
      __metadata("design:type", Object)
    ], MediationRequestMessage.prototype, "type", void 0);
    exports.MediationRequestMessage = MediationRequestMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/messages/index.js
var require_messages3 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/messages/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ForwardMessage(), exports);
    __exportStar(require_KeylistUpdateMessage(), exports);
    __exportStar(require_KeylistUpdateResponseMessage(), exports);
    __exportStar(require_MediationGrantMessage(), exports);
    __exportStar(require_MediationDenyMessage(), exports);
    __exportStar(require_MediationRequestMessage(), exports);
  }
});

// node_modules/@aries-framework/core/build/agent/EnvelopeService.js
var require_EnvelopeService = __commonJS({
  "node_modules/@aries-framework/core/build/agent/EnvelopeService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EnvelopeService = void 0;
    var constants_1 = require_constants();
    var crypto_1 = require_crypto();
    var messages_1 = require_messages3();
    var plugins_1 = require_plugins();
    var EnvelopeService = class EnvelopeService {
      constructor(logger) {
        this.logger = logger;
      }
      async packMessage(agentContext, payload, keys) {
        const { recipientKeys, routingKeys, senderKey } = keys;
        let recipientKeysBase58 = recipientKeys.map((key) => key.publicKeyBase58);
        const routingKeysBase58 = routingKeys.map((key) => key.publicKeyBase58);
        const senderKeyBase58 = senderKey && senderKey.publicKeyBase58;
        const message = payload.toJSON({ useLegacyDidSovPrefix: agentContext.config.useLegacyDidSovPrefix });
        this.logger.debug(`Pack outbound message ${message["@type"]}`);
        let encryptedMessage = await agentContext.wallet.pack(message, recipientKeysBase58, senderKeyBase58 !== null && senderKeyBase58 !== void 0 ? senderKeyBase58 : void 0);
        for (const routingKeyBase58 of routingKeysBase58) {
          const forwardMessage = new messages_1.ForwardMessage({
            // Forward to first recipient key
            to: recipientKeysBase58[0],
            message: encryptedMessage
          });
          recipientKeysBase58 = [routingKeyBase58];
          this.logger.debug("Forward message created", forwardMessage);
          const forwardJson = forwardMessage.toJSON({ useLegacyDidSovPrefix: agentContext.config.useLegacyDidSovPrefix });
          encryptedMessage = await agentContext.wallet.pack(forwardJson, [routingKeyBase58], void 0);
        }
        return encryptedMessage;
      }
      async unpackMessage(agentContext, encryptedMessage) {
        const decryptedMessage = await agentContext.wallet.unpack(encryptedMessage);
        const { recipientKey, senderKey, plaintextMessage } = decryptedMessage;
        return {
          recipientKey: recipientKey ? crypto_1.Key.fromPublicKeyBase58(recipientKey, crypto_1.KeyType.Ed25519) : void 0,
          senderKey: senderKey ? crypto_1.Key.fromPublicKeyBase58(senderKey, crypto_1.KeyType.Ed25519) : void 0,
          plaintextMessage
        };
      }
    };
    EnvelopeService = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [Object])
    ], EnvelopeService);
    exports.EnvelopeService = EnvelopeService;
  }
});

// node_modules/@aries-framework/core/build/agent/TransportService.js
var require_TransportService = __commonJS({
  "node_modules/@aries-framework/core/build/agent/TransportService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TransportService = void 0;
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var TransportService = class TransportService {
      constructor() {
        this.transportSessionTable = {};
      }
      saveSession(session) {
        this.transportSessionTable[session.id] = session;
      }
      findSessionByConnectionId(connectionId) {
        return Object.values(this.transportSessionTable).find((session) => {
          var _a;
          return ((_a = session === null || session === void 0 ? void 0 : session.connection) === null || _a === void 0 ? void 0 : _a.id) === connectionId;
        });
      }
      hasInboundEndpoint(didDocument) {
        var _a;
        return Boolean((_a = didDocument.service) === null || _a === void 0 ? void 0 : _a.find((s) => s.serviceEndpoint !== constants_1.DID_COMM_TRANSPORT_QUEUE));
      }
      findSessionById(sessionId) {
        return this.transportSessionTable[sessionId];
      }
      removeSession(session) {
        delete this.transportSessionTable[session.id];
      }
    };
    TransportService = __decorate([
      (0, plugins_1.injectable)()
    ], TransportService);
    exports.TransportService = TransportService;
  }
});

// node_modules/@aries-framework/core/build/agent/MessageSender.js
var require_MessageSender = __commonJS({
  "node_modules/@aries-framework/core/build/agent/MessageSender.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var __asyncValues = exports && exports.__asyncValues || function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isDidCommTransportQueue = exports.MessageSender = void 0;
    var constants_1 = require_constants();
    var TransportDecorator_1 = require_TransportDecorator();
    var error_1 = require_error();
    var didcomm_1 = require_didcomm();
    var key_type_1 = require_key_type();
    var helpers_1 = require_helpers();
    var DidResolverService_1 = require_DidResolverService();
    var plugins_1 = require_plugins();
    var MessageValidator_1 = require_MessageValidator();
    var uri_1 = require_uri();
    var EnvelopeService_1 = require_EnvelopeService();
    var EventEmitter_1 = require_EventEmitter();
    var Events_1 = require_Events();
    var TransportService_1 = require_TransportService();
    var models_1 = require_models3();
    var MessageSender = class MessageSender {
      constructor(envelopeService, transportService, messageRepository, logger, didResolverService, didCommDocumentService, eventEmitter) {
        this.outboundTransports = [];
        this.envelopeService = envelopeService;
        this.transportService = transportService;
        this.messageRepository = messageRepository;
        this.logger = logger;
        this.didResolverService = didResolverService;
        this.didCommDocumentService = didCommDocumentService;
        this.eventEmitter = eventEmitter;
        this.outboundTransports = [];
      }
      registerOutboundTransport(outboundTransport) {
        this.outboundTransports.push(outboundTransport);
      }
      async packMessage(agentContext, { keys, message, endpoint }) {
        const encryptedMessage = await this.envelopeService.packMessage(agentContext, message, keys);
        return {
          payload: encryptedMessage,
          responseRequested: message.hasAnyReturnRoute(),
          endpoint
        };
      }
      async sendMessageToSession(agentContext, session, message) {
        this.logger.debug(`Existing ${session.type} transport session has been found.`);
        if (!session.keys) {
          throw new error_1.AriesFrameworkError(`There are no keys for the given ${session.type} transport session.`);
        }
        const encryptedMessage = await this.envelopeService.packMessage(agentContext, message, session.keys);
        await session.send(encryptedMessage);
      }
      async sendPackage(agentContext, { connection, encryptedMessage, options }) {
        var _a, e_1, _b, _c;
        var _d;
        const errors = [];
        const session = this.transportService.findSessionByConnectionId(connection.id);
        if ((_d = session === null || session === void 0 ? void 0 : session.inboundMessage) === null || _d === void 0 ? void 0 : _d.hasReturnRouting()) {
          try {
            await session.send(encryptedMessage);
            return;
          } catch (error) {
            errors.push(error);
            this.logger.debug(`Sending packed message via session failed with error: ${error.message}.`, error);
          }
        }
        const { services, queueService } = await this.retrieveServicesByConnection(agentContext, connection, options === null || options === void 0 ? void 0 : options.transportPriority);
        if (this.outboundTransports.length === 0 && !queueService) {
          throw new error_1.AriesFrameworkError("Agent has no outbound transport!");
        }
        try {
          for (var _e = true, services_1 = __asyncValues(services), services_1_1; services_1_1 = await services_1.next(), _a = services_1_1.done, !_a; ) {
            _c = services_1_1.value;
            _e = false;
            try {
              const service = _c;
              this.logger.debug(`Sending outbound message to service:`, { service });
              try {
                const protocolScheme = (0, uri_1.getProtocolScheme)(service.serviceEndpoint);
                for (const transport of this.outboundTransports) {
                  if (transport.supportedSchemes.includes(protocolScheme)) {
                    await transport.sendMessage({
                      payload: encryptedMessage,
                      endpoint: service.serviceEndpoint,
                      connectionId: connection.id
                    });
                    break;
                  }
                }
                return;
              } catch (error) {
                this.logger.debug(`Sending outbound message to service with id ${service.id} failed with the following error:`, {
                  message: error.message,
                  error
                });
              }
            } finally {
              _e = true;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_e && !_a && (_b = services_1.return))
              await _b.call(services_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        if (queueService) {
          this.logger.debug(`Queue packed message for connection ${connection.id} (${connection.theirLabel})`);
          await this.messageRepository.add(connection.id, encryptedMessage);
          return;
        }
        this.logger.error(`Message is undeliverable to connection ${connection.id} (${connection.theirLabel})`, {
          message: encryptedMessage,
          errors,
          connection
        });
        throw new error_1.AriesFrameworkError(`Message is undeliverable to connection ${connection.id} (${connection.theirLabel})`);
      }
      async sendMessage(outboundMessageContext, options) {
        var _a, e_2, _b, _c;
        var _d, _e;
        const { agentContext, connection, outOfBand, sessionId, message } = outboundMessageContext;
        const errors = [];
        if (!connection) {
          this.logger.error("Outbound message has no associated connection");
          this.emitMessageSentEvent(outboundMessageContext, models_1.OutboundMessageSendStatus.Undeliverable);
          throw new error_1.MessageSendingError("Outbound message has no associated connection", {
            outboundMessageContext
          });
        }
        this.logger.debug("Send outbound message", {
          message,
          connectionId: connection.id
        });
        let session;
        if (sessionId) {
          session = this.transportService.findSessionById(sessionId);
        }
        if (!session) {
          session = this.transportService.findSessionByConnectionId(connection.id);
        }
        if ((_d = session === null || session === void 0 ? void 0 : session.inboundMessage) === null || _d === void 0 ? void 0 : _d.hasReturnRouting(message.threadId)) {
          this.logger.debug(`Found session with return routing for message '${message.id}' (connection '${connection.id}'`);
          try {
            await this.sendMessageToSession(agentContext, session, message);
            this.emitMessageSentEvent(outboundMessageContext, models_1.OutboundMessageSendStatus.SentToSession);
            return;
          } catch (error) {
            errors.push(error);
            this.logger.debug(`Sending an outbound message via session failed with error: ${error.message}.`, error);
          }
        }
        let services = [];
        let queueService;
        try {
          ;
          ({ services, queueService } = await this.retrieveServicesByConnection(agentContext, connection, options === null || options === void 0 ? void 0 : options.transportPriority, outOfBand));
        } catch (error) {
          this.logger.error(`Unable to retrieve services for connection '${connection.id}`);
          this.emitMessageSentEvent(outboundMessageContext, models_1.OutboundMessageSendStatus.Undeliverable);
          throw new error_1.MessageSendingError(`Unable to retrieve services for connection '${connection.id}`, {
            outboundMessageContext,
            cause: error
          });
        }
        if (!connection.did) {
          this.logger.error(`Unable to send message using connection '${connection.id}' that doesn't have a did`);
          this.emitMessageSentEvent(outboundMessageContext, models_1.OutboundMessageSendStatus.Undeliverable);
          throw new error_1.MessageSendingError(`Unable to send message using connection '${connection.id}' that doesn't have a did`, { outboundMessageContext });
        }
        let ourDidDocument;
        try {
          ourDidDocument = await this.didResolverService.resolveDidDocument(agentContext, connection.did);
        } catch (error) {
          this.logger.error(`Unable to resolve DID Document for '${connection.did}`);
          this.emitMessageSentEvent(outboundMessageContext, models_1.OutboundMessageSendStatus.Undeliverable);
          throw new error_1.MessageSendingError(`Unable to resolve DID Document for '${connection.did}`, {
            outboundMessageContext,
            cause: error
          });
        }
        const ourAuthenticationKeys = getAuthenticationKeys(ourDidDocument);
        const [firstOurAuthenticationKey] = ourAuthenticationKeys;
        const shouldAddReturnRoute = ((_e = message.transport) === null || _e === void 0 ? void 0 : _e.returnRoute) === void 0 && !this.transportService.hasInboundEndpoint(ourDidDocument);
        try {
          for (var _f = true, services_2 = __asyncValues(services), services_2_1; services_2_1 = await services_2.next(), _a = services_2_1.done, !_a; ) {
            _c = services_2_1.value;
            _f = false;
            try {
              const service = _c;
              try {
                await this.sendToService(new models_1.OutboundMessageContext(message, {
                  agentContext,
                  serviceParams: {
                    service,
                    senderKey: firstOurAuthenticationKey,
                    returnRoute: shouldAddReturnRoute
                  },
                  connection
                }));
                this.emitMessageSentEvent(outboundMessageContext, models_1.OutboundMessageSendStatus.SentToTransport);
                return;
              } catch (error) {
                errors.push(error);
                this.logger.debug(`Sending outbound message to service with id ${service.id} failed with the following error:`, {
                  message: error.message,
                  error
                });
              }
            } finally {
              _f = true;
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (!_f && !_a && (_b = services_2.return))
              await _b.call(services_2);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
        if (queueService) {
          this.logger.debug(`Queue message for connection ${connection.id} (${connection.theirLabel})`);
          const keys = {
            recipientKeys: queueService.recipientKeys,
            routingKeys: queueService.routingKeys,
            senderKey: firstOurAuthenticationKey
          };
          const encryptedMessage = await this.envelopeService.packMessage(agentContext, message, keys);
          await this.messageRepository.add(connection.id, encryptedMessage);
          this.emitMessageSentEvent(outboundMessageContext, models_1.OutboundMessageSendStatus.QueuedForPickup);
          return;
        }
        this.logger.error(`Message is undeliverable to connection ${connection.id} (${connection.theirLabel})`, {
          message,
          errors,
          connection
        });
        this.emitMessageSentEvent(outboundMessageContext, models_1.OutboundMessageSendStatus.Undeliverable);
        throw new error_1.MessageSendingError(`Message is undeliverable to connection ${connection.id} (${connection.theirLabel})`, { outboundMessageContext });
      }
      async sendMessageToService(outboundMessageContext) {
        var _a, _b;
        try {
          await this.sendToService(outboundMessageContext);
          this.emitMessageSentEvent(outboundMessageContext, models_1.OutboundMessageSendStatus.SentToTransport);
        } catch (error) {
          this.logger.error(`Message is undeliverable to service with id ${(_a = outboundMessageContext.serviceParams) === null || _a === void 0 ? void 0 : _a.service.id}: ${error.message}`, {
            message: outboundMessageContext.message,
            error
          });
          this.emitMessageSentEvent(outboundMessageContext, models_1.OutboundMessageSendStatus.Undeliverable);
          throw new error_1.MessageSendingError(`Message is undeliverable to service with id ${(_b = outboundMessageContext.serviceParams) === null || _b === void 0 ? void 0 : _b.service.id}: ${error.message}`, { outboundMessageContext });
        }
      }
      async sendToService(outboundMessageContext) {
        const { agentContext, message, serviceParams, connection } = outboundMessageContext;
        if (!serviceParams) {
          throw new error_1.AriesFrameworkError("No service parameters found in outbound message context");
        }
        const { service, senderKey, returnRoute } = serviceParams;
        if (this.outboundTransports.length === 0) {
          throw new error_1.AriesFrameworkError("Agent has no outbound transport!");
        }
        this.logger.debug(`Sending outbound message to service:`, {
          messageId: message.id,
          service: Object.assign(Object.assign({}, service), { recipientKeys: "omitted...", routingKeys: "omitted..." })
        });
        const keys = {
          recipientKeys: service.recipientKeys,
          routingKeys: service.routingKeys,
          senderKey
        };
        if (returnRoute) {
          message.setReturnRouting(TransportDecorator_1.ReturnRouteTypes.all);
        }
        try {
          MessageValidator_1.MessageValidator.validateSync(message);
        } catch (error) {
          this.logger.error(`Aborting sending outbound message ${message.type} to ${service.serviceEndpoint}. Message validation failed`, {
            errors: error,
            message: message.toJSON()
          });
          throw error;
        }
        const outboundPackage = await this.packMessage(agentContext, { message, keys, endpoint: service.serviceEndpoint });
        outboundPackage.endpoint = service.serviceEndpoint;
        outboundPackage.connectionId = connection === null || connection === void 0 ? void 0 : connection.id;
        for (const transport of this.outboundTransports) {
          const protocolScheme = (0, uri_1.getProtocolScheme)(service.serviceEndpoint);
          if (!protocolScheme) {
            this.logger.warn("Service does not have valid protocolScheme.");
          } else if (transport.supportedSchemes.includes(protocolScheme)) {
            await transport.sendMessage(outboundPackage);
            return;
          }
        }
        throw new error_1.MessageSendingError(`Unable to send message to service: ${service.serviceEndpoint}`, {
          outboundMessageContext
        });
      }
      async retrieveServicesByConnection(agentContext, connection, transportPriority, outOfBand) {
        var _a;
        this.logger.debug(`Retrieving services for connection '${connection.id}' (${connection.theirLabel})`, {
          transportPriority,
          connection
        });
        let didCommServices = [];
        if (connection.theirDid) {
          this.logger.debug(`Resolving services for connection theirDid ${connection.theirDid}.`);
          didCommServices = await this.didCommDocumentService.resolveServicesFromDid(agentContext, connection.theirDid);
        } else if (outOfBand) {
          this.logger.debug(`Resolving services from out-of-band record ${outOfBand.id}.`);
          if (connection.isRequester) {
            for (const service of outOfBand.outOfBandInvitation.getServices()) {
              if (typeof service === "string") {
                this.logger.debug(`Resolving services for did ${service}.`);
                didCommServices.push(...await this.didCommDocumentService.resolveServicesFromDid(agentContext, service));
              } else {
                didCommServices.push({
                  id: service.id,
                  recipientKeys: service.recipientKeys.map(helpers_1.didKeyToInstanceOfKey),
                  routingKeys: ((_a = service.routingKeys) === null || _a === void 0 ? void 0 : _a.map(helpers_1.didKeyToInstanceOfKey)) || [],
                  serviceEndpoint: service.serviceEndpoint
                });
              }
            }
          }
        }
        let services = didCommServices.filter((s) => !isDidCommTransportQueue(s.serviceEndpoint));
        const queueService = didCommServices.find((s) => isDidCommTransportQueue(s.serviceEndpoint));
        if (transportPriority === null || transportPriority === void 0 ? void 0 : transportPriority.restrictive) {
          services = services.filter((service) => {
            const serviceSchema = (0, uri_1.getProtocolScheme)(service.serviceEndpoint);
            return transportPriority.schemes.includes(serviceSchema);
          });
        }
        if (transportPriority === null || transportPriority === void 0 ? void 0 : transportPriority.schemes) {
          services = services.sort(function(a, b) {
            const aScheme = (0, uri_1.getProtocolScheme)(a.serviceEndpoint);
            const bScheme = (0, uri_1.getProtocolScheme)(b.serviceEndpoint);
            return (transportPriority === null || transportPriority === void 0 ? void 0 : transportPriority.schemes.indexOf(aScheme)) - (transportPriority === null || transportPriority === void 0 ? void 0 : transportPriority.schemes.indexOf(bScheme));
          });
        }
        this.logger.debug(`Retrieved ${services.length} services for message to connection '${connection.id}'(${connection.theirLabel})'`, { hasQueueService: queueService !== void 0 });
        return { services, queueService };
      }
      emitMessageSentEvent(outboundMessageContext, status) {
        const { agentContext } = outboundMessageContext;
        this.eventEmitter.emit(agentContext, {
          type: Events_1.AgentEventTypes.AgentMessageSent,
          payload: {
            message: outboundMessageContext,
            status
          }
        });
      }
    };
    MessageSender = __decorate([
      (0, plugins_1.injectable)(),
      __param(2, (0, plugins_1.inject)(constants_1.InjectionSymbols.MessageRepository)),
      __param(3, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [
        EnvelopeService_1.EnvelopeService,
        TransportService_1.TransportService,
        Object,
        Object,
        DidResolverService_1.DidResolverService,
        didcomm_1.DidCommDocumentService,
        EventEmitter_1.EventEmitter
      ])
    ], MessageSender);
    exports.MessageSender = MessageSender;
    function isDidCommTransportQueue(serviceEndpoint) {
      return serviceEndpoint === constants_1.DID_COMM_TRANSPORT_QUEUE;
    }
    exports.isDidCommTransportQueue = isDidCommTransportQueue;
    function getAuthenticationKeys(didDocument) {
      var _a, _b;
      return (_b = (_a = didDocument.authentication) === null || _a === void 0 ? void 0 : _a.map((authentication) => {
        const verificationMethod = typeof authentication === "string" ? didDocument.dereferenceVerificationMethod(authentication) : authentication;
        const { getKeyFromVerificationMethod } = (0, key_type_1.getKeyDidMappingByVerificationMethod)(verificationMethod);
        const key = getKeyFromVerificationMethod(verificationMethod);
        return key;
      })) !== null && _b !== void 0 ? _b : [];
    }
  }
});

// node_modules/@aries-framework/core/build/agent/Dispatcher.js
var require_Dispatcher = __commonJS({
  "node_modules/@aries-framework/core/build/agent/Dispatcher.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Dispatcher = void 0;
    var constants_1 = require_constants();
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var plugins_1 = require_plugins();
    var ProblemReportMessage_1 = require_ProblemReportMessage();
    var EventEmitter_1 = require_EventEmitter();
    var Events_1 = require_Events();
    var MessageHandlerRegistry_1 = require_MessageHandlerRegistry();
    var MessageSender_1 = require_MessageSender();
    var models_1 = require_models3();
    var Dispatcher = class Dispatcher {
      constructor(messageSender, eventEmitter, messageHandlerRegistry, logger) {
        this.messageSender = messageSender;
        this.eventEmitter = eventEmitter;
        this.messageHandlerRegistry = messageHandlerRegistry;
        this.logger = logger;
      }
      /**
       * @deprecated Use {@link MessageHandlerRegistry.registerMessageHandler} directly
       */
      registerMessageHandler(messageHandler) {
        this.messageHandlerRegistry.registerMessageHandler(messageHandler);
      }
      async dispatch(messageContext) {
        const { agentContext, connection, senderKey, recipientKey, message } = messageContext;
        const messageHandler = this.messageHandlerRegistry.getHandlerForMessageType(message.type);
        if (!messageHandler) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`No handler for message type "${message.type}" found`);
        }
        let outboundMessage;
        try {
          outboundMessage = await messageHandler.handle(messageContext);
        } catch (error) {
          const problemReportMessage = error.problemReport;
          if (problemReportMessage instanceof ProblemReportMessage_1.ProblemReportMessage && messageContext.connection) {
            problemReportMessage.setThread({
              threadId: message.threadId
            });
            outboundMessage = new models_1.OutboundMessageContext(problemReportMessage, {
              agentContext,
              connection: messageContext.connection
            });
          } else {
            this.logger.error(`Error handling message with type ${message.type}`, {
              message: message.toJSON(),
              error,
              senderKey: senderKey === null || senderKey === void 0 ? void 0 : senderKey.fingerprint,
              recipientKey: recipientKey === null || recipientKey === void 0 ? void 0 : recipientKey.fingerprint,
              connectionId: connection === null || connection === void 0 ? void 0 : connection.id
            });
            throw error;
          }
        }
        if (outboundMessage) {
          if (outboundMessage.isOutboundServiceMessage()) {
            await this.messageSender.sendMessageToService(outboundMessage);
          } else {
            outboundMessage.sessionId = messageContext.sessionId;
            await this.messageSender.sendMessage(outboundMessage);
          }
        }
        this.eventEmitter.emit(agentContext, {
          type: Events_1.AgentEventTypes.AgentMessageProcessed,
          payload: {
            message,
            connection
          }
        });
      }
    };
    Dispatcher = __decorate([
      (0, plugins_1.injectable)(),
      __param(3, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [
        MessageSender_1.MessageSender,
        EventEmitter_1.EventEmitter,
        MessageHandlerRegistry_1.MessageHandlerRegistry,
        Object
      ])
    ], Dispatcher);
    exports.Dispatcher = Dispatcher;
  }
});

// node_modules/@aries-framework/core/build/modules/oob/domain/OutOfBandEvents.js
var require_OutOfBandEvents = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/domain/OutOfBandEvents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutOfBandEventTypes = void 0;
    var OutOfBandEventTypes;
    (function(OutOfBandEventTypes2) {
      OutOfBandEventTypes2["OutOfBandStateChanged"] = "OutOfBandStateChanged";
      OutOfBandEventTypes2["HandshakeReused"] = "HandshakeReused";
    })(OutOfBandEventTypes = exports.OutOfBandEventTypes || (exports.OutOfBandEventTypes = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/oob/domain/OutOfBandDidCommService.js
var require_OutOfBandDidCommService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/domain/OutOfBandDidCommService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutOfBandDidCommService = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var dids_1 = require_dids();
    var OutOfBandDidCommService = class extends dids_1.DidDocumentService {
      constructor(options) {
        super(Object.assign(Object.assign({}, options), { type: OutOfBandDidCommService.type }));
        if (options) {
          this.recipientKeys = options.recipientKeys;
          this.routingKeys = options.routingKeys;
          this.accept = options.accept;
        }
      }
    };
    OutOfBandDidCommService.type = "did-communication";
    __decorate([
      (0, class_validator_1.ArrayNotEmpty)(),
      IsDidKeyString({ each: true }),
      __metadata("design:type", Array)
    ], OutOfBandDidCommService.prototype, "recipientKeys", void 0);
    __decorate([
      IsDidKeyString({ each: true }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], OutOfBandDidCommService.prototype, "routingKeys", void 0);
    __decorate([
      (0, class_validator_1.IsString)({ each: true }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], OutOfBandDidCommService.prototype, "accept", void 0);
    exports.OutOfBandDidCommService = OutOfBandDidCommService;
    function IsDidKeyString(validationOptions) {
      return (0, class_validator_1.ValidateBy)({
        name: "isDidKeyString",
        validator: {
          validate: (value) => (0, class_validator_1.isString)(value) && value.startsWith("did:key:"),
          defaultMessage: (0, class_validator_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a did:key string", validationOptions)
        }
      }, validationOptions);
    }
  }
});

// node_modules/@aries-framework/core/build/modules/oob/messages/OutOfBandInvitation.js
var require_OutOfBandInvitation = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/messages/OutOfBandInvitation.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutOfBandInvitation = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var query_string_1 = require_query_string();
    var AgentMessage_1 = require_AgentMessage();
    var Attachment_1 = require_Attachment();
    var error_1 = require_error();
    var JsonEncoder_1 = require_JsonEncoder();
    var JsonTransformer_1 = require_JsonTransformer();
    var messageType_1 = require_messageType();
    var validators_1 = require_validators();
    var peerDidNumAlgo2_1 = require_peerDidNumAlgo2();
    var OutOfBandDidCommService_1 = require_OutOfBandDidCommService();
    var OutOfBandInvitation = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a;
        super();
        this.type = OutOfBandInvitation.type.messageTypeUri;
        if (options) {
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.label = options.label;
          this.goalCode = options.goalCode;
          this.goal = options.goal;
          this.accept = options.accept;
          this.handshakeProtocols = options.handshakeProtocols;
          this.services = options.services;
          this.imageUrl = options.imageUrl;
          this.appendedAttachments = options.appendedAttachments;
        }
      }
      addRequest(message) {
        if (!this.requests)
          this.requests = [];
        const requestAttachment = new Attachment_1.Attachment({
          id: this.generateId(),
          mimeType: "application/json",
          data: new Attachment_1.AttachmentData({
            base64: JsonEncoder_1.JsonEncoder.toBase64(message.toJSON())
          })
        });
        this.requests.push(requestAttachment);
      }
      getRequests() {
        var _a;
        return (_a = this.requests) === null || _a === void 0 ? void 0 : _a.map((request) => request.getDataAsJson());
      }
      toUrl({ domain }) {
        const invitationJson = this.toJSON();
        const encodedInvitation = JsonEncoder_1.JsonEncoder.toBase64URL(invitationJson);
        const invitationUrl = `${domain}?oob=${encodedInvitation}`;
        return invitationUrl;
      }
      static fromUrl(invitationUrl) {
        const parsedUrl = (0, query_string_1.parseUrl)(invitationUrl).query;
        const encodedInvitation = parsedUrl["oob"];
        if (typeof encodedInvitation === "string") {
          const invitationJson = JsonEncoder_1.JsonEncoder.fromBase64(encodedInvitation);
          const invitation = this.fromJson(invitationJson);
          return invitation;
        } else {
          throw new error_1.AriesFrameworkError("InvitationUrl is invalid. It needs to contain one, and only one, of the following parameters; `oob`");
        }
      }
      static fromJson(json) {
        return JsonTransformer_1.JsonTransformer.fromJSON(json, OutOfBandInvitation);
      }
      get invitationDids() {
        const dids = this.getServices().map((didOrService) => {
          if (typeof didOrService === "string") {
            return didOrService;
          }
          return (0, peerDidNumAlgo2_1.outOfBandServiceToNumAlgo2Did)(didOrService);
        });
        return dids;
      }
      // shorthand for services without the need to deal with the String DIDs
      getServices() {
        return this.services.map((service) => {
          if (service instanceof String)
            return service.toString();
          return service;
        });
      }
      getDidServices() {
        return this.getServices().filter((service) => typeof service === "string");
      }
      getInlineServices() {
        return this.getServices().filter((service) => typeof service !== "string");
      }
    };
    OutOfBandInvitation.type = (0, messageType_1.parseMessageType)("https://didcomm.org/out-of-band/1.1/invitation");
    __decorate([
      (0, class_transformer_1.Transform)(({ value }) => (0, messageType_1.replaceLegacyDidSovPrefix)(value), {
        toClassOnly: true
      }),
      (0, messageType_1.IsValidMessageType)(OutOfBandInvitation.type),
      __metadata("design:type", Object)
    ], OutOfBandInvitation.prototype, "type", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "goal_code" }),
      __metadata("design:type", String)
    ], OutOfBandInvitation.prototype, "goalCode", void 0);
    __decorate([
      (0, class_transformer_1.Transform)(({ value }) => value === null || value === void 0 ? void 0 : value.map(messageType_1.replaceLegacyDidSovPrefix), { toClassOnly: true }),
      (0, class_transformer_1.Expose)({ name: "handshake_protocols" }),
      __metadata("design:type", Array)
    ], OutOfBandInvitation.prototype, "handshakeProtocols", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "requests~attach" }),
      (0, class_transformer_1.Type)(() => Attachment_1.Attachment),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)({
        each: true
      }),
      (0, class_validator_1.IsInstance)(Attachment_1.Attachment, { each: true }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], OutOfBandInvitation.prototype, "requests", void 0);
    __decorate([
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ArrayNotEmpty)(),
      OutOfBandServiceTransformer(),
      (0, validators_1.IsStringOrInstance)(OutOfBandDidCommService_1.OutOfBandDidCommService, { each: true }),
      (0, class_validator_1.ValidateNested)({ each: true }),
      __metadata("design:type", Array)
    ], OutOfBandInvitation.prototype, "services", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsUrl)(),
      __metadata("design:type", String)
    ], OutOfBandInvitation.prototype, "imageUrl", void 0);
    exports.OutOfBandInvitation = OutOfBandInvitation;
    function OutOfBandServiceTransformer() {
      return (0, class_transformer_1.Transform)(({ value, type }) => {
        if (type === class_transformer_1.TransformationType.PLAIN_TO_CLASS) {
          return value.map((service) => {
            if (typeof service === "string")
              return new String(service);
            return JsonTransformer_1.JsonTransformer.fromJSON(service, OutOfBandDidCommService_1.OutOfBandDidCommService);
          });
        } else if (type === class_transformer_1.TransformationType.CLASS_TO_PLAIN) {
          return value.map((service) => typeof service === "string" || service instanceof String ? service.toString() : JsonTransformer_1.JsonTransformer.toJSON(service));
        }
        return value;
      });
    }
  }
});

// node_modules/@aries-framework/core/build/modules/oob/messages/HandshakeReuseMessage.js
var require_HandshakeReuseMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/messages/HandshakeReuseMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HandshakeReuseMessage = void 0;
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var HandshakeReuseMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a;
        super();
        this.type = HandshakeReuseMessage.type.messageTypeUri;
        if (options) {
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.setThread({
            threadId: this.id,
            parentThreadId: options.parentThreadId
          });
        }
      }
    };
    HandshakeReuseMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/out-of-band/1.1/handshake-reuse");
    __decorate([
      (0, messageType_1.IsValidMessageType)(HandshakeReuseMessage.type),
      __metadata("design:type", Object)
    ], HandshakeReuseMessage.prototype, "type", void 0);
    exports.HandshakeReuseMessage = HandshakeReuseMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/oob/messages/index.js
var require_messages4 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/messages/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_OutOfBandInvitation(), exports);
    __exportStar(require_HandshakeReuseMessage(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/oob/messages/HandshakeReuseAcceptedMessage.js
var require_HandshakeReuseAcceptedMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/messages/HandshakeReuseAcceptedMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HandshakeReuseAcceptedMessage = void 0;
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var HandshakeReuseAcceptedMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a;
        super();
        this.type = HandshakeReuseAcceptedMessage.type.messageTypeUri;
        if (options) {
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.setThread({
            threadId: options.threadId,
            parentThreadId: options.parentThreadId
          });
        }
      }
    };
    HandshakeReuseAcceptedMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/out-of-band/1.1/handshake-reuse-accepted");
    __decorate([
      (0, messageType_1.IsValidMessageType)(HandshakeReuseAcceptedMessage.type),
      __metadata("design:type", Object)
    ], HandshakeReuseAcceptedMessage.prototype, "type", void 0);
    exports.HandshakeReuseAcceptedMessage = HandshakeReuseAcceptedMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/oob/repository/OutOfBandRecord.js
var require_OutOfBandRecord = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/repository/OutOfBandRecord.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutOfBandRecord = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var error_1 = require_error();
    var BaseRecord_1 = require_BaseRecord();
    var uuid_1 = require_uuid();
    var messages_1 = require_messages4();
    var OutOfBandRecord = class extends BaseRecord_1.BaseRecord {
      constructor(props) {
        var _a, _b, _c, _d;
        super();
        this.type = OutOfBandRecord.type;
        if (props) {
          this.id = (_a = props.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.createdAt = (_b = props.createdAt) !== null && _b !== void 0 ? _b : /* @__PURE__ */ new Date();
          this.outOfBandInvitation = props.outOfBandInvitation;
          this.role = props.role;
          this.state = props.state;
          this.alias = props.alias;
          this.autoAcceptConnection = props.autoAcceptConnection;
          this.reusable = (_c = props.reusable) !== null && _c !== void 0 ? _c : false;
          this.mediatorId = props.mediatorId;
          this.reuseConnectionId = props.reuseConnectionId;
          this._tags = (_d = props.tags) !== null && _d !== void 0 ? _d : { recipientKeyFingerprints: [] };
        }
      }
      getTags() {
        return Object.assign(Object.assign({}, this._tags), { role: this.role, state: this.state, invitationId: this.outOfBandInvitation.id });
      }
      assertRole(expectedRole) {
        if (this.role !== expectedRole) {
          throw new error_1.AriesFrameworkError(`Invalid out-of-band record role ${this.role}, expected is ${expectedRole}.`);
        }
      }
      assertState(expectedStates) {
        if (!Array.isArray(expectedStates)) {
          expectedStates = [expectedStates];
        }
        if (!expectedStates.includes(this.state)) {
          throw new error_1.AriesFrameworkError(`Invalid out-of-band record state ${this.state}, valid states are: ${expectedStates.join(", ")}.`);
        }
      }
    };
    OutOfBandRecord.type = "OutOfBandRecord";
    __decorate([
      (0, class_transformer_1.Type)(() => messages_1.OutOfBandInvitation),
      __metadata("design:type", messages_1.OutOfBandInvitation)
    ], OutOfBandRecord.prototype, "outOfBandInvitation", void 0);
    exports.OutOfBandRecord = OutOfBandRecord;
  }
});

// node_modules/@aries-framework/core/build/modules/oob/repository/OutOfBandRepository.js
var require_OutOfBandRepository = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/repository/OutOfBandRepository.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutOfBandRepository = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var Repository_1 = require_Repository();
    var OutOfBandRecord_1 = require_OutOfBandRecord();
    var OutOfBandRepository = class OutOfBandRepository extends Repository_1.Repository {
      constructor(storageService, eventEmitter) {
        super(OutOfBandRecord_1.OutOfBandRecord, storageService, eventEmitter);
      }
    };
    OutOfBandRepository = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.StorageService)),
      __metadata("design:paramtypes", [Object, EventEmitter_1.EventEmitter])
    ], OutOfBandRepository);
    exports.OutOfBandRepository = OutOfBandRepository;
  }
});

// node_modules/@aries-framework/core/build/modules/oob/repository/index.js
var require_repository3 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/repository/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_OutOfBandRecord(), exports);
    __exportStar(require_OutOfBandRepository(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/oob/OutOfBandService.js
var require_OutOfBandService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/OutOfBandService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutOfBandService = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var utils_1 = require_utils();
    var OutOfBandEvents_1 = require_OutOfBandEvents();
    var OutOfBandRole_1 = require_OutOfBandRole();
    var OutOfBandState_1 = require_OutOfBandState();
    var messages_1 = require_messages4();
    var HandshakeReuseAcceptedMessage_1 = require_HandshakeReuseAcceptedMessage();
    var repository_1 = require_repository3();
    var OutOfBandService = class OutOfBandService {
      constructor(outOfBandRepository, eventEmitter) {
        this.outOfBandRepository = outOfBandRepository;
        this.eventEmitter = eventEmitter;
      }
      async processHandshakeReuse(messageContext) {
        var _a, _b, _c;
        const reuseMessage = messageContext.message;
        const parentThreadId = (_a = reuseMessage.thread) === null || _a === void 0 ? void 0 : _a.parentThreadId;
        if (!parentThreadId) {
          throw new error_1.AriesFrameworkError("handshake-reuse message must have a parent thread id");
        }
        const outOfBandRecord = await this.findByCreatedInvitationId(messageContext.agentContext, parentThreadId);
        if (!outOfBandRecord) {
          throw new error_1.AriesFrameworkError("No out of band record found for handshake-reuse message");
        }
        outOfBandRecord.assertRole(OutOfBandRole_1.OutOfBandRole.Sender);
        outOfBandRecord.assertState(OutOfBandState_1.OutOfBandState.AwaitResponse);
        const requestLength = (_c = (_b = outOfBandRecord.outOfBandInvitation.getRequests()) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
        if (requestLength > 0) {
          throw new error_1.AriesFrameworkError("Handshake reuse should only be used when no requests are present");
        }
        const reusedConnection = messageContext.assertReadyConnection();
        this.eventEmitter.emit(messageContext.agentContext, {
          type: OutOfBandEvents_1.OutOfBandEventTypes.HandshakeReused,
          payload: {
            reuseThreadId: reuseMessage.threadId,
            connectionRecord: reusedConnection,
            outOfBandRecord
          }
        });
        if (!outOfBandRecord.reusable) {
          await this.updateState(messageContext.agentContext, outOfBandRecord, OutOfBandState_1.OutOfBandState.Done);
        }
        const reuseAcceptedMessage = new HandshakeReuseAcceptedMessage_1.HandshakeReuseAcceptedMessage({
          threadId: reuseMessage.threadId,
          parentThreadId
        });
        return reuseAcceptedMessage;
      }
      async processHandshakeReuseAccepted(messageContext) {
        var _a;
        const reuseAcceptedMessage = messageContext.message;
        const parentThreadId = (_a = reuseAcceptedMessage.thread) === null || _a === void 0 ? void 0 : _a.parentThreadId;
        if (!parentThreadId) {
          throw new error_1.AriesFrameworkError("handshake-reuse-accepted message must have a parent thread id");
        }
        const outOfBandRecord = await this.findByReceivedInvitationId(messageContext.agentContext, parentThreadId);
        if (!outOfBandRecord) {
          throw new error_1.AriesFrameworkError("No out of band record found for handshake-reuse-accepted message");
        }
        outOfBandRecord.assertRole(OutOfBandRole_1.OutOfBandRole.Receiver);
        outOfBandRecord.assertState(OutOfBandState_1.OutOfBandState.PrepareResponse);
        const reusedConnection = messageContext.assertReadyConnection();
        if (outOfBandRecord.reuseConnectionId !== reusedConnection.id) {
          throw new error_1.AriesFrameworkError("handshake-reuse-accepted is not in response to a handshake-reuse message.");
        }
        this.eventEmitter.emit(messageContext.agentContext, {
          type: OutOfBandEvents_1.OutOfBandEventTypes.HandshakeReused,
          payload: {
            reuseThreadId: reuseAcceptedMessage.threadId,
            connectionRecord: reusedConnection,
            outOfBandRecord
          }
        });
        await this.updateState(messageContext.agentContext, outOfBandRecord, OutOfBandState_1.OutOfBandState.Done);
      }
      async createHandShakeReuse(agentContext, outOfBandRecord, connectionRecord) {
        const reuseMessage = new messages_1.HandshakeReuseMessage({ parentThreadId: outOfBandRecord.outOfBandInvitation.id });
        outOfBandRecord.reuseConnectionId = connectionRecord.id;
        await this.outOfBandRepository.update(agentContext, outOfBandRecord);
        return reuseMessage;
      }
      async save(agentContext, outOfBandRecord) {
        return this.outOfBandRepository.save(agentContext, outOfBandRecord);
      }
      async updateState(agentContext, outOfBandRecord, newState) {
        const previousState = outOfBandRecord.state;
        outOfBandRecord.state = newState;
        await this.outOfBandRepository.update(agentContext, outOfBandRecord);
        this.emitStateChangedEvent(agentContext, outOfBandRecord, previousState);
      }
      emitStateChangedEvent(agentContext, outOfBandRecord, previousState) {
        const clonedOutOfBandRecord = utils_1.JsonTransformer.clone(outOfBandRecord);
        this.eventEmitter.emit(agentContext, {
          type: OutOfBandEvents_1.OutOfBandEventTypes.OutOfBandStateChanged,
          payload: {
            outOfBandRecord: clonedOutOfBandRecord,
            previousState
          }
        });
      }
      async findById(agentContext, outOfBandRecordId) {
        return this.outOfBandRepository.findById(agentContext, outOfBandRecordId);
      }
      async getById(agentContext, outOfBandRecordId) {
        return this.outOfBandRepository.getById(agentContext, outOfBandRecordId);
      }
      async findByReceivedInvitationId(agentContext, receivedInvitationId) {
        return this.outOfBandRepository.findSingleByQuery(agentContext, {
          invitationId: receivedInvitationId,
          role: OutOfBandRole_1.OutOfBandRole.Receiver
        });
      }
      async findByCreatedInvitationId(agentContext, createdInvitationId) {
        return this.outOfBandRepository.findSingleByQuery(agentContext, {
          invitationId: createdInvitationId,
          role: OutOfBandRole_1.OutOfBandRole.Sender
        });
      }
      async findCreatedByRecipientKey(agentContext, recipientKey) {
        return this.outOfBandRepository.findSingleByQuery(agentContext, {
          recipientKeyFingerprints: [recipientKey.fingerprint],
          role: OutOfBandRole_1.OutOfBandRole.Sender
        });
      }
      async getAll(agentContext) {
        return this.outOfBandRepository.getAll(agentContext);
      }
      async findAllByQuery(agentContext, query) {
        return this.outOfBandRepository.findByQuery(agentContext, query);
      }
      async deleteById(agentContext, outOfBandId) {
        const outOfBandRecord = await this.getById(agentContext, outOfBandId);
        return this.outOfBandRepository.delete(agentContext, outOfBandRecord);
      }
    };
    OutOfBandService = __decorate([
      (0, plugins_1.injectable)(),
      __metadata("design:paramtypes", [repository_1.OutOfBandRepository, EventEmitter_1.EventEmitter])
    ], OutOfBandService);
    exports.OutOfBandService = OutOfBandService;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/RoutingEvents.js
var require_RoutingEvents = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/RoutingEvents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RoutingEventTypes = void 0;
    var RoutingEventTypes;
    (function(RoutingEventTypes2) {
      RoutingEventTypes2["MediationStateChanged"] = "MediationStateChanged";
      RoutingEventTypes2["RecipientKeylistUpdated"] = "RecipientKeylistUpdated";
      RoutingEventTypes2["RoutingCreatedEvent"] = "RoutingCreatedEvent";
    })(RoutingEventTypes = exports.RoutingEventTypes || (exports.RoutingEventTypes = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/connections/repository/ConnectionMetadataTypes.js
var require_ConnectionMetadataTypes = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/repository/ConnectionMetadataTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionMetadataKeys = void 0;
    var ConnectionMetadataKeys;
    (function(ConnectionMetadataKeys2) {
      ConnectionMetadataKeys2["UseDidKeysForProtocol"] = "_internal/useDidKeysForProtocol";
    })(ConnectionMetadataKeys = exports.ConnectionMetadataKeys || (exports.ConnectionMetadataKeys = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/routing/RecipientModuleConfig.js
var require_RecipientModuleConfig = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/RecipientModuleConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RecipientModuleConfig = void 0;
    var RecipientModuleConfig = class {
      constructor(options) {
        this.options = options !== null && options !== void 0 ? options : {};
      }
      /** See {@link RecipientModuleConfigOptions.mediatorPollingInterval} */
      get mediatorPollingInterval() {
        var _a;
        return (_a = this.options.mediatorPollingInterval) !== null && _a !== void 0 ? _a : 5e3;
      }
      /** See {@link RecipientModuleConfigOptions.mediatorPickupStrategy} */
      get mediatorPickupStrategy() {
        return this.options.mediatorPickupStrategy;
      }
      /** See {@link RecipientModuleConfigOptions.maximumMessagePickup} */
      get maximumMessagePickup() {
        var _a;
        return (_a = this.options.maximumMessagePickup) !== null && _a !== void 0 ? _a : 10;
      }
      /** See {@link RecipientModuleConfigOptions.baseMediatorReconnectionIntervalMs} */
      get baseMediatorReconnectionIntervalMs() {
        var _a;
        return (_a = this.options.baseMediatorReconnectionIntervalMs) !== null && _a !== void 0 ? _a : 100;
      }
      /** See {@link RecipientModuleConfigOptions.maximumMediatorReconnectionIntervalMs} */
      get maximumMediatorReconnectionIntervalMs() {
        var _a;
        return (_a = this.options.maximumMediatorReconnectionIntervalMs) !== null && _a !== void 0 ? _a : Number.POSITIVE_INFINITY;
      }
      /** See {@link RecipientModuleConfigOptions.mediatorInvitationUrl} */
      get mediatorInvitationUrl() {
        return this.options.mediatorInvitationUrl;
      }
    };
    exports.RecipientModuleConfig = RecipientModuleConfig;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/error/RoutingProblemReportReason.js
var require_RoutingProblemReportReason = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/error/RoutingProblemReportReason.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RoutingProblemReportReason = void 0;
    var RoutingProblemReportReason;
    (function(RoutingProblemReportReason2) {
      RoutingProblemReportReason2["ErrorProcessingAttachments"] = "error-processing-attachments";
    })(RoutingProblemReportReason = exports.RoutingProblemReportReason || (exports.RoutingProblemReportReason = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/routing/error/index.js
var require_error4 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/error/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_RoutingProblemReportReason(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/routing/models/MediationRole.js
var require_MediationRole = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/models/MediationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MediationRole = void 0;
    var MediationRole;
    (function(MediationRole2) {
      MediationRole2["Mediator"] = "MEDIATOR";
      MediationRole2["Recipient"] = "RECIPIENT";
    })(MediationRole = exports.MediationRole || (exports.MediationRole = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/routing/models/MediationState.js
var require_MediationState = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/models/MediationState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MediationState = void 0;
    var MediationState;
    (function(MediationState2) {
      MediationState2["Requested"] = "requested";
      MediationState2["Granted"] = "granted";
      MediationState2["Denied"] = "denied";
    })(MediationState = exports.MediationState || (exports.MediationState = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/routing/models/index.js
var require_models4 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/models/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_MediationRole(), exports);
    __exportStar(require_MediationState(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/messages/DeliveryRequestMessage.js
var require_DeliveryRequestMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/messages/DeliveryRequestMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeliveryRequestMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var TransportDecorator_1 = require_TransportDecorator();
    var messageType_1 = require_messageType();
    var DeliveryRequestMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        super();
        this.type = DeliveryRequestMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.recipientKey = options.recipientKey;
          this.limit = options.limit;
        }
        this.setReturnRouting(TransportDecorator_1.ReturnRouteTypes.all);
      }
    };
    DeliveryRequestMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/messagepickup/2.0/delivery-request");
    __decorate([
      (0, messageType_1.IsValidMessageType)(DeliveryRequestMessage.type),
      __metadata("design:type", Object)
    ], DeliveryRequestMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      (0, class_transformer_1.Expose)({ name: "recipient_key" }),
      __metadata("design:type", String)
    ], DeliveryRequestMessage.prototype, "recipientKey", void 0);
    __decorate([
      (0, class_validator_1.IsInt)(),
      __metadata("design:type", Number)
    ], DeliveryRequestMessage.prototype, "limit", void 0);
    exports.DeliveryRequestMessage = DeliveryRequestMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/messages/MessageDeliveryMessage.js
var require_MessageDeliveryMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/messages/MessageDeliveryMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageDeliveryMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var TransportDecorator_1 = require_TransportDecorator();
    var messageType_1 = require_messageType();
    var MessageDeliveryMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        super();
        this.type = MessageDeliveryMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.recipientKey = options.recipientKey;
          this.appendedAttachments = options.attachments;
          this.setThread({
            threadId: options.threadId
          });
        }
        this.setReturnRouting(TransportDecorator_1.ReturnRouteTypes.all);
      }
    };
    MessageDeliveryMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/messagepickup/2.0/delivery");
    __decorate([
      (0, messageType_1.IsValidMessageType)(MessageDeliveryMessage.type),
      __metadata("design:type", Object)
    ], MessageDeliveryMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      (0, class_transformer_1.Expose)({ name: "recipient_key" }),
      __metadata("design:type", String)
    ], MessageDeliveryMessage.prototype, "recipientKey", void 0);
    exports.MessageDeliveryMessage = MessageDeliveryMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/messages/MessagesReceivedMessage.js
var require_MessagesReceivedMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/messages/MessagesReceivedMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessagesReceivedMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var TransportDecorator_1 = require_TransportDecorator();
    var messageType_1 = require_messageType();
    var MessagesReceivedMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        super();
        this.type = MessagesReceivedMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.messageIdList = options.messageIdList;
        }
        this.setReturnRouting(TransportDecorator_1.ReturnRouteTypes.all);
      }
    };
    MessagesReceivedMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/messagepickup/2.0/messages-received");
    __decorate([
      (0, messageType_1.IsValidMessageType)(MessagesReceivedMessage.type),
      __metadata("design:type", Object)
    ], MessagesReceivedMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.IsOptional)(),
      (0, class_transformer_1.Expose)({ name: "message_id_list" }),
      __metadata("design:type", Array)
    ], MessagesReceivedMessage.prototype, "messageIdList", void 0);
    exports.MessagesReceivedMessage = MessagesReceivedMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/messages/StatusMessage.js
var require_StatusMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/messages/StatusMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatusMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var TransportDecorator_1 = require_TransportDecorator();
    var messageType_1 = require_messageType();
    var transformers_1 = require_transformers();
    var StatusMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        super();
        this.type = StatusMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.recipientKey = options.recipientKey;
          this.messageCount = options.messageCount;
          this.longestWaitedSeconds = options.longestWaitedSeconds;
          this.newestReceivedTime = options.newestReceivedTime;
          this.oldestReceivedTime = options.oldestReceivedTime;
          this.totalBytes = options.totalBytes;
          this.liveDelivery = options.liveDelivery;
          this.setThread({
            threadId: options.threadId
          });
        }
        this.setReturnRouting(TransportDecorator_1.ReturnRouteTypes.all);
      }
    };
    StatusMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/messagepickup/2.0/status");
    __decorate([
      (0, messageType_1.IsValidMessageType)(StatusMessage.type),
      __metadata("design:type", Object)
    ], StatusMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      (0, class_transformer_1.Expose)({ name: "recipient_key" }),
      __metadata("design:type", String)
    ], StatusMessage.prototype, "recipientKey", void 0);
    __decorate([
      (0, class_validator_1.IsInt)(),
      (0, class_transformer_1.Expose)({ name: "message_count" }),
      __metadata("design:type", Number)
    ], StatusMessage.prototype, "messageCount", void 0);
    __decorate([
      (0, class_validator_1.IsInt)(),
      (0, class_validator_1.IsOptional)(),
      (0, class_transformer_1.Expose)({ name: "longest_waited_seconds" }),
      __metadata("design:type", Number)
    ], StatusMessage.prototype, "longestWaitedSeconds", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "newest_received_time" }),
      (0, class_transformer_1.Transform)(({ value }) => (0, transformers_1.DateParser)(value)),
      (0, class_validator_1.IsDate)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Date)
    ], StatusMessage.prototype, "newestReceivedTime", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_transformer_1.Transform)(({ value }) => (0, transformers_1.DateParser)(value)),
      (0, class_validator_1.IsDate)(),
      (0, class_transformer_1.Expose)({ name: "oldest_received_time" }),
      __metadata("design:type", Date)
    ], StatusMessage.prototype, "oldestReceivedTime", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsInt)(),
      (0, class_transformer_1.Expose)({ name: "total_bytes" }),
      __metadata("design:type", Number)
    ], StatusMessage.prototype, "totalBytes", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsBoolean)(),
      (0, class_transformer_1.Expose)({ name: "live_delivery" }),
      __metadata("design:type", Boolean)
    ], StatusMessage.prototype, "liveDelivery", void 0);
    exports.StatusMessage = StatusMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/messages/StatusRequestMessage.js
var require_StatusRequestMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/messages/StatusRequestMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatusRequestMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var StatusRequestMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        super();
        this.type = StatusRequestMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.recipientKey = options.recipientKey;
        }
      }
    };
    StatusRequestMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/messagepickup/2.0/status-request");
    __decorate([
      (0, messageType_1.IsValidMessageType)(StatusRequestMessage.type),
      __metadata("design:type", Object)
    ], StatusRequestMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      (0, class_transformer_1.Expose)({ name: "recipient_key" }),
      __metadata("design:type", String)
    ], StatusRequestMessage.prototype, "recipientKey", void 0);
    exports.StatusRequestMessage = StatusRequestMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/messages/index.js
var require_messages5 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/messages/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_DeliveryRequestMessage(), exports);
    __exportStar(require_MessageDeliveryMessage(), exports);
    __exportStar(require_MessagesReceivedMessage(), exports);
    __exportStar(require_StatusMessage(), exports);
    __exportStar(require_StatusRequestMessage(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/routing/MediatorPickupStrategy.js
var require_MediatorPickupStrategy = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/MediatorPickupStrategy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MediatorPickupStrategy = void 0;
    var MediatorPickupStrategy;
    (function(MediatorPickupStrategy2) {
      MediatorPickupStrategy2["PickUpV1"] = "PickUpV1";
      MediatorPickupStrategy2["PickUpV2"] = "PickUpV2";
      MediatorPickupStrategy2["Implicit"] = "Implicit";
      MediatorPickupStrategy2["None"] = "None";
    })(MediatorPickupStrategy = exports.MediatorPickupStrategy || (exports.MediatorPickupStrategy = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/routing/repository/MediationRecord.js
var require_MediationRecord = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/repository/MediationRecord.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MediationRecord = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var error_1 = require_error();
    var BaseRecord_1 = require_BaseRecord();
    var uuid_1 = require_uuid();
    var MediatorPickupStrategy_1 = require_MediatorPickupStrategy();
    var MediationState_1 = require_MediationState();
    var MediationRecord = class extends BaseRecord_1.BaseRecord {
      constructor(props) {
        var _a, _b, _c, _d;
        super();
        this.type = MediationRecord.type;
        if (props) {
          this.id = (_a = props.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.createdAt = (_b = props.createdAt) !== null && _b !== void 0 ? _b : /* @__PURE__ */ new Date();
          this.connectionId = props.connectionId;
          this.threadId = props.threadId;
          this.recipientKeys = props.recipientKeys || [];
          this.routingKeys = props.routingKeys || [];
          this.state = props.state;
          this.role = props.role;
          this.endpoint = (_c = props.endpoint) !== null && _c !== void 0 ? _c : void 0;
          this.pickupStrategy = props.pickupStrategy;
          this._tags = (_d = props.tags) !== null && _d !== void 0 ? _d : {};
        }
      }
      getTags() {
        return Object.assign(Object.assign({}, this._tags), { state: this.state, role: this.role, connectionId: this.connectionId, threadId: this.threadId, recipientKeys: this.recipientKeys });
      }
      addRecipientKey(recipientKey) {
        this.recipientKeys.push(recipientKey);
      }
      removeRecipientKey(recipientKey) {
        const index = this.recipientKeys.indexOf(recipientKey, 0);
        if (index > -1) {
          this.recipientKeys.splice(index, 1);
          return true;
        }
        return false;
      }
      get isReady() {
        return this.state === MediationState_1.MediationState.Granted;
      }
      assertReady() {
        if (!this.isReady) {
          throw new error_1.AriesFrameworkError(`Mediation record is not ready to be used. Expected ${MediationState_1.MediationState.Granted}, found invalid state ${this.state}`);
        }
      }
      assertState(expectedStates) {
        if (!Array.isArray(expectedStates)) {
          expectedStates = [expectedStates];
        }
        if (!expectedStates.includes(this.state)) {
          throw new error_1.AriesFrameworkError(`Mediation record is in invalid state ${this.state}. Valid states are: ${expectedStates.join(", ")}.`);
        }
      }
      assertRole(expectedRole) {
        if (this.role !== expectedRole) {
          throw new error_1.AriesFrameworkError(`Mediation record has invalid role ${this.role}. Expected role ${expectedRole}.`);
        }
      }
    };
    MediationRecord.type = "MediationRecord";
    __decorate([
      (0, class_transformer_1.Transform)(({ value }) => {
        if (value === "Explicit") {
          return MediatorPickupStrategy_1.MediatorPickupStrategy.PickUpV1;
        } else {
          return value;
        }
      }),
      __metadata("design:type", String)
    ], MediationRecord.prototype, "pickupStrategy", void 0);
    exports.MediationRecord = MediationRecord;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/repository/MediationRepository.js
var require_MediationRepository = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/repository/MediationRepository.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MediationRepository = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var Repository_1 = require_Repository();
    var MediationRecord_1 = require_MediationRecord();
    var MediationRepository = class MediationRepository extends Repository_1.Repository {
      constructor(storageService, eventEmitter) {
        super(MediationRecord_1.MediationRecord, storageService, eventEmitter);
      }
      getSingleByRecipientKey(agentContext, recipientKey) {
        return this.getSingleByQuery(agentContext, {
          recipientKeys: [recipientKey]
        });
      }
      async getByConnectionId(agentContext, connectionId) {
        return this.getSingleByQuery(agentContext, { connectionId });
      }
    };
    MediationRepository = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.StorageService)),
      __metadata("design:paramtypes", [Object, EventEmitter_1.EventEmitter])
    ], MediationRepository);
    exports.MediationRepository = MediationRepository;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/services/MediationRecipientService.js
var require_MediationRecipientService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/services/MediationRecipientService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MediationRecipientService = void 0;
    var rxjs_1 = require_cjs();
    var operators_1 = require_operators();
    var EventEmitter_1 = require_EventEmitter();
    var Events_1 = require_Events();
    var MessageSender_1 = require_MessageSender();
    var models_1 = require_models3();
    var crypto_1 = require_crypto();
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var utils_1 = require_utils();
    var ConnectionType_1 = require_ConnectionType();
    var ConnectionMetadataTypes_1 = require_ConnectionMetadataTypes();
    var ConnectionService_1 = require_ConnectionService();
    var dids_1 = require_dids();
    var helpers_1 = require_helpers();
    var problem_reports_1 = require_problem_reports();
    var RecipientModuleConfig_1 = require_RecipientModuleConfig();
    var RoutingEvents_1 = require_RoutingEvents();
    var error_2 = require_error4();
    var messages_1 = require_messages3();
    var KeylistUpdateMessage_1 = require_KeylistUpdateMessage();
    var models_2 = require_models4();
    var messages_2 = require_messages5();
    var MediationRecord_1 = require_MediationRecord();
    var MediationRepository_1 = require_MediationRepository();
    var MediationRecipientService = class MediationRecipientService {
      constructor(connectionService, messageSender, mediatorRepository, eventEmitter, recipientModuleConfig) {
        this.mediationRepository = mediatorRepository;
        this.eventEmitter = eventEmitter;
        this.connectionService = connectionService;
        this.messageSender = messageSender;
        this.recipientModuleConfig = recipientModuleConfig;
      }
      async createStatusRequest(mediationRecord, config = {}) {
        mediationRecord.assertRole(models_2.MediationRole.Recipient);
        mediationRecord.assertReady();
        const { recipientKey } = config;
        const statusRequest = new messages_2.StatusRequestMessage({
          recipientKey
        });
        return statusRequest;
      }
      async createRequest(agentContext, connection) {
        const message = new messages_1.MediationRequestMessage({});
        const mediationRecord = new MediationRecord_1.MediationRecord({
          threadId: message.threadId,
          state: models_2.MediationState.Requested,
          role: models_2.MediationRole.Recipient,
          connectionId: connection.id
        });
        await this.connectionService.addConnectionType(agentContext, connection, ConnectionType_1.ConnectionType.Mediator);
        await this.mediationRepository.save(agentContext, mediationRecord);
        this.emitStateChangedEvent(agentContext, mediationRecord, null);
        return { mediationRecord, message };
      }
      async processMediationGrant(messageContext) {
        const connection = messageContext.assertReadyConnection();
        const mediationRecord = await this.mediationRepository.getByConnectionId(messageContext.agentContext, connection.id);
        mediationRecord.assertState(models_2.MediationState.Requested);
        mediationRecord.assertRole(models_2.MediationRole.Recipient);
        mediationRecord.endpoint = messageContext.message.endpoint;
        const connectionUsesDidKey = messageContext.message.routingKeys.some(helpers_1.isDidKey);
        await this.updateUseDidKeysFlag(messageContext.agentContext, connection, messages_1.MediationGrantMessage.type.protocolUri, connectionUsesDidKey);
        mediationRecord.routingKeys = messageContext.message.routingKeys.map(helpers_1.didKeyToVerkey);
        return await this.updateState(messageContext.agentContext, mediationRecord, models_2.MediationState.Granted);
      }
      async processKeylistUpdateResults(messageContext) {
        const connection = messageContext.assertReadyConnection();
        const mediationRecord = await this.mediationRepository.getByConnectionId(messageContext.agentContext, connection.id);
        mediationRecord.assertReady();
        mediationRecord.assertRole(models_2.MediationRole.Recipient);
        const keylist = messageContext.message.updated;
        const connectionUsesDidKey = keylist.some((key) => (0, helpers_1.isDidKey)(key.recipientKey));
        await this.updateUseDidKeysFlag(messageContext.agentContext, connection, messages_1.KeylistUpdateResponseMessage.type.protocolUri, connectionUsesDidKey);
        for (const update of keylist) {
          if (update.action === messages_1.KeylistUpdateAction.add) {
            mediationRecord.addRecipientKey((0, helpers_1.didKeyToVerkey)(update.recipientKey));
          } else if (update.action === messages_1.KeylistUpdateAction.remove) {
            mediationRecord.removeRecipientKey((0, helpers_1.didKeyToVerkey)(update.recipientKey));
          }
        }
        await this.mediationRepository.update(messageContext.agentContext, mediationRecord);
        this.eventEmitter.emit(messageContext.agentContext, {
          type: RoutingEvents_1.RoutingEventTypes.RecipientKeylistUpdated,
          payload: {
            mediationRecord,
            keylist
          }
        });
      }
      async keylistUpdateAndAwait(agentContext, mediationRecord, updates, timeoutMs = 15e3) {
        var _a;
        const connection = await this.connectionService.getById(agentContext, mediationRecord.connectionId);
        let useDidKey = agentContext.config.useDidKeyInProtocols;
        const useDidKeysConnectionMetadata = connection.metadata.get(ConnectionMetadataTypes_1.ConnectionMetadataKeys.UseDidKeysForProtocol);
        if (useDidKeysConnectionMetadata) {
          useDidKey = (_a = useDidKeysConnectionMetadata[KeylistUpdateMessage_1.KeylistUpdateMessage.type.protocolUri]) !== null && _a !== void 0 ? _a : useDidKey;
        }
        const message = this.createKeylistUpdateMessage(updates.map((item) => new KeylistUpdateMessage_1.KeylistUpdate({
          action: item.action,
          recipientKey: useDidKey ? new dids_1.DidKey(item.recipientKey).did : item.recipientKey.publicKeyBase58
        })));
        mediationRecord.assertReady();
        mediationRecord.assertRole(models_2.MediationRole.Recipient);
        const observable = this.eventEmitter.observable(RoutingEvents_1.RoutingEventTypes.RecipientKeylistUpdated);
        const subject = new rxjs_1.ReplaySubject(1);
        observable.pipe(
          (0, Events_1.filterContextCorrelationId)(agentContext.contextCorrelationId),
          // Only take event for current mediation record
          (0, operators_1.filter)((event) => mediationRecord.id === event.payload.mediationRecord.id),
          // Only wait for first event that matches the criteria
          (0, operators_1.first)(),
          // Do not wait for longer than specified timeout
          (0, operators_1.timeout)(timeoutMs)
        ).subscribe(subject);
        const outboundMessageContext = new models_1.OutboundMessageContext(message, { agentContext, connection });
        await this.messageSender.sendMessage(outboundMessageContext);
        const keylistUpdate = await (0, rxjs_1.firstValueFrom)(subject);
        return keylistUpdate.payload.mediationRecord;
      }
      createKeylistUpdateMessage(updates) {
        const keylistUpdateMessage = new KeylistUpdateMessage_1.KeylistUpdateMessage({
          updates
        });
        return keylistUpdateMessage;
      }
      async addMediationRouting(agentContext, routing, { mediatorId, useDefaultMediator = true } = {}) {
        let mediationRecord = null;
        if (mediatorId) {
          mediationRecord = await this.getById(agentContext, mediatorId);
        } else if (useDefaultMediator) {
          mediationRecord = await this.findDefaultMediator(agentContext);
        }
        if (!mediationRecord)
          return routing;
        mediationRecord = await this.keylistUpdateAndAwait(agentContext, mediationRecord, [
          {
            recipientKey: routing.recipientKey,
            action: messages_1.KeylistUpdateAction.add
          }
        ]);
        return Object.assign(Object.assign({}, routing), { mediatorId: mediationRecord.id, endpoints: mediationRecord.endpoint ? [mediationRecord.endpoint] : routing.endpoints, routingKeys: mediationRecord.routingKeys.map((key) => crypto_1.Key.fromPublicKeyBase58(key, crypto_1.KeyType.Ed25519)) });
      }
      async removeMediationRouting(agentContext, { recipientKeys, mediatorId }) {
        const mediationRecord = await this.getById(agentContext, mediatorId);
        if (!mediationRecord) {
          throw new error_1.AriesFrameworkError("No mediation record to remove routing from has been found");
        }
        await this.keylistUpdateAndAwait(agentContext, mediationRecord, recipientKeys.map((item) => {
          return {
            recipientKey: item,
            action: messages_1.KeylistUpdateAction.remove
          };
        }));
      }
      async processMediationDeny(messageContext) {
        const connection = messageContext.assertReadyConnection();
        const mediationRecord = await this.findByConnectionId(messageContext.agentContext, connection.id);
        if (!mediationRecord) {
          throw new Error(`No mediation has been requested for this connection id: ${connection.id}`);
        }
        mediationRecord.assertRole(models_2.MediationRole.Recipient);
        mediationRecord.assertState(models_2.MediationState.Requested);
        await this.updateState(messageContext.agentContext, mediationRecord, models_2.MediationState.Denied);
        return mediationRecord;
      }
      async processStatus(messageContext) {
        const connection = messageContext.assertReadyConnection();
        const { message: statusMessage } = messageContext;
        const { messageCount, recipientKey } = statusMessage;
        if (messageCount === 0) {
          const { message, connectionRecord } = await this.connectionService.createTrustPing(messageContext.agentContext, connection, {
            responseRequested: false
          });
          const websocketSchemes = ["ws", "wss"];
          await this.messageSender.sendMessage(new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            connection: connectionRecord
          }), {
            transportPriority: {
              schemes: websocketSchemes,
              restrictive: true
              // TODO: add keepAlive: true to enforce through the public api
              // we need to keep the socket alive. It already works this way, but would
              // be good to make more explicit from the public facing API.
              // This would also make it easier to change the internal API later on.
              // keepAlive: true,
            }
          });
          return null;
        }
        const { maximumMessagePickup } = this.recipientModuleConfig;
        const limit2 = messageCount < maximumMessagePickup ? messageCount : maximumMessagePickup;
        const deliveryRequestMessage = new messages_2.DeliveryRequestMessage({
          limit: limit2,
          recipientKey
        });
        return deliveryRequestMessage;
      }
      async processDelivery(messageContext) {
        messageContext.assertReadyConnection();
        const { appendedAttachments } = messageContext.message;
        if (!appendedAttachments)
          throw new problem_reports_1.ProblemReportError("Error processing attachments", {
            problemCode: error_2.RoutingProblemReportReason.ErrorProcessingAttachments
          });
        const ids = [];
        for (const attachment of appendedAttachments) {
          ids.push(attachment.id);
          this.eventEmitter.emit(messageContext.agentContext, {
            type: Events_1.AgentEventTypes.AgentMessageReceived,
            payload: {
              message: attachment.getDataAsJson(),
              contextCorrelationId: messageContext.agentContext.contextCorrelationId
            }
          });
        }
        return new messages_2.MessagesReceivedMessage({
          messageIdList: ids
        });
      }
      /**
       * Update the record to a new state and emit an state changed event. Also updates the record
       * in storage.
       *
       * @param MediationRecord The proof record to update the state for
       * @param newState The state to update to
       *
       */
      async updateState(agentContext, mediationRecord, newState) {
        const previousState = mediationRecord.state;
        mediationRecord.state = newState;
        await this.mediationRepository.update(agentContext, mediationRecord);
        this.emitStateChangedEvent(agentContext, mediationRecord, previousState);
        return mediationRecord;
      }
      emitStateChangedEvent(agentContext, mediationRecord, previousState) {
        const clonedMediationRecord = utils_1.JsonTransformer.clone(mediationRecord);
        this.eventEmitter.emit(agentContext, {
          type: RoutingEvents_1.RoutingEventTypes.MediationStateChanged,
          payload: {
            mediationRecord: clonedMediationRecord,
            previousState
          }
        });
      }
      async getById(agentContext, id) {
        return this.mediationRepository.getById(agentContext, id);
      }
      async findByConnectionId(agentContext, connectionId) {
        return this.mediationRepository.findSingleByQuery(agentContext, { connectionId });
      }
      async getMediators(agentContext) {
        return this.mediationRepository.getAll(agentContext);
      }
      async findAllMediatorsByQuery(agentContext, query) {
        return await this.mediationRepository.findByQuery(agentContext, query);
      }
      async findDefaultMediator(agentContext) {
        return this.mediationRepository.findSingleByQuery(agentContext, { default: true });
      }
      async discoverMediation(agentContext, mediatorId) {
        if (mediatorId) {
          return this.mediationRepository.getById(agentContext, mediatorId);
        }
        const defaultMediator = await this.findDefaultMediator(agentContext);
        if (defaultMediator) {
          if (defaultMediator.state !== models_2.MediationState.Granted) {
            throw new error_1.AriesFrameworkError(`Mediation State for ${defaultMediator.id} is not granted, but is set as default mediator!`);
          }
          return defaultMediator;
        }
      }
      async setDefaultMediator(agentContext, mediator) {
        const mediationRecords = await this.mediationRepository.findByQuery(agentContext, { default: true });
        for (const record of mediationRecords) {
          record.setTag("default", false);
          await this.mediationRepository.update(agentContext, record);
        }
        mediator.setTag("default", true);
        await this.mediationRepository.update(agentContext, mediator);
      }
      async clearDefaultMediator(agentContext) {
        const mediationRecord = await this.findDefaultMediator(agentContext);
        if (mediationRecord) {
          mediationRecord.setTag("default", false);
          await this.mediationRepository.update(agentContext, mediationRecord);
        }
      }
      async updateUseDidKeysFlag(agentContext, connection, protocolUri, connectionUsesDidKey) {
        var _a;
        const useDidKeysForProtocol = (_a = connection.metadata.get(ConnectionMetadataTypes_1.ConnectionMetadataKeys.UseDidKeysForProtocol)) !== null && _a !== void 0 ? _a : {};
        useDidKeysForProtocol[protocolUri] = connectionUsesDidKey;
        connection.metadata.set(ConnectionMetadataTypes_1.ConnectionMetadataKeys.UseDidKeysForProtocol, useDidKeysForProtocol);
        await this.connectionService.update(agentContext, connection);
      }
    };
    MediationRecipientService = __decorate([
      (0, plugins_1.injectable)(),
      __metadata("design:paramtypes", [
        ConnectionService_1.ConnectionService,
        MessageSender_1.MessageSender,
        MediationRepository_1.MediationRepository,
        EventEmitter_1.EventEmitter,
        RecipientModuleConfig_1.RecipientModuleConfig
      ])
    ], MediationRecipientService);
    exports.MediationRecipientService = MediationRecipientService;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/services/RoutingService.js
var require_RoutingService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/services/RoutingService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RoutingService = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var crypto_1 = require_crypto();
    var plugins_1 = require_plugins();
    var RoutingEvents_1 = require_RoutingEvents();
    var MediationRecipientService_1 = require_MediationRecipientService();
    var RoutingService = class RoutingService {
      constructor(mediationRecipientService, eventEmitter) {
        this.mediationRecipientService = mediationRecipientService;
        this.eventEmitter = eventEmitter;
      }
      async getRouting(agentContext, { mediatorId, useDefaultMediator = true } = {}) {
        const recipientKey = await agentContext.wallet.createKey({ keyType: crypto_1.KeyType.Ed25519 });
        let routing = {
          endpoints: agentContext.config.endpoints,
          routingKeys: [],
          recipientKey
        };
        routing = await this.mediationRecipientService.addMediationRouting(agentContext, routing, {
          mediatorId,
          useDefaultMediator
        });
        this.eventEmitter.emit(agentContext, {
          type: RoutingEvents_1.RoutingEventTypes.RoutingCreatedEvent,
          payload: {
            routing
          }
        });
        return routing;
      }
      async removeRouting(agentContext, options) {
        await this.mediationRecipientService.removeMediationRouting(agentContext, options);
      }
    };
    RoutingService = __decorate([
      (0, plugins_1.injectable)(),
      __metadata("design:paramtypes", [MediationRecipientService_1.MediationRecipientService, EventEmitter_1.EventEmitter])
    ], RoutingService);
    exports.RoutingService = RoutingService;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/ConnectionsModuleConfig.js
var require_ConnectionsModuleConfig = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/ConnectionsModuleConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionsModuleConfig = void 0;
    var ConnectionsModuleConfig = class {
      constructor(options) {
        this.options = options !== null && options !== void 0 ? options : {};
      }
      /** See {@link ConnectionsModuleConfigOptions.autoAcceptConnections} */
      get autoAcceptConnections() {
        var _a;
        return (_a = this.options.autoAcceptConnections) !== null && _a !== void 0 ? _a : false;
      }
    };
    exports.ConnectionsModuleConfig = ConnectionsModuleConfig;
  }
});

// node_modules/@aries-framework/core/build/crypto/JwsService.js
var require_JwsService = __commonJS({
  "node_modules/@aries-framework/core/build/crypto/JwsService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JwsService = void 0;
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var utils_1 = require_utils();
    var error_2 = require_error3();
    var Key_1 = require_Key();
    var KeyType_1 = require_KeyType();
    var JWS_KEY_TYPE = "OKP";
    var JWS_CURVE = "Ed25519";
    var JWS_ALG = "EdDSA";
    var JwsService = class JwsService {
      async createJws(agentContext, { payload, verkey, header }) {
        const base64Payload = utils_1.TypedArrayEncoder.toBase64URL(payload);
        const base64Protected = utils_1.JsonEncoder.toBase64URL(this.buildProtected(verkey));
        const key = Key_1.Key.fromPublicKeyBase58(verkey, KeyType_1.KeyType.Ed25519);
        const signature = utils_1.TypedArrayEncoder.toBase64URL(await agentContext.wallet.sign({ data: utils_1.TypedArrayEncoder.fromString(`${base64Protected}.${base64Payload}`), key }));
        return {
          protected: base64Protected,
          signature,
          header
        };
      }
      /**
       * Verify a JWS
       */
      async verifyJws(agentContext, { jws, payload }) {
        var _a, _b, _c;
        const base64Payload = utils_1.TypedArrayEncoder.toBase64URL(payload);
        const signatures = "signatures" in jws ? jws.signatures : [jws];
        if (signatures.length === 0) {
          throw new error_1.AriesFrameworkError("Unable to verify JWS: No entries in JWS signatures array.");
        }
        const signerVerkeys = [];
        for (const jws2 of signatures) {
          const protectedJson = utils_1.JsonEncoder.fromBase64(jws2.protected);
          const isValidKeyType = ((_a = protectedJson === null || protectedJson === void 0 ? void 0 : protectedJson.jwk) === null || _a === void 0 ? void 0 : _a.kty) === JWS_KEY_TYPE;
          const isValidCurve = ((_b = protectedJson === null || protectedJson === void 0 ? void 0 : protectedJson.jwk) === null || _b === void 0 ? void 0 : _b.crv) === JWS_CURVE;
          const isValidAlg = (protectedJson === null || protectedJson === void 0 ? void 0 : protectedJson.alg) === JWS_ALG;
          if (!isValidKeyType || !isValidCurve || !isValidAlg) {
            throw new error_1.AriesFrameworkError("Invalid protected header");
          }
          const data = utils_1.TypedArrayEncoder.fromString(`${jws2.protected}.${base64Payload}`);
          const signature = utils_1.TypedArrayEncoder.fromBase64(jws2.signature);
          const verkey = utils_1.TypedArrayEncoder.toBase58(utils_1.TypedArrayEncoder.fromBase64((_c = protectedJson === null || protectedJson === void 0 ? void 0 : protectedJson.jwk) === null || _c === void 0 ? void 0 : _c.x));
          const key = Key_1.Key.fromPublicKeyBase58(verkey, KeyType_1.KeyType.Ed25519);
          signerVerkeys.push(verkey);
          try {
            const isValid = await agentContext.wallet.verify({ key, data, signature });
            if (!isValid) {
              return {
                isValid: false,
                signerVerkeys: []
              };
            }
          } catch (error) {
            if (error instanceof error_2.WalletError) {
              return {
                isValid: false,
                signerVerkeys: []
              };
            }
            throw error;
          }
        }
        return { isValid: true, signerVerkeys };
      }
      /**
       * @todo This currently only work with a single alg, key type and curve
       *    This needs to be extended with other formats in the future
       */
      buildProtected(verkey) {
        return {
          alg: "EdDSA",
          jwk: {
            kty: "OKP",
            crv: "Ed25519",
            x: utils_1.TypedArrayEncoder.toBase64URL(utils_1.TypedArrayEncoder.fromBase58(verkey))
          }
        };
      }
    };
    JwsService = __decorate([
      (0, plugins_1.injectable)()
    ], JwsService);
    exports.JwsService = JwsService;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/DidExchangeStateMachine.js
var require_DidExchangeStateMachine = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/DidExchangeStateMachine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidExchangeStateMachine = void 0;
    var error_1 = require_error();
    var messageType_1 = require_messageType();
    var messages_1 = require_messages();
    var models_1 = require_models();
    var DidExchangeStateMachine = class {
      static assertCreateMessageState(messageType, record) {
        const rule = this.createMessageStateRules.find((r) => (0, messageType_1.canHandleMessageType)(r.message, messageType));
        if (!rule) {
          throw new error_1.AriesFrameworkError(`Could not find create message rule for ${messageType}`);
        }
        if (rule.state !== record.state || rule.role !== record.role) {
          throw new error_1.AriesFrameworkError(`Record with role ${record.role} is in invalid state ${record.state} to create ${messageType}. Expected state for role ${rule.role} is ${rule.state}.`);
        }
      }
      static assertProcessMessageState(messageType, record) {
        const rule = this.processMessageStateRules.find((r) => (0, messageType_1.canHandleMessageType)(r.message, messageType));
        if (!rule) {
          throw new error_1.AriesFrameworkError(`Could not find create message rule for ${messageType}`);
        }
        if (rule.state !== record.state || rule.role !== record.role) {
          throw new error_1.AriesFrameworkError(`Record with role ${record.role} is in invalid state ${record.state} to process ${messageType}. Expected state for role ${rule.role} is ${rule.state}.`);
        }
      }
      static nextState(messageType, record) {
        const rule = this.createMessageStateRules.concat(this.processMessageStateRules).find((r) => (0, messageType_1.canHandleMessageType)(r.message, messageType) && r.role === record.role);
        if (!rule) {
          throw new error_1.AriesFrameworkError(`Could not find create message rule for messageType ${messageType}, state ${record.state} and role ${record.role}`);
        }
        return rule.nextState;
      }
    };
    exports.DidExchangeStateMachine = DidExchangeStateMachine;
    DidExchangeStateMachine.createMessageStateRules = [
      {
        message: messages_1.DidExchangeRequestMessage,
        state: models_1.DidExchangeState.InvitationReceived,
        role: models_1.DidExchangeRole.Requester,
        nextState: models_1.DidExchangeState.RequestSent
      },
      {
        message: messages_1.DidExchangeResponseMessage,
        state: models_1.DidExchangeState.RequestReceived,
        role: models_1.DidExchangeRole.Responder,
        nextState: models_1.DidExchangeState.ResponseSent
      },
      {
        message: messages_1.DidExchangeCompleteMessage,
        state: models_1.DidExchangeState.ResponseReceived,
        role: models_1.DidExchangeRole.Requester,
        nextState: models_1.DidExchangeState.Completed
      }
    ];
    DidExchangeStateMachine.processMessageStateRules = [
      {
        message: messages_1.DidExchangeRequestMessage,
        state: models_1.DidExchangeState.InvitationSent,
        role: models_1.DidExchangeRole.Responder,
        nextState: models_1.DidExchangeState.RequestReceived
      },
      {
        message: messages_1.DidExchangeResponseMessage,
        state: models_1.DidExchangeState.RequestSent,
        role: models_1.DidExchangeRole.Requester,
        nextState: models_1.DidExchangeState.ResponseReceived
      },
      {
        message: messages_1.DidExchangeCompleteMessage,
        state: models_1.DidExchangeState.ResponseSent,
        role: models_1.DidExchangeRole.Responder,
        nextState: models_1.DidExchangeState.Completed
      }
    ];
  }
});

// node_modules/@aries-framework/core/build/modules/connections/DidExchangeProtocol.js
var require_DidExchangeProtocol = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/DidExchangeProtocol.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidExchangeProtocol = void 0;
    var constants_1 = require_constants();
    var crypto_1 = require_crypto();
    var JwsService_1 = require_JwsService();
    var Attachment_1 = require_Attachment();
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var JsonEncoder_1 = require_JsonEncoder();
    var JsonTransformer_1 = require_JsonTransformer();
    var dids_1 = require_dids();
    var key_type_1 = require_key_type();
    var helpers_1 = require_helpers();
    var repository_1 = require_repository();
    var OutOfBandRole_1 = require_OutOfBandRole();
    var OutOfBandState_1 = require_OutOfBandState();
    var DidExchangeStateMachine_1 = require_DidExchangeStateMachine();
    var errors_1 = require_errors2();
    var DidExchangeCompleteMessage_1 = require_DidExchangeCompleteMessage();
    var DidExchangeRequestMessage_1 = require_DidExchangeRequestMessage();
    var DidExchangeResponseMessage_1 = require_DidExchangeResponseMessage();
    var models_1 = require_models();
    var services_1 = require_services3();
    var DidExchangeProtocol = class DidExchangeProtocol {
      constructor(connectionService, didRegistrarService, didRepository, jwsService, logger) {
        this.connectionService = connectionService;
        this.didRegistrarService = didRegistrarService;
        this.didRepository = didRepository;
        this.jwsService = jwsService;
        this.logger = logger;
      }
      async createRequest(agentContext, outOfBandRecord, params) {
        var _a, _b;
        this.logger.debug(`Create message ${DidExchangeRequestMessage_1.DidExchangeRequestMessage.type.messageTypeUri} start`, {
          outOfBandRecord,
          params
        });
        const { outOfBandInvitation } = outOfBandRecord;
        const { alias, goal, goalCode, routing, autoAcceptConnection } = params;
        const [invitationDid] = outOfBandInvitation.invitationDids;
        const connectionRecord = await this.connectionService.createConnection(agentContext, {
          protocol: models_1.HandshakeProtocol.DidExchange,
          role: models_1.DidExchangeRole.Requester,
          alias,
          state: models_1.DidExchangeState.InvitationReceived,
          theirLabel: outOfBandInvitation.label,
          mediatorId: (_a = routing.mediatorId) !== null && _a !== void 0 ? _a : outOfBandRecord.mediatorId,
          autoAcceptConnection: outOfBandRecord.autoAcceptConnection,
          outOfBandId: outOfBandRecord.id,
          invitationDid
        });
        DidExchangeStateMachine_1.DidExchangeStateMachine.assertCreateMessageState(DidExchangeRequestMessage_1.DidExchangeRequestMessage.type, connectionRecord);
        const label = (_b = params.label) !== null && _b !== void 0 ? _b : agentContext.config.label;
        const didDocument = await this.createPeerDidDoc(agentContext, this.routingToServices(routing));
        const parentThreadId = outOfBandInvitation.id;
        const message = new DidExchangeRequestMessage_1.DidExchangeRequestMessage({ label, parentThreadId, did: didDocument.id, goal, goalCode });
        if ((0, dids_1.getNumAlgoFromPeerDid)(didDocument.id) === dids_1.PeerDidNumAlgo.GenesisDoc) {
          const didDocAttach = await this.createSignedAttachment(agentContext, didDocument, [
            routing.recipientKey.publicKeyBase58
          ]);
          message.didDoc = didDocAttach;
        }
        connectionRecord.did = didDocument.id;
        connectionRecord.threadId = message.id;
        if (autoAcceptConnection !== void 0 || autoAcceptConnection !== null) {
          connectionRecord.autoAcceptConnection = autoAcceptConnection;
        }
        await this.updateState(agentContext, DidExchangeRequestMessage_1.DidExchangeRequestMessage.type, connectionRecord);
        this.logger.debug(`Create message ${DidExchangeRequestMessage_1.DidExchangeRequestMessage.type.messageTypeUri} end`, {
          connectionRecord,
          message
        });
        return { message, connectionRecord };
      }
      async processRequest(messageContext, outOfBandRecord) {
        var _a, _b;
        this.logger.debug(`Process message ${DidExchangeRequestMessage_1.DidExchangeRequestMessage.type.messageTypeUri} start`, {
          message: messageContext.message
        });
        outOfBandRecord.assertRole(OutOfBandRole_1.OutOfBandRole.Sender);
        outOfBandRecord.assertState(OutOfBandState_1.OutOfBandState.AwaitResponse);
        const { message } = messageContext;
        if (!((_a = message.thread) === null || _a === void 0 ? void 0 : _a.parentThreadId) || ((_b = message.thread) === null || _b === void 0 ? void 0 : _b.parentThreadId) !== outOfBandRecord.getTags().invitationId) {
          throw new errors_1.DidExchangeProblemReportError("Missing reference to invitation.", {
            problemCode: errors_1.DidExchangeProblemReportReason.RequestNotAccepted
          });
        }
        if (!message.did.startsWith("did:peer:")) {
          throw new errors_1.DidExchangeProblemReportError(`Message contains unsupported did ${message.did}. Supported dids are [did:peer]`, {
            problemCode: errors_1.DidExchangeProblemReportReason.RequestNotAccepted
          });
        }
        const numAlgo = (0, dids_1.getNumAlgoFromPeerDid)(message.did);
        if (numAlgo !== dids_1.PeerDidNumAlgo.GenesisDoc) {
          throw new errors_1.DidExchangeProblemReportError(`Unsupported numalgo ${numAlgo}. Supported numalgos are [${dids_1.PeerDidNumAlgo.GenesisDoc}]`, {
            problemCode: errors_1.DidExchangeProblemReportReason.RequestNotAccepted
          });
        }
        const didDocument = await this.extractDidDocument(messageContext.agentContext, message);
        const didRecord = new repository_1.DidRecord({
          did: message.did,
          role: dids_1.DidDocumentRole.Received,
          // It is important to take the did document from the PeerDid class
          // as it will have the id property
          didDocument,
          tags: {
            // We need to save the recipientKeys, so we can find the associated did
            // of a key when we receive a message from another connection.
            recipientKeyFingerprints: didDocument.recipientKeys.map((key) => key.fingerprint)
          }
        });
        this.logger.debug("Saving DID record", {
          id: didRecord.id,
          did: didRecord.did,
          role: didRecord.role,
          tags: didRecord.getTags(),
          didDocument: "omitted..."
        });
        await this.didRepository.save(messageContext.agentContext, didRecord);
        const connectionRecord = await this.connectionService.createConnection(messageContext.agentContext, {
          protocol: models_1.HandshakeProtocol.DidExchange,
          role: models_1.DidExchangeRole.Responder,
          state: models_1.DidExchangeState.RequestReceived,
          alias: outOfBandRecord.alias,
          theirDid: message.did,
          theirLabel: message.label,
          threadId: message.threadId,
          mediatorId: outOfBandRecord.mediatorId,
          autoAcceptConnection: outOfBandRecord.autoAcceptConnection,
          outOfBandId: outOfBandRecord.id
        });
        await this.updateState(messageContext.agentContext, DidExchangeRequestMessage_1.DidExchangeRequestMessage.type, connectionRecord);
        this.logger.debug(`Process message ${DidExchangeRequestMessage_1.DidExchangeRequestMessage.type.messageTypeUri} end`, connectionRecord);
        return connectionRecord;
      }
      async createResponse(agentContext, connectionRecord, outOfBandRecord, routing) {
        this.logger.debug(`Create message ${DidExchangeResponseMessage_1.DidExchangeResponseMessage.type.messageTypeUri} start`, connectionRecord);
        DidExchangeStateMachine_1.DidExchangeStateMachine.assertCreateMessageState(DidExchangeResponseMessage_1.DidExchangeResponseMessage.type, connectionRecord);
        const { threadId } = connectionRecord;
        if (!threadId) {
          throw new error_1.AriesFrameworkError("Missing threadId on connection record.");
        }
        let services = [];
        if (routing) {
          services = this.routingToServices(routing);
        } else if (outOfBandRecord) {
          const inlineServices = outOfBandRecord.outOfBandInvitation.getInlineServices();
          services = inlineServices.map((service) => {
            var _a, _b;
            return {
              id: service.id,
              serviceEndpoint: service.serviceEndpoint,
              recipientKeys: service.recipientKeys.map(helpers_1.didKeyToInstanceOfKey),
              routingKeys: (_b = (_a = service.routingKeys) === null || _a === void 0 ? void 0 : _a.map(helpers_1.didKeyToInstanceOfKey)) !== null && _b !== void 0 ? _b : []
            };
          });
        }
        const didDocument = await this.createPeerDidDoc(agentContext, services);
        const message = new DidExchangeResponseMessage_1.DidExchangeResponseMessage({ did: didDocument.id, threadId });
        if ((0, dids_1.getNumAlgoFromPeerDid)(didDocument.id) === dids_1.PeerDidNumAlgo.GenesisDoc) {
          const didDocAttach = await this.createSignedAttachment(agentContext, didDocument, Array.from(new Set(services.map((s) => s.recipientKeys).reduce((acc, curr) => acc.concat(curr), []).map((key) => key.publicKeyBase58))));
          message.didDoc = didDocAttach;
        }
        connectionRecord.did = didDocument.id;
        await this.updateState(agentContext, DidExchangeResponseMessage_1.DidExchangeResponseMessage.type, connectionRecord);
        this.logger.debug(`Create message ${DidExchangeResponseMessage_1.DidExchangeResponseMessage.type.messageTypeUri} end`, {
          connectionRecord,
          message
        });
        return message;
      }
      async processResponse(messageContext, outOfBandRecord) {
        var _a, _b;
        this.logger.debug(`Process message ${DidExchangeResponseMessage_1.DidExchangeResponseMessage.type.messageTypeUri} start`, {
          message: messageContext.message
        });
        const { connection: connectionRecord, message } = messageContext;
        if (!connectionRecord) {
          throw new error_1.AriesFrameworkError("No connection record in message context.");
        }
        DidExchangeStateMachine_1.DidExchangeStateMachine.assertProcessMessageState(DidExchangeResponseMessage_1.DidExchangeResponseMessage.type, connectionRecord);
        if (!((_a = message.thread) === null || _a === void 0 ? void 0 : _a.threadId) || ((_b = message.thread) === null || _b === void 0 ? void 0 : _b.threadId) !== connectionRecord.threadId) {
          throw new errors_1.DidExchangeProblemReportError("Invalid or missing thread ID.", {
            problemCode: errors_1.DidExchangeProblemReportReason.ResponseNotAccepted
          });
        }
        if (!message.did.startsWith("did:peer:")) {
          throw new errors_1.DidExchangeProblemReportError(`Message contains unsupported did ${message.did}. Supported dids are [did:peer]`, {
            problemCode: errors_1.DidExchangeProblemReportReason.ResponseNotAccepted
          });
        }
        const numAlgo = (0, dids_1.getNumAlgoFromPeerDid)(message.did);
        if (numAlgo !== dids_1.PeerDidNumAlgo.GenesisDoc) {
          throw new errors_1.DidExchangeProblemReportError(`Unsupported numalgo ${numAlgo}. Supported numalgos are [${dids_1.PeerDidNumAlgo.GenesisDoc}]`, {
            problemCode: errors_1.DidExchangeProblemReportReason.ResponseNotAccepted
          });
        }
        const didDocument = await this.extractDidDocument(messageContext.agentContext, message, outOfBandRecord.getTags().recipientKeyFingerprints.map((fingerprint) => crypto_1.Key.fromFingerprint(fingerprint).publicKeyBase58));
        const didRecord = new repository_1.DidRecord({
          did: message.did,
          role: dids_1.DidDocumentRole.Received,
          didDocument,
          tags: {
            // We need to save the recipientKeys, so we can find the associated did
            // of a key when we receive a message from another connection.
            recipientKeyFingerprints: didDocument.recipientKeys.map((key) => key.fingerprint)
          }
        });
        this.logger.debug("Saving DID record", {
          id: didRecord.id,
          did: didRecord.did,
          role: didRecord.role,
          tags: didRecord.getTags(),
          didDocument: "omitted..."
        });
        await this.didRepository.save(messageContext.agentContext, didRecord);
        connectionRecord.theirDid = message.did;
        await this.updateState(messageContext.agentContext, DidExchangeResponseMessage_1.DidExchangeResponseMessage.type, connectionRecord);
        this.logger.debug(`Process message ${DidExchangeResponseMessage_1.DidExchangeResponseMessage.type.messageTypeUri} end`, connectionRecord);
        return connectionRecord;
      }
      async createComplete(agentContext, connectionRecord, outOfBandRecord) {
        this.logger.debug(`Create message ${DidExchangeCompleteMessage_1.DidExchangeCompleteMessage.type.messageTypeUri} start`, connectionRecord);
        DidExchangeStateMachine_1.DidExchangeStateMachine.assertCreateMessageState(DidExchangeCompleteMessage_1.DidExchangeCompleteMessage.type, connectionRecord);
        const threadId = connectionRecord.threadId;
        const parentThreadId = outOfBandRecord.outOfBandInvitation.id;
        if (!threadId) {
          throw new error_1.AriesFrameworkError(`Connection record ${connectionRecord.id} does not have 'threadId' attribute.`);
        }
        if (!parentThreadId) {
          throw new error_1.AriesFrameworkError(`Connection record ${connectionRecord.id} does not have 'parentThreadId' attribute.`);
        }
        const message = new DidExchangeCompleteMessage_1.DidExchangeCompleteMessage({ threadId, parentThreadId });
        await this.updateState(agentContext, DidExchangeCompleteMessage_1.DidExchangeCompleteMessage.type, connectionRecord);
        this.logger.debug(`Create message ${DidExchangeCompleteMessage_1.DidExchangeCompleteMessage.type.messageTypeUri} end`, {
          connectionRecord,
          message
        });
        return message;
      }
      async processComplete(messageContext, outOfBandRecord) {
        var _a, _b;
        this.logger.debug(`Process message ${DidExchangeCompleteMessage_1.DidExchangeCompleteMessage.type.messageTypeUri} start`, {
          message: messageContext.message
        });
        const { connection: connectionRecord, message } = messageContext;
        if (!connectionRecord) {
          throw new error_1.AriesFrameworkError("No connection record in message context.");
        }
        DidExchangeStateMachine_1.DidExchangeStateMachine.assertProcessMessageState(DidExchangeCompleteMessage_1.DidExchangeCompleteMessage.type, connectionRecord);
        if (message.threadId !== connectionRecord.threadId) {
          throw new errors_1.DidExchangeProblemReportError("Invalid or missing thread ID.", {
            problemCode: errors_1.DidExchangeProblemReportReason.CompleteRejected
          });
        }
        if (!((_a = message.thread) === null || _a === void 0 ? void 0 : _a.parentThreadId) || ((_b = message.thread) === null || _b === void 0 ? void 0 : _b.parentThreadId) !== outOfBandRecord.getTags().invitationId) {
          throw new errors_1.DidExchangeProblemReportError("Invalid or missing parent thread ID referencing to the invitation.", {
            problemCode: errors_1.DidExchangeProblemReportReason.CompleteRejected
          });
        }
        await this.updateState(messageContext.agentContext, DidExchangeCompleteMessage_1.DidExchangeCompleteMessage.type, connectionRecord);
        this.logger.debug(`Process message ${DidExchangeCompleteMessage_1.DidExchangeCompleteMessage.type.messageTypeUri} end`, { connectionRecord });
        return connectionRecord;
      }
      async updateState(agentContext, messageType, connectionRecord) {
        this.logger.debug(`Updating state`, { connectionRecord });
        const nextState = DidExchangeStateMachine_1.DidExchangeStateMachine.nextState(messageType, connectionRecord);
        return this.connectionService.updateState(agentContext, connectionRecord, nextState);
      }
      async createPeerDidDoc(agentContext, services) {
        var _a;
        const didDocument = (0, dids_1.createPeerDidDocumentFromServices)(services);
        const result2 = await this.didRegistrarService.create(agentContext, {
          method: "peer",
          didDocument,
          options: {
            numAlgo: dids_1.PeerDidNumAlgo.GenesisDoc
          }
        });
        if (((_a = result2.didState) === null || _a === void 0 ? void 0 : _a.state) !== "finished") {
          throw new error_1.AriesFrameworkError(`Did document creation failed: ${JSON.stringify(result2.didState)}`);
        }
        this.logger.debug(`Did document with did ${result2.didState.did} created.`, {
          did: result2.didState.did,
          didDocument: result2.didState.didDocument
        });
        return result2.didState.didDocument;
      }
      async createSignedAttachment(agentContext, didDoc, verkeys) {
        const didDocAttach = new Attachment_1.Attachment({
          mimeType: "application/json",
          data: new Attachment_1.AttachmentData({
            base64: JsonEncoder_1.JsonEncoder.toBase64(didDoc)
          })
        });
        await Promise.all(verkeys.map(async (verkey) => {
          const key = crypto_1.Key.fromPublicKeyBase58(verkey, crypto_1.KeyType.Ed25519);
          const kid = new dids_1.DidKey(key).did;
          const payload = JsonEncoder_1.JsonEncoder.toBuffer(didDoc);
          const jws = await this.jwsService.createJws(agentContext, {
            payload,
            verkey,
            header: {
              kid
            }
          });
          didDocAttach.addJws(jws);
        }));
        return didDocAttach;
      }
      /**
       * Extracts DID document as is from request or response message attachment and verifies its signature.
       *
       * @param message DID request or DID response message
       * @param invitationKeys array containing keys from connection invitation that could be used for signing of DID document
       * @returns verified DID document content from message attachment
       */
      async extractDidDocument(agentContext, message, invitationKeysBase58 = []) {
        var _a;
        if (!message.didDoc) {
          const problemCode = message instanceof DidExchangeRequestMessage_1.DidExchangeRequestMessage ? errors_1.DidExchangeProblemReportReason.RequestNotAccepted : errors_1.DidExchangeProblemReportReason.ResponseNotAccepted;
          throw new errors_1.DidExchangeProblemReportError("DID Document attachment is missing.", { problemCode });
        }
        const didDocumentAttachment = message.didDoc;
        const jws = didDocumentAttachment.data.jws;
        if (!jws) {
          const problemCode = message instanceof DidExchangeRequestMessage_1.DidExchangeRequestMessage ? errors_1.DidExchangeProblemReportReason.RequestNotAccepted : errors_1.DidExchangeProblemReportReason.ResponseNotAccepted;
          throw new errors_1.DidExchangeProblemReportError("DID Document signature is missing.", { problemCode });
        }
        const json = didDocumentAttachment.getDataAsJson();
        this.logger.trace("DidDocument JSON", json);
        const payload = JsonEncoder_1.JsonEncoder.toBuffer(json);
        const { isValid, signerVerkeys } = await this.jwsService.verifyJws(agentContext, { jws, payload });
        const didDocument = JsonTransformer_1.JsonTransformer.fromJSON(json, dids_1.DidDocument);
        const didDocumentKeysBase58 = (_a = didDocument.authentication) === null || _a === void 0 ? void 0 : _a.map((authentication) => {
          const verificationMethod = typeof authentication === "string" ? didDocument.dereferenceVerificationMethod(authentication) : authentication;
          const { getKeyFromVerificationMethod } = (0, key_type_1.getKeyDidMappingByVerificationMethod)(verificationMethod);
          const key = getKeyFromVerificationMethod(verificationMethod);
          return key.publicKeyBase58;
        }).concat(invitationKeysBase58);
        this.logger.trace("JWS verification result", { isValid, signerVerkeys, didDocumentKeysBase58 });
        if (!isValid || !signerVerkeys.every((verkey) => didDocumentKeysBase58 === null || didDocumentKeysBase58 === void 0 ? void 0 : didDocumentKeysBase58.includes(verkey))) {
          const problemCode = message instanceof DidExchangeRequestMessage_1.DidExchangeRequestMessage ? errors_1.DidExchangeProblemReportReason.RequestNotAccepted : errors_1.DidExchangeProblemReportReason.ResponseNotAccepted;
          throw new errors_1.DidExchangeProblemReportError("DID Document signature is invalid.", { problemCode });
        }
        return didDocument;
      }
      routingToServices(routing) {
        return routing.endpoints.map((endpoint, index) => ({
          id: `#inline-${index}`,
          serviceEndpoint: endpoint,
          recipientKeys: [routing.recipientKey],
          routingKeys: routing.routingKeys
        }));
      }
    };
    DidExchangeProtocol = __decorate([
      (0, plugins_1.injectable)(),
      __param(4, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [
        services_1.ConnectionService,
        dids_1.DidRegistrarService,
        repository_1.DidRepository,
        JwsService_1.JwsService,
        Object
      ])
    ], DidExchangeProtocol);
    exports.DidExchangeProtocol = DidExchangeProtocol;
  }
});

// node_modules/@aries-framework/core/build/modules/common/messages/AckMessage.js
var require_AckMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/common/messages/AckMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AckMessage = exports.AckStatus = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var AckStatus;
    (function(AckStatus2) {
      AckStatus2["OK"] = "OK";
      AckStatus2["PENDING"] = "PENDING";
    })(AckStatus = exports.AckStatus || (exports.AckStatus = {}));
    var AckMessage = class extends AgentMessage_1.AgentMessage {
      /**
       * Create new AckMessage instance.
       * @param options
       */
      constructor(options) {
        super();
        this.type = AckMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.status = options.status;
          this.setThread({
            threadId: options.threadId
          });
        }
      }
    };
    AckMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/notification/1.0/ack");
    __decorate([
      (0, messageType_1.IsValidMessageType)(AckMessage.type),
      __metadata("design:type", String)
    ], AckMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsEnum)(AckStatus),
      __metadata("design:type", String)
    ], AckMessage.prototype, "status", void 0);
    exports.AckMessage = AckMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/common/index.js
var require_common = __commonJS({
  "node_modules/@aries-framework/core/build/modules/common/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_AckMessage(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/connections/handlers/AckMessageHandler.js
var require_AckMessageHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/handlers/AckMessageHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AckMessageHandler = void 0;
    var common_1 = require_common();
    var AckMessageHandler = class {
      constructor(connectionService) {
        this.supportedMessages = [common_1.AckMessage];
        this.connectionService = connectionService;
      }
      async handle(inboundMessage) {
        await this.connectionService.processAck(inboundMessage);
      }
    };
    exports.AckMessageHandler = AckMessageHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/handlers/ConnectionRequestHandler.js
var require_ConnectionRequestHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/handlers/ConnectionRequestHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionRequestHandler = void 0;
    var models_1 = require_models3();
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var messages_1 = require_messages();
    var ConnectionRequestHandler = class {
      constructor(connectionService, outOfBandService, routingService, didRepository, connectionsModuleConfig) {
        this.supportedMessages = [messages_1.ConnectionRequestMessage];
        this.connectionService = connectionService;
        this.outOfBandService = outOfBandService;
        this.routingService = routingService;
        this.didRepository = didRepository;
        this.connectionsModuleConfig = connectionsModuleConfig;
      }
      async handle(messageContext) {
        var _a;
        const { connection, recipientKey, senderKey } = messageContext;
        if (!recipientKey || !senderKey) {
          throw new AriesFrameworkError_1.AriesFrameworkError("Unable to process connection request without senderVerkey or recipientKey");
        }
        const outOfBandRecord = await this.outOfBandService.findCreatedByRecipientKey(messageContext.agentContext, recipientKey);
        if (!outOfBandRecord) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`Out-of-band record for recipient key ${recipientKey.fingerprint} was not found.`);
        }
        if (connection && !outOfBandRecord.reusable) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`Connection record for non-reusable out-of-band ${outOfBandRecord.id} already exists.`);
        }
        const receivedDidRecord = await this.didRepository.findReceivedDidByRecipientKey(messageContext.agentContext, senderKey);
        if (receivedDidRecord) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`A received did record for sender key ${senderKey.fingerprint} already exists.`);
        }
        const connectionRecord = await this.connectionService.processRequest(messageContext, outOfBandRecord);
        if ((_a = connectionRecord === null || connectionRecord === void 0 ? void 0 : connectionRecord.autoAcceptConnection) !== null && _a !== void 0 ? _a : this.connectionsModuleConfig.autoAcceptConnections) {
          const routing = outOfBandRecord.reusable ? await this.routingService.getRouting(messageContext.agentContext) : void 0;
          const { message } = await this.connectionService.createResponse(messageContext.agentContext, connectionRecord, outOfBandRecord, routing);
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            connection: connectionRecord,
            outOfBand: outOfBandRecord
          });
        }
      }
    };
    exports.ConnectionRequestHandler = ConnectionRequestHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/handlers/ConnectionResponseHandler.js
var require_ConnectionResponseHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/handlers/ConnectionResponseHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionResponseHandler = void 0;
    var models_1 = require_models3();
    var TransportDecorator_1 = require_TransportDecorator();
    var error_1 = require_error();
    var messages_1 = require_messages();
    var models_2 = require_models();
    var ConnectionResponseHandler = class {
      constructor(connectionService, outOfBandService, didResolverService, connectionsModuleConfig) {
        this.supportedMessages = [messages_1.ConnectionResponseMessage];
        this.connectionService = connectionService;
        this.outOfBandService = outOfBandService;
        this.didResolverService = didResolverService;
        this.connectionsModuleConfig = connectionsModuleConfig;
      }
      async handle(messageContext) {
        var _a;
        const { recipientKey, senderKey, message } = messageContext;
        if (!recipientKey || !senderKey) {
          throw new error_1.AriesFrameworkError("Unable to process connection response without senderKey or recipientKey");
        }
        const connectionRecord = await this.connectionService.getByRoleAndThreadId(messageContext.agentContext, models_2.DidExchangeRole.Requester, message.threadId);
        if (!connectionRecord) {
          throw new error_1.AriesFrameworkError(`Connection for thread ID ${message.threadId} not found!`);
        }
        if (!connectionRecord.did) {
          throw new error_1.AriesFrameworkError(`Connection record ${connectionRecord.id} has no 'did'`);
        }
        const ourDidDocument = await this.didResolverService.resolveDidDocument(messageContext.agentContext, connectionRecord.did);
        if (!ourDidDocument) {
          throw new error_1.AriesFrameworkError(`Did document for did ${connectionRecord.did} was not resolved!`);
        }
        if (!ourDidDocument.recipientKeys.find((key) => key.fingerprint === recipientKey.fingerprint)) {
          throw new error_1.AriesFrameworkError(`Recipient key ${recipientKey.fingerprint} not found in did document recipient keys.`);
        }
        const outOfBandRecord = connectionRecord.outOfBandId && await this.outOfBandService.findById(messageContext.agentContext, connectionRecord.outOfBandId);
        if (!outOfBandRecord) {
          throw new error_1.AriesFrameworkError(`Out-of-band record ${connectionRecord.outOfBandId} was not found.`);
        }
        messageContext.connection = connectionRecord;
        const connection = await this.connectionService.processResponse(messageContext, outOfBandRecord);
        if ((_a = connection.autoAcceptConnection) !== null && _a !== void 0 ? _a : this.connectionsModuleConfig.autoAcceptConnections) {
          const { message: message2 } = await this.connectionService.createTrustPing(messageContext.agentContext, connection, {
            responseRequested: false
          });
          message2.setReturnRouting(TransportDecorator_1.ReturnRouteTypes.none);
          return new models_1.OutboundMessageContext(message2, { agentContext: messageContext.agentContext, connection });
        }
      }
    };
    exports.ConnectionResponseHandler = ConnectionResponseHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/handlers/TrustPingMessageHandler.js
var require_TrustPingMessageHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/handlers/TrustPingMessageHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TrustPingMessageHandler = void 0;
    var error_1 = require_error();
    var messages_1 = require_messages();
    var models_1 = require_models();
    var TrustPingMessageHandler = class {
      constructor(trustPingService, connectionService) {
        this.supportedMessages = [messages_1.TrustPingMessage];
        this.trustPingService = trustPingService;
        this.connectionService = connectionService;
      }
      async handle(messageContext) {
        const { connection, recipientKey } = messageContext;
        if (!connection) {
          throw new error_1.AriesFrameworkError(`Connection for verkey ${recipientKey === null || recipientKey === void 0 ? void 0 : recipientKey.fingerprint} not found!`);
        }
        if (connection.state === models_1.DidExchangeState.ResponseSent) {
          await this.connectionService.updateState(messageContext.agentContext, connection, models_1.DidExchangeState.Completed);
        }
        return this.trustPingService.processPing(messageContext, connection);
      }
    };
    exports.TrustPingMessageHandler = TrustPingMessageHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/handlers/TrustPingResponseMessageHandler.js
var require_TrustPingResponseMessageHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/handlers/TrustPingResponseMessageHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TrustPingResponseMessageHandler = void 0;
    var messages_1 = require_messages();
    var TrustPingResponseMessageHandler = class {
      constructor(trustPingService) {
        this.supportedMessages = [messages_1.TrustPingResponseMessage];
        this.trustPingService = trustPingService;
      }
      async handle(inboundMessage) {
        return this.trustPingService.processPingResponse(inboundMessage);
      }
    };
    exports.TrustPingResponseMessageHandler = TrustPingResponseMessageHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/handlers/DidExchangeRequestHandler.js
var require_DidExchangeRequestHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/handlers/DidExchangeRequestHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidExchangeRequestHandler = void 0;
    var models_1 = require_models3();
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var OutOfBandState_1 = require_OutOfBandState();
    var messages_1 = require_messages();
    var DidExchangeRequestHandler = class {
      constructor(didExchangeProtocol, outOfBandService, routingService, didRepository, connectionsModuleConfig) {
        this.supportedMessages = [messages_1.DidExchangeRequestMessage];
        this.didExchangeProtocol = didExchangeProtocol;
        this.outOfBandService = outOfBandService;
        this.routingService = routingService;
        this.didRepository = didRepository;
        this.connectionsModuleConfig = connectionsModuleConfig;
      }
      async handle(messageContext) {
        var _a, _b, _c;
        const { recipientKey, senderKey, message, connection } = messageContext;
        if (!recipientKey || !senderKey) {
          throw new AriesFrameworkError_1.AriesFrameworkError("Unable to process connection request without senderKey or recipientKey");
        }
        if (!((_a = message.thread) === null || _a === void 0 ? void 0 : _a.parentThreadId)) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`Message does not contain 'pthid' attribute`);
        }
        const outOfBandRecord = await this.outOfBandService.findByCreatedInvitationId(messageContext.agentContext, message.thread.parentThreadId);
        if (!outOfBandRecord) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`OutOfBand record for message ID ${(_b = message.thread) === null || _b === void 0 ? void 0 : _b.parentThreadId} not found!`);
        }
        if (connection && !outOfBandRecord.reusable) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`Connection record for non-reusable out-of-band ${outOfBandRecord.id} already exists.`);
        }
        const receivedDidRecord = await this.didRepository.findReceivedDidByRecipientKey(messageContext.agentContext, senderKey);
        if (receivedDidRecord) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`A received did record for sender key ${senderKey.fingerprint} already exists.`);
        }
        if (outOfBandRecord.state === OutOfBandState_1.OutOfBandState.Done) {
          throw new AriesFrameworkError_1.AriesFrameworkError("Out-of-band record has been already processed and it does not accept any new requests");
        }
        const connectionRecord = await this.didExchangeProtocol.processRequest(messageContext, outOfBandRecord);
        if ((_c = connectionRecord.autoAcceptConnection) !== null && _c !== void 0 ? _c : this.connectionsModuleConfig.autoAcceptConnections) {
          const routing = outOfBandRecord.reusable ? await this.routingService.getRouting(messageContext.agentContext) : void 0;
          const message2 = await this.didExchangeProtocol.createResponse(messageContext.agentContext, connectionRecord, outOfBandRecord, routing);
          return new models_1.OutboundMessageContext(message2, {
            agentContext: messageContext.agentContext,
            connection: connectionRecord,
            outOfBand: outOfBandRecord
          });
        }
      }
    };
    exports.DidExchangeRequestHandler = DidExchangeRequestHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/handlers/DidExchangeResponseHandler.js
var require_DidExchangeResponseHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/handlers/DidExchangeResponseHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidExchangeResponseHandler = void 0;
    var models_1 = require_models3();
    var TransportDecorator_1 = require_TransportDecorator();
    var error_1 = require_error();
    var OutOfBandState_1 = require_OutOfBandState();
    var messages_1 = require_messages();
    var models_2 = require_models();
    var DidExchangeResponseHandler = class {
      constructor(didExchangeProtocol, outOfBandService, connectionService, didResolverService, connectionsModuleConfig) {
        this.supportedMessages = [messages_1.DidExchangeResponseMessage];
        this.didExchangeProtocol = didExchangeProtocol;
        this.outOfBandService = outOfBandService;
        this.connectionService = connectionService;
        this.didResolverService = didResolverService;
        this.connectionsModuleConfig = connectionsModuleConfig;
      }
      async handle(messageContext) {
        var _a;
        const { agentContext, recipientKey, senderKey, message } = messageContext;
        if (!recipientKey || !senderKey) {
          throw new error_1.AriesFrameworkError("Unable to process connection response without sender key or recipient key");
        }
        const connectionRecord = await this.connectionService.getByRoleAndThreadId(agentContext, models_2.DidExchangeRole.Requester, message.threadId);
        if (!connectionRecord) {
          throw new error_1.AriesFrameworkError(`Connection for thread ID ${message.threadId} not found!`);
        }
        if (!connectionRecord.did) {
          throw new error_1.AriesFrameworkError(`Connection record ${connectionRecord.id} has no 'did'`);
        }
        const ourDidDocument = await this.didResolverService.resolveDidDocument(agentContext, connectionRecord.did);
        if (!ourDidDocument) {
          throw new error_1.AriesFrameworkError(`Did document for did ${connectionRecord.did} was not resolved`);
        }
        if (!ourDidDocument.recipientKeys.find((key) => key.fingerprint === recipientKey.fingerprint)) {
          throw new error_1.AriesFrameworkError(`Recipient key ${recipientKey.fingerprint} not found in did document recipient keys.`);
        }
        const { protocol } = connectionRecord;
        if (protocol !== models_2.HandshakeProtocol.DidExchange) {
          throw new error_1.AriesFrameworkError(`Connection record protocol is ${protocol} but handler supports only ${models_2.HandshakeProtocol.DidExchange}.`);
        }
        if (!connectionRecord.outOfBandId) {
          throw new error_1.AriesFrameworkError(`Connection ${connectionRecord.id} does not have outOfBandId!`);
        }
        const outOfBandRecord = await this.outOfBandService.findById(agentContext, connectionRecord.outOfBandId);
        if (!outOfBandRecord) {
          throw new error_1.AriesFrameworkError(`OutOfBand record for connection ${connectionRecord.id} with outOfBandId ${connectionRecord.outOfBandId} not found!`);
        }
        messageContext.connection = connectionRecord;
        const connection = await this.didExchangeProtocol.processResponse(messageContext, outOfBandRecord);
        if ((_a = connection.autoAcceptConnection) !== null && _a !== void 0 ? _a : this.connectionsModuleConfig.autoAcceptConnections) {
          const message2 = await this.didExchangeProtocol.createComplete(agentContext, connection, outOfBandRecord);
          message2.setReturnRouting(TransportDecorator_1.ReturnRouteTypes.none);
          if (!outOfBandRecord.reusable) {
            await this.outOfBandService.updateState(agentContext, outOfBandRecord, OutOfBandState_1.OutOfBandState.Done);
          }
          return new models_1.OutboundMessageContext(message2, { agentContext, connection });
        }
      }
    };
    exports.DidExchangeResponseHandler = DidExchangeResponseHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/handlers/DidExchangeCompleteHandler.js
var require_DidExchangeCompleteHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/handlers/DidExchangeCompleteHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidExchangeCompleteHandler = void 0;
    var error_1 = require_error();
    var OutOfBandState_1 = require_OutOfBandState();
    var messages_1 = require_messages();
    var models_1 = require_models();
    var DidExchangeCompleteHandler = class {
      constructor(didExchangeProtocol, outOfBandService) {
        this.supportedMessages = [messages_1.DidExchangeCompleteMessage];
        this.didExchangeProtocol = didExchangeProtocol;
        this.outOfBandService = outOfBandService;
      }
      async handle(messageContext) {
        var _a, _b, _c;
        const { connection: connectionRecord } = messageContext;
        if (!connectionRecord) {
          throw new error_1.AriesFrameworkError(`Connection is missing in message context`);
        }
        const { protocol } = connectionRecord;
        if (protocol !== models_1.HandshakeProtocol.DidExchange) {
          throw new error_1.AriesFrameworkError(`Connection record protocol is ${protocol} but handler supports only ${models_1.HandshakeProtocol.DidExchange}.`);
        }
        const { message } = messageContext;
        if (!((_a = message.thread) === null || _a === void 0 ? void 0 : _a.parentThreadId)) {
          throw new error_1.AriesFrameworkError(`Message does not contain pthid attribute`);
        }
        const outOfBandRecord = await this.outOfBandService.findByCreatedInvitationId(messageContext.agentContext, (_b = message.thread) === null || _b === void 0 ? void 0 : _b.parentThreadId);
        if (!outOfBandRecord) {
          throw new error_1.AriesFrameworkError(`OutOfBand record for message ID ${(_c = message.thread) === null || _c === void 0 ? void 0 : _c.parentThreadId} not found!`);
        }
        if (!outOfBandRecord.reusable) {
          await this.outOfBandService.updateState(messageContext.agentContext, outOfBandRecord, OutOfBandState_1.OutOfBandState.Done);
        }
        await this.didExchangeProtocol.processComplete(messageContext, outOfBandRecord);
      }
    };
    exports.DidExchangeCompleteHandler = DidExchangeCompleteHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/handlers/index.js
var require_handlers = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/handlers/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_AckMessageHandler(), exports);
    __exportStar(require_ConnectionRequestHandler(), exports);
    __exportStar(require_ConnectionResponseHandler(), exports);
    __exportStar(require_TrustPingMessageHandler(), exports);
    __exportStar(require_TrustPingResponseMessageHandler(), exports);
    __exportStar(require_DidExchangeRequestHandler(), exports);
    __exportStar(require_DidExchangeResponseHandler(), exports);
    __exportStar(require_DidExchangeCompleteHandler(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/connections/ConnectionsApi.js
var require_ConnectionsApi = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/ConnectionsApi.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionsApi = void 0;
    var agent_1 = require_agent();
    var Dispatcher_1 = require_Dispatcher();
    var MessageSender_1 = require_MessageSender();
    var models_1 = require_models3();
    var TransportDecorator_1 = require_TransportDecorator();
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var dids_1 = require_dids();
    var repository_1 = require_repository();
    var OutOfBandService_1 = require_OutOfBandService();
    var RoutingService_1 = require_RoutingService();
    var ConnectionsModuleConfig_1 = require_ConnectionsModuleConfig();
    var DidExchangeProtocol_1 = require_DidExchangeProtocol();
    var handlers_1 = require_handlers();
    var models_2 = require_models();
    var ConnectionService_1 = require_ConnectionService();
    var TrustPingService_1 = require_TrustPingService();
    var ConnectionsApi = class ConnectionsApi {
      constructor(dispatcher, didExchangeProtocol, connectionService, outOfBandService, trustPingService, routingService, didRepository, didResolverService, messageSender, agentContext, connectionsModuleConfig) {
        this.didExchangeProtocol = didExchangeProtocol;
        this.connectionService = connectionService;
        this.outOfBandService = outOfBandService;
        this.trustPingService = trustPingService;
        this.routingService = routingService;
        this.didRepository = didRepository;
        this.messageSender = messageSender;
        this.didResolverService = didResolverService;
        this.agentContext = agentContext;
        this.config = connectionsModuleConfig;
        this.registerMessageHandlers(dispatcher);
      }
      async acceptOutOfBandInvitation(outOfBandRecord, config) {
        const { protocol, label, alias, imageUrl, autoAcceptConnection } = config;
        const routing = config.routing || await this.routingService.getRouting(this.agentContext, { mediatorId: outOfBandRecord.mediatorId });
        let result2;
        if (protocol === models_2.HandshakeProtocol.DidExchange) {
          result2 = await this.didExchangeProtocol.createRequest(this.agentContext, outOfBandRecord, {
            label,
            alias,
            routing,
            autoAcceptConnection
          });
        } else if (protocol === models_2.HandshakeProtocol.Connections) {
          result2 = await this.connectionService.createRequest(this.agentContext, outOfBandRecord, {
            label,
            alias,
            imageUrl,
            routing,
            autoAcceptConnection
          });
        } else {
          throw new error_1.AriesFrameworkError(`Unsupported handshake protocol ${protocol}.`);
        }
        const { message, connectionRecord } = result2;
        const outboundMessageContext = new models_1.OutboundMessageContext(message, {
          agentContext: this.agentContext,
          connection: connectionRecord,
          outOfBand: outOfBandRecord
        });
        await this.messageSender.sendMessage(outboundMessageContext);
        return connectionRecord;
      }
      /**
       * Accept a connection request as inviter (by sending a connection response message) for the connection with the specified connection id.
       * This is not needed when auto accepting of connection is enabled.
       *
       * @param connectionId the id of the connection for which to accept the request
       * @returns connection record
       */
      async acceptRequest(connectionId) {
        const connectionRecord = await this.connectionService.findById(this.agentContext, connectionId);
        if (!connectionRecord) {
          throw new error_1.AriesFrameworkError(`Connection record ${connectionId} not found.`);
        }
        if (!connectionRecord.outOfBandId) {
          throw new error_1.AriesFrameworkError(`Connection record ${connectionId} does not have out-of-band record.`);
        }
        const outOfBandRecord = await this.outOfBandService.findById(this.agentContext, connectionRecord.outOfBandId);
        if (!outOfBandRecord) {
          throw new error_1.AriesFrameworkError(`Out-of-band record ${connectionRecord.outOfBandId} not found.`);
        }
        const routing = outOfBandRecord.reusable ? await this.routingService.getRouting(this.agentContext) : void 0;
        let outboundMessageContext;
        if (connectionRecord.protocol === models_2.HandshakeProtocol.DidExchange) {
          const message = await this.didExchangeProtocol.createResponse(this.agentContext, connectionRecord, outOfBandRecord, routing);
          outboundMessageContext = new models_1.OutboundMessageContext(message, {
            agentContext: this.agentContext,
            connection: connectionRecord
          });
        } else {
          const { message } = await this.connectionService.createResponse(this.agentContext, connectionRecord, outOfBandRecord, routing);
          outboundMessageContext = new models_1.OutboundMessageContext(message, {
            agentContext: this.agentContext,
            connection: connectionRecord
          });
        }
        await this.messageSender.sendMessage(outboundMessageContext);
        return connectionRecord;
      }
      /**
       * Accept a connection response as invitee (by sending a trust ping message) for the connection with the specified connection id.
       * This is not needed when auto accepting of connection is enabled.
       *
       * @param connectionId the id of the connection for which to accept the response
       * @returns connection record
       */
      async acceptResponse(connectionId) {
        const connectionRecord = await this.connectionService.getById(this.agentContext, connectionId);
        let outboundMessageContext;
        if (connectionRecord.protocol === models_2.HandshakeProtocol.DidExchange) {
          if (!connectionRecord.outOfBandId) {
            throw new error_1.AriesFrameworkError(`Connection ${connectionRecord.id} does not have outOfBandId!`);
          }
          const outOfBandRecord = await this.outOfBandService.findById(this.agentContext, connectionRecord.outOfBandId);
          if (!outOfBandRecord) {
            throw new error_1.AriesFrameworkError(`OutOfBand record for connection ${connectionRecord.id} with outOfBandId ${connectionRecord.outOfBandId} not found!`);
          }
          const message = await this.didExchangeProtocol.createComplete(this.agentContext, connectionRecord, outOfBandRecord);
          message.setReturnRouting(TransportDecorator_1.ReturnRouteTypes.none);
          outboundMessageContext = new models_1.OutboundMessageContext(message, {
            agentContext: this.agentContext,
            connection: connectionRecord
          });
        } else {
          const { message } = await this.connectionService.createTrustPing(this.agentContext, connectionRecord, {
            responseRequested: false
          });
          message.setReturnRouting(TransportDecorator_1.ReturnRouteTypes.none);
          outboundMessageContext = new models_1.OutboundMessageContext(message, {
            agentContext: this.agentContext,
            connection: connectionRecord
          });
        }
        await this.messageSender.sendMessage(outboundMessageContext);
        return connectionRecord;
      }
      /**
       * Send a trust ping to an established connection
       *
       * @param connectionId the id of the connection for which to accept the response
       * @param responseRequested do we want a response to our ping
       * @param withReturnRouting do we want a response at the time of posting
       * @returns TurstPingMessage
       */
      async sendPing(connectionId, { responseRequested = true, withReturnRouting = void 0 }) {
        const connection = await this.getById(connectionId);
        const { message } = await this.connectionService.createTrustPing(this.agentContext, connection, {
          responseRequested
        });
        if (withReturnRouting === true) {
          message.setReturnRouting(TransportDecorator_1.ReturnRouteTypes.all);
        }
        if (withReturnRouting === false) {
          message.setReturnRouting(TransportDecorator_1.ReturnRouteTypes.none);
        }
        await this.messageSender.sendMessage(new models_1.OutboundMessageContext(message, { agentContext: this.agentContext, connection }));
        return message;
      }
      async returnWhenIsConnected(connectionId, options) {
        return this.connectionService.returnWhenIsConnected(this.agentContext, connectionId, options === null || options === void 0 ? void 0 : options.timeoutMs);
      }
      /**
       * Retrieve all connections records
       *
       * @returns List containing all connection records
       */
      getAll() {
        return this.connectionService.getAll(this.agentContext);
      }
      /**
       * Retrieve all connections records by specified query params
       *
       * @returns List containing all connection records matching specified query paramaters
       */
      findAllByQuery(query) {
        return this.connectionService.findAllByQuery(this.agentContext, query);
      }
      /**
       * Allows for the addition of connectionType to the record.
       *  Either updates or creates an array of string connection types
       * @param connectionId
       * @param type
       * @throws {RecordNotFoundError} If no record is found
       */
      async addConnectionType(connectionId, type) {
        const record = await this.getById(connectionId);
        await this.connectionService.addConnectionType(this.agentContext, record, type);
        return record;
      }
      /**
       * Removes the given tag from the given record found by connectionId, if the tag exists otherwise does nothing
       * @param connectionId
       * @param type
       * @throws {RecordNotFoundError} If no record is found
       */
      async removeConnectionType(connectionId, type) {
        const record = await this.getById(connectionId);
        await this.connectionService.removeConnectionType(this.agentContext, record, type);
        return record;
      }
      /**
       * Gets the known connection types for the record matching the given connectionId
       * @param connectionId
       * @returns An array of known connection types or null if none exist
       * @throws {RecordNotFoundError} If no record is found
       */
      async getConnectionTypes(connectionId) {
        const record = await this.getById(connectionId);
        return this.connectionService.getConnectionTypes(record);
      }
      /**
       *
       * @param connectionTypes An array of connection types to query for a match for
       * @returns a promise of ab array of connection records
       */
      async findAllByConnectionTypes(connectionTypes) {
        return this.connectionService.findAllByConnectionTypes(this.agentContext, connectionTypes);
      }
      /**
       * Retrieve a connection record by id
       *
       * @param connectionId The connection record id
       * @throws {RecordNotFoundError} If no record is found
       * @return The connection record
       *
       */
      getById(connectionId) {
        return this.connectionService.getById(this.agentContext, connectionId);
      }
      /**
       * Find a connection record by id
       *
       * @param connectionId the connection record id
       * @returns The connection record or null if not found
       */
      findById(connectionId) {
        return this.connectionService.findById(this.agentContext, connectionId);
      }
      /**
       * Delete a connection record by id
       *
       * @param connectionId the connection record id
       */
      async deleteById(connectionId) {
        const connection = await this.connectionService.getById(this.agentContext, connectionId);
        if (connection.mediatorId && connection.did) {
          const did = await this.didResolverService.resolve(this.agentContext, connection.did);
          if (did.didDocument) {
            await this.routingService.removeRouting(this.agentContext, {
              recipientKeys: did.didDocument.recipientKeys,
              mediatorId: connection.mediatorId
            });
          }
        }
        return this.connectionService.deleteById(this.agentContext, connectionId);
      }
      async findAllByOutOfBandId(outOfBandId) {
        return this.connectionService.findAllByOutOfBandId(this.agentContext, outOfBandId);
      }
      /**
       * Retrieve a connection record by thread id
       *
       * @param threadId The thread id
       * @throws {RecordNotFoundError} If no record is found
       * @throws {RecordDuplicateError} If multiple records are found
       * @returns The connection record
       */
      getByThreadId(threadId) {
        return this.connectionService.getByThreadId(this.agentContext, threadId);
      }
      async findByDid(did) {
        return this.connectionService.findByTheirDid(this.agentContext, did);
      }
      async findByInvitationDid(invitationDid) {
        return this.connectionService.findByInvitationDid(this.agentContext, invitationDid);
      }
      registerMessageHandlers(dispatcher) {
        dispatcher.registerMessageHandler(new handlers_1.ConnectionRequestHandler(this.connectionService, this.outOfBandService, this.routingService, this.didRepository, this.config));
        dispatcher.registerMessageHandler(new handlers_1.ConnectionResponseHandler(this.connectionService, this.outOfBandService, this.didResolverService, this.config));
        dispatcher.registerMessageHandler(new handlers_1.AckMessageHandler(this.connectionService));
        dispatcher.registerMessageHandler(new handlers_1.TrustPingMessageHandler(this.trustPingService, this.connectionService));
        dispatcher.registerMessageHandler(new handlers_1.TrustPingResponseMessageHandler(this.trustPingService));
        dispatcher.registerMessageHandler(new handlers_1.DidExchangeRequestHandler(this.didExchangeProtocol, this.outOfBandService, this.routingService, this.didRepository, this.config));
        dispatcher.registerMessageHandler(new handlers_1.DidExchangeResponseHandler(this.didExchangeProtocol, this.outOfBandService, this.connectionService, this.didResolverService, this.config));
        dispatcher.registerMessageHandler(new handlers_1.DidExchangeCompleteHandler(this.didExchangeProtocol, this.outOfBandService));
      }
    };
    ConnectionsApi = __decorate([
      (0, plugins_1.injectable)(),
      __metadata("design:paramtypes", [
        Dispatcher_1.Dispatcher,
        DidExchangeProtocol_1.DidExchangeProtocol,
        ConnectionService_1.ConnectionService,
        OutOfBandService_1.OutOfBandService,
        TrustPingService_1.TrustPingService,
        RoutingService_1.RoutingService,
        repository_1.DidRepository,
        dids_1.DidResolverService,
        MessageSender_1.MessageSender,
        agent_1.AgentContext,
        ConnectionsModuleConfig_1.ConnectionsModuleConfig
      ])
    ], ConnectionsApi);
    exports.ConnectionsApi = ConnectionsApi;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/ConnectionsModule.js
var require_ConnectionsModule = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/ConnectionsModule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionsModule = void 0;
    var models_1 = require_models3();
    var ConnectionsApi_1 = require_ConnectionsApi();
    var ConnectionsModuleConfig_1 = require_ConnectionsModuleConfig();
    var DidExchangeProtocol_1 = require_DidExchangeProtocol();
    var models_2 = require_models();
    var repository_1 = require_repository2();
    var services_1 = require_services3();
    var ConnectionsModule = class {
      constructor(config) {
        this.api = ConnectionsApi_1.ConnectionsApi;
        this.config = new ConnectionsModuleConfig_1.ConnectionsModuleConfig(config);
      }
      /**
       * Registers the dependencies of the connections module on the dependency manager.
       */
      register(dependencyManager, featureRegistry) {
        dependencyManager.registerContextScoped(ConnectionsApi_1.ConnectionsApi);
        dependencyManager.registerInstance(ConnectionsModuleConfig_1.ConnectionsModuleConfig, this.config);
        dependencyManager.registerSingleton(services_1.ConnectionService);
        dependencyManager.registerSingleton(DidExchangeProtocol_1.DidExchangeProtocol);
        dependencyManager.registerSingleton(services_1.TrustPingService);
        dependencyManager.registerSingleton(repository_1.ConnectionRepository);
        featureRegistry.register(new models_1.Protocol({
          id: "https://didcomm.org/connections/1.0",
          roles: [models_2.ConnectionRole.Invitee, models_2.ConnectionRole.Inviter]
        }), new models_1.Protocol({
          id: "https://didcomm.org/didexchange/1.0",
          roles: [models_2.DidExchangeRole.Requester, models_2.DidExchangeRole.Responder]
        }));
      }
    };
    exports.ConnectionsModule = ConnectionsModule;
  }
});

// node_modules/@aries-framework/core/build/modules/connections/index.js
var require_connections = __commonJS({
  "node_modules/@aries-framework/core/build/modules/connections/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_messages(), exports);
    __exportStar(require_models(), exports);
    __exportStar(require_repository2(), exports);
    __exportStar(require_services3(), exports);
    __exportStar(require_ConnectionEvents(), exports);
    __exportStar(require_TrustPingEvents(), exports);
    __exportStar(require_ConnectionsApi(), exports);
    __exportStar(require_DidExchangeProtocol(), exports);
    __exportStar(require_ConnectionsModuleConfig(), exports);
    __exportStar(require_ConnectionsModule(), exports);
  }
});

// node_modules/@aries-framework/core/build/agent/MessageReceiver.js
var require_MessageReceiver = __commonJS({
  "node_modules/@aries-framework/core/build/agent/MessageReceiver.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageReceiver = void 0;
    var constants_1 = require_constants();
    var error_1 = require_error();
    var connections_1 = require_connections();
    var problem_reports_1 = require_problem_reports();
    var plugins_1 = require_plugins();
    var JWE_1 = require_JWE();
    var JsonTransformer_1 = require_JsonTransformer();
    var messageType_1 = require_messageType();
    var Dispatcher_1 = require_Dispatcher();
    var EnvelopeService_1 = require_EnvelopeService();
    var MessageHandlerRegistry_1 = require_MessageHandlerRegistry();
    var MessageSender_1 = require_MessageSender();
    var TransportService_1 = require_TransportService();
    var models_1 = require_models3();
    var MessageReceiver = class MessageReceiver {
      constructor(envelopeService, transportService, messageSender, connectionService, dispatcher, messageHandlerRegistry, agentContextProvider, logger) {
        this.inboundTransports = [];
        this.envelopeService = envelopeService;
        this.transportService = transportService;
        this.messageSender = messageSender;
        this.connectionService = connectionService;
        this.dispatcher = dispatcher;
        this.messageHandlerRegistry = messageHandlerRegistry;
        this.agentContextProvider = agentContextProvider;
        this.logger = logger;
      }
      registerInboundTransport(inboundTransport) {
        this.inboundTransports.push(inboundTransport);
      }
      /**
       * Receive and handle an inbound DIDComm message. It will determine the agent context, decrypt the message, transform it
       * to it's corresponding message class and finally dispatch it to the dispatcher.
       *
       * @param inboundMessage the message to receive and handle
       */
      async receiveMessage(inboundMessage, { session, connection, contextCorrelationId } = {}) {
        this.logger.debug(`Agent received message`);
        const agentContext = await this.agentContextProvider.getContextForInboundMessage(inboundMessage, {
          contextCorrelationId
        });
        try {
          if (this.isEncryptedMessage(inboundMessage)) {
            await this.receiveEncryptedMessage(agentContext, inboundMessage, session);
          } else if (this.isPlaintextMessage(inboundMessage)) {
            await this.receivePlaintextMessage(agentContext, inboundMessage, connection);
          } else {
            throw new error_1.AriesFrameworkError("Unable to parse incoming message: unrecognized format");
          }
        } finally {
          await agentContext.endSession();
        }
      }
      async receivePlaintextMessage(agentContext, plaintextMessage, connection) {
        const message = await this.transformAndValidate(agentContext, plaintextMessage);
        const messageContext = new models_1.InboundMessageContext(message, { connection, agentContext });
        await this.dispatcher.dispatch(messageContext);
      }
      async receiveEncryptedMessage(agentContext, encryptedMessage, session) {
        const decryptedMessage = await this.decryptMessage(agentContext, encryptedMessage);
        const { plaintextMessage, senderKey, recipientKey } = decryptedMessage;
        this.logger.info(`Received message with type '${plaintextMessage["@type"]}', recipient key ${recipientKey === null || recipientKey === void 0 ? void 0 : recipientKey.fingerprint} and sender key ${senderKey === null || senderKey === void 0 ? void 0 : senderKey.fingerprint}`, plaintextMessage);
        const connection = await this.findConnectionByMessageKeys(agentContext, decryptedMessage);
        const message = await this.transformAndValidate(agentContext, plaintextMessage, connection);
        const messageContext = new models_1.InboundMessageContext(message, {
          // Only make the connection available in message context if the connection is ready
          // To prevent unwanted usage of unready connections. Connections can still be retrieved from
          // Storage if the specific protocol allows an unready connection to be used.
          connection: (connection === null || connection === void 0 ? void 0 : connection.isReady) ? connection : void 0,
          senderKey,
          recipientKey,
          agentContext
        });
        if (senderKey && recipientKey && message.hasAnyReturnRoute() && session) {
          this.logger.debug(`Storing session for inbound message '${message.id}'`);
          const keys = {
            recipientKeys: [senderKey],
            routingKeys: [],
            senderKey: recipientKey
          };
          session.keys = keys;
          session.inboundMessage = message;
          session.connection = connection !== null && connection !== void 0 ? connection : void 0;
          messageContext.sessionId = session.id;
          this.transportService.saveSession(session);
        } else if (session) {
          await session.close();
        }
        await this.dispatcher.dispatch(messageContext);
      }
      /**
       * Decrypt a message using the envelope service.
       *
       * @param message the received inbound message to decrypt
       */
      async decryptMessage(agentContext, message) {
        try {
          return await this.envelopeService.unpackMessage(agentContext, message);
        } catch (error) {
          this.logger.error("Error while decrypting message", {
            error,
            encryptedMessage: message,
            errorMessage: error instanceof Error ? error.message : error
          });
          throw error;
        }
      }
      isPlaintextMessage(message) {
        if (typeof message !== "object" || message == null) {
          return false;
        }
        return "@type" in message;
      }
      isEncryptedMessage(message) {
        return (0, JWE_1.isValidJweStructure)(message);
      }
      async transformAndValidate(agentContext, plaintextMessage, connection) {
        let message;
        try {
          message = await this.transformMessage(plaintextMessage);
        } catch (error) {
          if (connection)
            await this.sendProblemReportMessage(agentContext, error.message, connection, plaintextMessage);
          throw error;
        }
        return message;
      }
      async findConnectionByMessageKeys(agentContext, { recipientKey, senderKey }) {
        if (!recipientKey || !senderKey)
          return null;
        return this.connectionService.findByKeys(agentContext, {
          senderKey,
          recipientKey
        });
      }
      /**
       * Transform an plaintext DIDComm message into it's corresponding message class. Will look at all message types in the registered handlers.
       *
       * @param message the plaintext message for which to transform the message in to a class instance
       */
      async transformMessage(message) {
        (0, messageType_1.replaceLegacyDidSovPrefixOnMessage)(message);
        const messageType = message["@type"];
        const MessageClass = this.messageHandlerRegistry.getMessageClassForMessageType(messageType);
        if (!MessageClass) {
          throw new problem_reports_1.ProblemReportError(`No message class found for message type "${messageType}"`, {
            problemCode: problem_reports_1.ProblemReportReason.MessageParseFailure
          });
        }
        let messageTransformed;
        try {
          messageTransformed = JsonTransformer_1.JsonTransformer.fromJSON(message, MessageClass);
        } catch (error) {
          this.logger.error(`Error validating message ${message.type}`, {
            errors: error,
            message: JSON.stringify(message)
          });
          throw new problem_reports_1.ProblemReportError(`Error validating message ${message.type}`, {
            problemCode: problem_reports_1.ProblemReportReason.MessageParseFailure
          });
        }
        return messageTransformed;
      }
      /**
       * Send the problem report message (https://didcomm.org/notification/1.0/problem-report) to the recipient.
       * @param message error message to send
       * @param connection connection to send the message to
       * @param plaintextMessage received inbound message
       */
      async sendProblemReportMessage(agentContext, message, connection, plaintextMessage) {
        const messageType = (0, messageType_1.parseMessageType)(plaintextMessage["@type"]);
        if ((0, messageType_1.canHandleMessageType)(problem_reports_1.ProblemReportMessage, messageType)) {
          throw new error_1.AriesFrameworkError(`Not sending problem report in response to problem report: ${message}`);
        }
        const problemReportMessage = new problem_reports_1.ProblemReportMessage({
          description: {
            en: message,
            code: problem_reports_1.ProblemReportReason.MessageParseFailure
          }
        });
        problemReportMessage.setThread({
          threadId: plaintextMessage["@id"]
        });
        const outboundMessageContext = new models_1.OutboundMessageContext(problemReportMessage, { agentContext, connection });
        if (outboundMessageContext) {
          await this.messageSender.sendMessage(outboundMessageContext);
        }
      }
    };
    MessageReceiver = __decorate([
      (0, plugins_1.injectable)(),
      __param(6, (0, plugins_1.inject)(constants_1.InjectionSymbols.AgentContextProvider)),
      __param(7, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [
        EnvelopeService_1.EnvelopeService,
        TransportService_1.TransportService,
        MessageSender_1.MessageSender,
        connections_1.ConnectionService,
        Dispatcher_1.Dispatcher,
        MessageHandlerRegistry_1.MessageHandlerRegistry,
        Object,
        Object
      ])
    ], MessageReceiver);
    exports.MessageReceiver = MessageReceiver;
  }
});

// node_modules/@aries-framework/core/build/storage/didcomm/DidCommMessageRecord.js
var require_DidCommMessageRecord = __commonJS({
  "node_modules/@aries-framework/core/build/storage/didcomm/DidCommMessageRecord.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidCommMessageRecord = void 0;
    var error_1 = require_error();
    var JsonTransformer_1 = require_JsonTransformer();
    var messageType_1 = require_messageType();
    var type_1 = require_type();
    var uuid_1 = require_uuid();
    var BaseRecord_1 = require_BaseRecord();
    var DidCommMessageRecord = class extends BaseRecord_1.BaseRecord {
      constructor(props) {
        var _a, _b;
        super();
        this.type = DidCommMessageRecord.type;
        if (props) {
          this.id = (_a = props.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.createdAt = (_b = props.createdAt) !== null && _b !== void 0 ? _b : /* @__PURE__ */ new Date();
          this.associatedRecordId = props.associatedRecordId;
          this.role = props.role;
          this.message = props.message;
        }
      }
      getTags() {
        const messageId = this.message["@id"];
        const messageType = this.message["@type"];
        const { protocolName, protocolMajorVersion, protocolMinorVersion, messageName } = (0, messageType_1.parseMessageType)(messageType);
        const thread = this.message["~thread"];
        let threadId = messageId;
        if ((0, type_1.isJsonObject)(thread) && typeof thread.thid === "string") {
          threadId = thread.thid;
        }
        return Object.assign(Object.assign({}, this._tags), {
          role: this.role,
          associatedRecordId: this.associatedRecordId,
          // Computed properties based on message id and type
          threadId,
          protocolName,
          messageName,
          protocolMajorVersion: protocolMajorVersion.toString(),
          protocolMinorVersion: protocolMinorVersion.toString(),
          messageType,
          messageId
        });
      }
      getMessageInstance(messageClass) {
        const messageType = (0, messageType_1.parseMessageType)(this.message["@type"]);
        if (!(0, messageType_1.canHandleMessageType)(messageClass, messageType)) {
          throw new error_1.AriesFrameworkError("Provided message class type does not match type of stored message");
        }
        return JsonTransformer_1.JsonTransformer.fromJSON(this.message, messageClass);
      }
    };
    exports.DidCommMessageRecord = DidCommMessageRecord;
    DidCommMessageRecord.type = "DidCommMessageRecord";
  }
});

// node_modules/@aries-framework/core/build/storage/didcomm/DidCommMessageRepository.js
var require_DidCommMessageRepository = __commonJS({
  "node_modules/@aries-framework/core/build/storage/didcomm/DidCommMessageRepository.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidCommMessageRepository = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var messageType_1 = require_messageType();
    var Repository_1 = require_Repository();
    var DidCommMessageRecord_1 = require_DidCommMessageRecord();
    var DidCommMessageRepository = class DidCommMessageRepository extends Repository_1.Repository {
      constructor(storageService, eventEmitter) {
        super(DidCommMessageRecord_1.DidCommMessageRecord, storageService, eventEmitter);
      }
      async saveAgentMessage(agentContext, { role, agentMessage, associatedRecordId }) {
        const didCommMessageRecord = new DidCommMessageRecord_1.DidCommMessageRecord({
          message: agentMessage.toJSON(),
          role,
          associatedRecordId
        });
        await this.save(agentContext, didCommMessageRecord);
      }
      async saveOrUpdateAgentMessage(agentContext, options) {
        const { messageName, protocolName, protocolMajorVersion } = (0, messageType_1.parseMessageType)(options.agentMessage.type);
        const record = await this.findSingleByQuery(agentContext, {
          associatedRecordId: options.associatedRecordId,
          messageName,
          protocolName,
          protocolMajorVersion: String(protocolMajorVersion)
        });
        if (record) {
          record.message = options.agentMessage.toJSON();
          record.role = options.role;
          await this.update(agentContext, record);
          return;
        }
        await this.saveAgentMessage(agentContext, options);
      }
      async getAgentMessage(agentContext, { associatedRecordId, messageClass }) {
        const record = await this.getSingleByQuery(agentContext, {
          associatedRecordId,
          messageName: messageClass.type.messageName,
          protocolName: messageClass.type.protocolName,
          protocolMajorVersion: String(messageClass.type.protocolMajorVersion)
        });
        return record.getMessageInstance(messageClass);
      }
      async findAgentMessage(agentContext, { associatedRecordId, messageClass }) {
        var _a;
        const record = await this.findSingleByQuery(agentContext, {
          associatedRecordId,
          messageName: messageClass.type.messageName,
          protocolName: messageClass.type.protocolName,
          protocolMajorVersion: String(messageClass.type.protocolMajorVersion)
        });
        return (_a = record === null || record === void 0 ? void 0 : record.getMessageInstance(messageClass)) !== null && _a !== void 0 ? _a : null;
      }
    };
    DidCommMessageRepository = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.StorageService)),
      __metadata("design:paramtypes", [Object, EventEmitter_1.EventEmitter])
    ], DidCommMessageRepository);
    exports.DidCommMessageRepository = DidCommMessageRepository;
  }
});

// node_modules/@aries-framework/core/build/storage/didcomm/DidCommMessageRole.js
var require_DidCommMessageRole = __commonJS({
  "node_modules/@aries-framework/core/build/storage/didcomm/DidCommMessageRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidCommMessageRole = void 0;
    var DidCommMessageRole;
    (function(DidCommMessageRole2) {
      DidCommMessageRole2["Sender"] = "sender";
      DidCommMessageRole2["Receiver"] = "receiver";
    })(DidCommMessageRole = exports.DidCommMessageRole || (exports.DidCommMessageRole = {}));
  }
});

// node_modules/@aries-framework/core/build/storage/didcomm/index.js
var require_didcomm2 = __commonJS({
  "node_modules/@aries-framework/core/build/storage/didcomm/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_DidCommMessageRecord(), exports);
    __exportStar(require_DidCommMessageRepository(), exports);
    __exportStar(require_DidCommMessageRole(), exports);
  }
});

// node_modules/@aries-framework/core/build/storage/migration/repository/StorageVersionRecord.js
var require_StorageVersionRecord = __commonJS({
  "node_modules/@aries-framework/core/build/storage/migration/repository/StorageVersionRecord.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageVersionRecord = void 0;
    var uuid_1 = require_uuid();
    var BaseRecord_1 = require_BaseRecord();
    var StorageVersionRecord = class extends BaseRecord_1.BaseRecord {
      constructor(props) {
        var _a, _b;
        super();
        this.type = StorageVersionRecord.type;
        if (props) {
          this.id = (_a = props.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.createdAt = (_b = props.createdAt) !== null && _b !== void 0 ? _b : /* @__PURE__ */ new Date();
          this.storageVersion = props.storageVersion;
        }
      }
      getTags() {
        return this._tags;
      }
    };
    exports.StorageVersionRecord = StorageVersionRecord;
    StorageVersionRecord.type = "StorageVersionRecord";
  }
});

// node_modules/@aries-framework/core/build/storage/migration/repository/StorageVersionRepository.js
var require_StorageVersionRepository = __commonJS({
  "node_modules/@aries-framework/core/build/storage/migration/repository/StorageVersionRepository.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageVersionRepository = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var Repository_1 = require_Repository();
    var StorageVersionRecord_1 = require_StorageVersionRecord();
    var StorageVersionRepository = class StorageVersionRepository extends Repository_1.Repository {
      constructor(storageService, eventEmitter) {
        super(StorageVersionRecord_1.StorageVersionRecord, storageService, eventEmitter);
      }
    };
    StorageVersionRepository = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.StorageService)),
      __metadata("design:paramtypes", [Object, EventEmitter_1.EventEmitter])
    ], StorageVersionRepository);
    exports.StorageVersionRepository = StorageVersionRepository;
  }
});

// node_modules/@aries-framework/core/build/modules/oob/helpers.js
var require_helpers3 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertToOldInvitation = exports.convertToNewInvitation = void 0;
    var connections_1 = require_connections();
    var helpers_1 = require_helpers();
    var OutOfBandDidCommService_1 = require_OutOfBandDidCommService();
    var messages_1 = require_messages4();
    function convertToNewInvitation(oldInvitation) {
      var _a, _b;
      let service;
      if (oldInvitation.did) {
        service = oldInvitation.did;
      } else if (oldInvitation.serviceEndpoint && oldInvitation.recipientKeys && oldInvitation.recipientKeys.length > 0) {
        service = new OutOfBandDidCommService_1.OutOfBandDidCommService({
          id: "#inline",
          recipientKeys: (_a = oldInvitation.recipientKeys) === null || _a === void 0 ? void 0 : _a.map(helpers_1.verkeyToDidKey),
          routingKeys: (_b = oldInvitation.routingKeys) === null || _b === void 0 ? void 0 : _b.map(helpers_1.verkeyToDidKey),
          serviceEndpoint: oldInvitation.serviceEndpoint
        });
      } else {
        throw new Error("Missing required serviceEndpoint, routingKeys and/or did fields in connection invitation");
      }
      const options = {
        id: oldInvitation.id,
        label: oldInvitation.label,
        imageUrl: oldInvitation.imageUrl,
        appendedAttachments: oldInvitation.appendedAttachments,
        accept: ["didcomm/aip1", "didcomm/aip2;env=rfc19"],
        services: [service],
        handshakeProtocols: [connections_1.HandshakeProtocol.Connections]
      };
      return new messages_1.OutOfBandInvitation(options);
    }
    exports.convertToNewInvitation = convertToNewInvitation;
    function convertToOldInvitation(newInvitation) {
      var _a;
      const [service] = newInvitation.getServices();
      let options;
      if (typeof service === "string") {
        options = {
          id: newInvitation.id,
          label: newInvitation.label,
          did: service,
          imageUrl: newInvitation.imageUrl,
          appendedAttachments: newInvitation.appendedAttachments
        };
      } else {
        options = {
          id: newInvitation.id,
          label: newInvitation.label,
          recipientKeys: service.recipientKeys.map(helpers_1.didKeyToVerkey),
          routingKeys: (_a = service.routingKeys) === null || _a === void 0 ? void 0 : _a.map(helpers_1.didKeyToVerkey),
          serviceEndpoint: service.serviceEndpoint,
          imageUrl: newInvitation.imageUrl,
          appendedAttachments: newInvitation.appendedAttachments
        };
      }
      const connectionInvitationMessage = new connections_1.ConnectionInvitationMessage(options);
      return connectionInvitationMessage;
    }
    exports.convertToOldInvitation = convertToOldInvitation;
  }
});

// node_modules/@aries-framework/core/build/storage/migration/updates/0.1-0.2/connection.js
var require_connection = __commonJS({
  "node_modules/@aries-framework/core/build/storage/migration/updates/0.1-0.2/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.didExchangeStateAndRoleFromRoleAndState = exports.oobStateFromDidExchangeRoleAndState = exports.migrateToOobRecord = exports.extractDidDocument = exports.updateConnectionRoleAndState = exports.migrateConnectionRecordToV0_2 = void 0;
    var connections_1 = require_connections();
    var helpers_1 = require_helpers2();
    var dids_1 = require_dids();
    var DidDocumentRole_1 = require_DidDocumentRole();
    var repository_1 = require_repository();
    var didRecordMetadataTypes_1 = require_didRecordMetadataTypes();
    var OutOfBandRole_1 = require_OutOfBandRole();
    var OutOfBandState_1 = require_OutOfBandState();
    var helpers_2 = require_helpers3();
    var repository_2 = require_repository3();
    var utils_1 = require_utils();
    async function migrateConnectionRecordToV0_2(agent) {
      agent.config.logger.info("Migrating connection records to storage version 0.2");
      const connectionRepository = agent.dependencyManager.resolve(connections_1.ConnectionRepository);
      agent.config.logger.debug(`Fetching all connection records from storage`);
      const allConnections = await connectionRepository.getAll(agent.context);
      agent.config.logger.debug(`Found a total of ${allConnections.length} connection records to update.`);
      for (const connectionRecord of allConnections) {
        agent.config.logger.debug(`Migrating connection record with id ${connectionRecord.id} to storage version 0.2`);
        await updateConnectionRoleAndState(agent, connectionRecord);
        await extractDidDocument(agent, connectionRecord);
        const _connectionRecord = await migrateToOobRecord(agent, connectionRecord);
        if (_connectionRecord) {
          await connectionRepository.update(agent.context, connectionRecord);
        }
        agent.config.logger.debug(`Successfully migrated connection record with id ${connectionRecord.id} to storage version 0.2`);
      }
    }
    exports.migrateConnectionRecordToV0_2 = migrateConnectionRecordToV0_2;
    async function updateConnectionRoleAndState(agent, connectionRecord) {
      agent.config.logger.debug(`Extracting 'didDoc' and 'theirDidDoc' from connection record into separate DidRecord and updating unqualified dids to did:peer dids`);
      const oldState = connectionRecord.state;
      const oldRole = connectionRecord.role;
      const [didExchangeRole, didExchangeState] = didExchangeStateAndRoleFromRoleAndState(connectionRecord.role, connectionRecord.state);
      connectionRecord.role = didExchangeRole;
      connectionRecord.state = didExchangeState;
      agent.config.logger.debug(`Updated connection record state from ${oldState} to ${connectionRecord.state} and role from ${oldRole} to ${connectionRecord.role}`);
    }
    exports.updateConnectionRoleAndState = updateConnectionRoleAndState;
    async function extractDidDocument(agent, connectionRecord) {
      agent.config.logger.debug(`Extracting 'didDoc' and 'theirDidDoc' from connection record into separate DidRecord and updating unqualified dids to did:peer dids`);
      const didRepository = agent.dependencyManager.resolve(repository_1.DidRepository);
      const untypedConnectionRecord = connectionRecord;
      const oldOurDidDocJson = untypedConnectionRecord.didDoc;
      const oldTheirDidDocJson = untypedConnectionRecord.theirDidDoc;
      if (oldOurDidDocJson) {
        const oldOurDidDoc = utils_1.JsonTransformer.fromJSON(oldOurDidDocJson, connections_1.DidDoc);
        agent.config.logger.debug(`Found a legacy did document for did ${oldOurDidDoc.id} in connection record didDoc. Converting it to a peer did document.`);
        const newOurDidDocument = (0, helpers_1.convertToNewDidDocument)(oldOurDidDoc);
        let ourDidRecord = await didRepository.findById(agent.context, newOurDidDocument.id);
        if (!ourDidRecord) {
          agent.config.logger.debug(`Creating did record for our did ${newOurDidDocument.id}`);
          ourDidRecord = new repository_1.DidRecord({
            // NOTE: in 0.3.0 the id property was updated to be a uuid, and a new did property was added. Here we make the id and did property both the did.
            // In the 0.3.0 update the `id` property will be updated to an uuid.
            id: newOurDidDocument.id,
            did: newOurDidDocument.id,
            role: DidDocumentRole_1.DidDocumentRole.Created,
            didDocument: newOurDidDocument,
            createdAt: connectionRecord.createdAt,
            tags: {
              recipientKeyFingerprints: newOurDidDocument.recipientKeys.map((key) => key.fingerprint)
            }
          });
          ourDidRecord.metadata.set(didRecordMetadataTypes_1.DidRecordMetadataKeys.LegacyDid, {
            unqualifiedDid: oldOurDidDoc.id,
            didDocumentString: utils_1.JsonEncoder.toString(oldOurDidDocJson)
          });
          await didRepository.save(agent.context, ourDidRecord);
          agent.config.logger.debug(`Successfully saved did record for did ${newOurDidDocument.id}`);
        } else {
          agent.config.logger.debug(`Found existing did record for did ${newOurDidDocument.id}, not creating did record.`);
        }
        agent.config.logger.debug(`Deleting old did document from connection record and storing new did:peer did`);
        delete untypedConnectionRecord.didDoc;
        connectionRecord.did = newOurDidDocument.id;
      } else {
        agent.config.logger.debug(`Did not find a did document in connection record didDoc. Not converting it to a peer did document.`);
      }
      if (oldTheirDidDocJson) {
        const oldTheirDidDoc = utils_1.JsonTransformer.fromJSON(oldTheirDidDocJson, connections_1.DidDoc);
        agent.config.logger.debug(`Found a legacy did document for theirDid ${oldTheirDidDoc.id} in connection record theirDidDoc. Converting it to a peer did document.`);
        const newTheirDidDocument = (0, helpers_1.convertToNewDidDocument)(oldTheirDidDoc);
        let theirDidRecord = await didRepository.findById(agent.context, newTheirDidDocument.id);
        if (!theirDidRecord) {
          agent.config.logger.debug(`Creating did record for theirDid ${newTheirDidDocument.id}`);
          theirDidRecord = new repository_1.DidRecord({
            // NOTE: in 0.3.0 the id property was updated to be a uuid, and a new did property was added. Here we make the id and did property both the did.
            // In the 0.3.0 update the `id` property will be updated to an uuid.
            id: newTheirDidDocument.id,
            did: newTheirDidDocument.id,
            role: DidDocumentRole_1.DidDocumentRole.Received,
            didDocument: newTheirDidDocument,
            createdAt: connectionRecord.createdAt,
            tags: {
              recipientKeyFingerprints: newTheirDidDocument.recipientKeys.map((key) => key.fingerprint)
            }
          });
          theirDidRecord.metadata.set(didRecordMetadataTypes_1.DidRecordMetadataKeys.LegacyDid, {
            unqualifiedDid: oldTheirDidDoc.id,
            didDocumentString: utils_1.JsonEncoder.toString(oldTheirDidDocJson)
          });
          await didRepository.save(agent.context, theirDidRecord);
          agent.config.logger.debug(`Successfully saved did record for theirDid ${newTheirDidDocument.id}`);
        } else {
          agent.config.logger.debug(`Found existing did record for theirDid ${newTheirDidDocument.id}, not creating did record.`);
        }
        agent.config.logger.debug(`Deleting old theirDidDoc from connection record and storing new did:peer theirDid`);
        delete untypedConnectionRecord.theirDidDoc;
        connectionRecord.theirDid = newTheirDidDocument.id;
      } else {
        agent.config.logger.debug(`Did not find a did document in connection record theirDidDoc. Not converting it to a peer did document.`);
      }
      delete untypedConnectionRecord.verkey;
    }
    exports.extractDidDocument = extractDidDocument;
    async function migrateToOobRecord(agent, connectionRecord) {
      agent.config.logger.debug(`Migrating properties from connection record with id ${connectionRecord.id} to out of band record`);
      const oobRepository = agent.dependencyManager.resolve(repository_2.OutOfBandRepository);
      const connectionRepository = agent.dependencyManager.resolve(connections_1.ConnectionRepository);
      const untypedConnectionRecord = connectionRecord;
      const oldInvitationJson = untypedConnectionRecord.invitation;
      const oldMultiUseInvitation = untypedConnectionRecord.multiUseInvitation;
      if (oldInvitationJson) {
        const oldInvitation = utils_1.JsonTransformer.fromJSON(oldInvitationJson, connections_1.ConnectionInvitationMessage);
        agent.config.logger.debug(`Found a legacy invitation in connection record. Migrating it to an out of band record.`);
        const outOfBandInvitation = (0, helpers_2.convertToNewInvitation)(oldInvitation);
        const recipientKeyFingerprints = outOfBandInvitation.getInlineServices().map((s) => s.recipientKeys).reduce((acc, curr) => [...acc, ...curr], []).map((didKey) => dids_1.DidKey.fromDid(didKey).key.fingerprint);
        const oobRole = connectionRecord.role === connections_1.DidExchangeRole.Responder ? OutOfBandRole_1.OutOfBandRole.Sender : OutOfBandRole_1.OutOfBandRole.Receiver;
        const oobRecords = await oobRepository.findByQuery(agent.context, {
          invitationId: oldInvitation.id,
          recipientKeyFingerprints,
          role: oobRole
        });
        let oobRecord = oobRecords[0];
        if (!oobRecord) {
          agent.config.logger.debug(`Create out of band record.`);
          const connectionRole = connectionRecord.role;
          const connectionState = connectionRecord.state;
          const oobState = oobStateFromDidExchangeRoleAndState(connectionRole, connectionState);
          oobRecord = new repository_2.OutOfBandRecord({
            role: oobRole,
            state: oobState,
            alias: connectionRecord.alias,
            autoAcceptConnection: connectionRecord.autoAcceptConnection,
            outOfBandInvitation,
            reusable: oldMultiUseInvitation,
            mediatorId: connectionRecord.mediatorId,
            createdAt: connectionRecord.createdAt,
            tags: { recipientKeyFingerprints }
          });
          await oobRepository.save(agent.context, oobRecord);
          agent.config.logger.debug(`Successfully saved out of band record for invitation @id ${oldInvitation.id}`);
        } else {
          agent.config.logger.debug(`Found existing out of band record for invitation @id ${oldInvitation.id} and did ${connectionRecord.did}, not creating a new out of band record.`);
        }
        if (oldMultiUseInvitation) {
          oobRecord.reusable = true;
          oobRecord.state = OutOfBandState_1.OutOfBandState.AwaitResponse;
          oobRecord.mediatorId = connectionRecord.mediatorId;
          oobRecord.autoAcceptConnection = connectionRecord.autoAcceptConnection;
          await oobRepository.update(agent.context, oobRecord);
          await connectionRepository.delete(agent.context, connectionRecord);
          agent.config.logger.debug(`Set reusable=true for out of band record with invitation @id ${oobRecord.outOfBandInvitation.id} and role ${oobRole}.`);
          return;
        }
        agent.config.logger.debug(`Setting invitationDid and outOfBand Id, and removing invitation from connection record`);
        const [invitationDid] = oobRecord.outOfBandInvitation.invitationDids;
        connectionRecord.invitationDid = invitationDid;
        delete untypedConnectionRecord.invitation;
        connectionRecord.outOfBandId = oobRecord.id;
      }
      agent.config.logger.debug("Removing multiUseInvitation property from connection record");
      delete untypedConnectionRecord.multiUseInvitation;
      return connectionRecord;
    }
    exports.migrateToOobRecord = migrateToOobRecord;
    function oobStateFromDidExchangeRoleAndState(role, state) {
      const stateMapping = {
        [connections_1.DidExchangeState.InvitationReceived]: OutOfBandState_1.OutOfBandState.PrepareResponse,
        [connections_1.DidExchangeState.InvitationSent]: OutOfBandState_1.OutOfBandState.AwaitResponse,
        [connections_1.DidExchangeState.RequestReceived]: OutOfBandState_1.OutOfBandState.Done,
        [connections_1.DidExchangeState.RequestSent]: OutOfBandState_1.OutOfBandState.Done,
        [connections_1.DidExchangeState.ResponseReceived]: OutOfBandState_1.OutOfBandState.Done,
        [connections_1.DidExchangeState.ResponseSent]: OutOfBandState_1.OutOfBandState.Done,
        [connections_1.DidExchangeState.Completed]: OutOfBandState_1.OutOfBandState.Done,
        [connections_1.DidExchangeState.Abandoned]: OutOfBandState_1.OutOfBandState.Done
      };
      if (state === connections_1.DidExchangeState.Start) {
        return role === connections_1.DidExchangeRole.Requester ? OutOfBandState_1.OutOfBandState.PrepareResponse : OutOfBandState_1.OutOfBandState.AwaitResponse;
      }
      return stateMapping[state];
    }
    exports.oobStateFromDidExchangeRoleAndState = oobStateFromDidExchangeRoleAndState;
    function didExchangeStateAndRoleFromRoleAndState(role, state) {
      const roleMapping = {
        // Responder / Inviter
        [connections_1.DidExchangeRole.Responder]: connections_1.DidExchangeRole.Responder,
        [connections_1.ConnectionRole.Inviter]: connections_1.DidExchangeRole.Responder,
        // Request / Invitee
        [connections_1.DidExchangeRole.Requester]: connections_1.DidExchangeRole.Requester,
        [connections_1.ConnectionRole.Invitee]: connections_1.DidExchangeRole.Requester
      };
      const roleStateMapping = {
        [connections_1.DidExchangeRole.Requester]: {
          // DidExchangeRole.Requester
          [connections_1.ConnectionState.Invited]: connections_1.DidExchangeState.InvitationReceived,
          [connections_1.ConnectionState.Requested]: connections_1.DidExchangeState.RequestSent,
          [connections_1.ConnectionState.Responded]: connections_1.DidExchangeState.ResponseReceived,
          [connections_1.ConnectionState.Complete]: connections_1.DidExchangeState.Completed,
          [connections_1.ConnectionState.Null]: connections_1.DidExchangeState.Start
        },
        [connections_1.DidExchangeRole.Responder]: {
          // DidExchangeRole.Responder
          [connections_1.ConnectionState.Invited]: connections_1.DidExchangeState.InvitationSent,
          [connections_1.ConnectionState.Requested]: connections_1.DidExchangeState.RequestReceived,
          [connections_1.ConnectionState.Responded]: connections_1.DidExchangeState.ResponseSent,
          [connections_1.ConnectionState.Complete]: connections_1.DidExchangeState.Completed,
          [connections_1.ConnectionState.Null]: connections_1.DidExchangeState.Start
        }
      };
      const didExchangeRole = roleMapping[role];
      const stateMapping = roleStateMapping[didExchangeRole];
      if (isConnectionState(state)) {
        return [didExchangeRole, stateMapping[state]];
      }
      return [didExchangeRole, state];
    }
    exports.didExchangeStateAndRoleFromRoleAndState = didExchangeStateAndRoleFromRoleAndState;
    function isConnectionState(state) {
      return Object.values(connections_1.ConnectionState).includes(state);
    }
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/models/CredentialState.js
var require_CredentialState = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/models/CredentialState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CredentialState = void 0;
    var CredentialState;
    (function(CredentialState2) {
      CredentialState2["ProposalSent"] = "proposal-sent";
      CredentialState2["ProposalReceived"] = "proposal-received";
      CredentialState2["OfferSent"] = "offer-sent";
      CredentialState2["OfferReceived"] = "offer-received";
      CredentialState2["Declined"] = "declined";
      CredentialState2["RequestSent"] = "request-sent";
      CredentialState2["RequestReceived"] = "request-received";
      CredentialState2["CredentialIssued"] = "credential-issued";
      CredentialState2["CredentialReceived"] = "credential-received";
      CredentialState2["Done"] = "done";
    })(CredentialState = exports.CredentialState || (exports.CredentialState = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/repository/CredentialMetadataTypes.js
var require_CredentialMetadataTypes = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/repository/CredentialMetadataTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CredentialMetadataKeys = void 0;
    var CredentialMetadataKeys;
    (function(CredentialMetadataKeys2) {
      CredentialMetadataKeys2["IndyCredential"] = "_internal/indyCredential";
      CredentialMetadataKeys2["IndyRequest"] = "_internal/indyRequest";
    })(CredentialMetadataKeys = exports.CredentialMetadataKeys || (exports.CredentialMetadataKeys = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/formats/indy/models/IndyCredentialView.js
var require_IndyCredentialView = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/formats/indy/models/IndyCredentialView.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyCredentialView = void 0;
    var IndyCredentialView = class {
      constructor(options) {
        var _a;
        this.metadata = (_a = options.metadata) !== null && _a !== void 0 ? _a : {};
        this.claims = options.claims;
        this.attachments = options.attachments;
      }
    };
    exports.IndyCredentialView = IndyCredentialView;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/models/CredentialPreviewAttribute.js
var require_CredentialPreviewAttribute = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/models/CredentialPreviewAttribute.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CredentialPreviewAttribute = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var JsonTransformer_1 = require_JsonTransformer();
    var CredentialPreviewAttribute = class {
      constructor(options) {
        this.mimeType = "text/plain";
        if (options) {
          this.name = options.name;
          this.mimeType = options.mimeType;
          this.value = options.value;
        }
      }
      toJSON() {
        return JsonTransformer_1.JsonTransformer.toJSON(this);
      }
    };
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], CredentialPreviewAttribute.prototype, "name", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "mime-type" }),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsMimeType)(),
      __metadata("design:type", String)
    ], CredentialPreviewAttribute.prototype, "mimeType", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], CredentialPreviewAttribute.prototype, "value", void 0);
    exports.CredentialPreviewAttribute = CredentialPreviewAttribute;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/repository/CredentialExchangeRecord.js
var require_CredentialExchangeRecord = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/repository/CredentialExchangeRecord.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CredentialExchangeRecord = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var Attachment_1 = require_Attachment();
    var error_1 = require_error();
    var BaseRecord_1 = require_BaseRecord();
    var uuid_1 = require_uuid();
    var IndyCredentialView_1 = require_IndyCredentialView();
    var CredentialPreviewAttribute_1 = require_CredentialPreviewAttribute();
    var CredentialMetadataTypes_1 = require_CredentialMetadataTypes();
    var CredentialExchangeRecord = class extends BaseRecord_1.BaseRecord {
      constructor(props) {
        var _a, _b, _c;
        super();
        this.credentials = [];
        this.type = CredentialExchangeRecord.type;
        if (props) {
          this.id = (_a = props.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.createdAt = (_b = props.createdAt) !== null && _b !== void 0 ? _b : /* @__PURE__ */ new Date();
          this.state = props.state;
          this.connectionId = props.connectionId;
          this.threadId = props.threadId;
          this.protocolVersion = props.protocolVersion;
          this._tags = (_c = props.tags) !== null && _c !== void 0 ? _c : {};
          this.credentialAttributes = props.credentialAttributes;
          this.autoAcceptCredential = props.autoAcceptCredential;
          this.linkedAttachments = props.linkedAttachments;
          this.revocationNotification = props.revocationNotification;
          this.errorMessage = props.errorMessage;
          this.credentials = props.credentials || [];
        }
      }
      getTags() {
        const metadata = this.metadata.get(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential);
        const ids = this.credentials.map((c) => c.credentialRecordId);
        return Object.assign(Object.assign({}, this._tags), { threadId: this.threadId, connectionId: this.connectionId, state: this.state, credentialIds: ids, indyRevocationRegistryId: metadata === null || metadata === void 0 ? void 0 : metadata.indyRevocationRegistryId, indyCredentialRevocationId: metadata === null || metadata === void 0 ? void 0 : metadata.indyCredentialRevocationId });
      }
      getCredentialInfo() {
        if (!this.credentialAttributes)
          return null;
        const claims = this.credentialAttributes.reduce((accumulator, current) => Object.assign(Object.assign({}, accumulator), { [current.name]: current.value }), {});
        return new IndyCredentialView_1.IndyCredentialView({
          claims,
          attachments: this.linkedAttachments,
          metadata: this.metadata.data
        });
      }
      assertProtocolVersion(version2) {
        if (this.protocolVersion != version2) {
          throw new error_1.AriesFrameworkError(`Credential record has invalid protocol version ${this.protocolVersion}. Expected version ${version2}`);
        }
      }
      assertState(expectedStates) {
        if (!Array.isArray(expectedStates)) {
          expectedStates = [expectedStates];
        }
        if (!expectedStates.includes(this.state)) {
          throw new error_1.AriesFrameworkError(`Credential record is in invalid state ${this.state}. Valid states are: ${expectedStates.join(", ")}.`);
        }
      }
      assertConnection(currentConnectionId) {
        if (!this.connectionId) {
          throw new error_1.AriesFrameworkError(`Credential record is not associated with any connection. This is often the case with connection-less credential exchange`);
        } else if (this.connectionId !== currentConnectionId) {
          throw new error_1.AriesFrameworkError(`Credential record is associated with connection '${this.connectionId}'. Current connection is '${currentConnectionId}'`);
        }
      }
    };
    CredentialExchangeRecord.type = "CredentialRecord";
    __decorate([
      (0, class_transformer_1.Type)(() => CredentialPreviewAttribute_1.CredentialPreviewAttribute),
      __metadata("design:type", Array)
    ], CredentialExchangeRecord.prototype, "credentialAttributes", void 0);
    __decorate([
      (0, class_transformer_1.Type)(() => Attachment_1.Attachment),
      __metadata("design:type", Array)
    ], CredentialExchangeRecord.prototype, "linkedAttachments", void 0);
    exports.CredentialExchangeRecord = CredentialExchangeRecord;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/repository/CredentialRepository.js
var require_CredentialRepository = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/repository/CredentialRepository.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CredentialRepository = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var Repository_1 = require_Repository();
    var CredentialExchangeRecord_1 = require_CredentialExchangeRecord();
    var CredentialRepository = class CredentialRepository extends Repository_1.Repository {
      constructor(storageService, eventEmitter) {
        super(CredentialExchangeRecord_1.CredentialExchangeRecord, storageService, eventEmitter);
      }
    };
    CredentialRepository = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.StorageService)),
      __metadata("design:paramtypes", [Object, EventEmitter_1.EventEmitter])
    ], CredentialRepository);
    exports.CredentialRepository = CredentialRepository;
  }
});

// node_modules/@aries-framework/core/build/storage/migration/updates/0.1-0.2/credential.js
var require_credential = __commonJS({
  "node_modules/@aries-framework/core/build/storage/migration/updates/0.1-0.2/credential.js"(exports) {
    "use strict";
    var __rest2 = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.moveDidCommMessages = exports.migrateInternalCredentialRecordProperties = exports.updateIndyMetadata = exports.getCredentialRole = exports.CredentialRole = exports.migrateCredentialRecordToV0_2 = void 0;
    var CredentialState_1 = require_CredentialState();
    var CredentialMetadataTypes_1 = require_CredentialMetadataTypes();
    var CredentialRepository_1 = require_CredentialRepository();
    var Metadata_1 = require_Metadata();
    var didcomm_1 = require_didcomm2();
    async function migrateCredentialRecordToV0_2(agent) {
      agent.config.logger.info("Migrating credential records to storage version 0.2");
      const credentialRepository = agent.dependencyManager.resolve(CredentialRepository_1.CredentialRepository);
      agent.config.logger.debug(`Fetching all credential records from storage`);
      const allCredentials = await credentialRepository.getAll(agent.context);
      agent.config.logger.debug(`Found a total of ${allCredentials.length} credential records to update.`);
      for (const credentialRecord of allCredentials) {
        agent.config.logger.debug(`Migrating credential record with id ${credentialRecord.id} to storage version 0.2`);
        await updateIndyMetadata(agent, credentialRecord);
        await migrateInternalCredentialRecordProperties(agent, credentialRecord);
        await moveDidCommMessages(agent, credentialRecord);
        await credentialRepository.update(agent.context, credentialRecord);
        agent.config.logger.debug(`Successfully migrated credential record with id ${credentialRecord.id} to storage version 0.2`);
      }
    }
    exports.migrateCredentialRecordToV0_2 = migrateCredentialRecordToV0_2;
    var CredentialRole;
    (function(CredentialRole2) {
      CredentialRole2[CredentialRole2["Issuer"] = 0] = "Issuer";
      CredentialRole2[CredentialRole2["Holder"] = 1] = "Holder";
    })(CredentialRole = exports.CredentialRole || (exports.CredentialRole = {}));
    var holderCredentialStates = [
      CredentialState_1.CredentialState.Declined,
      CredentialState_1.CredentialState.ProposalSent,
      CredentialState_1.CredentialState.OfferReceived,
      CredentialState_1.CredentialState.RequestSent,
      CredentialState_1.CredentialState.CredentialReceived
    ];
    var didCommMessageRoleMapping = {
      [CredentialRole.Issuer]: {
        proposalMessage: didcomm_1.DidCommMessageRole.Receiver,
        offerMessage: didcomm_1.DidCommMessageRole.Sender,
        requestMessage: didcomm_1.DidCommMessageRole.Receiver,
        credentialMessage: didcomm_1.DidCommMessageRole.Sender
      },
      [CredentialRole.Holder]: {
        proposalMessage: didcomm_1.DidCommMessageRole.Sender,
        offerMessage: didcomm_1.DidCommMessageRole.Receiver,
        requestMessage: didcomm_1.DidCommMessageRole.Sender,
        credentialMessage: didcomm_1.DidCommMessageRole.Receiver
      }
    };
    var credentialRecordMessageKeys = ["proposalMessage", "offerMessage", "requestMessage", "credentialMessage"];
    function getCredentialRole(credentialRecord) {
      if (credentialRecord.credentials.length > 0) {
        return CredentialRole.Holder;
      } else if (credentialRecord.state === CredentialState_1.CredentialState.Done) {
        return CredentialRole.Issuer;
      } else if (holderCredentialStates.includes(credentialRecord.state)) {
        return CredentialRole.Holder;
      }
      return CredentialRole.Issuer;
    }
    exports.getCredentialRole = getCredentialRole;
    async function updateIndyMetadata(agent, credentialRecord) {
      agent.config.logger.debug(`Updating indy metadata to use the generic metadata api available to records.`);
      const _a = credentialRecord.metadata.data, { requestMetadata, schemaId, credentialDefinitionId } = _a, rest = __rest2(_a, ["requestMetadata", "schemaId", "credentialDefinitionId"]);
      const metadata = new Metadata_1.Metadata(rest);
      if (requestMetadata) {
        agent.config.logger.trace(`Found top-level 'requestMetadata' key, moving to '${CredentialMetadataTypes_1.CredentialMetadataKeys.IndyRequest}'`);
        metadata.add(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyRequest, Object.assign({}, requestMetadata));
      }
      if (schemaId && typeof schemaId === "string") {
        agent.config.logger.trace(`Found top-level 'schemaId' key, moving to '${CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential}.schemaId'`);
        metadata.add(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, { schemaId });
      }
      if (credentialDefinitionId && typeof credentialDefinitionId === "string") {
        agent.config.logger.trace(`Found top-level 'credentialDefinitionId' key, moving to '${CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential}.credentialDefinitionId'`);
        metadata.add(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, { credentialDefinitionId });
      }
      credentialRecord.metadata = metadata;
    }
    exports.updateIndyMetadata = updateIndyMetadata;
    async function migrateInternalCredentialRecordProperties(agent, credentialRecord) {
      agent.config.logger.debug(`Migrating internal credential record ${credentialRecord.id} properties to storage version 0.2`);
      if (!credentialRecord.protocolVersion) {
        agent.config.logger.debug(`Setting protocolVersion to v1`);
        credentialRecord.protocolVersion = "v1";
      }
      const untypedCredentialRecord = credentialRecord;
      if (untypedCredentialRecord.credentialId) {
        agent.config.logger.debug(`Migrating indy credentialId ${untypedCredentialRecord.id} to credentials array`);
        credentialRecord.credentials = [
          {
            credentialRecordId: untypedCredentialRecord.credentialId,
            credentialRecordType: "indy"
          }
        ];
        delete untypedCredentialRecord.credentialId;
      }
      agent.config.logger.debug(`Successfully migrated internal credential record ${credentialRecord.id} properties to storage version 0.2`);
    }
    exports.migrateInternalCredentialRecordProperties = migrateInternalCredentialRecordProperties;
    async function moveDidCommMessages(agent, credentialRecord) {
      agent.config.logger.debug(`Moving didcomm messages from credential record with id ${credentialRecord.id} to DidCommMessageRecord`);
      const didCommMessageRepository = agent.dependencyManager.resolve(didcomm_1.DidCommMessageRepository);
      for (const messageKey of credentialRecordMessageKeys) {
        agent.config.logger.debug(`Starting move of ${messageKey} from credential record with id ${credentialRecord.id} to DIDCommMessageRecord`);
        const credentialRecordJson = credentialRecord;
        const message = credentialRecordJson[messageKey];
        if (message) {
          const credentialRole = getCredentialRole(credentialRecord);
          const didCommMessageRole = didCommMessageRoleMapping[credentialRole][messageKey];
          const didCommMessageRecord = new didcomm_1.DidCommMessageRecord({
            role: didCommMessageRole,
            associatedRecordId: credentialRecord.id,
            message
          });
          await didCommMessageRepository.save(agent.context, didCommMessageRecord);
          agent.config.logger.debug(`Successfully moved ${messageKey} from credential record with id ${credentialRecord.id} to DIDCommMessageRecord`);
          delete credentialRecordJson[messageKey];
        } else {
          agent.config.logger.debug(`Credential record with id ${credentialRecord.id} does not have a ${messageKey}. Not creating a DIDCommMessageRecord`);
        }
      }
      agent.config.logger.debug(`Successfully moved didcomm messages from credential record with id ${credentialRecord.id} to DIDCommMessageRecord`);
    }
    exports.moveDidCommMessages = moveDidCommMessages;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/repository/MediatorRoutingRecord.js
var require_MediatorRoutingRecord = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/repository/MediatorRoutingRecord.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MediatorRoutingRecord = void 0;
    var BaseRecord_1 = require_BaseRecord();
    var uuid_1 = require_uuid();
    var MediatorRoutingRecord = class extends BaseRecord_1.BaseRecord {
      constructor(props) {
        var _a, _b;
        super();
        this.type = MediatorRoutingRecord.type;
        if (props) {
          this.id = (_a = props.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.createdAt = (_b = props.createdAt) !== null && _b !== void 0 ? _b : /* @__PURE__ */ new Date();
          this.routingKeys = props.routingKeys || [];
        }
      }
      getTags() {
        return this._tags;
      }
    };
    exports.MediatorRoutingRecord = MediatorRoutingRecord;
    MediatorRoutingRecord.type = "MediatorRoutingRecord";
  }
});

// node_modules/@aries-framework/core/build/modules/routing/repository/MediatorRoutingRepository.js
var require_MediatorRoutingRepository = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/repository/MediatorRoutingRepository.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MediatorRoutingRepository = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var Repository_1 = require_Repository();
    var MediatorRoutingRecord_1 = require_MediatorRoutingRecord();
    var MediatorRoutingRepository = class MediatorRoutingRepository extends Repository_1.Repository {
      constructor(storageService, eventEmitter) {
        super(MediatorRoutingRecord_1.MediatorRoutingRecord, storageService, eventEmitter);
        this.MEDIATOR_ROUTING_RECORD_ID = "MEDIATOR_ROUTING_RECORD";
      }
    };
    MediatorRoutingRepository = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.StorageService)),
      __metadata("design:paramtypes", [Object, EventEmitter_1.EventEmitter])
    ], MediatorRoutingRepository);
    exports.MediatorRoutingRepository = MediatorRoutingRepository;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/repository/index.js
var require_repository4 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/repository/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_MediationRepository(), exports);
    __exportStar(require_MediatorRoutingRepository(), exports);
    __exportStar(require_MediationRecord(), exports);
    __exportStar(require_MediatorRoutingRecord(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/routing/services/MediatorService.js
var require_MediatorService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/services/MediatorService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MediatorService = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var constants_1 = require_constants();
    var crypto_1 = require_crypto();
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var JsonTransformer_1 = require_JsonTransformer();
    var connections_1 = require_connections();
    var ConnectionMetadataTypes_1 = require_ConnectionMetadataTypes();
    var helpers_1 = require_helpers();
    var RoutingEvents_1 = require_RoutingEvents();
    var messages_1 = require_messages3();
    var MediationRole_1 = require_MediationRole();
    var MediationState_1 = require_MediationState();
    var repository_1 = require_repository4();
    var MediationRecord_1 = require_MediationRecord();
    var MediationRepository_1 = require_MediationRepository();
    var MediatorRoutingRepository_1 = require_MediatorRoutingRepository();
    var MediatorService = class MediatorService {
      constructor(mediationRepository, mediatorRoutingRepository, eventEmitter, logger, connectionService) {
        this.mediationRepository = mediationRepository;
        this.mediatorRoutingRepository = mediatorRoutingRepository;
        this.eventEmitter = eventEmitter;
        this.logger = logger;
        this.connectionService = connectionService;
      }
      async getRoutingKeys(agentContext) {
        const mediatorRoutingRecord = await this.findMediatorRoutingRecord(agentContext);
        if (mediatorRoutingRecord) {
          this.logger.debug(`Returning mediator routing keys ${mediatorRoutingRecord.routingKeys}`);
          return mediatorRoutingRecord.routingKeys;
        }
        throw new error_1.AriesFrameworkError(`Mediator has not been initialized yet.`);
      }
      async processForwardMessage(messageContext) {
        const { message } = messageContext;
        if (!message.to) {
          throw new error_1.AriesFrameworkError('Invalid Message: Missing required attribute "to"');
        }
        const mediationRecord = await this.mediationRepository.getSingleByRecipientKey(messageContext.agentContext, message.to);
        mediationRecord.assertReady();
        mediationRecord.assertRole(MediationRole_1.MediationRole.Mediator);
        return {
          encryptedMessage: message.message,
          mediationRecord
        };
      }
      async processKeylistUpdateRequest(messageContext) {
        const connection = messageContext.assertReadyConnection();
        const { message } = messageContext;
        const keylist = [];
        const mediationRecord = await this.mediationRepository.getByConnectionId(messageContext.agentContext, connection.id);
        mediationRecord.assertReady();
        mediationRecord.assertRole(MediationRole_1.MediationRole.Mediator);
        const connectionUsesDidKey = message.updates.some((update) => (0, helpers_1.isDidKey)(update.recipientKey));
        await this.updateUseDidKeysFlag(messageContext.agentContext, connection, messages_1.KeylistUpdateMessage.type.protocolUri, connectionUsesDidKey);
        for (const update of message.updates) {
          const updated = new messages_1.KeylistUpdated({
            action: update.action,
            recipientKey: update.recipientKey,
            result: messages_1.KeylistUpdateResult.NoChange
          });
          const publicKeyBase58 = (0, helpers_1.didKeyToVerkey)(update.recipientKey);
          if (update.action === messages_1.KeylistUpdateAction.add) {
            mediationRecord.addRecipientKey(publicKeyBase58);
            updated.result = messages_1.KeylistUpdateResult.Success;
            keylist.push(updated);
          } else if (update.action === messages_1.KeylistUpdateAction.remove) {
            const success = mediationRecord.removeRecipientKey(publicKeyBase58);
            updated.result = success ? messages_1.KeylistUpdateResult.Success : messages_1.KeylistUpdateResult.NoChange;
            keylist.push(updated);
          }
        }
        await this.mediationRepository.update(messageContext.agentContext, mediationRecord);
        return new messages_1.KeylistUpdateResponseMessage({ keylist, threadId: message.threadId });
      }
      async createGrantMediationMessage(agentContext, mediationRecord) {
        mediationRecord.assertState(MediationState_1.MediationState.Requested);
        mediationRecord.assertRole(MediationRole_1.MediationRole.Mediator);
        await this.updateState(agentContext, mediationRecord, MediationState_1.MediationState.Granted);
        const useDidKey = agentContext.config.useDidKeyInProtocols;
        const message = new messages_1.MediationGrantMessage({
          endpoint: agentContext.config.endpoints[0],
          routingKeys: useDidKey ? (await this.getRoutingKeys(agentContext)).map(helpers_1.verkeyToDidKey) : await this.getRoutingKeys(agentContext),
          threadId: mediationRecord.threadId
        });
        return { mediationRecord, message };
      }
      async processMediationRequest(messageContext) {
        const connection = messageContext.assertReadyConnection();
        const mediationRecord = new MediationRecord_1.MediationRecord({
          connectionId: connection.id,
          role: MediationRole_1.MediationRole.Mediator,
          state: MediationState_1.MediationState.Requested,
          threadId: messageContext.message.threadId
        });
        await this.mediationRepository.save(messageContext.agentContext, mediationRecord);
        this.emitStateChangedEvent(messageContext.agentContext, mediationRecord, null);
        return mediationRecord;
      }
      async findById(agentContext, mediatorRecordId) {
        return this.mediationRepository.findById(agentContext, mediatorRecordId);
      }
      async getById(agentContext, mediatorRecordId) {
        return this.mediationRepository.getById(agentContext, mediatorRecordId);
      }
      async getAll(agentContext) {
        return await this.mediationRepository.getAll(agentContext);
      }
      async findMediatorRoutingRecord(agentContext) {
        const routingRecord = await this.mediatorRoutingRepository.findById(agentContext, this.mediatorRoutingRepository.MEDIATOR_ROUTING_RECORD_ID);
        return routingRecord;
      }
      async createMediatorRoutingRecord(agentContext) {
        const routingKey = await agentContext.wallet.createKey({
          keyType: crypto_1.KeyType.Ed25519
        });
        const routingRecord = new repository_1.MediatorRoutingRecord({
          id: this.mediatorRoutingRepository.MEDIATOR_ROUTING_RECORD_ID,
          // FIXME: update to fingerprint to include the key type
          routingKeys: [routingKey.publicKeyBase58]
        });
        await this.mediatorRoutingRepository.save(agentContext, routingRecord);
        return routingRecord;
      }
      async findAllByQuery(agentContext, query) {
        return await this.mediationRepository.findByQuery(agentContext, query);
      }
      async updateState(agentContext, mediationRecord, newState) {
        const previousState = mediationRecord.state;
        mediationRecord.state = newState;
        await this.mediationRepository.update(agentContext, mediationRecord);
        this.emitStateChangedEvent(agentContext, mediationRecord, previousState);
      }
      emitStateChangedEvent(agentContext, mediationRecord, previousState) {
        const clonedMediationRecord = JsonTransformer_1.JsonTransformer.clone(mediationRecord);
        this.eventEmitter.emit(agentContext, {
          type: RoutingEvents_1.RoutingEventTypes.MediationStateChanged,
          payload: {
            mediationRecord: clonedMediationRecord,
            previousState
          }
        });
      }
      async updateUseDidKeysFlag(agentContext, connection, protocolUri, connectionUsesDidKey) {
        var _a;
        const useDidKeysForProtocol = (_a = connection.metadata.get(ConnectionMetadataTypes_1.ConnectionMetadataKeys.UseDidKeysForProtocol)) !== null && _a !== void 0 ? _a : {};
        useDidKeysForProtocol[protocolUri] = connectionUsesDidKey;
        connection.metadata.set(ConnectionMetadataTypes_1.ConnectionMetadataKeys.UseDidKeysForProtocol, useDidKeysForProtocol);
        await this.connectionService.update(agentContext, connection);
      }
    };
    MediatorService = __decorate([
      (0, plugins_1.injectable)(),
      __param(3, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [
        MediationRepository_1.MediationRepository,
        MediatorRoutingRepository_1.MediatorRoutingRepository,
        EventEmitter_1.EventEmitter,
        Object,
        connections_1.ConnectionService
      ])
    ], MediatorService);
    exports.MediatorService = MediatorService;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/services/index.js
var require_services5 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/services/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_MediationRecipientService(), exports);
    __exportStar(require_MediatorService(), exports);
    __exportStar(require_RoutingService(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v1/messages/BatchMessage.js
var require_BatchMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v1/messages/BatchMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BatchMessage = exports.BatchMessageMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var BaseMessage_1 = require_BaseMessage();
    var messageType_1 = require_messageType();
    var uuid_1 = require_uuid();
    var BatchMessageMessage = class {
      constructor(options) {
        if (options) {
          this.id = options.id || (0, uuid_1.uuid)();
          this.message = options.message;
        }
      }
    };
    __decorate([
      (0, class_validator_1.Matches)(BaseMessage_1.MessageIdRegExp),
      __metadata("design:type", String)
    ], BatchMessageMessage.prototype, "id", void 0);
    __decorate([
      (0, class_validator_1.IsObject)(),
      __metadata("design:type", Object)
    ], BatchMessageMessage.prototype, "message", void 0);
    exports.BatchMessageMessage = BatchMessageMessage;
    var BatchMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        super();
        this.type = BatchMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.messages = options.messages;
        }
      }
    };
    BatchMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/messagepickup/1.0/batch");
    __decorate([
      (0, messageType_1.IsValidMessageType)(BatchMessage.type),
      __metadata("design:type", Object)
    ], BatchMessage.prototype, "type", void 0);
    __decorate([
      (0, class_transformer_1.Type)(() => BatchMessageMessage),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsInstance)(BatchMessageMessage, { each: true }),
      (0, class_transformer_1.Expose)({ name: "messages~attach" }),
      __metadata("design:type", Array)
    ], BatchMessage.prototype, "messages", void 0);
    exports.BatchMessage = BatchMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v1/messages/BatchPickupMessage.js
var require_BatchPickupMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v1/messages/BatchPickupMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BatchPickupMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var BatchPickupMessage = class extends AgentMessage_1.AgentMessage {
      /**
       * Create new BatchPickupMessage instance.
       *
       * @param options
       */
      constructor(options) {
        super();
        this.type = BatchPickupMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.batchSize = options.batchSize;
        }
      }
    };
    BatchPickupMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/messagepickup/1.0/batch-pickup");
    __decorate([
      (0, messageType_1.IsValidMessageType)(BatchPickupMessage.type),
      __metadata("design:type", Object)
    ], BatchPickupMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsInt)(),
      (0, class_transformer_1.Expose)({ name: "batch_size" }),
      __metadata("design:type", Number)
    ], BatchPickupMessage.prototype, "batchSize", void 0);
    exports.BatchPickupMessage = BatchPickupMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v1/messages/index.js
var require_messages6 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v1/messages/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_BatchMessage(), exports);
    __exportStar(require_BatchPickupMessage(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v1/handlers/BatchHandler.js
var require_BatchHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v1/handlers/BatchHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BatchHandler = void 0;
    var Events_1 = require_Events();
    var messages_1 = require_messages6();
    var BatchHandler = class {
      constructor(eventEmitter) {
        this.supportedMessages = [messages_1.BatchMessage];
        this.eventEmitter = eventEmitter;
      }
      async handle(messageContext) {
        const { message } = messageContext;
        messageContext.assertReadyConnection();
        const forwardedMessages = message.messages;
        forwardedMessages.forEach((message2) => {
          this.eventEmitter.emit(messageContext.agentContext, {
            type: Events_1.AgentEventTypes.AgentMessageReceived,
            payload: {
              message: message2.message,
              contextCorrelationId: messageContext.agentContext.contextCorrelationId
            }
          });
        });
      }
    };
    exports.BatchHandler = BatchHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v1/handlers/BatchPickupHandler.js
var require_BatchPickupHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v1/handlers/BatchPickupHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BatchPickupHandler = void 0;
    var messages_1 = require_messages6();
    var BatchPickupHandler = class {
      constructor(messagePickupService) {
        this.supportedMessages = [messages_1.BatchPickupMessage];
        this.messagePickupService = messagePickupService;
      }
      async handle(messageContext) {
        messageContext.assertReadyConnection();
        return this.messagePickupService.batch(messageContext);
      }
    };
    exports.BatchPickupHandler = BatchPickupHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v1/handlers/index.js
var require_handlers2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v1/handlers/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_BatchHandler(), exports);
    __exportStar(require_BatchPickupHandler(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v1/MessagePickupService.js
var require_MessagePickupService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v1/MessagePickupService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessagePickupService = void 0;
    var Dispatcher_1 = require_Dispatcher();
    var EventEmitter_1 = require_EventEmitter();
    var models_1 = require_models3();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var handlers_1 = require_handlers2();
    var messages_1 = require_messages6();
    var MessagePickupService = class MessagePickupService {
      constructor(messageRepository, dispatcher, eventEmitter) {
        this.messageRepository = messageRepository;
        this.dispatcher = dispatcher;
        this.eventEmitter = eventEmitter;
        this.registerMessageHandlers();
      }
      async batch(messageContext) {
        const connection = messageContext.assertReadyConnection();
        const { message } = messageContext;
        const messages = await this.messageRepository.takeFromQueue(connection.id, message.batchSize);
        const batchMessages = messages.map((msg) => new messages_1.BatchMessageMessage({
          message: msg
        }));
        const batchMessage = new messages_1.BatchMessage({
          messages: batchMessages
        });
        return new models_1.OutboundMessageContext(batchMessage, { agentContext: messageContext.agentContext, connection });
      }
      async queueMessage(connectionId, message) {
        await this.messageRepository.add(connectionId, message);
      }
      registerMessageHandlers() {
        this.dispatcher.registerMessageHandler(new handlers_1.BatchPickupHandler(this));
        this.dispatcher.registerMessageHandler(new handlers_1.BatchHandler(this.eventEmitter));
      }
    };
    MessagePickupService = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.MessageRepository)),
      __metadata("design:paramtypes", [
        Object,
        Dispatcher_1.Dispatcher,
        EventEmitter_1.EventEmitter
      ])
    ], MessagePickupService);
    exports.MessagePickupService = MessagePickupService;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v1/index.js
var require_v1 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v1/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_MessagePickupService(), exports);
    __exportStar(require_messages6(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/handlers/DeliveryRequestHandler.js
var require_DeliveryRequestHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/handlers/DeliveryRequestHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeliveryRequestHandler = void 0;
    var messages_1 = require_messages5();
    var DeliveryRequestHandler = class {
      constructor(messagePickupService) {
        this.supportedMessages = [messages_1.DeliveryRequestMessage];
        this.messagePickupService = messagePickupService;
      }
      async handle(messageContext) {
        messageContext.assertReadyConnection();
        return this.messagePickupService.processDeliveryRequest(messageContext);
      }
    };
    exports.DeliveryRequestHandler = DeliveryRequestHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/handlers/MessageDeliveryHandler.js
var require_MessageDeliveryHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/handlers/MessageDeliveryHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageDeliveryHandler = void 0;
    var models_1 = require_models3();
    var MessageDeliveryMessage_1 = require_MessageDeliveryMessage();
    var MessageDeliveryHandler = class {
      constructor(mediationRecipientService) {
        this.supportedMessages = [MessageDeliveryMessage_1.MessageDeliveryMessage];
        this.mediationRecipientService = mediationRecipientService;
      }
      async handle(messageContext) {
        const connection = messageContext.assertReadyConnection();
        const deliveryReceivedMessage = await this.mediationRecipientService.processDelivery(messageContext);
        if (deliveryReceivedMessage) {
          return new models_1.OutboundMessageContext(deliveryReceivedMessage, {
            agentContext: messageContext.agentContext,
            connection
          });
        }
      }
    };
    exports.MessageDeliveryHandler = MessageDeliveryHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/handlers/MessagesReceivedHandler.js
var require_MessagesReceivedHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/handlers/MessagesReceivedHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessagesReceivedHandler = void 0;
    var messages_1 = require_messages5();
    var MessagesReceivedHandler = class {
      constructor(messagePickupService) {
        this.supportedMessages = [messages_1.MessagesReceivedMessage];
        this.messagePickupService = messagePickupService;
      }
      async handle(messageContext) {
        messageContext.assertReadyConnection();
        return this.messagePickupService.processMessagesReceived(messageContext);
      }
    };
    exports.MessagesReceivedHandler = MessagesReceivedHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/handlers/StatusHandler.js
var require_StatusHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/handlers/StatusHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatusHandler = void 0;
    var models_1 = require_models3();
    var messages_1 = require_messages5();
    var StatusHandler = class {
      constructor(mediatorRecipientService) {
        this.supportedMessages = [messages_1.StatusMessage];
        this.mediatorRecipientService = mediatorRecipientService;
      }
      async handle(messageContext) {
        const connection = messageContext.assertReadyConnection();
        const deliveryRequestMessage = await this.mediatorRecipientService.processStatus(messageContext);
        if (deliveryRequestMessage) {
          return new models_1.OutboundMessageContext(deliveryRequestMessage, {
            agentContext: messageContext.agentContext,
            connection
          });
        }
      }
    };
    exports.StatusHandler = StatusHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/handlers/StatusRequestHandler.js
var require_StatusRequestHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/handlers/StatusRequestHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatusRequestHandler = void 0;
    var messages_1 = require_messages5();
    var StatusRequestHandler = class {
      constructor(messagePickupService) {
        this.supportedMessages = [messages_1.StatusRequestMessage];
        this.messagePickupService = messagePickupService;
      }
      async handle(messageContext) {
        messageContext.assertReadyConnection();
        return this.messagePickupService.processStatusRequest(messageContext);
      }
    };
    exports.StatusRequestHandler = StatusRequestHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/handlers/index.js
var require_handlers3 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/handlers/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_DeliveryRequestHandler(), exports);
    __exportStar(require_MessageDeliveryHandler(), exports);
    __exportStar(require_MessagesReceivedHandler(), exports);
    __exportStar(require_StatusHandler(), exports);
    __exportStar(require_StatusRequestHandler(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/V2MessagePickupService.js
var require_V2MessagePickupService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/V2MessagePickupService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2MessagePickupService = void 0;
    var Dispatcher_1 = require_Dispatcher();
    var models_1 = require_models3();
    var constants_1 = require_constants();
    var Attachment_1 = require_Attachment();
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var services_1 = require_services5();
    var handlers_1 = require_handlers3();
    var messages_1 = require_messages5();
    var V2MessagePickupService = class V2MessagePickupService {
      constructor(messageRepository, dispatcher, mediationRecipientService) {
        this.messageRepository = messageRepository;
        this.dispatcher = dispatcher;
        this.mediationRecipientService = mediationRecipientService;
        this.registerMessageHandlers();
      }
      async processStatusRequest(messageContext) {
        const connection = messageContext.assertReadyConnection();
        if (messageContext.message.recipientKey) {
          throw new error_1.AriesFrameworkError("recipient_key parameter not supported");
        }
        const statusMessage = new messages_1.StatusMessage({
          threadId: messageContext.message.threadId,
          messageCount: await this.messageRepository.getAvailableMessageCount(connection.id)
        });
        return new models_1.OutboundMessageContext(statusMessage, { agentContext: messageContext.agentContext, connection });
      }
      async queueMessage(connectionId, message) {
        await this.messageRepository.add(connectionId, message);
      }
      async processDeliveryRequest(messageContext) {
        const connection = messageContext.assertReadyConnection();
        if (messageContext.message.recipientKey) {
          throw new error_1.AriesFrameworkError("recipient_key parameter not supported");
        }
        const { message } = messageContext;
        const messages = await this.messageRepository.takeFromQueue(connection.id, message.limit, true);
        const attachments = messages.map((msg) => new Attachment_1.Attachment({
          data: {
            json: msg
          }
        }));
        const outboundMessageContext = messages.length > 0 ? new messages_1.MessageDeliveryMessage({
          threadId: messageContext.message.threadId,
          attachments
        }) : new messages_1.StatusMessage({
          threadId: messageContext.message.threadId,
          messageCount: 0
        });
        return new models_1.OutboundMessageContext(outboundMessageContext, { agentContext: messageContext.agentContext, connection });
      }
      async processMessagesReceived(messageContext) {
        const connection = messageContext.assertReadyConnection();
        const { message } = messageContext;
        await this.messageRepository.takeFromQueue(connection.id, message.messageIdList ? message.messageIdList.length : void 0);
        const statusMessage = new messages_1.StatusMessage({
          threadId: messageContext.message.threadId,
          messageCount: await this.messageRepository.getAvailableMessageCount(connection.id)
        });
        return new models_1.OutboundMessageContext(statusMessage, { agentContext: messageContext.agentContext, connection });
      }
      registerMessageHandlers() {
        this.dispatcher.registerMessageHandler(new handlers_1.StatusRequestHandler(this));
        this.dispatcher.registerMessageHandler(new handlers_1.DeliveryRequestHandler(this));
        this.dispatcher.registerMessageHandler(new handlers_1.MessagesReceivedHandler(this));
        this.dispatcher.registerMessageHandler(new handlers_1.StatusHandler(this.mediationRecipientService));
        this.dispatcher.registerMessageHandler(new handlers_1.MessageDeliveryHandler(this.mediationRecipientService));
      }
    };
    V2MessagePickupService = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.MessageRepository)),
      __metadata("design:paramtypes", [
        Object,
        Dispatcher_1.Dispatcher,
        services_1.MediationRecipientService
      ])
    ], V2MessagePickupService);
    exports.V2MessagePickupService = V2MessagePickupService;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/index.js
var require_v2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/v2/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_V2MessagePickupService(), exports);
    __exportStar(require_messages5(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/index.js
var require_pickup = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/pickup/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_v1(), exports);
    __exportStar(require_v2(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/routing/protocol/index.js
var require_protocol = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/protocol/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_pickup(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/routing/MediatorModuleConfig.js
var require_MediatorModuleConfig = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/MediatorModuleConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MediatorModuleConfig = void 0;
    var MediatorModuleConfig = class {
      constructor(options) {
        this.options = options !== null && options !== void 0 ? options : {};
      }
      /** See {@link RecipientModuleConfigOptions.autoAcceptMediationRequests} */
      get autoAcceptMediationRequests() {
        var _a;
        return (_a = this.options.autoAcceptMediationRequests) !== null && _a !== void 0 ? _a : false;
      }
    };
    exports.MediatorModuleConfig = MediatorModuleConfig;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/handlers/ForwardHandler.js
var require_ForwardHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/handlers/ForwardHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ForwardHandler = void 0;
    var messages_1 = require_messages3();
    var ForwardHandler = class {
      constructor(mediatorService, connectionService, messageSender) {
        this.supportedMessages = [messages_1.ForwardMessage];
        this.mediatorService = mediatorService;
        this.connectionService = connectionService;
        this.messageSender = messageSender;
      }
      async handle(messageContext) {
        const { encryptedMessage, mediationRecord } = await this.mediatorService.processForwardMessage(messageContext);
        const connectionRecord = await this.connectionService.getById(messageContext.agentContext, mediationRecord.connectionId);
        await this.messageSender.sendPackage(messageContext.agentContext, {
          connection: connectionRecord,
          encryptedMessage
        });
      }
    };
    exports.ForwardHandler = ForwardHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/handlers/KeylistUpdateHandler.js
var require_KeylistUpdateHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/handlers/KeylistUpdateHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeylistUpdateHandler = void 0;
    var models_1 = require_models3();
    var messages_1 = require_messages3();
    var KeylistUpdateHandler = class {
      constructor(mediatorService) {
        this.supportedMessages = [messages_1.KeylistUpdateMessage];
        this.mediatorService = mediatorService;
      }
      async handle(messageContext) {
        const connection = messageContext.assertReadyConnection();
        const response = await this.mediatorService.processKeylistUpdateRequest(messageContext);
        return new models_1.OutboundMessageContext(response, {
          agentContext: messageContext.agentContext,
          connection
        });
      }
    };
    exports.KeylistUpdateHandler = KeylistUpdateHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/handlers/KeylistUpdateResponseHandler.js
var require_KeylistUpdateResponseHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/handlers/KeylistUpdateResponseHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeylistUpdateResponseHandler = void 0;
    var messages_1 = require_messages3();
    var KeylistUpdateResponseHandler = class {
      constructor(mediationRecipientService) {
        this.supportedMessages = [messages_1.KeylistUpdateResponseMessage];
        this.mediationRecipientService = mediationRecipientService;
      }
      async handle(messageContext) {
        messageContext.assertReadyConnection();
        return await this.mediationRecipientService.processKeylistUpdateResults(messageContext);
      }
    };
    exports.KeylistUpdateResponseHandler = KeylistUpdateResponseHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/handlers/MediationDenyHandler.js
var require_MediationDenyHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/handlers/MediationDenyHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MediationDenyHandler = void 0;
    var messages_1 = require_messages3();
    var MediationDenyHandler = class {
      constructor(mediationRecipientService) {
        this.supportedMessages = [messages_1.MediationDenyMessage];
        this.mediationRecipientService = mediationRecipientService;
      }
      async handle(messageContext) {
        messageContext.assertReadyConnection();
        await this.mediationRecipientService.processMediationDeny(messageContext);
      }
    };
    exports.MediationDenyHandler = MediationDenyHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/handlers/MediationGrantHandler.js
var require_MediationGrantHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/handlers/MediationGrantHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MediationGrantHandler = void 0;
    var messages_1 = require_messages3();
    var MediationGrantHandler = class {
      constructor(mediationRecipientService) {
        this.supportedMessages = [messages_1.MediationGrantMessage];
        this.mediationRecipientService = mediationRecipientService;
      }
      async handle(messageContext) {
        messageContext.assertReadyConnection();
        await this.mediationRecipientService.processMediationGrant(messageContext);
      }
    };
    exports.MediationGrantHandler = MediationGrantHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/handlers/MediationRequestHandler.js
var require_MediationRequestHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/handlers/MediationRequestHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MediationRequestHandler = void 0;
    var models_1 = require_models3();
    var MediationRequestMessage_1 = require_MediationRequestMessage();
    var MediationRequestHandler = class {
      constructor(mediatorService, mediatorModuleConfig) {
        this.supportedMessages = [MediationRequestMessage_1.MediationRequestMessage];
        this.mediatorService = mediatorService;
        this.mediatorModuleConfig = mediatorModuleConfig;
      }
      async handle(messageContext) {
        const connection = messageContext.assertReadyConnection();
        const mediationRecord = await this.mediatorService.processMediationRequest(messageContext);
        if (this.mediatorModuleConfig.autoAcceptMediationRequests) {
          const { message } = await this.mediatorService.createGrantMediationMessage(messageContext.agentContext, mediationRecord);
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            connection,
            associatedRecord: mediationRecord
          });
        }
      }
    };
    exports.MediationRequestHandler = MediationRequestHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/handlers/index.js
var require_handlers4 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/handlers/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ForwardHandler(), exports);
    __exportStar(require_KeylistUpdateHandler(), exports);
    __exportStar(require_KeylistUpdateResponseHandler(), exports);
    __exportStar(require_MediationDenyHandler(), exports);
    __exportStar(require_MediationGrantHandler(), exports);
    __exportStar(require_MediationRequestHandler(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/routing/MediatorApi.js
var require_MediatorApi = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/MediatorApi.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MediatorApi = void 0;
    var agent_1 = require_agent();
    var Dispatcher_1 = require_Dispatcher();
    var EventEmitter_1 = require_EventEmitter();
    var MessageSender_1 = require_MessageSender();
    var models_1 = require_models3();
    var plugins_1 = require_plugins();
    var services_1 = require_services3();
    var MediatorModuleConfig_1 = require_MediatorModuleConfig();
    var handlers_1 = require_handlers4();
    var MediationRequestHandler_1 = require_MediationRequestHandler();
    var protocol_1 = require_protocol();
    var handlers_2 = require_handlers2();
    var MediatorService_1 = require_MediatorService();
    var MediatorApi = class MediatorApi {
      constructor(dispatcher, mediationService, messagePickupService, v2MessagePickupService, messageSender, eventEmitter, agentContext, connectionService, config) {
        this.mediatorService = mediationService;
        this.messagePickupService = messagePickupService;
        this.messageSender = messageSender;
        this.eventEmitter = eventEmitter;
        this.connectionService = connectionService;
        this.agentContext = agentContext;
        this.config = config;
        this.registerMessageHandlers(dispatcher);
      }
      async initialize() {
        this.agentContext.config.logger.debug("Mediator routing record not loaded yet, retrieving from storage");
        const routingRecord = await this.mediatorService.findMediatorRoutingRecord(this.agentContext);
        if (!routingRecord) {
          this.agentContext.config.logger.debug("Mediator routing record does not exist yet, creating routing keys and record");
          await this.mediatorService.createMediatorRoutingRecord(this.agentContext);
        }
      }
      async grantRequestedMediation(mediatorId) {
        const record = await this.mediatorService.getById(this.agentContext, mediatorId);
        const connectionRecord = await this.connectionService.getById(this.agentContext, record.connectionId);
        const { message, mediationRecord } = await this.mediatorService.createGrantMediationMessage(this.agentContext, record);
        const outboundMessageContext = new models_1.OutboundMessageContext(message, {
          agentContext: this.agentContext,
          connection: connectionRecord,
          associatedRecord: mediationRecord
        });
        await this.messageSender.sendMessage(outboundMessageContext);
        return mediationRecord;
      }
      queueMessage(connectionId, message) {
        return this.messagePickupService.queueMessage(connectionId, message);
      }
      registerMessageHandlers(dispatcher) {
        dispatcher.registerMessageHandler(new handlers_1.KeylistUpdateHandler(this.mediatorService));
        dispatcher.registerMessageHandler(new handlers_1.ForwardHandler(this.mediatorService, this.connectionService, this.messageSender));
        dispatcher.registerMessageHandler(new handlers_2.BatchPickupHandler(this.messagePickupService));
        dispatcher.registerMessageHandler(new handlers_2.BatchHandler(this.eventEmitter));
        dispatcher.registerMessageHandler(new MediationRequestHandler_1.MediationRequestHandler(this.mediatorService, this.config));
      }
    };
    MediatorApi = __decorate([
      (0, plugins_1.injectable)(),
      __metadata("design:paramtypes", [
        Dispatcher_1.Dispatcher,
        MediatorService_1.MediatorService,
        protocol_1.MessagePickupService,
        protocol_1.V2MessagePickupService,
        MessageSender_1.MessageSender,
        EventEmitter_1.EventEmitter,
        agent_1.AgentContext,
        services_1.ConnectionService,
        MediatorModuleConfig_1.MediatorModuleConfig
      ])
    ], MediatorApi);
    exports.MediatorApi = MediatorApi;
  }
});

// node_modules/@aries-framework/core/build/transport/InboundTransport.js
var require_InboundTransport = __commonJS({
  "node_modules/@aries-framework/core/build/transport/InboundTransport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/transport/OutboundTransport.js
var require_OutboundTransport = __commonJS({
  "node_modules/@aries-framework/core/build/transport/OutboundTransport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/abort-controller/browser.js
var require_browser2 = __commonJS({
  "node_modules/abort-controller/browser.js"(exports, module) {
    "use strict";
    var { AbortController, AbortSignal } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
      /* otherwise */
      void 0
    );
    module.exports = AbortController;
    module.exports.AbortSignal = AbortSignal;
    module.exports.default = AbortController;
  }
});

// node_modules/@aries-framework/core/build/transport/HttpOutboundTransport.js
var require_HttpOutboundTransport = __commonJS({
  "node_modules/@aries-framework/core/build/transport/HttpOutboundTransport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpOutboundTransport = void 0;
    var abort_controller_1 = require_browser2();
    var Events_1 = require_Events();
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var utils_1 = require_utils();
    var HttpOutboundTransport = class {
      constructor() {
        this.supportedSchemes = ["http", "https"];
      }
      async start(agent) {
        this.agent = agent;
        this.logger = this.agent.config.logger;
        this.fetch = this.agent.config.agentDependencies.fetch;
        this.logger.debug("Starting HTTP outbound transport");
      }
      async stop() {
        this.logger.debug("Stopping HTTP outbound transport");
      }
      async sendMessage(outboundPackage) {
        const { payload, endpoint } = outboundPackage;
        if (!endpoint) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`Missing endpoint. I don't know how and where to send the message.`);
        }
        this.logger.debug(`Sending outbound message to endpoint '${outboundPackage.endpoint}'`, {
          payload: outboundPackage.payload
        });
        try {
          const abortController = new abort_controller_1.AbortController();
          const id = setTimeout(() => abortController.abort(), 15e3);
          let response;
          let responseMessage;
          try {
            response = await this.fetch(endpoint, {
              method: "POST",
              body: JSON.stringify(payload),
              headers: { "Content-Type": this.agent.config.didCommMimeType },
              signal: abortController.signal
            });
            clearTimeout(id);
            responseMessage = await response.text();
          } catch (error) {
            if (error.name == "AbortError" && outboundPackage.responseRequested) {
              this.logger.debug("Request was aborted due to timeout. Not throwing error due to return routing on sent message");
            } else {
              throw error;
            }
          }
          if (response && responseMessage) {
            this.logger.debug(`Response received`, { responseMessage, status: response.status });
            try {
              const encryptedMessage = utils_1.JsonEncoder.fromString(responseMessage);
              if (!(0, utils_1.isValidJweStructure)(encryptedMessage)) {
                this.logger.error(`Received a response from the other agent but the structure of the incoming message is not a DIDComm message: ${responseMessage}`);
                return;
              }
              this.agent.events.emit(this.agent.context, {
                type: Events_1.AgentEventTypes.AgentMessageReceived,
                payload: {
                  message: encryptedMessage
                }
              });
            } catch (error) {
              this.logger.debug("Unable to parse response message");
            }
          } else {
            this.logger.debug(`No response received.`);
          }
        } catch (error) {
          this.logger.error(`Error sending message to ${endpoint}: ${error.message}`, {
            error,
            message: error.message,
            body: payload,
            didCommMimeType: this.agent.config.didCommMimeType
          });
          throw new AriesFrameworkError_1.AriesFrameworkError(`Error sending message to ${endpoint}: ${error.message}`, { cause: error });
        }
      }
    };
    exports.HttpOutboundTransport = HttpOutboundTransport;
  }
});

// node_modules/@aries-framework/core/build/transport/TransportEventTypes.js
var require_TransportEventTypes = __commonJS({
  "node_modules/@aries-framework/core/build/transport/TransportEventTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TransportEventTypes = void 0;
    var TransportEventTypes;
    (function(TransportEventTypes2) {
      TransportEventTypes2["OutboundWebSocketClosedEvent"] = "OutboundWebSocketClosedEvent";
      TransportEventTypes2["OutboundWebSocketOpenedEvent"] = "OutboundWebSocketOpenedEvent";
    })(TransportEventTypes = exports.TransportEventTypes || (exports.TransportEventTypes = {}));
  }
});

// node_modules/@aries-framework/core/build/transport/WsOutboundTransport.js
var require_WsOutboundTransport = __commonJS({
  "node_modules/@aries-framework/core/build/transport/WsOutboundTransport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WsOutboundTransport = void 0;
    var Events_1 = require_Events();
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var utils_1 = require_utils();
    var buffer_1 = require_buffer2();
    var TransportEventTypes_1 = require_TransportEventTypes();
    var WsOutboundTransport = class {
      constructor() {
        this.transportTable = /* @__PURE__ */ new Map();
        this.supportedSchemes = ["ws", "wss"];
        this.handleMessageEvent = (event) => {
          this.logger.trace("WebSocket message event received.", { url: event.target.url });
          const payload = utils_1.JsonEncoder.fromBuffer(event.data);
          if (!(0, utils_1.isValidJweStructure)(payload)) {
            throw new Error(`Received a response from the other agent but the structure of the incoming message is not a DIDComm message: ${payload}`);
          }
          this.logger.debug("Payload received from mediator:", payload);
          this.agent.events.emit(this.agent.context, {
            type: Events_1.AgentEventTypes.AgentMessageReceived,
            payload: {
              message: payload
            }
          });
        };
      }
      async start(agent) {
        this.agent = agent;
        this.logger = agent.config.logger;
        this.logger.debug("Starting WS outbound transport");
        this.WebSocketClass = agent.config.agentDependencies.WebSocketClass;
      }
      async stop() {
        this.logger.debug("Stopping WS outbound transport");
        this.transportTable.forEach((socket) => {
          socket.removeEventListener("message", this.handleMessageEvent);
          socket.close();
        });
      }
      async sendMessage(outboundPackage) {
        const { payload, endpoint, connectionId } = outboundPackage;
        this.logger.debug(`Sending outbound message to endpoint '${endpoint}' over WebSocket transport.`, {
          payload
        });
        if (!endpoint) {
          throw new AriesFrameworkError_1.AriesFrameworkError("Missing connection or endpoint. I don't know how and where to send the message.");
        }
        const isNewSocket = this.hasOpenSocket(endpoint);
        const socket = await this.resolveSocket({ socketId: endpoint, endpoint, connectionId });
        socket.send(buffer_1.Buffer.from(JSON.stringify(payload)));
        if (isNewSocket && !outboundPackage.responseRequested) {
          socket.close();
        }
      }
      hasOpenSocket(socketId) {
        return this.transportTable.get(socketId) !== void 0;
      }
      async resolveSocket({ socketId, endpoint, connectionId }) {
        let socket = this.transportTable.get(socketId);
        if (!socket) {
          if (!endpoint) {
            throw new AriesFrameworkError_1.AriesFrameworkError(`Missing endpoint. I don't know how and where to send the message.`);
          }
          socket = await this.createSocketConnection({
            endpoint,
            socketId,
            connectionId
          });
          this.transportTable.set(socketId, socket);
          this.listenOnWebSocketMessages(socket);
        }
        if (socket.readyState !== this.WebSocketClass.OPEN) {
          throw new AriesFrameworkError_1.AriesFrameworkError("Socket is not open.");
        }
        return socket;
      }
      listenOnWebSocketMessages(socket) {
        socket.addEventListener("message", this.handleMessageEvent);
      }
      createSocketConnection({ socketId, endpoint, connectionId }) {
        return new Promise((resolve, reject) => {
          this.logger.debug(`Connecting to WebSocket ${endpoint}`);
          const socket = new this.WebSocketClass(endpoint);
          socket.onopen = () => {
            this.logger.debug(`Successfully connected to WebSocket ${endpoint}`);
            resolve(socket);
            this.agent.events.emit(this.agent.context, {
              type: TransportEventTypes_1.TransportEventTypes.OutboundWebSocketOpenedEvent,
              payload: {
                socketId,
                connectionId
              }
            });
          };
          socket.onerror = (error) => {
            this.logger.debug(`Error while connecting to WebSocket ${endpoint}`, {
              error
            });
            reject(error);
          };
          socket.onclose = async () => {
            this.logger.debug(`WebSocket closing to ${endpoint}`);
            socket.removeEventListener("message", this.handleMessageEvent);
            this.transportTable.delete(socketId);
            this.agent.events.emit(this.agent.context, {
              type: TransportEventTypes_1.TransportEventTypes.OutboundWebSocketClosedEvent,
              payload: {
                socketId,
                connectionId
              }
            });
          };
        });
      }
    };
    exports.WsOutboundTransport = WsOutboundTransport;
  }
});

// node_modules/@aries-framework/core/build/transport/index.js
var require_transport = __commonJS({
  "node_modules/@aries-framework/core/build/transport/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_InboundTransport(), exports);
    __exportStar(require_OutboundTransport(), exports);
    __exportStar(require_HttpOutboundTransport(), exports);
    __exportStar(require_WsOutboundTransport(), exports);
    __exportStar(require_TransportEventTypes(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/DiscoverFeaturesEvents.js
var require_DiscoverFeaturesEvents = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/DiscoverFeaturesEvents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscoverFeaturesEventTypes = void 0;
    var DiscoverFeaturesEventTypes;
    (function(DiscoverFeaturesEventTypes2) {
      DiscoverFeaturesEventTypes2["QueryReceived"] = "QueryReceived";
      DiscoverFeaturesEventTypes2["DisclosureReceived"] = "DisclosureReceived";
    })(DiscoverFeaturesEventTypes = exports.DiscoverFeaturesEventTypes || (exports.DiscoverFeaturesEventTypes = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/DiscoverFeaturesModuleConfig.js
var require_DiscoverFeaturesModuleConfig = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/DiscoverFeaturesModuleConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscoverFeaturesModuleConfig = void 0;
    var DiscoverFeaturesModuleConfig = class {
      constructor(options) {
        this.options = options !== null && options !== void 0 ? options : {};
      }
      /** {@inheritDoc DiscoverFeaturesModuleConfigOptions.autoAcceptQueries} */
      get autoAcceptQueries() {
        var _a;
        return (_a = this.options.autoAcceptQueries) !== null && _a !== void 0 ? _a : true;
      }
    };
    exports.DiscoverFeaturesModuleConfig = DiscoverFeaturesModuleConfig;
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/services/DiscoverFeaturesService.js
var require_DiscoverFeaturesService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/services/DiscoverFeaturesService.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscoverFeaturesService = void 0;
    var DiscoverFeaturesService = class {
      constructor(featureRegistry, eventEmitter, dispatcher, logger, discoverFeaturesModuleConfig) {
        this.featureRegistry = featureRegistry;
        this.eventEmitter = eventEmitter;
        this.dispatcher = dispatcher;
        this.logger = logger;
        this.discoverFeaturesModuleConfig = discoverFeaturesModuleConfig;
      }
    };
    exports.DiscoverFeaturesService = DiscoverFeaturesService;
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/services/index.js
var require_services6 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/services/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_DiscoverFeaturesService(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/protocol/v1/messages/DiscloseMessage.js
var require_DiscloseMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/protocol/v1/messages/DiscloseMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1DiscloseMessage = exports.DiscloseProtocol = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var DiscloseProtocol = class {
      constructor(options) {
        if (options) {
          this.protocolId = options.protocolId;
          this.roles = options.roles;
        }
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "pid" }),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], DiscloseProtocol.prototype, "protocolId", void 0);
    __decorate([
      (0, class_validator_1.IsString)({ each: true }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Array)
    ], DiscloseProtocol.prototype, "roles", void 0);
    exports.DiscloseProtocol = DiscloseProtocol;
    var V1DiscloseMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a;
        super();
        this.type = V1DiscloseMessage.type.messageTypeUri;
        if (options) {
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.protocols = options.protocols.map((p) => new DiscloseProtocol(p));
          this.setThread({
            threadId: options.threadId
          });
        }
      }
    };
    V1DiscloseMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/discover-features/1.0/disclose");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V1DiscloseMessage.type),
      __metadata("design:type", Object)
    ], V1DiscloseMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsInstance)(DiscloseProtocol, { each: true }),
      (0, class_transformer_1.Type)(() => DiscloseProtocol),
      __metadata("design:type", Array)
    ], V1DiscloseMessage.prototype, "protocols", void 0);
    exports.V1DiscloseMessage = V1DiscloseMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/protocol/v1/messages/QueryMessage.js
var require_QueryMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/protocol/v1/messages/QueryMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1QueryMessage = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var V1QueryMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a;
        super();
        this.type = V1QueryMessage.type.messageTypeUri;
        if (options) {
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.query = options.query;
          this.comment = options.comment;
        }
      }
    };
    V1QueryMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/discover-features/1.0/query");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V1QueryMessage.type),
      __metadata("design:type", Object)
    ], V1QueryMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], V1QueryMessage.prototype, "query", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], V1QueryMessage.prototype, "comment", void 0);
    exports.V1QueryMessage = V1QueryMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/protocol/v1/messages/index.js
var require_messages7 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/protocol/v1/messages/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_DiscloseMessage(), exports);
    __exportStar(require_QueryMessage(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/protocol/v1/handlers/V1DiscloseMessageHandler.js
var require_V1DiscloseMessageHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/protocol/v1/handlers/V1DiscloseMessageHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1DiscloseMessageHandler = void 0;
    var messages_1 = require_messages7();
    var V1DiscloseMessageHandler = class {
      constructor(discoverFeaturesService) {
        this.supportedMessages = [messages_1.V1DiscloseMessage];
        this.discoverFeaturesService = discoverFeaturesService;
      }
      async handle(inboundMessage) {
        await this.discoverFeaturesService.processDisclosure(inboundMessage);
      }
    };
    exports.V1DiscloseMessageHandler = V1DiscloseMessageHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/protocol/v1/handlers/V1QueryMessageHandler.js
var require_V1QueryMessageHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/protocol/v1/handlers/V1QueryMessageHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1QueryMessageHandler = void 0;
    var models_1 = require_models3();
    var messages_1 = require_messages7();
    var V1QueryMessageHandler = class {
      constructor(discoverFeaturesService) {
        this.supportedMessages = [messages_1.V1QueryMessage];
        this.discoverFeaturesService = discoverFeaturesService;
      }
      async handle(inboundMessage) {
        const connection = inboundMessage.assertReadyConnection();
        const discloseMessage = await this.discoverFeaturesService.processQuery(inboundMessage);
        if (discloseMessage) {
          return new models_1.OutboundMessageContext(discloseMessage.message, {
            agentContext: inboundMessage.agentContext,
            connection
          });
        }
      }
    };
    exports.V1QueryMessageHandler = V1QueryMessageHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/protocol/v1/handlers/index.js
var require_handlers5 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/protocol/v1/handlers/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_V1DiscloseMessageHandler(), exports);
    __exportStar(require_V1QueryMessageHandler(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/protocol/v1/V1DiscoverFeaturesService.js
var require_V1DiscoverFeaturesService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/protocol/v1/V1DiscoverFeaturesService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1DiscoverFeaturesService = void 0;
    var Dispatcher_1 = require_Dispatcher();
    var EventEmitter_1 = require_EventEmitter();
    var FeatureRegistry_1 = require_FeatureRegistry();
    var models_1 = require_models3();
    var constants_1 = require_constants();
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var DiscoverFeaturesEvents_1 = require_DiscoverFeaturesEvents();
    var DiscoverFeaturesModuleConfig_1 = require_DiscoverFeaturesModuleConfig();
    var services_1 = require_services6();
    var handlers_1 = require_handlers5();
    var messages_1 = require_messages7();
    var V1DiscoverFeaturesService = class V1DiscoverFeaturesService extends services_1.DiscoverFeaturesService {
      constructor(featureRegistry, eventEmitter, dispatcher, logger, discoverFeaturesConfig) {
        super(featureRegistry, eventEmitter, dispatcher, logger, discoverFeaturesConfig);
        this.version = "v1";
        this.registerMessageHandlers(dispatcher);
      }
      registerMessageHandlers(dispatcher) {
        dispatcher.registerMessageHandler(new handlers_1.V1DiscloseMessageHandler(this));
        dispatcher.registerMessageHandler(new handlers_1.V1QueryMessageHandler(this));
      }
      async createQuery(options) {
        if (options.queries.length > 1) {
          throw new error_1.AriesFrameworkError("Discover Features V1 only supports a single query");
        }
        if (options.queries[0].featureType !== "protocol") {
          throw new error_1.AriesFrameworkError("Discover Features V1 only supports querying for protocol support");
        }
        const queryMessage = new messages_1.V1QueryMessage({
          query: options.queries[0].match,
          comment: options.comment
        });
        return { message: queryMessage };
      }
      async processQuery(messageContext) {
        const { query, threadId } = messageContext.message;
        const connection = messageContext.assertReadyConnection();
        this.eventEmitter.emit(messageContext.agentContext, {
          type: DiscoverFeaturesEvents_1.DiscoverFeaturesEventTypes.QueryReceived,
          payload: {
            message: messageContext.message,
            connection,
            queries: [{ featureType: "protocol", match: query }],
            protocolVersion: this.version,
            threadId
          }
        });
        if (this.discoverFeaturesModuleConfig.autoAcceptQueries) {
          return await this.createDisclosure({
            threadId,
            disclosureQueries: [{ featureType: "protocol", match: query }]
          });
        }
      }
      async createDisclosure(options) {
        if (options.disclosureQueries.some((item) => item.featureType !== "protocol")) {
          throw new error_1.AriesFrameworkError("Discover Features V1 only supports protocols");
        }
        if (!options.threadId) {
          throw new error_1.AriesFrameworkError("Thread Id is required for Discover Features V1 disclosure");
        }
        const matches2 = this.featureRegistry.query(...options.disclosureQueries);
        const discloseMessage = new messages_1.V1DiscloseMessage({
          threadId: options.threadId,
          protocols: matches2.map((item) => new messages_1.DiscloseProtocol({
            protocolId: item.id,
            roles: item.roles
          }))
        });
        return { message: discloseMessage };
      }
      async processDisclosure(messageContext) {
        const { protocols, threadId } = messageContext.message;
        const connection = messageContext.assertReadyConnection();
        this.eventEmitter.emit(messageContext.agentContext, {
          type: DiscoverFeaturesEvents_1.DiscoverFeaturesEventTypes.DisclosureReceived,
          payload: {
            message: messageContext.message,
            connection,
            disclosures: protocols.map((item) => new models_1.Protocol({ id: item.protocolId, roles: item.roles })),
            protocolVersion: this.version,
            threadId
          }
        });
      }
    };
    V1DiscoverFeaturesService = __decorate([
      (0, plugins_1.injectable)(),
      __param(3, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [
        FeatureRegistry_1.FeatureRegistry,
        EventEmitter_1.EventEmitter,
        Dispatcher_1.Dispatcher,
        Object,
        DiscoverFeaturesModuleConfig_1.DiscoverFeaturesModuleConfig
      ])
    ], V1DiscoverFeaturesService);
    exports.V1DiscoverFeaturesService = V1DiscoverFeaturesService;
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/protocol/v1/index.js
var require_v12 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/protocol/v1/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_V1DiscoverFeaturesService(), exports);
    __exportStar(require_messages7(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/protocol/v2/messages/V2DisclosuresMessage.js
var require_V2DisclosuresMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/protocol/v2/messages/V2DisclosuresMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2DisclosuresMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var models_1 = require_models3();
    var messageType_1 = require_messageType();
    var V2DisclosuresMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a, _b;
        super();
        this.type = V2DisclosuresMessage.type.messageTypeUri;
        if (options) {
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.disclosures = (_b = options.features) !== null && _b !== void 0 ? _b : [];
          if (options.threadId) {
            this.setThread({
              threadId: options.threadId
            });
          }
        }
      }
    };
    V2DisclosuresMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/discover-features/2.0/disclosures");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V2DisclosuresMessage.type),
      __metadata("design:type", Object)
    ], V2DisclosuresMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsInstance)(models_1.Feature, { each: true }),
      (0, class_transformer_1.Type)(() => models_1.Feature),
      __metadata("design:type", Array)
    ], V2DisclosuresMessage.prototype, "disclosures", void 0);
    exports.V2DisclosuresMessage = V2DisclosuresMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/protocol/v2/messages/V2QueriesMessage.js
var require_V2QueriesMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/protocol/v2/messages/V2QueriesMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2QueriesMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var models_1 = require_models3();
    var messageType_1 = require_messageType();
    var V2QueriesMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a;
        super();
        this.type = V2QueriesMessage.type.messageTypeUri;
        if (options) {
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.queries = options.queries.map((q) => new models_1.FeatureQuery(q));
        }
      }
    };
    V2QueriesMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/discover-features/2.0/queries");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V2QueriesMessage.type),
      __metadata("design:type", Object)
    ], V2QueriesMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsInstance)(models_1.FeatureQuery, { each: true }),
      (0, class_transformer_1.Type)(() => models_1.FeatureQuery),
      (0, class_validator_1.ArrayNotEmpty)(),
      __metadata("design:type", Array)
    ], V2QueriesMessage.prototype, "queries", void 0);
    exports.V2QueriesMessage = V2QueriesMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/protocol/v2/messages/index.js
var require_messages8 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/protocol/v2/messages/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_V2DisclosuresMessage(), exports);
    __exportStar(require_V2QueriesMessage(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/protocol/v2/handlers/V2DisclosuresMessageHandler.js
var require_V2DisclosuresMessageHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/protocol/v2/handlers/V2DisclosuresMessageHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2DisclosuresMessageHandler = void 0;
    var messages_1 = require_messages8();
    var V2DisclosuresMessageHandler = class {
      constructor(discoverFeaturesService) {
        this.supportedMessages = [messages_1.V2DisclosuresMessage];
        this.discoverFeaturesService = discoverFeaturesService;
      }
      async handle(inboundMessage) {
        await this.discoverFeaturesService.processDisclosure(inboundMessage);
      }
    };
    exports.V2DisclosuresMessageHandler = V2DisclosuresMessageHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/protocol/v2/handlers/V2QueriesMessageHandler.js
var require_V2QueriesMessageHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/protocol/v2/handlers/V2QueriesMessageHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2QueriesMessageHandler = void 0;
    var models_1 = require_models3();
    var messages_1 = require_messages8();
    var V2QueriesMessageHandler = class {
      constructor(discoverFeaturesService) {
        this.supportedMessages = [messages_1.V2QueriesMessage];
        this.discoverFeaturesService = discoverFeaturesService;
      }
      async handle(inboundMessage) {
        const connection = inboundMessage.assertReadyConnection();
        const discloseMessage = await this.discoverFeaturesService.processQuery(inboundMessage);
        if (discloseMessage) {
          return new models_1.OutboundMessageContext(discloseMessage.message, {
            agentContext: inboundMessage.agentContext,
            connection
          });
        }
      }
    };
    exports.V2QueriesMessageHandler = V2QueriesMessageHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/protocol/v2/handlers/index.js
var require_handlers6 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/protocol/v2/handlers/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_V2DisclosuresMessageHandler(), exports);
    __exportStar(require_V2QueriesMessageHandler(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/protocol/v2/V2DiscoverFeaturesService.js
var require_V2DiscoverFeaturesService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/protocol/v2/V2DiscoverFeaturesService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2DiscoverFeaturesService = void 0;
    var Dispatcher_1 = require_Dispatcher();
    var EventEmitter_1 = require_EventEmitter();
    var FeatureRegistry_1 = require_FeatureRegistry();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var DiscoverFeaturesEvents_1 = require_DiscoverFeaturesEvents();
    var DiscoverFeaturesModuleConfig_1 = require_DiscoverFeaturesModuleConfig();
    var services_1 = require_services6();
    var handlers_1 = require_handlers6();
    var messages_1 = require_messages8();
    var V2DiscoverFeaturesService = class V2DiscoverFeaturesService extends services_1.DiscoverFeaturesService {
      constructor(featureRegistry, eventEmitter, dispatcher, logger, discoverFeaturesModuleConfig) {
        super(featureRegistry, eventEmitter, dispatcher, logger, discoverFeaturesModuleConfig);
        this.version = "v2";
        this.registerMessageHandlers(dispatcher);
      }
      registerMessageHandlers(dispatcher) {
        dispatcher.registerMessageHandler(new handlers_1.V2DisclosuresMessageHandler(this));
        dispatcher.registerMessageHandler(new handlers_1.V2QueriesMessageHandler(this));
      }
      async createQuery(options) {
        const queryMessage = new messages_1.V2QueriesMessage({ queries: options.queries });
        return { message: queryMessage };
      }
      async processQuery(messageContext) {
        const { queries, threadId } = messageContext.message;
        const connection = messageContext.assertReadyConnection();
        this.eventEmitter.emit(messageContext.agentContext, {
          type: DiscoverFeaturesEvents_1.DiscoverFeaturesEventTypes.QueryReceived,
          payload: {
            message: messageContext.message,
            connection,
            queries,
            protocolVersion: this.version,
            threadId
          }
        });
        if (this.discoverFeaturesModuleConfig.autoAcceptQueries) {
          return await this.createDisclosure({
            threadId,
            disclosureQueries: queries
          });
        }
      }
      async createDisclosure(options) {
        const matches2 = this.featureRegistry.query(...options.disclosureQueries);
        const discloseMessage = new messages_1.V2DisclosuresMessage({
          threadId: options.threadId,
          features: matches2
        });
        return { message: discloseMessage };
      }
      async processDisclosure(messageContext) {
        const { disclosures, threadId } = messageContext.message;
        const connection = messageContext.assertReadyConnection();
        this.eventEmitter.emit(messageContext.agentContext, {
          type: DiscoverFeaturesEvents_1.DiscoverFeaturesEventTypes.DisclosureReceived,
          payload: {
            message: messageContext.message,
            connection,
            disclosures,
            protocolVersion: this.version,
            threadId
          }
        });
      }
    };
    V2DiscoverFeaturesService = __decorate([
      (0, plugins_1.injectable)(),
      __param(3, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [
        FeatureRegistry_1.FeatureRegistry,
        EventEmitter_1.EventEmitter,
        Dispatcher_1.Dispatcher,
        Object,
        DiscoverFeaturesModuleConfig_1.DiscoverFeaturesModuleConfig
      ])
    ], V2DiscoverFeaturesService);
    exports.V2DiscoverFeaturesService = V2DiscoverFeaturesService;
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/protocol/v2/index.js
var require_v22 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/protocol/v2/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_V2DiscoverFeaturesService(), exports);
    __exportStar(require_messages8(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/protocol/index.js
var require_protocol2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/protocol/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_v12(), exports);
    __exportStar(require_v22(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/DiscoverFeaturesApi.js
var require_DiscoverFeaturesApi = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/DiscoverFeaturesApi.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscoverFeaturesApi = void 0;
    var rxjs_1 = require_cjs();
    var operators_1 = require_operators();
    var agent_1 = require_agent();
    var EventEmitter_1 = require_EventEmitter();
    var MessageSender_1 = require_MessageSender();
    var models_1 = require_models3();
    var constants_1 = require_constants();
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var services_1 = require_services3();
    var DiscoverFeaturesEvents_1 = require_DiscoverFeaturesEvents();
    var DiscoverFeaturesModuleConfig_1 = require_DiscoverFeaturesModuleConfig();
    var protocol_1 = require_protocol2();
    var DiscoverFeaturesApi = class DiscoverFeaturesApi {
      constructor(connectionService, messageSender, v1Service, v2Service, eventEmitter, stop$, agentContext, config) {
        this.connectionService = connectionService;
        this.messageSender = messageSender;
        this.eventEmitter = eventEmitter;
        this.stop$ = stop$;
        this.agentContext = agentContext;
        this.config = config;
        this.serviceMap = [v1Service, v2Service].reduce((serviceMap, service) => Object.assign(Object.assign({}, serviceMap), { [service.version]: service }), {});
      }
      getService(protocolVersion) {
        if (!this.serviceMap[protocolVersion]) {
          throw new error_1.AriesFrameworkError(`No discover features service registered for protocol version ${protocolVersion}`);
        }
        return this.serviceMap[protocolVersion];
      }
      /**
       * Send a query to an existing connection for discovering supported features of any kind. If desired, do the query synchronously,
       * meaning that it will await the response (or timeout) before resolving. Otherwise, response can be hooked by subscribing to
       * {DiscoverFeaturesDisclosureReceivedEvent}.
       *
       * Note: V1 protocol only supports a single query and is limited to protocols
       *
       * @param options feature queries to perform, protocol version and optional comment string (only used
       * in V1 protocol). If awaitDisclosures is set, perform the query synchronously with awaitDisclosuresTimeoutMs timeout.
       */
      async queryFeatures(options) {
        var _a;
        const service = this.getService(options.protocolVersion);
        const connection = await this.connectionService.getById(this.agentContext, options.connectionId);
        const { message: queryMessage } = await service.createQuery({
          queries: options.queries,
          comment: options.comment
        });
        const outboundMessageContext = new models_1.OutboundMessageContext(queryMessage, {
          agentContext: this.agentContext,
          connection
        });
        const replaySubject = new rxjs_1.ReplaySubject(1);
        if (options.awaitDisclosures) {
          this.eventEmitter.observable(DiscoverFeaturesEvents_1.DiscoverFeaturesEventTypes.DisclosureReceived).pipe(
            // Stop when the agent shuts down
            (0, operators_1.takeUntil)(this.stop$),
            // filter by connection id
            (0, operators_1.filter)((e) => {
              var _a2;
              return ((_a2 = e.payload.connection) === null || _a2 === void 0 ? void 0 : _a2.id) === connection.id;
            }),
            // Return disclosures
            (0, operators_1.map)((e) => e.payload.disclosures),
            // If we don't have an answer in timeoutMs miliseconds (no response, not supported, etc...) error
            (0, operators_1.timeout)((_a = options.awaitDisclosuresTimeoutMs) !== null && _a !== void 0 ? _a : 7e3),
            // TODO: Harmonize default timeouts across the framework
            // We want to return false if an error occurred
            (0, operators_1.catchError)(() => (0, rxjs_1.of)([]))
          ).subscribe(replaySubject);
        }
        await this.messageSender.sendMessage(outboundMessageContext);
        return { features: options.awaitDisclosures ? await (0, rxjs_1.firstValueFrom)(replaySubject) : void 0 };
      }
      /**
       * Disclose features to a connection, either proactively or as a response to a query.
       *
       * Features are disclosed based on queries that will be performed to Agent's Feature Registry,
       * meaning that they should be registered prior to disclosure. When sending disclosure as response,
       * these queries will usually match those from the corresponding Query or Queries message.
       *
       * Note: V1 protocol only supports sending disclosures as a response to a query.
       *
       * @param options multiple properties like protocol version to use, disclosure queries and thread id
       * (in case of disclosure as response to query)
       */
      async discloseFeatures(options) {
        const service = this.getService(options.protocolVersion);
        const connection = await this.connectionService.getById(this.agentContext, options.connectionId);
        const { message: disclosuresMessage } = await service.createDisclosure({
          disclosureQueries: options.disclosureQueries,
          threadId: options.threadId
        });
        const outboundMessageContext = new models_1.OutboundMessageContext(disclosuresMessage, {
          agentContext: this.agentContext,
          connection
        });
        await this.messageSender.sendMessage(outboundMessageContext);
      }
    };
    DiscoverFeaturesApi = __decorate([
      (0, plugins_1.injectable)(),
      __param(5, (0, plugins_1.inject)(constants_1.InjectionSymbols.Stop$)),
      __metadata("design:paramtypes", [
        services_1.ConnectionService,
        MessageSender_1.MessageSender,
        protocol_1.V1DiscoverFeaturesService,
        protocol_1.V2DiscoverFeaturesService,
        EventEmitter_1.EventEmitter,
        rxjs_1.Subject,
        agent_1.AgentContext,
        DiscoverFeaturesModuleConfig_1.DiscoverFeaturesModuleConfig
      ])
    ], DiscoverFeaturesApi);
    exports.DiscoverFeaturesApi = DiscoverFeaturesApi;
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/DiscoverFeaturesModule.js
var require_DiscoverFeaturesModule = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/DiscoverFeaturesModule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscoverFeaturesModule = void 0;
    var models_1 = require_models3();
    var DiscoverFeaturesApi_1 = require_DiscoverFeaturesApi();
    var DiscoverFeaturesModuleConfig_1 = require_DiscoverFeaturesModuleConfig();
    var v1_1 = require_v12();
    var v2_1 = require_v22();
    var DiscoverFeaturesModule = class {
      constructor(config) {
        this.api = DiscoverFeaturesApi_1.DiscoverFeaturesApi;
        this.config = new DiscoverFeaturesModuleConfig_1.DiscoverFeaturesModuleConfig(config);
      }
      /**
       * Registers the dependencies of the discover features module on the dependency manager.
       */
      register(dependencyManager, featureRegistry) {
        dependencyManager.registerContextScoped(DiscoverFeaturesApi_1.DiscoverFeaturesApi);
        dependencyManager.registerInstance(DiscoverFeaturesModuleConfig_1.DiscoverFeaturesModuleConfig, this.config);
        dependencyManager.registerSingleton(v1_1.V1DiscoverFeaturesService);
        dependencyManager.registerSingleton(v2_1.V2DiscoverFeaturesService);
        featureRegistry.register(new models_1.Protocol({
          id: "https://didcomm.org/discover-features/1.0",
          roles: ["requester", "responder"]
        }), new models_1.Protocol({
          id: "https://didcomm.org/discover-features/2.0",
          roles: ["requester", "responder"]
        }));
      }
    };
    exports.DiscoverFeaturesModule = DiscoverFeaturesModule;
  }
});

// node_modules/@aries-framework/core/build/modules/discover-features/index.js
var require_discover_features = __commonJS({
  "node_modules/@aries-framework/core/build/modules/discover-features/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_DiscoverFeaturesApi(), exports);
    __exportStar(require_DiscoverFeaturesEvents(), exports);
    __exportStar(require_DiscoverFeaturesModule(), exports);
    __exportStar(require_protocol2(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/routing/RecipientApi.js
var require_RecipientApi = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/RecipientApi.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RecipientApi = void 0;
    var rxjs_1 = require_cjs();
    var operators_1 = require_operators();
    var agent_1 = require_agent();
    var Dispatcher_1 = require_Dispatcher();
    var EventEmitter_1 = require_EventEmitter();
    var Events_1 = require_Events();
    var MessageSender_1 = require_MessageSender();
    var models_1 = require_models3();
    var constants_1 = require_constants();
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var transport_1 = require_transport();
    var ConnectionMetadataTypes_1 = require_ConnectionMetadataTypes();
    var services_1 = require_services3();
    var dids_1 = require_dids();
    var helpers_1 = require_helpers();
    var discover_features_1 = require_discover_features();
    var MediatorPickupStrategy_1 = require_MediatorPickupStrategy();
    var RecipientModuleConfig_1 = require_RecipientModuleConfig();
    var RoutingEvents_1 = require_RoutingEvents();
    var KeylistUpdateResponseHandler_1 = require_KeylistUpdateResponseHandler();
    var MediationDenyHandler_1 = require_MediationDenyHandler();
    var MediationGrantHandler_1 = require_MediationGrantHandler();
    var messages_1 = require_messages3();
    var MediationState_1 = require_MediationState();
    var protocol_1 = require_protocol();
    var handlers_1 = require_handlers3();
    var repository_1 = require_repository4();
    var MediationRecipientService_1 = require_MediationRecipientService();
    var RoutingService_1 = require_RoutingService();
    var RecipientApi = class RecipientApi {
      constructor(dispatcher, mediationRecipientService, connectionService, dids, messageSender, eventEmitter, discoverFeaturesApi, mediationRepository, routingService, logger, agentContext, stop$, recipientModuleConfig) {
        this.stopMessagePickup$ = new rxjs_1.Subject();
        this.connectionService = connectionService;
        this.dids = dids;
        this.mediationRecipientService = mediationRecipientService;
        this.messageSender = messageSender;
        this.eventEmitter = eventEmitter;
        this.logger = logger;
        this.discoverFeaturesApi = discoverFeaturesApi;
        this.mediationRepository = mediationRepository;
        this.routingService = routingService;
        this.agentContext = agentContext;
        this.stop$ = stop$;
        this.config = recipientModuleConfig;
        this.registerMessageHandlers(dispatcher);
      }
      async initialize() {
        const { defaultMediatorId, clearDefaultMediator } = this.agentContext.config;
        if (defaultMediatorId) {
          const mediatorRecord = await this.mediationRecipientService.getById(this.agentContext, defaultMediatorId);
          await this.mediationRecipientService.setDefaultMediator(this.agentContext, mediatorRecord);
        } else if (clearDefaultMediator) {
          await this.mediationRecipientService.clearDefaultMediator(this.agentContext);
        }
        const defaultMediator = await this.findDefaultMediator();
        if (defaultMediator) {
          this.initiateMessagePickup(defaultMediator).catch((error) => {
            this.logger.warn(`Error initiating message pickup with mediator ${defaultMediator.id}`, { error });
          });
        }
      }
      async sendMessage(outboundMessageContext, pickupStrategy) {
        const mediatorPickupStrategy = pickupStrategy !== null && pickupStrategy !== void 0 ? pickupStrategy : this.config.mediatorPickupStrategy;
        const transportPriority = mediatorPickupStrategy === MediatorPickupStrategy_1.MediatorPickupStrategy.Implicit ? { schemes: ["wss", "ws"], restrictive: true } : void 0;
        await this.messageSender.sendMessage(outboundMessageContext, {
          transportPriority
          // TODO: add keepAlive: true to enforce through the public api
          // we need to keep the socket alive. It already works this way, but would
          // be good to make more explicit from the public facing API.
          // This would also make it easier to change the internal API later on.
          // keepAlive: true,
        });
      }
      async openMediationWebSocket(mediator) {
        const connection = await this.connectionService.getById(this.agentContext, mediator.connectionId);
        const { message, connectionRecord } = await this.connectionService.createTrustPing(this.agentContext, connection, {
          responseRequested: false
        });
        const websocketSchemes = ["ws", "wss"];
        const didDocument = connectionRecord.theirDid && await this.dids.resolveDidDocument(connectionRecord.theirDid);
        const services = didDocument && (didDocument === null || didDocument === void 0 ? void 0 : didDocument.didCommServices);
        const hasWebSocketTransport = services && services.some((s) => websocketSchemes.includes(s.protocolScheme));
        if (!hasWebSocketTransport) {
          throw new error_1.AriesFrameworkError("Cannot open websocket to connection without websocket service endpoint");
        }
        await this.messageSender.sendMessage(new models_1.OutboundMessageContext(message, { agentContext: this.agentContext, connection: connectionRecord }), {
          transportPriority: {
            schemes: websocketSchemes,
            restrictive: true
            // TODO: add keepAlive: true to enforce through the public api
            // we need to keep the socket alive. It already works this way, but would
            // be good to make more explicit from the public facing API.
            // This would also make it easier to change the internal API later on.
            // keepAlive: true,
          }
        });
      }
      async openWebSocketAndPickUp(mediator, pickupStrategy) {
        const { baseMediatorReconnectionIntervalMs, maximumMediatorReconnectionIntervalMs } = this.config;
        let interval = baseMediatorReconnectionIntervalMs;
        const stopConditions$ = (0, rxjs_1.merge)(this.stop$, this.stopMessagePickup$).pipe();
        this.eventEmitter.observable(transport_1.TransportEventTypes.OutboundWebSocketOpenedEvent).pipe(
          // Stop when the agent shuts down or stop message pickup signal is received
          (0, operators_1.takeUntil)(stopConditions$),
          (0, operators_1.filter)((e) => e.payload.connectionId === mediator.connectionId)
        ).subscribe(() => {
          interval = baseMediatorReconnectionIntervalMs;
        });
        this.eventEmitter.observable(transport_1.TransportEventTypes.OutboundWebSocketClosedEvent).pipe(
          // Stop when the agent shuts down or stop message pickup signal is received
          (0, operators_1.takeUntil)(stopConditions$),
          (0, operators_1.filter)((e) => e.payload.connectionId === mediator.connectionId),
          // Make sure we're not reconnecting multiple times
          (0, operators_1.throttleTime)(interval),
          // Wait for interval time before reconnecting
          (0, operators_1.delayWhen)(() => (0, rxjs_1.timer)(interval)),
          // Increase the interval (recursive back-off)
          (0, operators_1.tap)(() => {
            interval = Math.min(interval * 2, maximumMediatorReconnectionIntervalMs);
          })
        ).subscribe({
          next: async () => {
            this.logger.debug(`Websocket connection to mediator with connectionId '${mediator.connectionId}' is closed, attempting to reconnect...`);
            try {
              if (pickupStrategy === MediatorPickupStrategy_1.MediatorPickupStrategy.PickUpV2) {
                await this.sendStatusRequest({ mediatorId: mediator.id });
              } else {
                await this.openMediationWebSocket(mediator);
              }
            } catch (error) {
              this.logger.warn("Unable to re-open websocket connection to mediator", { error });
            }
          },
          complete: () => this.logger.info(`Stopping pickup of messages from mediator '${mediator.id}'`)
        });
        try {
          if (pickupStrategy === MediatorPickupStrategy_1.MediatorPickupStrategy.Implicit) {
            await this.openMediationWebSocket(mediator);
          }
        } catch (error) {
          this.logger.warn("Unable to open websocket connection to mediator", { error });
        }
      }
      /**
       * Start a Message Pickup flow with a registered Mediator.
       *
       * @param mediator optional {MediationRecord} corresponding to the mediator to pick messages from. It will use
       * default mediator otherwise
       * @param pickupStrategy optional {MediatorPickupStrategy} to use in the loop. It will use Agent's default
       * strategy or attempt to find it by Discover Features otherwise
       * @returns
       */
      async initiateMessagePickup(mediator, pickupStrategy) {
        const { mediatorPollingInterval } = this.config;
        const mediatorRecord = mediator !== null && mediator !== void 0 ? mediator : await this.findDefaultMediator();
        if (!mediatorRecord) {
          throw new error_1.AriesFrameworkError("There is no mediator to pickup messages from");
        }
        const mediatorPickupStrategy = pickupStrategy !== null && pickupStrategy !== void 0 ? pickupStrategy : await this.getPickupStrategyForMediator(mediatorRecord);
        const mediatorConnection = await this.connectionService.getById(this.agentContext, mediatorRecord.connectionId);
        switch (mediatorPickupStrategy) {
          case MediatorPickupStrategy_1.MediatorPickupStrategy.PickUpV2:
            this.logger.info(`Starting pickup of messages from mediator '${mediatorRecord.id}'`);
            await this.openWebSocketAndPickUp(mediatorRecord, mediatorPickupStrategy);
            await this.sendStatusRequest({ mediatorId: mediatorRecord.id });
            break;
          case MediatorPickupStrategy_1.MediatorPickupStrategy.PickUpV1: {
            const stopConditions$ = (0, rxjs_1.merge)(this.stop$, this.stopMessagePickup$).pipe();
            this.logger.info(`Starting explicit (batch) pickup of messages from mediator '${mediatorRecord.id}'`);
            const subscription = (0, rxjs_1.interval)(mediatorPollingInterval).pipe((0, operators_1.takeUntil)(stopConditions$)).subscribe({
              next: async () => {
                await this.pickupMessages(mediatorConnection);
              },
              complete: () => this.logger.info(`Stopping pickup of messages from mediator '${mediatorRecord.id}'`)
            });
            return subscription;
          }
          case MediatorPickupStrategy_1.MediatorPickupStrategy.Implicit:
            this.logger.info(`Starting implicit pickup of messages from mediator '${mediatorRecord.id}'`);
            await this.openWebSocketAndPickUp(mediatorRecord, mediatorPickupStrategy);
            break;
          default:
            this.logger.info(`Skipping pickup of messages from mediator '${mediatorRecord.id}' due to pickup strategy none`);
        }
      }
      /**
       * Terminate all ongoing Message Pickup loops
       */
      async stopMessagePickup() {
        this.stopMessagePickup$.next(true);
      }
      async sendStatusRequest(config) {
        const mediationRecord = await this.mediationRecipientService.getById(this.agentContext, config.mediatorId);
        const statusRequestMessage = await this.mediationRecipientService.createStatusRequest(mediationRecord, {
          recipientKey: config.recipientKey
        });
        const mediatorConnection = await this.connectionService.getById(this.agentContext, mediationRecord.connectionId);
        return this.messageSender.sendMessage(new models_1.OutboundMessageContext(statusRequestMessage, {
          agentContext: this.agentContext,
          connection: mediatorConnection
        }));
      }
      async getPickupStrategyForMediator(mediator) {
        var _a, _b, _c;
        let mediatorPickupStrategy = (_a = mediator.pickupStrategy) !== null && _a !== void 0 ? _a : this.config.mediatorPickupStrategy;
        if (!mediatorPickupStrategy) {
          const discloseForPickupV2 = await this.discoverFeaturesApi.queryFeatures({
            connectionId: mediator.connectionId,
            protocolVersion: "v1",
            queries: [{ featureType: "protocol", match: protocol_1.StatusMessage.type.protocolUri }],
            awaitDisclosures: true
          });
          if ((_b = discloseForPickupV2.features) === null || _b === void 0 ? void 0 : _b.find((item) => item.id === protocol_1.StatusMessage.type.protocolUri)) {
            mediatorPickupStrategy = MediatorPickupStrategy_1.MediatorPickupStrategy.PickUpV2;
          } else {
            const discloseForPickupV1 = await this.discoverFeaturesApi.queryFeatures({
              connectionId: mediator.connectionId,
              protocolVersion: "v1",
              queries: [{ featureType: "protocol", match: protocol_1.BatchPickupMessage.type.protocolUri }],
              awaitDisclosures: true
            });
            mediatorPickupStrategy = ((_c = discloseForPickupV1.features) === null || _c === void 0 ? void 0 : _c.find((item) => item.id === protocol_1.BatchPickupMessage.type.protocolUri)) ? MediatorPickupStrategy_1.MediatorPickupStrategy.PickUpV1 : MediatorPickupStrategy_1.MediatorPickupStrategy.Implicit;
          }
          mediator.pickupStrategy = mediatorPickupStrategy;
          await this.mediationRepository.update(this.agentContext, mediator);
        }
        return mediatorPickupStrategy;
      }
      async discoverMediation() {
        return this.mediationRecipientService.discoverMediation(this.agentContext);
      }
      async pickupMessages(mediatorConnection, pickupStrategy) {
        mediatorConnection.assertReady();
        const pickupMessage = pickupStrategy === MediatorPickupStrategy_1.MediatorPickupStrategy.PickUpV2 ? new protocol_1.StatusRequestMessage({}) : new protocol_1.BatchPickupMessage({ batchSize: 10 });
        const outboundMessageContext = new models_1.OutboundMessageContext(pickupMessage, {
          agentContext: this.agentContext,
          connection: mediatorConnection
        });
        await this.sendMessage(outboundMessageContext, pickupStrategy);
      }
      async setDefaultMediator(mediatorRecord) {
        return this.mediationRecipientService.setDefaultMediator(this.agentContext, mediatorRecord);
      }
      async requestMediation(connection) {
        const { mediationRecord, message } = await this.mediationRecipientService.createRequest(this.agentContext, connection);
        const outboundMessage = new models_1.OutboundMessageContext(message, {
          agentContext: this.agentContext,
          connection
        });
        await this.sendMessage(outboundMessage);
        return mediationRecord;
      }
      async notifyKeylistUpdate(connection, verkey, action) {
        var _a;
        let useDidKey = this.agentContext.config.useDidKeyInProtocols;
        const useDidKeysConnectionMetadata = connection.metadata.get(ConnectionMetadataTypes_1.ConnectionMetadataKeys.UseDidKeysForProtocol);
        if (useDidKeysConnectionMetadata) {
          useDidKey = (_a = useDidKeysConnectionMetadata[messages_1.KeylistUpdateMessage.type.protocolUri]) !== null && _a !== void 0 ? _a : useDidKey;
        }
        const message = this.mediationRecipientService.createKeylistUpdateMessage([
          new messages_1.KeylistUpdate({
            action: action !== null && action !== void 0 ? action : messages_1.KeylistUpdateAction.add,
            recipientKey: useDidKey ? (0, helpers_1.verkeyToDidKey)(verkey) : verkey
          })
        ]);
        const outboundMessageContext = new models_1.OutboundMessageContext(message, {
          agentContext: this.agentContext,
          connection
        });
        await this.sendMessage(outboundMessageContext);
      }
      async findByConnectionId(connectionId) {
        return await this.mediationRecipientService.findByConnectionId(this.agentContext, connectionId);
      }
      async getMediators() {
        return await this.mediationRecipientService.getMediators(this.agentContext);
      }
      async findDefaultMediator() {
        return this.mediationRecipientService.findDefaultMediator(this.agentContext);
      }
      async findDefaultMediatorConnection() {
        const mediatorRecord = await this.findDefaultMediator();
        if (mediatorRecord) {
          return this.connectionService.getById(this.agentContext, mediatorRecord.connectionId);
        }
        return null;
      }
      async requestAndAwaitGrant(connection, timeoutMs = 1e4) {
        const { mediationRecord, message } = await this.mediationRecipientService.createRequest(this.agentContext, connection);
        const observable = this.eventEmitter.observable(RoutingEvents_1.RoutingEventTypes.MediationStateChanged);
        const subject = new rxjs_1.ReplaySubject(1);
        observable.pipe(
          (0, Events_1.filterContextCorrelationId)(this.agentContext.contextCorrelationId),
          // Only take event for current mediation record
          (0, operators_1.filter)((event2) => event2.payload.mediationRecord.id === mediationRecord.id),
          // Only take event for previous state requested, current state granted
          (0, operators_1.filter)((event2) => event2.payload.previousState === MediationState_1.MediationState.Requested),
          (0, operators_1.filter)((event2) => event2.payload.mediationRecord.state === MediationState_1.MediationState.Granted),
          // Only wait for first event that matches the criteria
          (0, operators_1.first)(),
          // Do not wait for longer than specified timeout
          (0, operators_1.timeout)(timeoutMs)
        ).subscribe(subject);
        const outboundMessageContext = new models_1.OutboundMessageContext(message, {
          agentContext: this.agentContext,
          connection,
          associatedRecord: mediationRecord
        });
        await this.sendMessage(outboundMessageContext);
        const event = await (0, rxjs_1.firstValueFrom)(subject);
        return event.payload.mediationRecord;
      }
      /**
       * Requests mediation for a given connection and sets that as default mediator.
       *
       * @param connection connection record which will be used for mediation
       * @returns mediation record
       */
      async provision(connection) {
        this.logger.debug("Connection completed, requesting mediation");
        let mediation = await this.findByConnectionId(connection.id);
        if (!mediation) {
          this.logger.info(`Requesting mediation for connection ${connection.id}`);
          mediation = await this.requestAndAwaitGrant(connection, 6e4);
          this.logger.debug("Mediation granted, setting as default mediator");
          await this.setDefaultMediator(mediation);
          this.logger.debug("Default mediator set");
        } else {
          this.logger.debug(`Mediator invitation has already been ${mediation.isReady ? "granted" : "requested"}`);
        }
        return mediation;
      }
      async getRouting(options) {
        return this.routingService.getRouting(this.agentContext, options);
      }
      // Register handlers for the several messages for the mediator.
      registerMessageHandlers(dispatcher) {
        dispatcher.registerMessageHandler(new KeylistUpdateResponseHandler_1.KeylistUpdateResponseHandler(this.mediationRecipientService));
        dispatcher.registerMessageHandler(new MediationGrantHandler_1.MediationGrantHandler(this.mediationRecipientService));
        dispatcher.registerMessageHandler(new MediationDenyHandler_1.MediationDenyHandler(this.mediationRecipientService));
        dispatcher.registerMessageHandler(new handlers_1.StatusHandler(this.mediationRecipientService));
        dispatcher.registerMessageHandler(new handlers_1.MessageDeliveryHandler(this.mediationRecipientService));
      }
    };
    RecipientApi = __decorate([
      (0, plugins_1.injectable)(),
      __param(9, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __param(11, (0, plugins_1.inject)(constants_1.InjectionSymbols.Stop$)),
      __metadata("design:paramtypes", [
        Dispatcher_1.Dispatcher,
        MediationRecipientService_1.MediationRecipientService,
        services_1.ConnectionService,
        dids_1.DidsApi,
        MessageSender_1.MessageSender,
        EventEmitter_1.EventEmitter,
        discover_features_1.DiscoverFeaturesApi,
        repository_1.MediationRepository,
        RoutingService_1.RoutingService,
        Object,
        agent_1.AgentContext,
        rxjs_1.Subject,
        RecipientModuleConfig_1.RecipientModuleConfig
      ])
    ], RecipientApi);
    exports.RecipientApi = RecipientApi;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/MediatorModule.js
var require_MediatorModule = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/MediatorModule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MediatorModule = void 0;
    var models_1 = require_models3();
    var MediatorApi_1 = require_MediatorApi();
    var MediatorModuleConfig_1 = require_MediatorModuleConfig();
    var models_2 = require_models4();
    var protocol_1 = require_protocol();
    var repository_1 = require_repository4();
    var services_1 = require_services5();
    var MediatorModule = class {
      constructor(config) {
        this.api = MediatorApi_1.MediatorApi;
        this.config = new MediatorModuleConfig_1.MediatorModuleConfig(config);
      }
      /**
       * Registers the dependencies of the question answer module on the dependency manager.
       */
      register(dependencyManager, featureRegistry) {
        dependencyManager.registerContextScoped(MediatorApi_1.MediatorApi);
        dependencyManager.registerInstance(MediatorModuleConfig_1.MediatorModuleConfig, this.config);
        dependencyManager.registerSingleton(services_1.MediatorService);
        dependencyManager.registerSingleton(protocol_1.MessagePickupService);
        dependencyManager.registerSingleton(protocol_1.V2MessagePickupService);
        dependencyManager.registerSingleton(repository_1.MediationRepository);
        dependencyManager.registerSingleton(repository_1.MediatorRoutingRepository);
        featureRegistry.register(new models_1.Protocol({
          id: "https://didcomm.org/coordinate-mediation/1.0",
          roles: [models_2.MediationRole.Mediator]
        }), new models_1.Protocol({
          id: "https://didcomm.org/messagepickup/1.0",
          roles: ["message_holder", "recipient", "batch_sender", "batch_recipient"]
        }), new models_1.Protocol({
          id: "https://didcomm.org/messagepickup/2.0",
          roles: ["mediator", "recipient"]
        }));
      }
    };
    exports.MediatorModule = MediatorModule;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/RecipientModule.js
var require_RecipientModule = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/RecipientModule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RecipientModule = void 0;
    var models_1 = require_models3();
    var RecipientApi_1 = require_RecipientApi();
    var RecipientModuleConfig_1 = require_RecipientModuleConfig();
    var models_2 = require_models4();
    var repository_1 = require_repository4();
    var services_1 = require_services5();
    var RecipientModule = class {
      constructor(config) {
        this.api = RecipientApi_1.RecipientApi;
        this.config = new RecipientModuleConfig_1.RecipientModuleConfig(config);
      }
      /**
       * Registers the dependencies of the mediator recipient module on the dependency manager.
       */
      register(dependencyManager, featureRegistry) {
        dependencyManager.registerContextScoped(RecipientApi_1.RecipientApi);
        dependencyManager.registerInstance(RecipientModuleConfig_1.RecipientModuleConfig, this.config);
        dependencyManager.registerSingleton(services_1.MediationRecipientService);
        dependencyManager.registerSingleton(services_1.RoutingService);
        dependencyManager.registerSingleton(repository_1.MediationRepository);
        featureRegistry.register(new models_1.Protocol({
          id: "https://didcomm.org/coordinate-mediation/1.0",
          roles: [models_2.MediationRole.Recipient]
        }));
      }
    };
    exports.RecipientModule = RecipientModule;
  }
});

// node_modules/@aries-framework/core/build/modules/routing/index.js
var require_routing = __commonJS({
  "node_modules/@aries-framework/core/build/modules/routing/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_messages3(), exports);
    __exportStar(require_services5(), exports);
    __exportStar(require_protocol(), exports);
    __exportStar(require_repository4(), exports);
    __exportStar(require_models4(), exports);
    __exportStar(require_RoutingEvents(), exports);
    __exportStar(require_MediatorApi(), exports);
    __exportStar(require_RecipientApi(), exports);
    __exportStar(require_MediatorPickupStrategy(), exports);
    __exportStar(require_MediatorModule(), exports);
    __exportStar(require_RecipientModule(), exports);
  }
});

// node_modules/@aries-framework/core/build/storage/migration/updates/0.1-0.2/mediation.js
var require_mediation = __commonJS({
  "node_modules/@aries-framework/core/build/storage/migration/updates/0.1-0.2/mediation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateMediationRole = exports.migrateMediationRecordToV0_2 = void 0;
    var routing_1 = require_routing();
    async function migrateMediationRecordToV0_2(agent, upgradeConfig) {
      agent.config.logger.info("Migrating mediation records to storage version 0.2");
      const mediationRepository = agent.dependencyManager.resolve(routing_1.MediationRepository);
      agent.config.logger.debug(`Fetching all mediation records from storage`);
      const allMediationRecords = await mediationRepository.getAll(agent.context);
      agent.config.logger.debug(`Found a total of ${allMediationRecords.length} mediation records to update.`);
      for (const mediationRecord of allMediationRecords) {
        agent.config.logger.debug(`Migrating mediation record with id ${mediationRecord.id} to storage version 0.2`);
        await updateMediationRole(agent, mediationRecord, upgradeConfig);
        await mediationRepository.update(agent.context, mediationRecord);
        agent.config.logger.debug(`Successfully migrated mediation record with id ${mediationRecord.id} to storage version 0.2`);
      }
    }
    exports.migrateMediationRecordToV0_2 = migrateMediationRecordToV0_2;
    async function updateMediationRole(agent, mediationRecord, { mediationRoleUpdateStrategy }) {
      agent.config.logger.debug(`Updating mediation record role using strategy '${mediationRoleUpdateStrategy}'`);
      switch (mediationRoleUpdateStrategy) {
        case "allMediator":
          mediationRecord.role = routing_1.MediationRole.Mediator;
          break;
        case "allRecipient":
          mediationRecord.role = routing_1.MediationRole.Recipient;
          break;
        case "recipientIfEndpoint":
          if (mediationRecord.endpoint) {
            agent.config.logger.debug("Mediation record endpoint is set, setting mediation role to recipient");
            mediationRecord.role = routing_1.MediationRole.Recipient;
          } else {
            agent.config.logger.debug("Mediation record endpoint is not set, setting mediation role to mediator");
            mediationRecord.role = routing_1.MediationRole.Mediator;
          }
          break;
        case "doNotChange":
          break;
      }
    }
    exports.updateMediationRole = updateMediationRole;
  }
});

// node_modules/@aries-framework/core/build/storage/migration/updates/0.1-0.2/index.js
var require__ = __commonJS({
  "node_modules/@aries-framework/core/build/storage/migration/updates/0.1-0.2/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateV0_1ToV0_2 = void 0;
    var connection_1 = require_connection();
    var credential_1 = require_credential();
    var mediation_1 = require_mediation();
    async function updateV0_1ToV0_2(agent, config) {
      await (0, credential_1.migrateCredentialRecordToV0_2)(agent);
      await (0, mediation_1.migrateMediationRecordToV0_2)(agent, config.v0_1ToV0_2);
      await (0, connection_1.migrateConnectionRecordToV0_2)(agent);
    }
    exports.updateV0_1ToV0_2 = updateV0_1ToV0_2;
  }
});

// node_modules/@aries-framework/core/build/storage/migration/updates/0.2-0.3/connection.js
var require_connection2 = __commonJS({
  "node_modules/@aries-framework/core/build/storage/migration/updates/0.2-0.3/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.migrateConnectionRecordTags = exports.migrateConnectionRecordToV0_3 = void 0;
    var connections_1 = require_connections();
    var routing_1 = require_routing();
    async function migrateConnectionRecordToV0_3(agent) {
      agent.config.logger.info("Migrating connection records to storage version 0.3");
      const connectionRepository = agent.dependencyManager.resolve(connections_1.ConnectionRepository);
      const mediationRepository = agent.dependencyManager.resolve(routing_1.MediationRepository);
      agent.config.logger.debug("Fetching all connection records from storage");
      const allConnections = await connectionRepository.getAll(agent.context);
      agent.config.logger.debug(`Found a total of ${allConnections.length} connection records to update`);
      agent.config.logger.debug("Fetching all mediation records from storage");
      const allMediators = await mediationRepository.getAll(agent.context);
      agent.config.logger.debug(`Found a total of ${allMediators.length} mediation records`);
      const mediatorConnectionIds = new Set(allMediators.map((mediator) => mediator.connectionId));
      for (const connectionRecord of allConnections) {
        agent.config.logger.debug(`Migrating connection record with id ${connectionRecord.id} to storage version 0.3`);
        await migrateConnectionRecordTags(agent, connectionRecord, mediatorConnectionIds);
        await connectionRepository.update(agent.context, connectionRecord);
        agent.config.logger.debug(`Successfully migrated connection record with id ${connectionRecord.id} to storage version 0.3`);
      }
    }
    exports.migrateConnectionRecordToV0_3 = migrateConnectionRecordToV0_3;
    async function migrateConnectionRecordTags(agent, connectionRecord, mediatorConnectionIds = /* @__PURE__ */ new Set()) {
      agent.config.logger.debug(`Migrating internal connection record type tags ${connectionRecord.id} to storage version 0.3`);
      const connectionTypeTags = connectionRecord.getTags().connectionType || [];
      const connectionTypes = [...connectionTypeTags];
      if (mediatorConnectionIds.has(connectionRecord.id) && !connectionTypes.includes(connections_1.ConnectionType.Mediator)) {
        connectionTypes.push(connections_1.ConnectionType.Mediator);
      }
      connectionRecord.connectionTypes = connectionTypes;
      connectionRecord.setTag("connectionType", void 0);
      agent.config.logger.debug(`Successfully migrated internal connection record type tags ${connectionRecord.id} to storage version 0.3`);
    }
    exports.migrateConnectionRecordTags = migrateConnectionRecordTags;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/models/GetRequestedCredentialsConfig.js
var require_GetRequestedCredentialsConfig = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/models/GetRequestedCredentialsConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/models/ProofState.js
var require_ProofState = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/models/ProofState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofState = void 0;
    var ProofState;
    (function(ProofState2) {
      ProofState2["ProposalSent"] = "proposal-sent";
      ProofState2["ProposalReceived"] = "proposal-received";
      ProofState2["RequestSent"] = "request-sent";
      ProofState2["RequestReceived"] = "request-received";
      ProofState2["PresentationSent"] = "presentation-sent";
      ProofState2["PresentationReceived"] = "presentation-received";
      ProofState2["Declined"] = "declined";
      ProofState2["Abandoned"] = "abandoned";
      ProofState2["Done"] = "done";
    })(ProofState = exports.ProofState || (exports.ProofState = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/models/index.js
var require_models5 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/models/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_GetRequestedCredentialsConfig(), exports);
    __exportStar(require_ProofAutoAcceptType(), exports);
    __exportStar(require_ProofState(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/repository/ProofExchangeRecord.js
var require_ProofExchangeRecord = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/repository/ProofExchangeRecord.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofExchangeRecord = void 0;
    var error_1 = require_error();
    var BaseRecord_1 = require_BaseRecord();
    var uuid_1 = require_uuid();
    var ProofExchangeRecord = class extends BaseRecord_1.BaseRecord {
      constructor(props) {
        var _a, _b, _c;
        super();
        this.type = ProofExchangeRecord.type;
        if (props) {
          this.id = (_a = props.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.createdAt = (_b = props.createdAt) !== null && _b !== void 0 ? _b : /* @__PURE__ */ new Date();
          this.protocolVersion = props.protocolVersion;
          this.isVerified = props.isVerified;
          this.state = props.state;
          this.connectionId = props.connectionId;
          this.threadId = props.threadId;
          this.parentThreadId = props.parentThreadId;
          this.autoAcceptProof = props.autoAcceptProof;
          this._tags = (_c = props.tags) !== null && _c !== void 0 ? _c : {};
          this.errorMessage = props.errorMessage;
        }
      }
      getTags() {
        return Object.assign(Object.assign({}, this._tags), { threadId: this.threadId, parentThreadId: this.parentThreadId, connectionId: this.connectionId, state: this.state });
      }
      assertState(expectedStates) {
        if (!Array.isArray(expectedStates)) {
          expectedStates = [expectedStates];
        }
        if (!expectedStates.includes(this.state)) {
          throw new error_1.AriesFrameworkError(`Proof record is in invalid state ${this.state}. Valid states are: ${expectedStates.join(", ")}.`);
        }
      }
      assertConnection(currentConnectionId) {
        if (!this.connectionId) {
          throw new error_1.AriesFrameworkError(`Proof record is not associated with any connection. This is often the case with connection-less presentation exchange`);
        } else if (this.connectionId !== currentConnectionId) {
          throw new error_1.AriesFrameworkError(`Proof record is associated with connection '${this.connectionId}'. Current connection is '${currentConnectionId}'`);
        }
      }
    };
    exports.ProofExchangeRecord = ProofExchangeRecord;
    ProofExchangeRecord.type = "ProofRecord";
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/repository/ProofRepository.js
var require_ProofRepository = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/repository/ProofRepository.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofRepository = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var Repository_1 = require_Repository();
    var ProofExchangeRecord_1 = require_ProofExchangeRecord();
    var ProofRepository = class ProofRepository extends Repository_1.Repository {
      constructor(storageService, eventEmitter) {
        super(ProofExchangeRecord_1.ProofExchangeRecord, storageService, eventEmitter);
      }
      /**
       * Retrieve a proof record by connection id and thread id
       *
       * @param connectionId The connection id
       * @param threadId The thread id
       * @throws {RecordNotFoundError} If no record is found
       * @throws {RecordDuplicateError} If multiple records are found
       * @returns The proof record
       */
      async getByThreadAndConnectionId(agentContext, threadId, connectionId) {
        return this.getSingleByQuery(agentContext, { threadId, connectionId });
      }
      /**
       * Retrieve proof records by connection id and parent thread id
       *
       * @param connectionId The connection id
       * @param parentThreadId The parent thread id
       * @returns List containing all proof records matching the given query
       */
      async getByParentThreadAndConnectionId(agentContext, parentThreadId, connectionId) {
        return this.findByQuery(agentContext, { parentThreadId, connectionId });
      }
    };
    ProofRepository = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.StorageService)),
      __metadata("design:paramtypes", [Object, EventEmitter_1.EventEmitter])
    ], ProofRepository);
    exports.ProofRepository = ProofRepository;
  }
});

// node_modules/@aries-framework/core/build/storage/migration/updates/0.2-0.3/proof.js
var require_proof = __commonJS({
  "node_modules/@aries-framework/core/build/storage/migration/updates/0.2-0.3/proof.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.moveDidCommMessages = exports.migrateInternalProofExchangeRecordProperties = exports.getProofRole = exports.ProofRole = exports.migrateProofExchangeRecordToV0_3 = void 0;
    var models_1 = require_models5();
    var ProofRepository_1 = require_ProofRepository();
    var didcomm_1 = require_didcomm2();
    async function migrateProofExchangeRecordToV0_3(agent) {
      agent.config.logger.info("Migrating proof records to storage version 0.3");
      const proofRepository = agent.dependencyManager.resolve(ProofRepository_1.ProofRepository);
      agent.config.logger.debug(`Fetching all proof records from storage`);
      const allProofs = await proofRepository.getAll(agent.context);
      agent.config.logger.debug(`Found a total of ${allProofs.length} proof records to update.`);
      for (const proofRecord of allProofs) {
        agent.config.logger.debug(`Migrating proof record with id ${proofRecord.id} to storage version 0.3`);
        await migrateInternalProofExchangeRecordProperties(agent, proofRecord);
        await moveDidCommMessages(agent, proofRecord);
        await proofRepository.update(agent.context, proofRecord);
        agent.config.logger.debug(`Successfully migrated proof record with id ${proofRecord.id} to storage version 0.3`);
      }
    }
    exports.migrateProofExchangeRecordToV0_3 = migrateProofExchangeRecordToV0_3;
    var ProofRole;
    (function(ProofRole2) {
      ProofRole2[ProofRole2["Verifier"] = 0] = "Verifier";
      ProofRole2[ProofRole2["Prover"] = 1] = "Prover";
    })(ProofRole = exports.ProofRole || (exports.ProofRole = {}));
    var proverProofStates = [
      models_1.ProofState.Declined,
      models_1.ProofState.ProposalSent,
      models_1.ProofState.RequestReceived,
      models_1.ProofState.PresentationSent,
      models_1.ProofState.Done
    ];
    var didCommMessageRoleMapping = {
      [ProofRole.Verifier]: {
        proposalMessage: didcomm_1.DidCommMessageRole.Receiver,
        requestMessage: didcomm_1.DidCommMessageRole.Sender,
        presentationMessage: didcomm_1.DidCommMessageRole.Receiver
      },
      [ProofRole.Prover]: {
        proposalMessage: didcomm_1.DidCommMessageRole.Sender,
        requestMessage: didcomm_1.DidCommMessageRole.Receiver,
        presentationMessage: didcomm_1.DidCommMessageRole.Sender
      }
    };
    var proofRecordMessageKeys = ["proposalMessage", "requestMessage", "presentationMessage"];
    function getProofRole(proofRecord) {
      if (proofRecord.isVerified !== void 0) {
        return ProofRole.Verifier;
      } else if (proofRecord.state === models_1.ProofState.Done) {
        return ProofRole.Prover;
      } else if (proverProofStates.includes(proofRecord.state)) {
        return ProofRole.Prover;
      }
      return ProofRole.Verifier;
    }
    exports.getProofRole = getProofRole;
    async function migrateInternalProofExchangeRecordProperties(agent, proofRecord) {
      agent.config.logger.debug(`Migrating internal proof record ${proofRecord.id} properties to storage version 0.3`);
      if (!proofRecord.protocolVersion) {
        agent.config.logger.debug(`Setting protocolVersion to v1`);
        proofRecord.protocolVersion = "v1";
      }
      agent.config.logger.debug(`Successfully migrated internal proof record ${proofRecord.id} properties to storage version 0.3`);
    }
    exports.migrateInternalProofExchangeRecordProperties = migrateInternalProofExchangeRecordProperties;
    async function moveDidCommMessages(agent, proofRecord) {
      agent.config.logger.debug(`Moving didcomm messages from proof record with id ${proofRecord.id} to DidCommMessageRecord`);
      const didCommMessageRepository = agent.dependencyManager.resolve(didcomm_1.DidCommMessageRepository);
      for (const messageKey of proofRecordMessageKeys) {
        agent.config.logger.debug(`Starting move of ${messageKey} from proof record with id ${proofRecord.id} to DIDCommMessageRecord`);
        const proofRecordJson = proofRecord;
        const message = proofRecordJson[messageKey];
        if (message) {
          const proofRole = getProofRole(proofRecord);
          const didCommMessageRole = didCommMessageRoleMapping[proofRole][messageKey];
          const didCommMessageRecord = new didcomm_1.DidCommMessageRecord({
            role: didCommMessageRole,
            associatedRecordId: proofRecord.id,
            message
          });
          await didCommMessageRepository.save(agent.context, didCommMessageRecord);
          agent.config.logger.debug(`Successfully moved ${messageKey} from proof record with id ${proofRecord.id} to DIDCommMessageRecord`);
          delete proofRecordJson[messageKey];
        } else {
          agent.config.logger.debug(`Proof record with id ${proofRecord.id} does not have a ${messageKey}. Not creating a DIDCommMessageRecord`);
        }
      }
      agent.config.logger.debug(`Successfully moved didcomm messages from proof record with id ${proofRecord.id} to DIDCommMessageRecord`);
    }
    exports.moveDidCommMessages = moveDidCommMessages;
  }
});

// node_modules/@aries-framework/core/build/storage/migration/updates/0.2-0.3/index.js
var require__2 = __commonJS({
  "node_modules/@aries-framework/core/build/storage/migration/updates/0.2-0.3/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateV0_2ToV0_3 = void 0;
    var connection_1 = require_connection2();
    var proof_1 = require_proof();
    async function updateV0_2ToV0_3(agent) {
      await (0, proof_1.migrateProofExchangeRecordToV0_3)(agent);
      await (0, connection_1.migrateConnectionRecordToV0_3)(agent);
    }
    exports.updateV0_2ToV0_3 = updateV0_2ToV0_3;
  }
});

// node_modules/@aries-framework/core/build/storage/migration/updates/0.3-0.3.1/did.js
var require_did3 = __commonJS({
  "node_modules/@aries-framework/core/build/storage/migration/updates/0.3-0.3.1/did.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.migrateDidRecordToV0_3_1 = void 0;
    var dids_1 = require_dids();
    var uuid_1 = require_uuid();
    async function migrateDidRecordToV0_3_1(agent) {
      agent.config.logger.info("Migrating did records to storage version 0.3.1");
      const didRepository = agent.dependencyManager.resolve(dids_1.DidRepository);
      agent.config.logger.debug(`Fetching all did records from storage`);
      const allDids = await didRepository.getAll(agent.context);
      agent.config.logger.debug(`Found a total of ${allDids.length} did records to update.`);
      for (const didRecord of allDids) {
        agent.config.logger.debug(`Migrating did record with id ${didRecord.id} to storage version 0.3.1`);
        const newId = (0, uuid_1.uuid)();
        agent.config.logger.debug(`Updating id ${didRecord.id} to ${newId} for did record`);
        didRecord.did = didRecord.id;
        didRecord.id = newId;
        await didRepository.save(agent.context, didRecord);
        await didRepository.deleteById(agent.context, didRecord.did);
        agent.config.logger.debug(`Successfully migrated did record with old id ${didRecord.did} to new id ${didRecord.id} to storage version 0.3.1`);
      }
    }
    exports.migrateDidRecordToV0_3_1 = migrateDidRecordToV0_3_1;
  }
});

// node_modules/@aries-framework/core/build/storage/migration/updates/0.3-0.3.1/index.js
var require__3 = __commonJS({
  "node_modules/@aries-framework/core/build/storage/migration/updates/0.3-0.3.1/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateV0_3ToV0_3_1 = void 0;
    var did_1 = require_did3();
    async function updateV0_3ToV0_3_1(agent) {
      await (0, did_1.migrateDidRecordToV0_3_1)(agent);
    }
    exports.updateV0_3ToV0_3_1 = updateV0_3ToV0_3_1;
  }
});

// node_modules/@aries-framework/core/build/storage/migration/updates.js
var require_updates = __commonJS({
  "node_modules/@aries-framework/core/build/storage/migration/updates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CURRENT_FRAMEWORK_STORAGE_VERSION = exports.supportedUpdates = exports.DEFAULT_UPDATE_CONFIG = exports.INITIAL_STORAGE_VERSION = void 0;
    var _0_1_0_2_1 = require__();
    var _0_2_0_3_1 = require__2();
    var _0_3_0_3_1_1 = require__3();
    exports.INITIAL_STORAGE_VERSION = "0.1";
    exports.DEFAULT_UPDATE_CONFIG = {
      v0_1ToV0_2: {
        mediationRoleUpdateStrategy: "recipientIfEndpoint"
      }
    };
    exports.supportedUpdates = [
      {
        fromVersion: "0.1",
        toVersion: "0.2",
        doUpdate: _0_1_0_2_1.updateV0_1ToV0_2
      },
      {
        fromVersion: "0.2",
        toVersion: "0.3",
        doUpdate: _0_2_0_3_1.updateV0_2ToV0_3
      },
      {
        fromVersion: "0.3",
        toVersion: "0.3.1",
        doUpdate: _0_3_0_3_1_1.updateV0_3ToV0_3_1
      }
    ];
    exports.CURRENT_FRAMEWORK_STORAGE_VERSION = exports.supportedUpdates[exports.supportedUpdates.length - 1].toVersion;
  }
});

// node_modules/@aries-framework/core/build/storage/migration/StorageUpdateService.js
var require_StorageUpdateService = __commonJS({
  "node_modules/@aries-framework/core/build/storage/migration/StorageUpdateService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var StorageUpdateService_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageUpdateService = void 0;
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var version_1 = require_version();
    var StorageVersionRecord_1 = require_StorageVersionRecord();
    var StorageVersionRepository_1 = require_StorageVersionRepository();
    var updates_1 = require_updates();
    var StorageUpdateService = StorageUpdateService_1 = class StorageUpdateService {
      constructor(logger, storageVersionRepository) {
        this.logger = logger;
        this.storageVersionRepository = storageVersionRepository;
      }
      async isUpToDate(agentContext, updateToVersion) {
        const currentStorageVersion = (0, version_1.parseVersionString)(await this.getCurrentStorageVersion(agentContext));
        const compareToVersion = (0, version_1.parseVersionString)(updateToVersion !== null && updateToVersion !== void 0 ? updateToVersion : updates_1.CURRENT_FRAMEWORK_STORAGE_VERSION);
        const isUpToDate = (0, version_1.isFirstVersionEqualToSecond)(currentStorageVersion, compareToVersion) || (0, version_1.isFirstVersionHigherThanSecond)(currentStorageVersion, compareToVersion);
        return isUpToDate;
      }
      async getCurrentStorageVersion(agentContext) {
        const storageVersionRecord = await this.getStorageVersionRecord(agentContext);
        return storageVersionRecord.storageVersion;
      }
      async setCurrentStorageVersion(agentContext, storageVersion) {
        this.logger.debug(`Setting current agent storage version to ${storageVersion}`);
        const storageVersionRecord = await this.storageVersionRepository.findById(agentContext, StorageUpdateService_1.STORAGE_VERSION_RECORD_ID);
        if (!storageVersionRecord) {
          this.logger.trace("Storage upgrade record does not exist yet. Creating.");
          await this.storageVersionRepository.save(agentContext, new StorageVersionRecord_1.StorageVersionRecord({
            id: StorageUpdateService_1.STORAGE_VERSION_RECORD_ID,
            storageVersion
          }));
        } else {
          this.logger.trace("Storage upgrade record already exists. Updating.");
          storageVersionRecord.storageVersion = storageVersion;
          await this.storageVersionRepository.update(agentContext, storageVersionRecord);
        }
      }
      /**
       * Retrieve the update record, creating it if it doesn't exist already.
       *
       * The storageVersion will be set to the INITIAL_STORAGE_VERSION if it doesn't exist yet,
       * as we can assume the wallet was created before the update record existed
       */
      async getStorageVersionRecord(agentContext) {
        let storageVersionRecord = await this.storageVersionRepository.findById(agentContext, StorageUpdateService_1.STORAGE_VERSION_RECORD_ID);
        if (!storageVersionRecord) {
          storageVersionRecord = new StorageVersionRecord_1.StorageVersionRecord({
            id: StorageUpdateService_1.STORAGE_VERSION_RECORD_ID,
            storageVersion: updates_1.INITIAL_STORAGE_VERSION
          });
          await this.storageVersionRepository.save(agentContext, storageVersionRecord);
        }
        return storageVersionRecord;
      }
    };
    StorageUpdateService.STORAGE_VERSION_RECORD_ID = "STORAGE_VERSION_RECORD_ID";
    StorageUpdateService = StorageUpdateService_1 = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [Object, StorageVersionRepository_1.StorageVersionRepository])
    ], StorageUpdateService);
    exports.StorageUpdateService = StorageUpdateService;
  }
});

// node_modules/@aries-framework/core/build/storage/migration/error/StorageUpdateError.js
var require_StorageUpdateError = __commonJS({
  "node_modules/@aries-framework/core/build/storage/migration/error/StorageUpdateError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageUpdateError = void 0;
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var StorageUpdateError = class extends AriesFrameworkError_1.AriesFrameworkError {
      constructor(message, { cause } = {}) {
        super(message, { cause });
      }
    };
    exports.StorageUpdateError = StorageUpdateError;
  }
});

// node_modules/@aries-framework/core/build/storage/migration/UpdateAssistant.js
var require_UpdateAssistant = __commonJS({
  "node_modules/@aries-framework/core/build/storage/migration/UpdateAssistant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpdateAssistant = void 0;
    var constants_1 = require_constants();
    var error_1 = require_error();
    var indyError_1 = require_indyError();
    var version_1 = require_version();
    var WalletError_1 = require_WalletError();
    var StorageUpdateService_1 = require_StorageUpdateService();
    var StorageUpdateError_1 = require_StorageUpdateError();
    var updates_1 = require_updates();
    var UpdateAssistant = class {
      constructor(agent, updateConfig) {
        this.agent = agent;
        this.updateConfig = updateConfig;
        this.storageUpdateService = this.agent.dependencyManager.resolve(StorageUpdateService_1.StorageUpdateService);
        this.fileSystem = this.agent.dependencyManager.resolve(constants_1.InjectionSymbols.FileSystem);
      }
      async initialize() {
        if (this.agent.isInitialized) {
          throw new error_1.AriesFrameworkError("Can't initialize UpdateAssistant after agent is initialized");
        }
        if (!this.agent.wallet.isInitialized && this.agent.config.walletConfig) {
          await this.agent.wallet.initialize(this.agent.config.walletConfig);
        } else if (!this.agent.wallet.isInitialized) {
          throw new WalletError_1.WalletError("Wallet config has not been set on the agent config. Make sure to initialize the wallet yourself before initializing the update assistant, or provide the required wallet configuration in the agent constructor");
        }
      }
      async isUpToDate(updateToVersion) {
        return this.storageUpdateService.isUpToDate(this.agent.context, updateToVersion);
      }
      async getCurrentAgentStorageVersion() {
        return this.storageUpdateService.getCurrentStorageVersion(this.agent.context);
      }
      static get frameworkStorageVersion() {
        return updates_1.CURRENT_FRAMEWORK_STORAGE_VERSION;
      }
      async getNeededUpdates(toVersion) {
        const currentStorageVersion = (0, version_1.parseVersionString)(await this.storageUpdateService.getCurrentStorageVersion(this.agent.context));
        const parsedToVersion = toVersion ? (0, version_1.parseVersionString)(toVersion) : void 0;
        if (parsedToVersion && ((0, version_1.isFirstVersionHigherThanSecond)(currentStorageVersion, parsedToVersion) || (0, version_1.isFirstVersionEqualToSecond)(currentStorageVersion, parsedToVersion))) {
          return [];
        }
        const neededUpdates = updates_1.supportedUpdates.filter((update) => {
          const updateToVersion = (0, version_1.parseVersionString)(update.toVersion);
          if (parsedToVersion && (0, version_1.isFirstVersionHigherThanSecond)(updateToVersion, parsedToVersion)) {
            return false;
          }
          return (0, version_1.isFirstVersionHigherThanSecond)(updateToVersion, currentStorageVersion);
        });
        if (neededUpdates.length > 0 && (0, version_1.isFirstVersionHigherThanSecond)((0, version_1.parseVersionString)(neededUpdates[0].fromVersion), currentStorageVersion)) {
          throw new error_1.AriesFrameworkError(`First fromVersion is higher than current storage version. You need to use an older version of the framework to update to at least version ${neededUpdates[0].fromVersion}`);
        }
        const lastUpdateToVersion = neededUpdates.length > 0 ? neededUpdates[neededUpdates.length - 1].toVersion : void 0;
        if (toVersion && lastUpdateToVersion && lastUpdateToVersion !== toVersion) {
          throw new error_1.AriesFrameworkError(`No update found for toVersion ${toVersion}. Make sure the toVersion is a valid version you can update to`);
        }
        return neededUpdates;
      }
      async update(updateToVersion) {
        const updateIdentifier = Date.now().toString();
        try {
          this.agent.config.logger.info(`Starting update of agent storage with updateIdentifier ${updateIdentifier}`);
          const neededUpdates = await this.getNeededUpdates(updateToVersion);
          const currentStorageVersion = (0, version_1.parseVersionString)(await this.storageUpdateService.getCurrentStorageVersion(this.agent.context));
          const parsedToVersion = updateToVersion ? (0, version_1.parseVersionString)(updateToVersion) : void 0;
          if (parsedToVersion && ((0, version_1.isFirstVersionHigherThanSecond)(currentStorageVersion, parsedToVersion) || (0, version_1.isFirstVersionEqualToSecond)(currentStorageVersion, parsedToVersion))) {
            throw new StorageUpdateError_1.StorageUpdateError(`Can't update to version ${updateToVersion} because it is lower or equal to the current agent storage version ${currentStorageVersion[0]}.${currentStorageVersion[1]}}`);
          }
          if (neededUpdates.length == 0) {
            this.agent.config.logger.info("No update needed. Agent storage is up to date.");
            return;
          }
          const fromVersion = neededUpdates[0].fromVersion;
          const toVersion = neededUpdates[neededUpdates.length - 1].toVersion;
          this.agent.config.logger.info(`Starting update process. Total of ${neededUpdates.length} update(s) will be applied to update the agent storage from version ${fromVersion} to version ${toVersion}`);
          await this.createBackup(updateIdentifier);
          try {
            for (const update of neededUpdates) {
              this.agent.config.logger.info(`Starting update of agent storage from version ${update.fromVersion} to version ${update.toVersion}`);
              await update.doUpdate(this.agent, this.updateConfig);
              await this.storageUpdateService.setCurrentStorageVersion(this.agent.context, update.toVersion);
              this.agent.config.logger.info(`Successfully updated agent storage from version ${update.fromVersion} to version ${update.toVersion}`);
            }
          } catch (error) {
            this.agent.config.logger.fatal("An error occurred while updating the wallet. Restoring backup", {
              error
            });
            await this.restoreBackup(updateIdentifier);
            throw error;
          }
        } catch (error) {
          if (error instanceof error_1.AriesFrameworkError && (0, indyError_1.isIndyError)(error.cause, "CommonIOError")) {
            const backupPath = this.getBackupPath(updateIdentifier);
            const errorMessage = `Error updating storage with updateIdentifier ${updateIdentifier} because of an IO error. This is probably because the backup at path ${backupPath} already exists`;
            this.agent.config.logger.fatal(errorMessage, {
              error,
              updateIdentifier,
              backupPath
            });
            throw new StorageUpdateError_1.StorageUpdateError(errorMessage, { cause: error });
          }
          this.agent.config.logger.error(`Error updating storage (updateIdentifier: ${updateIdentifier})`, {
            cause: error
          });
          throw new StorageUpdateError_1.StorageUpdateError(`Error updating storage (updateIdentifier: ${updateIdentifier}): ${error.message}`, {
            cause: error
          });
        }
        return updateIdentifier;
      }
      getBackupPath(backupIdentifier) {
        return `${this.fileSystem.basePath}/afj/migration/backup/${backupIdentifier}`;
      }
      async createBackup(backupIdentifier) {
        var _a;
        const backupPath = this.getBackupPath(backupIdentifier);
        const walletKey = (_a = this.agent.wallet.walletConfig) === null || _a === void 0 ? void 0 : _a.key;
        if (!walletKey) {
          throw new error_1.AriesFrameworkError("Could not extract wallet key from wallet module. Can't create backup");
        }
        await this.agent.wallet.export({ key: walletKey, path: backupPath });
        this.agent.config.logger.info("Created backup of the wallet", {
          backupPath
        });
      }
      async restoreBackup(backupIdentifier) {
        const backupPath = this.getBackupPath(backupIdentifier);
        const walletConfig = this.agent.wallet.walletConfig;
        if (!walletConfig) {
          throw new error_1.AriesFrameworkError("Could not extract wallet config from wallet module. Cannot restore backup");
        }
        await this.agent.wallet.export({ key: walletConfig.key, path: `${backupPath}-error` });
        await this.agent.wallet.delete();
        await this.agent.wallet.import(walletConfig, { key: walletConfig.key, path: backupPath });
        await this.agent.wallet.initialize(walletConfig);
        this.agent.config.logger.info(`Successfully restored wallet from backup ${backupIdentifier}`, {
          backupPath
        });
      }
    };
    exports.UpdateAssistant = UpdateAssistant;
  }
});

// node_modules/@aries-framework/core/build/storage/migration/index.js
var require_migration = __commonJS({
  "node_modules/@aries-framework/core/build/storage/migration/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_StorageVersionRecord(), exports);
    __exportStar(require_StorageVersionRepository(), exports);
    __exportStar(require_StorageUpdateService(), exports);
    __exportStar(require_UpdateAssistant(), exports);
  }
});

// node_modules/@aries-framework/core/build/storage/index.js
var require_storage = __commonJS({
  "node_modules/@aries-framework/core/build/storage/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_didcomm2(), exports);
    __exportStar(require_migration(), exports);
  }
});

// node_modules/@aries-framework/core/build/storage/InMemoryMessageRepository.js
var require_InMemoryMessageRepository = __commonJS({
  "node_modules/@aries-framework/core/build/storage/InMemoryMessageRepository.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InMemoryMessageRepository = void 0;
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var InMemoryMessageRepository = class InMemoryMessageRepository {
      constructor(logger) {
        this.messages = {};
        this.logger = logger;
      }
      getAvailableMessageCount(connectionId) {
        return this.messages[connectionId] ? this.messages[connectionId].length : 0;
      }
      takeFromQueue(connectionId, limit2, keepMessages) {
        if (!this.messages[connectionId]) {
          return [];
        }
        const messagesToTake = limit2 !== null && limit2 !== void 0 ? limit2 : this.messages[connectionId].length;
        this.logger.debug(`Taking ${messagesToTake} messages from queue for connection ${connectionId}`);
        return keepMessages ? this.messages[connectionId].slice(0, messagesToTake) : this.messages[connectionId].splice(0, messagesToTake);
      }
      add(connectionId, payload) {
        if (!this.messages[connectionId]) {
          this.messages[connectionId] = [];
        }
        this.messages[connectionId].push(payload);
      }
    };
    InMemoryMessageRepository = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [Object])
    ], InMemoryMessageRepository);
    exports.InMemoryMessageRepository = InMemoryMessageRepository;
  }
});

// node_modules/@aries-framework/core/build/storage/IndyStorageService.js
var require_IndyStorageService = __commonJS({
  "node_modules/@aries-framework/core/build/storage/IndyStorageService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var __rest2 = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    var __asyncValues = exports && exports.__asyncValues || function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    var __await = exports && exports.__await || function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f2, v) {
        if (f2(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    var IndyStorageService_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyStorageService = void 0;
    var constants_1 = require_constants();
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var JsonTransformer_1 = require_JsonTransformer();
    var indyError_1 = require_indyError();
    var type_1 = require_type();
    var assertIndyWallet_1 = require_assertIndyWallet();
    var IndyStorageService = IndyStorageService_1 = class IndyStorageService {
      constructor(agentDependencies) {
        this.indy = agentDependencies.indy;
      }
      transformToRecordTagValues(tags) {
        const transformedTags = {};
        for (const [key, value] of Object.entries(tags)) {
          if (value === "1" && (key === null || key === void 0 ? void 0 : key.includes(":"))) {
            const [tagName, tagValue] = key.split(":");
            const transformedValue = transformedTags[tagName];
            if (Array.isArray(transformedValue)) {
              transformedTags[tagName] = [...transformedValue, tagValue];
            } else {
              transformedTags[tagName] = [tagValue];
            }
          } else if (value === "1" || value === "0") {
            transformedTags[key] = value === "1";
          } else if (value === "n__1" || value === "n__0") {
            transformedTags[key] = value === "n__1" ? "1" : "0";
          } else {
            transformedTags[key] = value;
          }
        }
        return transformedTags;
      }
      transformFromRecordTagValues(tags) {
        const transformedTags = {};
        for (const [key, value] of Object.entries(tags)) {
          if (value === null) {
            transformedTags[key] = void 0;
          } else if ((0, type_1.isBoolean)(value)) {
            transformedTags[key] = value ? "1" : "0";
          } else if (value === "1" || value === "0") {
            transformedTags[key] = `n__${value}`;
          } else if (Array.isArray(value)) {
            value.forEach((item) => {
              const tagName = `${key}:${item}`;
              transformedTags[tagName] = "1";
            });
          } else {
            transformedTags[key] = value;
          }
        }
        return transformedTags;
      }
      /**
       * Transforms the search query into a wallet query compatible with indy WQL.
       *
       * The format used by AFJ is almost the same as the indy query, with the exception of
       * the encoding of values, however this is handled by the {@link IndyStorageService.transformToRecordTagValues}
       * method.
       */
      indyQueryFromSearchQuery(query) {
        let { $and, $or, $not } = query, tags = __rest2(query, ["$and", "$or", "$not"]);
        $and = $and === null || $and === void 0 ? void 0 : $and.map((q) => this.indyQueryFromSearchQuery(q));
        $or = $or === null || $or === void 0 ? void 0 : $or.map((q) => this.indyQueryFromSearchQuery(q));
        $not = $not ? this.indyQueryFromSearchQuery($not) : void 0;
        const indyQuery = Object.assign(Object.assign({}, this.transformFromRecordTagValues(tags)), {
          $and,
          $or,
          $not
        });
        return indyQuery;
      }
      recordToInstance(record, recordClass) {
        const instance2 = JsonTransformer_1.JsonTransformer.deserialize(record.value, recordClass);
        instance2.id = record.id;
        const tags = record.tags ? this.transformToRecordTagValues(record.tags) : {};
        instance2.replaceTags(tags);
        return instance2;
      }
      /** @inheritDoc */
      async save(agentContext, record) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        const value = JsonTransformer_1.JsonTransformer.serialize(record);
        const tags = this.transformFromRecordTagValues(record.getTags());
        try {
          await this.indy.addWalletRecord(agentContext.wallet.handle, record.type, record.id, value, tags);
        } catch (error) {
          if ((0, indyError_1.isIndyError)(error, "WalletItemAlreadyExists")) {
            throw new error_1.RecordDuplicateError(`Record with id ${record.id} already exists`, { recordType: record.type });
          }
          throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
      }
      /** @inheritDoc */
      async update(agentContext, record) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        const value = JsonTransformer_1.JsonTransformer.serialize(record);
        const tags = this.transformFromRecordTagValues(record.getTags());
        try {
          await this.indy.updateWalletRecordValue(agentContext.wallet.handle, record.type, record.id, value);
          await this.indy.updateWalletRecordTags(agentContext.wallet.handle, record.type, record.id, tags);
        } catch (error) {
          if ((0, indyError_1.isIndyError)(error, "WalletItemNotFound")) {
            throw new error_1.RecordNotFoundError(`record with id ${record.id} not found.`, {
              recordType: record.type,
              cause: error
            });
          }
          throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
      }
      /** @inheritDoc */
      async delete(agentContext, record) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
          await this.indy.deleteWalletRecord(agentContext.wallet.handle, record.type, record.id);
        } catch (error) {
          if ((0, indyError_1.isIndyError)(error, "WalletItemNotFound")) {
            throw new error_1.RecordNotFoundError(`record with id ${record.id} not found.`, {
              recordType: record.type,
              cause: error
            });
          }
          throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
      }
      /** @inheritDoc */
      async deleteById(agentContext, recordClass, id) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
          await this.indy.deleteWalletRecord(agentContext.wallet.handle, recordClass.type, id);
        } catch (error) {
          if ((0, indyError_1.isIndyError)(error, "WalletItemNotFound")) {
            throw new error_1.RecordNotFoundError(`record with id ${id} not found.`, {
              recordType: recordClass.type,
              cause: error
            });
          }
          throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
      }
      /** @inheritDoc */
      async getById(agentContext, recordClass, id) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
          const record = await this.indy.getWalletRecord(agentContext.wallet.handle, recordClass.type, id, IndyStorageService_1.DEFAULT_QUERY_OPTIONS);
          return this.recordToInstance(record, recordClass);
        } catch (error) {
          if ((0, indyError_1.isIndyError)(error, "WalletItemNotFound")) {
            throw new error_1.RecordNotFoundError(`record with id ${id} not found.`, {
              recordType: recordClass.type,
              cause: error
            });
          }
          throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
      }
      /** @inheritDoc */
      async getAll(agentContext, recordClass) {
        var _a, e_1, _b, _c;
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        const recordIterator = this.search(agentContext.wallet, recordClass.type, {}, IndyStorageService_1.DEFAULT_QUERY_OPTIONS);
        const records = [];
        try {
          for (var _d = true, recordIterator_1 = __asyncValues(recordIterator), recordIterator_1_1; recordIterator_1_1 = await recordIterator_1.next(), _a = recordIterator_1_1.done, !_a; ) {
            _c = recordIterator_1_1.value;
            _d = false;
            try {
              const record = _c;
              records.push(this.recordToInstance(record, recordClass));
            } finally {
              _d = true;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = recordIterator_1.return))
              await _b.call(recordIterator_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return records;
      }
      /** @inheritDoc */
      async findByQuery(agentContext, recordClass, query) {
        var _a, e_2, _b, _c;
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        const indyQuery = this.indyQueryFromSearchQuery(query);
        const recordIterator = this.search(agentContext.wallet, recordClass.type, indyQuery, IndyStorageService_1.DEFAULT_QUERY_OPTIONS);
        const records = [];
        try {
          for (var _d = true, recordIterator_2 = __asyncValues(recordIterator), recordIterator_2_1; recordIterator_2_1 = await recordIterator_2.next(), _a = recordIterator_2_1.done, !_a; ) {
            _c = recordIterator_2_1.value;
            _d = false;
            try {
              const record = _c;
              records.push(this.recordToInstance(record, recordClass));
            } finally {
              _d = true;
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = recordIterator_2.return))
              await _b.call(recordIterator_2);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
        return records;
      }
      search(wallet, type, query, _a) {
        var { limit: limit2 = Infinity } = _a, options = __rest2(_a, ["limit"]);
        return __asyncGenerator(this, arguments, function* search_1() {
          try {
            const searchHandle = yield __await(this.indy.openWalletSearch(wallet.handle, type, query, options));
            let records = [];
            const chunk = limit2 ? Math.min(256, limit2) : 256;
            while (!limit2 || records.length < limit2) {
              const recordsJson = yield __await(this.indy.fetchWalletSearchNextRecords(wallet.handle, searchHandle, chunk));
              if (recordsJson.records) {
                records = [...records, ...recordsJson.records];
                for (const record of recordsJson.records) {
                  yield yield __await(record);
                }
              }
              if (!records.length || !recordsJson.records || recordsJson.records.length < chunk) {
                yield __await(this.indy.closeWalletSearch(searchHandle));
                return yield __await(void 0);
              }
            }
          } catch (error) {
            throw new error_1.IndySdkError(error, `Searching '${type}' records for query '${JSON.stringify(query)}' failed`);
          }
        });
      }
    };
    IndyStorageService.DEFAULT_QUERY_OPTIONS = {
      retrieveType: true,
      retrieveTags: true
    };
    IndyStorageService = IndyStorageService_1 = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.AgentDependencies)),
      __metadata("design:paramtypes", [Object])
    ], IndyStorageService);
    exports.IndyStorageService = IndyStorageService;
  }
});

// node_modules/@aries-framework/core/build/modules/basic-messages/messages/BasicMessage.js
var require_BasicMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/basic-messages/messages/BasicMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var transformers_1 = require_transformers();
    var BasicMessage = class extends AgentMessage_1.AgentMessage {
      /**
       * Create new BasicMessage instance.
       * sentTime will be assigned to new Date if not passed, id will be assigned to uuid/v4 if not passed
       * @param options
       */
      constructor(options) {
        super();
        this.type = BasicMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.sentTime = options.sentTime || /* @__PURE__ */ new Date();
          this.content = options.content;
          this.addLocale(options.locale || "en");
        }
      }
    };
    BasicMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/basicmessage/1.0/message");
    __decorate([
      (0, messageType_1.IsValidMessageType)(BasicMessage.type),
      __metadata("design:type", Object)
    ], BasicMessage.prototype, "type", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "sent_time" }),
      (0, class_transformer_1.Transform)(({ value }) => (0, transformers_1.DateParser)(value)),
      (0, class_validator_1.IsDate)(),
      __metadata("design:type", Date)
    ], BasicMessage.prototype, "sentTime", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "content" }),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], BasicMessage.prototype, "content", void 0);
    exports.BasicMessage = BasicMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/basic-messages/messages/index.js
var require_messages9 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/basic-messages/messages/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_BasicMessage(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/basic-messages/BasicMessageEvents.js
var require_BasicMessageEvents = __commonJS({
  "node_modules/@aries-framework/core/build/modules/basic-messages/BasicMessageEvents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicMessageEventTypes = void 0;
    var BasicMessageEventTypes;
    (function(BasicMessageEventTypes2) {
      BasicMessageEventTypes2["BasicMessageStateChanged"] = "BasicMessageStateChanged";
    })(BasicMessageEventTypes = exports.BasicMessageEventTypes || (exports.BasicMessageEventTypes = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/basic-messages/BasicMessageRole.js
var require_BasicMessageRole = __commonJS({
  "node_modules/@aries-framework/core/build/modules/basic-messages/BasicMessageRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicMessageRole = void 0;
    var BasicMessageRole;
    (function(BasicMessageRole2) {
      BasicMessageRole2["Sender"] = "sender";
      BasicMessageRole2["Receiver"] = "receiver";
    })(BasicMessageRole = exports.BasicMessageRole || (exports.BasicMessageRole = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/basic-messages/repository/BasicMessageRecord.js
var require_BasicMessageRecord = __commonJS({
  "node_modules/@aries-framework/core/build/modules/basic-messages/repository/BasicMessageRecord.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicMessageRecord = void 0;
    var BaseRecord_1 = require_BaseRecord();
    var uuid_1 = require_uuid();
    var BasicMessageRecord = class extends BaseRecord_1.BaseRecord {
      constructor(props) {
        var _a, _b, _c;
        super();
        this.type = BasicMessageRecord.type;
        if (props) {
          this.id = (_a = props.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.createdAt = (_b = props.createdAt) !== null && _b !== void 0 ? _b : /* @__PURE__ */ new Date();
          this.content = props.content;
          this.sentTime = props.sentTime;
          this.connectionId = props.connectionId;
          this._tags = (_c = props.tags) !== null && _c !== void 0 ? _c : {};
          this.role = props.role;
        }
      }
      getTags() {
        return Object.assign(Object.assign({}, this._tags), { connectionId: this.connectionId, role: this.role });
      }
    };
    exports.BasicMessageRecord = BasicMessageRecord;
    BasicMessageRecord.type = "BasicMessageRecord";
  }
});

// node_modules/@aries-framework/core/build/modules/basic-messages/repository/BasicMessageRepository.js
var require_BasicMessageRepository = __commonJS({
  "node_modules/@aries-framework/core/build/modules/basic-messages/repository/BasicMessageRepository.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicMessageRepository = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var Repository_1 = require_Repository();
    var BasicMessageRecord_1 = require_BasicMessageRecord();
    var BasicMessageRepository = class BasicMessageRepository extends Repository_1.Repository {
      constructor(storageService, eventEmitter) {
        super(BasicMessageRecord_1.BasicMessageRecord, storageService, eventEmitter);
      }
    };
    BasicMessageRepository = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.StorageService)),
      __metadata("design:paramtypes", [Object, EventEmitter_1.EventEmitter])
    ], BasicMessageRepository);
    exports.BasicMessageRepository = BasicMessageRepository;
  }
});

// node_modules/@aries-framework/core/build/modules/basic-messages/repository/index.js
var require_repository5 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/basic-messages/repository/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_BasicMessageRecord(), exports);
    __exportStar(require_BasicMessageRepository(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/basic-messages/services/BasicMessageService.js
var require_BasicMessageService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/basic-messages/services/BasicMessageService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicMessageService = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var plugins_1 = require_plugins();
    var utils_1 = require_utils();
    var BasicMessageEvents_1 = require_BasicMessageEvents();
    var BasicMessageRole_1 = require_BasicMessageRole();
    var messages_1 = require_messages9();
    var repository_1 = require_repository5();
    var BasicMessageService = class BasicMessageService {
      constructor(basicMessageRepository, eventEmitter) {
        this.basicMessageRepository = basicMessageRepository;
        this.eventEmitter = eventEmitter;
      }
      async createMessage(agentContext, message, connectionRecord) {
        const basicMessage = new messages_1.BasicMessage({ content: message });
        const basicMessageRecord = new repository_1.BasicMessageRecord({
          sentTime: basicMessage.sentTime.toISOString(),
          content: basicMessage.content,
          connectionId: connectionRecord.id,
          role: BasicMessageRole_1.BasicMessageRole.Sender
        });
        await this.basicMessageRepository.save(agentContext, basicMessageRecord);
        this.emitStateChangedEvent(agentContext, basicMessageRecord, basicMessage);
        return { message: basicMessage, record: basicMessageRecord };
      }
      /**
       * @todo use connection from message context
       */
      async save({ message, agentContext }, connection) {
        const basicMessageRecord = new repository_1.BasicMessageRecord({
          sentTime: message.sentTime.toISOString(),
          content: message.content,
          connectionId: connection.id,
          role: BasicMessageRole_1.BasicMessageRole.Receiver
        });
        await this.basicMessageRepository.save(agentContext, basicMessageRecord);
        this.emitStateChangedEvent(agentContext, basicMessageRecord, message);
      }
      emitStateChangedEvent(agentContext, basicMessageRecord, basicMessage) {
        const clonedBasicMessageRecord = utils_1.JsonTransformer.clone(basicMessageRecord);
        this.eventEmitter.emit(agentContext, {
          type: BasicMessageEvents_1.BasicMessageEventTypes.BasicMessageStateChanged,
          payload: { message: basicMessage, basicMessageRecord: clonedBasicMessageRecord }
        });
      }
      async findAllByQuery(agentContext, query) {
        return this.basicMessageRepository.findByQuery(agentContext, query);
      }
      async getById(agentContext, basicMessageRecordId) {
        return this.basicMessageRepository.getById(agentContext, basicMessageRecordId);
      }
      async deleteById(agentContext, basicMessageRecordId) {
        const basicMessageRecord = await this.getById(agentContext, basicMessageRecordId);
        return this.basicMessageRepository.delete(agentContext, basicMessageRecord);
      }
    };
    BasicMessageService = __decorate([
      (0, plugins_1.injectable)(),
      __metadata("design:paramtypes", [repository_1.BasicMessageRepository, EventEmitter_1.EventEmitter])
    ], BasicMessageService);
    exports.BasicMessageService = BasicMessageService;
  }
});

// node_modules/@aries-framework/core/build/modules/basic-messages/services/index.js
var require_services7 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/basic-messages/services/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_BasicMessageService(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/basic-messages/handlers/BasicMessageHandler.js
var require_BasicMessageHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/basic-messages/handlers/BasicMessageHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicMessageHandler = void 0;
    var messages_1 = require_messages9();
    var BasicMessageHandler = class {
      constructor(basicMessageService) {
        this.supportedMessages = [messages_1.BasicMessage];
        this.basicMessageService = basicMessageService;
      }
      async handle(messageContext) {
        const connection = messageContext.assertReadyConnection();
        await this.basicMessageService.save(messageContext, connection);
      }
    };
    exports.BasicMessageHandler = BasicMessageHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/basic-messages/handlers/index.js
var require_handlers7 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/basic-messages/handlers/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_BasicMessageHandler(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/basic-messages/BasicMessagesApi.js
var require_BasicMessagesApi = __commonJS({
  "node_modules/@aries-framework/core/build/modules/basic-messages/BasicMessagesApi.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicMessagesApi = void 0;
    var agent_1 = require_agent();
    var Dispatcher_1 = require_Dispatcher();
    var MessageSender_1 = require_MessageSender();
    var models_1 = require_models3();
    var plugins_1 = require_plugins();
    var connections_1 = require_connections();
    var handlers_1 = require_handlers7();
    var services_1 = require_services7();
    var BasicMessagesApi = class BasicMessagesApi {
      constructor(dispatcher, basicMessageService, messageSender, connectionService, agentContext) {
        this.basicMessageService = basicMessageService;
        this.messageSender = messageSender;
        this.connectionService = connectionService;
        this.agentContext = agentContext;
        this.registerMessageHandlers(dispatcher);
      }
      /**
       * Send a message to an active connection
       *
       * @param connectionId Connection Id
       * @param message Message contents
       * @throws {RecordNotFoundError} If connection is not found
       * @throws {MessageSendingError} If message is undeliverable
       * @returns the created record
       */
      async sendMessage(connectionId, message) {
        const connection = await this.connectionService.getById(this.agentContext, connectionId);
        const { message: basicMessage, record: basicMessageRecord } = await this.basicMessageService.createMessage(this.agentContext, message, connection);
        const outboundMessageContext = new models_1.OutboundMessageContext(basicMessage, {
          agentContext: this.agentContext,
          connection,
          associatedRecord: basicMessageRecord
        });
        await this.messageSender.sendMessage(outboundMessageContext);
        return basicMessageRecord;
      }
      /**
       * Retrieve all basic messages matching a given query
       *
       * @param query The query
       * @returns array containing all matching records
       */
      async findAllByQuery(query) {
        return this.basicMessageService.findAllByQuery(this.agentContext, query);
      }
      /**
       * Retrieve a basic message record by id
       *
       * @param basicMessageRecordId The basic message record id
       * @throws {RecordNotFoundError} If no record is found
       * @return The basic message record
       *
       */
      async getById(basicMessageRecordId) {
        return this.basicMessageService.getById(this.agentContext, basicMessageRecordId);
      }
      /**
       * Delete a basic message record by id
       *
       * @param connectionId the basic message record id
       * @throws {RecordNotFoundError} If no record is found
       */
      async deleteById(basicMessageRecordId) {
        await this.basicMessageService.deleteById(this.agentContext, basicMessageRecordId);
      }
      registerMessageHandlers(dispatcher) {
        dispatcher.registerMessageHandler(new handlers_1.BasicMessageHandler(this.basicMessageService));
      }
    };
    BasicMessagesApi = __decorate([
      (0, plugins_1.injectable)(),
      __metadata("design:paramtypes", [
        Dispatcher_1.Dispatcher,
        services_1.BasicMessageService,
        MessageSender_1.MessageSender,
        connections_1.ConnectionService,
        agent_1.AgentContext
      ])
    ], BasicMessagesApi);
    exports.BasicMessagesApi = BasicMessagesApi;
  }
});

// node_modules/@aries-framework/core/build/modules/basic-messages/BasicMessagesModule.js
var require_BasicMessagesModule = __commonJS({
  "node_modules/@aries-framework/core/build/modules/basic-messages/BasicMessagesModule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicMessagesModule = void 0;
    var models_1 = require_models3();
    var BasicMessageRole_1 = require_BasicMessageRole();
    var BasicMessagesApi_1 = require_BasicMessagesApi();
    var repository_1 = require_repository5();
    var services_1 = require_services7();
    var BasicMessagesModule = class {
      constructor() {
        this.api = BasicMessagesApi_1.BasicMessagesApi;
      }
      /**
       * Registers the dependencies of the basic message module on the dependency manager.
       */
      register(dependencyManager, featureRegistry) {
        dependencyManager.registerContextScoped(BasicMessagesApi_1.BasicMessagesApi);
        dependencyManager.registerSingleton(services_1.BasicMessageService);
        dependencyManager.registerSingleton(repository_1.BasicMessageRepository);
        featureRegistry.register(new models_1.Protocol({
          id: "https://didcomm.org/basicmessage/1.0",
          roles: [BasicMessageRole_1.BasicMessageRole.Sender, BasicMessageRole_1.BasicMessageRole.Receiver]
        }));
      }
    };
    exports.BasicMessagesModule = BasicMessagesModule;
  }
});

// node_modules/@aries-framework/core/build/modules/basic-messages/index.js
var require_basic_messages = __commonJS({
  "node_modules/@aries-framework/core/build/modules/basic-messages/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_messages9(), exports);
    __exportStar(require_services7(), exports);
    __exportStar(require_repository5(), exports);
    __exportStar(require_BasicMessageEvents(), exports);
    __exportStar(require_BasicMessagesApi(), exports);
    __exportStar(require_BasicMessageRole(), exports);
    __exportStar(require_BasicMessagesModule(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/models/RevocationNotification.js
var require_RevocationNotification = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/models/RevocationNotification.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RevocationNotification = void 0;
    var RevocationNotification = class {
      constructor(comment, revocationDate = /* @__PURE__ */ new Date()) {
        this.revocationDate = revocationDate;
        this.comment = comment;
      }
    };
    exports.RevocationNotification = RevocationNotification;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/models/CredentialFormatSpec.js
var require_CredentialFormatSpec = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/models/CredentialFormatSpec.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CredentialFormatSpec = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var uuid_1 = require_uuid();
    var CredentialFormatSpec = class {
      constructor(options) {
        var _a;
        if (options) {
          this.attachId = (_a = options.attachId) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.format = options.format;
        }
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "attach_id" }),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], CredentialFormatSpec.prototype, "attachId", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], CredentialFormatSpec.prototype, "format", void 0);
    exports.CredentialFormatSpec = CredentialFormatSpec;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/models/index.js
var require_models6 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/models/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_RevocationNotification(), exports);
    __exportStar(require_CredentialPreviewAttribute(), exports);
    __exportStar(require_CredentialAutoAcceptType(), exports);
    __exportStar(require_CredentialFormatSpec(), exports);
    __exportStar(require_CredentialState(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/CredentialsModuleConfig.js
var require_CredentialsModuleConfig = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/CredentialsModuleConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CredentialsModuleConfig = void 0;
    var models_1 = require_models6();
    var CredentialsModuleConfig = class {
      constructor(options) {
        this.options = options;
      }
      /** See {@link CredentialsModuleConfigOptions.autoAcceptCredentials} */
      get autoAcceptCredentials() {
        var _a;
        return (_a = this.options.autoAcceptCredentials) !== null && _a !== void 0 ? _a : models_1.AutoAcceptCredential.Never;
      }
      /** See {@link CredentialsModuleConfigOptions.credentialProtocols} */
      get credentialProtocols() {
        return this.options.credentialProtocols;
      }
    };
    exports.CredentialsModuleConfig = CredentialsModuleConfig;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/CredentialEvents.js
var require_CredentialEvents = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/CredentialEvents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CredentialEventTypes = void 0;
    var CredentialEventTypes;
    (function(CredentialEventTypes2) {
      CredentialEventTypes2["CredentialStateChanged"] = "CredentialStateChanged";
      CredentialEventTypes2["RevocationNotificationReceived"] = "RevocationNotificationReceived";
    })(CredentialEventTypes = exports.CredentialEventTypes || (exports.CredentialEventTypes = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/repository/index.js
var require_repository6 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/repository/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_CredentialExchangeRecord(), exports);
    __exportStar(require_CredentialRepository(), exports);
    __exportStar(require_CredentialMetadataTypes(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/messages/V1RevocationNotificationMessage.js
var require_V1RevocationNotificationMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/messages/V1RevocationNotificationMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1RevocationNotificationMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var V1RevocationNotificationMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a;
        super();
        this.type = V1RevocationNotificationMessage.type.messageTypeUri;
        if (options) {
          this.issueThread = options.issueThread;
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.comment = options.comment;
          this.pleaseAck = options.pleaseAck;
        }
      }
    };
    V1RevocationNotificationMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/revocation_notification/1.0/revoke");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V1RevocationNotificationMessage.type),
      __metadata("design:type", Object)
    ], V1RevocationNotificationMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], V1RevocationNotificationMessage.prototype, "comment", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "thread_id" }),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], V1RevocationNotificationMessage.prototype, "issueThread", void 0);
    exports.V1RevocationNotificationMessage = V1RevocationNotificationMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/handlers/V1RevocationNotificationHandler.js
var require_V1RevocationNotificationHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/handlers/V1RevocationNotificationHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1RevocationNotificationHandler = void 0;
    var V1RevocationNotificationMessage_1 = require_V1RevocationNotificationMessage();
    var V1RevocationNotificationHandler = class {
      constructor(revocationService) {
        this.supportedMessages = [V1RevocationNotificationMessage_1.V1RevocationNotificationMessage];
        this.revocationService = revocationService;
      }
      async handle(messageContext) {
        await this.revocationService.v1ProcessRevocationNotification(messageContext);
      }
    };
    exports.V1RevocationNotificationHandler = V1RevocationNotificationHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/messages/V2RevocationNotificationMessage.js
var require_V2RevocationNotificationMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/messages/V2RevocationNotificationMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2RevocationNotificationMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var V2RevocationNotificationMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a;
        super();
        this.type = V2RevocationNotificationMessage.type.messageTypeUri;
        if (options) {
          this.revocationFormat = options.revocationFormat;
          this.credentialId = options.credentialId;
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.comment = options.comment;
          this.pleaseAck = options.pleaseAck;
        }
      }
    };
    V2RevocationNotificationMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/revocation_notification/2.0/revoke");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V2RevocationNotificationMessage.type),
      __metadata("design:type", Object)
    ], V2RevocationNotificationMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], V2RevocationNotificationMessage.prototype, "comment", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "revocation_format" }),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], V2RevocationNotificationMessage.prototype, "revocationFormat", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "credential_id" }),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], V2RevocationNotificationMessage.prototype, "credentialId", void 0);
    exports.V2RevocationNotificationMessage = V2RevocationNotificationMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/handlers/V2RevocationNotificationHandler.js
var require_V2RevocationNotificationHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/handlers/V2RevocationNotificationHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2RevocationNotificationHandler = void 0;
    var V2RevocationNotificationMessage_1 = require_V2RevocationNotificationMessage();
    var V2RevocationNotificationHandler = class {
      constructor(revocationService) {
        this.supportedMessages = [V2RevocationNotificationMessage_1.V2RevocationNotificationMessage];
        this.revocationService = revocationService;
      }
      async handle(messageContext) {
        await this.revocationService.v2ProcessRevocationNotification(messageContext);
      }
    };
    exports.V2RevocationNotificationHandler = V2RevocationNotificationHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/handlers/index.js
var require_handlers8 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/handlers/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_V1RevocationNotificationHandler(), exports);
    __exportStar(require_V2RevocationNotificationHandler(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/util/revocationIdentifier.js
var require_revocationIdentifier = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/util/revocationIdentifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.v2IndyRevocationFormat = exports.v2IndyRevocationIdentifierRegex = exports.v1ThreadRegex = void 0;
    exports.v1ThreadRegex = /(indy)::((?:[\dA-z]{21,22}):4:(?:[\dA-z]{21,22}):3:[Cc][Ll]:(?:(?:[1-9][0-9]*)|(?:[\dA-z]{21,22}:2:.+:[0-9.]+)):.+?:CL_ACCUM:(?:[\dA-z-]+))::(\d+)$/;
    exports.v2IndyRevocationIdentifierRegex = /((?:[\dA-z]{21,22}):4:(?:[\dA-z]{21,22}):3:[Cc][Ll]:(?:(?:[1-9][0-9]*)|(?:[\dA-z]{21,22}:2:.+:[0-9.]+)):.+?:CL_ACCUM:(?:[\dA-z-]+))::(\d+)$/;
    exports.v2IndyRevocationFormat = "indy-anoncreds";
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/services/RevocationNotificationService.js
var require_RevocationNotificationService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/services/RevocationNotificationService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RevocationNotificationService = void 0;
    var Dispatcher_1 = require_Dispatcher();
    var EventEmitter_1 = require_EventEmitter();
    var constants_1 = require_constants();
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var plugins_1 = require_plugins();
    var utils_1 = require_utils();
    var CredentialEvents_1 = require_CredentialEvents();
    var RevocationNotification_1 = require_RevocationNotification();
    var repository_1 = require_repository6();
    var handlers_1 = require_handlers8();
    var revocationIdentifier_1 = require_revocationIdentifier();
    var RevocationNotificationService = class RevocationNotificationService {
      constructor(credentialRepository, eventEmitter, dispatcher, logger) {
        this.credentialRepository = credentialRepository;
        this.eventEmitter = eventEmitter;
        this.dispatcher = dispatcher;
        this.logger = logger;
        this.registerMessageHandlers();
      }
      async processRevocationNotification(agentContext, indyRevocationRegistryId, indyCredentialRevocationId, connection, comment) {
        const query = { indyRevocationRegistryId, indyCredentialRevocationId, connectionId: connection.id };
        this.logger.trace(`Getting record by query for revocation notification:`, query);
        const credentialRecord = await this.credentialRepository.getSingleByQuery(agentContext, query);
        credentialRecord.revocationNotification = new RevocationNotification_1.RevocationNotification(comment);
        await this.credentialRepository.update(agentContext, credentialRecord);
        const clonedCredentialRecord = utils_1.JsonTransformer.clone(credentialRecord);
        this.logger.trace("Emitting RevocationNotificationReceivedEvent");
        this.eventEmitter.emit(agentContext, {
          type: CredentialEvents_1.CredentialEventTypes.RevocationNotificationReceived,
          payload: {
            credentialRecord: clonedCredentialRecord
          }
        });
      }
      /**
       * Process a received {@link V1RevocationNotificationMessage}. This will create a
       * {@link RevocationNotification} and store it in the corresponding {@link CredentialRecord}
       *
       * @param messageContext message context of RevocationNotificationMessageV1
       */
      async v1ProcessRevocationNotification(messageContext) {
        this.logger.info("Processing revocation notification v1", { message: messageContext.message });
        const threadId = messageContext.message.issueThread;
        try {
          const threadIdGroups = threadId.match(revocationIdentifier_1.v1ThreadRegex);
          if (!threadIdGroups) {
            throw new AriesFrameworkError_1.AriesFrameworkError(`Incorrect revocation notification threadId format: 
${threadId}
does not match
"indy::<revocation_registry_id>::<credential_revocation_id>"`);
          }
          const [, , indyRevocationRegistryId, indyCredentialRevocationId] = threadIdGroups;
          const comment = messageContext.message.comment;
          const connection = messageContext.assertReadyConnection();
          await this.processRevocationNotification(messageContext.agentContext, indyRevocationRegistryId, indyCredentialRevocationId, connection, comment);
        } catch (error) {
          this.logger.warn("Failed to process revocation notification message", { error, threadId });
        }
      }
      /**
       * Process a received {@link V2RevocationNotificationMessage}. This will create a
       * {@link RevocationNotification} and store it in the corresponding {@link CredentialRecord}
       *
       * @param messageContext message context of RevocationNotificationMessageV2
       */
      async v2ProcessRevocationNotification(messageContext) {
        this.logger.info("Processing revocation notification v2", { message: messageContext.message });
        const credentialId = messageContext.message.credentialId;
        if (messageContext.message.revocationFormat !== revocationIdentifier_1.v2IndyRevocationFormat) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`Unknown revocation format: ${messageContext.message.revocationFormat}. Supported formats are indy-anoncreds`);
        }
        try {
          const credentialIdGroups = credentialId.match(revocationIdentifier_1.v2IndyRevocationIdentifierRegex);
          if (!credentialIdGroups) {
            throw new AriesFrameworkError_1.AriesFrameworkError(`Incorrect revocation notification credentialId format: 
${credentialId}
does not match
"<revocation_registry_id>::<credential_revocation_id>"`);
          }
          const [, indyRevocationRegistryId, indyCredentialRevocationId] = credentialIdGroups;
          const comment = messageContext.message.comment;
          const connection = messageContext.assertReadyConnection();
          await this.processRevocationNotification(messageContext.agentContext, indyRevocationRegistryId, indyCredentialRevocationId, connection, comment);
        } catch (error) {
          this.logger.warn("Failed to process revocation notification message", { error, credentialId });
        }
      }
      registerMessageHandlers() {
        this.dispatcher.registerMessageHandler(new handlers_1.V1RevocationNotificationHandler(this));
        this.dispatcher.registerMessageHandler(new handlers_1.V2RevocationNotificationHandler(this));
      }
    };
    RevocationNotificationService = __decorate([
      (0, plugins_1.injectable)(),
      __param(3, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [
        repository_1.CredentialRepository,
        EventEmitter_1.EventEmitter,
        Dispatcher_1.Dispatcher,
        Object
      ])
    ], RevocationNotificationService);
    exports.RevocationNotificationService = RevocationNotificationService;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/services/index.js
var require_services8 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/services/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_RevocationNotificationService(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/CredentialsApi.js
var require_CredentialsApi = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/CredentialsApi.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CredentialsApi = void 0;
    var agent_1 = require_agent();
    var MessageSender_1 = require_MessageSender();
    var models_1 = require_models3();
    var constants_1 = require_constants();
    var ServiceDecorator_1 = require_ServiceDecorator();
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var storage_1 = require_storage();
    var DidCommMessageRepository_1 = require_DidCommMessageRepository();
    var services_1 = require_services3();
    var RoutingService_1 = require_RoutingService();
    var CredentialsModuleConfig_1 = require_CredentialsModuleConfig();
    var CredentialState_1 = require_CredentialState();
    var services_2 = require_services8();
    var CredentialRepository_1 = require_CredentialRepository();
    var CredentialsApi = class CredentialsApi {
      constructor(messageSender, connectionService, agentContext, logger, credentialRepository, mediationRecipientService, didCommMessageRepository, _revocationNotificationService, config) {
        this.messageSender = messageSender;
        this.connectionService = connectionService;
        this.credentialRepository = credentialRepository;
        this.routingService = mediationRecipientService;
        this.agentContext = agentContext;
        this.didCommMessageRepository = didCommMessageRepository;
        this.logger = logger;
        this.config = config;
        this.credentialProtocolMap = config.credentialProtocols.reduce((protocolMap, service) => Object.assign(Object.assign({}, protocolMap), { [service.version]: service }), {});
      }
      getProtocol(protocolVersion) {
        if (!this.credentialProtocolMap[protocolVersion]) {
          throw new error_1.AriesFrameworkError(`No credential protocol registered for protocol version ${protocolVersion}`);
        }
        return this.credentialProtocolMap[protocolVersion];
      }
      /**
       * Initiate a new credential exchange as holder by sending a credential proposal message
       * to the connection with the specified credential options
       *
       * @param options configuration to use for the proposal
       * @returns Credential exchange record associated with the sent proposal message
       */
      async proposeCredential(options) {
        const service = this.getProtocol(options.protocolVersion);
        this.logger.debug(`Got a credentialProtocol object for version ${options.protocolVersion}`);
        const connection = await this.connectionService.getById(this.agentContext, options.connectionId);
        const { credentialRecord, message } = await service.createProposal(this.agentContext, {
          connection,
          credentialFormats: options.credentialFormats,
          comment: options.comment,
          autoAcceptCredential: options.autoAcceptCredential
        });
        this.logger.debug("We have a message (sending outbound): ", message);
        const outboundMessageContext = new models_1.OutboundMessageContext(message, {
          agentContext: this.agentContext,
          connection,
          associatedRecord: credentialRecord
        });
        this.logger.debug("In proposeCredential: Send Proposal to Issuer");
        await this.messageSender.sendMessage(outboundMessageContext);
        return credentialRecord;
      }
      /**
       * Accept a credential proposal as issuer (by sending a credential offer message) to the connection
       * associated with the credential record.
       *
       * @param options config object for accepting the proposal
       * @returns Credential exchange record associated with the credential offer
       *
       */
      async acceptProposal(options) {
        const credentialRecord = await this.getById(options.credentialRecordId);
        if (!credentialRecord.connectionId) {
          throw new error_1.AriesFrameworkError(`No connectionId found for credential record '${credentialRecord.id}'. Connection-less issuance does not support credential proposal or negotiation.`);
        }
        const service = this.getProtocol(credentialRecord.protocolVersion);
        const { message } = await service.acceptProposal(this.agentContext, {
          credentialRecord,
          credentialFormats: options.credentialFormats,
          comment: options.comment,
          autoAcceptCredential: options.autoAcceptCredential
        });
        const connection = await this.connectionService.getById(this.agentContext, credentialRecord.connectionId);
        const outboundMessageContext = new models_1.OutboundMessageContext(message, {
          agentContext: this.agentContext,
          connection,
          associatedRecord: credentialRecord
        });
        await this.messageSender.sendMessage(outboundMessageContext);
        return credentialRecord;
      }
      /**
       * Negotiate a credential proposal as issuer (by sending a credential offer message) to the connection
       * associated with the credential record.
       *
       * @param options configuration for the offer see {@link NegotiateCredentialProposalOptions}
       * @returns Credential exchange record associated with the credential offer
       *
       */
      async negotiateProposal(options) {
        const credentialRecord = await this.getById(options.credentialRecordId);
        if (!credentialRecord.connectionId) {
          throw new error_1.AriesFrameworkError(`No connection id for credential record ${credentialRecord.id} not found. Connection-less issuance does not support negotiation`);
        }
        const service = this.getProtocol(credentialRecord.protocolVersion);
        const { message } = await service.negotiateProposal(this.agentContext, {
          credentialRecord,
          credentialFormats: options.credentialFormats,
          comment: options.comment,
          autoAcceptCredential: options.autoAcceptCredential
        });
        const connection = await this.connectionService.getById(this.agentContext, credentialRecord.connectionId);
        const outboundMessageContext = new models_1.OutboundMessageContext(message, {
          agentContext: this.agentContext,
          connection,
          associatedRecord: credentialRecord
        });
        await this.messageSender.sendMessage(outboundMessageContext);
        return credentialRecord;
      }
      /**
       * Initiate a new credential exchange as issuer by sending a credential offer message
       * to the connection with the specified connection id.
       *
       * @param options config options for the credential offer
       * @returns Credential exchange record associated with the sent credential offer message
       */
      async offerCredential(options) {
        const connection = await this.connectionService.getById(this.agentContext, options.connectionId);
        const service = this.getProtocol(options.protocolVersion);
        this.logger.debug(`Got a credentialProtocol object for version ${options.protocolVersion}`);
        const { message, credentialRecord } = await service.createOffer(this.agentContext, {
          credentialFormats: options.credentialFormats,
          autoAcceptCredential: options.autoAcceptCredential,
          comment: options.comment,
          connection
        });
        this.logger.debug("Offer Message successfully created; message= ", message);
        const outboundMessageContext = new models_1.OutboundMessageContext(message, {
          agentContext: this.agentContext,
          connection,
          associatedRecord: credentialRecord
        });
        await this.messageSender.sendMessage(outboundMessageContext);
        return credentialRecord;
      }
      /**
       * Accept a credential offer as holder (by sending a credential request message) to the connection
       * associated with the credential record.
       *
       * @param options The object containing config options of the offer to be accepted
       * @returns Object containing offer associated credential record
       */
      async acceptOffer(options) {
        const credentialRecord = await this.getById(options.credentialRecordId);
        const service = this.getProtocol(credentialRecord.protocolVersion);
        this.logger.debug(`Got a credentialProtocol object for this version; version = ${service.version}`);
        const offerMessage = await service.findOfferMessage(this.agentContext, credentialRecord.id);
        if (credentialRecord.connectionId) {
          const connection = await this.connectionService.getById(this.agentContext, credentialRecord.connectionId);
          const { message } = await service.acceptOffer(this.agentContext, {
            credentialRecord,
            credentialFormats: options.credentialFormats,
            comment: options.comment,
            autoAcceptCredential: options.autoAcceptCredential
          });
          const outboundMessageContext = new models_1.OutboundMessageContext(message, {
            agentContext: this.agentContext,
            connection,
            associatedRecord: credentialRecord
          });
          await this.messageSender.sendMessage(outboundMessageContext);
          return credentialRecord;
        } else if (offerMessage === null || offerMessage === void 0 ? void 0 : offerMessage.service) {
          const routing = await this.routingService.getRouting(this.agentContext);
          const ourService = new ServiceDecorator_1.ServiceDecorator({
            serviceEndpoint: routing.endpoints[0],
            recipientKeys: [routing.recipientKey.publicKeyBase58],
            routingKeys: routing.routingKeys.map((key) => key.publicKeyBase58)
          });
          const recipientService = offerMessage.service;
          const { message } = await service.acceptOffer(this.agentContext, {
            credentialRecord,
            credentialFormats: options.credentialFormats,
            comment: options.comment,
            autoAcceptCredential: options.autoAcceptCredential
          });
          message.service = ourService;
          await this.didCommMessageRepository.saveOrUpdateAgentMessage(this.agentContext, {
            agentMessage: message,
            role: storage_1.DidCommMessageRole.Sender,
            associatedRecordId: credentialRecord.id
          });
          await this.messageSender.sendMessageToService(new models_1.OutboundMessageContext(message, {
            agentContext: this.agentContext,
            serviceParams: {
              service: recipientService.resolvedDidCommService,
              senderKey: ourService.resolvedDidCommService.recipientKeys[0],
              returnRoute: true
            }
          }));
          return credentialRecord;
        } else {
          throw new error_1.AriesFrameworkError(`Cannot accept offer for credential record without connectionId or ~service decorator on credential offer.`);
        }
      }
      async declineOffer(credentialRecordId) {
        const credentialRecord = await this.getById(credentialRecordId);
        credentialRecord.assertState(CredentialState_1.CredentialState.OfferReceived);
        const service = this.getProtocol(credentialRecord.protocolVersion);
        await service.updateState(this.agentContext, credentialRecord, CredentialState_1.CredentialState.Declined);
        return credentialRecord;
      }
      async negotiateOffer(options) {
        const credentialRecord = await this.getById(options.credentialRecordId);
        const service = this.getProtocol(credentialRecord.protocolVersion);
        const { message } = await service.negotiateOffer(this.agentContext, {
          credentialFormats: options.credentialFormats,
          credentialRecord,
          comment: options.comment,
          autoAcceptCredential: options.autoAcceptCredential
        });
        if (!credentialRecord.connectionId) {
          throw new error_1.AriesFrameworkError(`No connection id for credential record ${credentialRecord.id} not found. Connection-less issuance does not support negotiation`);
        }
        const connection = await this.connectionService.getById(this.agentContext, credentialRecord.connectionId);
        const outboundMessageContext = new models_1.OutboundMessageContext(message, {
          agentContext: this.agentContext,
          connection,
          associatedRecord: credentialRecord
        });
        await this.messageSender.sendMessage(outboundMessageContext);
        return credentialRecord;
      }
      /**
       * Initiate a new credential exchange as issuer by creating a credential offer
       * not bound to any connection. The offer must be delivered out-of-band to the holder
       * @param options The credential options to use for the offer
       * @returns The credential record and credential offer message
       */
      async createOffer(options) {
        const service = this.getProtocol(options.protocolVersion);
        this.logger.debug(`Got a credentialProtocol object for version ${options.protocolVersion}`);
        const { message, credentialRecord } = await service.createOffer(this.agentContext, {
          credentialFormats: options.credentialFormats,
          comment: options.comment,
          autoAcceptCredential: options.autoAcceptCredential
        });
        this.logger.debug("Offer Message successfully created; message= ", message);
        return { message, credentialRecord };
      }
      /**
       * Accept a credential request as holder (by sending a credential request message) to the connection
       * associated with the credential record.
       *
       * @param options The object containing config options of the request
       * @returns CredentialExchangeRecord updated with information pertaining to this request
       */
      async acceptRequest(options) {
        const credentialRecord = await this.getById(options.credentialRecordId);
        const service = this.getProtocol(credentialRecord.protocolVersion);
        this.logger.debug(`Got a credentialProtocol object for version ${credentialRecord.protocolVersion}`);
        const { message } = await service.acceptRequest(this.agentContext, {
          credentialRecord,
          credentialFormats: options.credentialFormats,
          comment: options.comment,
          autoAcceptCredential: options.autoAcceptCredential
        });
        this.logger.debug("We have a credential message (sending outbound): ", message);
        const requestMessage = await service.findRequestMessage(this.agentContext, credentialRecord.id);
        const offerMessage = await service.findOfferMessage(this.agentContext, credentialRecord.id);
        if (credentialRecord.connectionId) {
          const connection = await this.connectionService.getById(this.agentContext, credentialRecord.connectionId);
          const outboundMessageContext = new models_1.OutboundMessageContext(message, {
            agentContext: this.agentContext,
            connection,
            associatedRecord: credentialRecord
          });
          await this.messageSender.sendMessage(outboundMessageContext);
          return credentialRecord;
        } else if ((requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.service) && (offerMessage === null || offerMessage === void 0 ? void 0 : offerMessage.service)) {
          const recipientService = requestMessage.service;
          const ourService = offerMessage.service;
          message.service = ourService;
          await this.didCommMessageRepository.saveOrUpdateAgentMessage(this.agentContext, {
            agentMessage: message,
            role: storage_1.DidCommMessageRole.Sender,
            associatedRecordId: credentialRecord.id
          });
          await this.messageSender.sendMessageToService(new models_1.OutboundMessageContext(message, {
            agentContext: this.agentContext,
            serviceParams: {
              service: recipientService.resolvedDidCommService,
              senderKey: ourService.resolvedDidCommService.recipientKeys[0],
              returnRoute: true
            }
          }));
          return credentialRecord;
        } else {
          throw new error_1.AriesFrameworkError(`Cannot accept request for credential record without connectionId or ~service decorator on credential offer / request.`);
        }
      }
      /**
       * Accept a credential as holder (by sending a credential acknowledgement message) to the connection
       * associated with the credential record.
       *
       * @param credentialRecordId The id of the credential record for which to accept the credential
       * @returns credential exchange record associated with the sent credential acknowledgement message
       *
       */
      async acceptCredential(options) {
        const credentialRecord = await this.getById(options.credentialRecordId);
        const service = this.getProtocol(credentialRecord.protocolVersion);
        this.logger.debug(`Got a credentialProtocol object for version ${credentialRecord.protocolVersion}`);
        const { message } = await service.acceptCredential(this.agentContext, {
          credentialRecord
        });
        const requestMessage = await service.findRequestMessage(this.agentContext, credentialRecord.id);
        const credentialMessage = await service.findCredentialMessage(this.agentContext, credentialRecord.id);
        if (credentialRecord.connectionId) {
          const connection = await this.connectionService.getById(this.agentContext, credentialRecord.connectionId);
          const outboundMessageContext = new models_1.OutboundMessageContext(message, {
            agentContext: this.agentContext,
            connection,
            associatedRecord: credentialRecord
          });
          await this.messageSender.sendMessage(outboundMessageContext);
          return credentialRecord;
        } else if ((credentialMessage === null || credentialMessage === void 0 ? void 0 : credentialMessage.service) && (requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.service)) {
          const recipientService = credentialMessage.service;
          const ourService = requestMessage.service;
          await this.messageSender.sendMessageToService(new models_1.OutboundMessageContext(message, {
            agentContext: this.agentContext,
            serviceParams: {
              service: recipientService.resolvedDidCommService,
              senderKey: ourService.resolvedDidCommService.recipientKeys[0],
              returnRoute: true
            }
          }));
          return credentialRecord;
        } else {
          throw new error_1.AriesFrameworkError(`Cannot accept credential without connectionId or ~service decorator on credential message.`);
        }
      }
      /**
       * Send problem report message for a credential record
       * @param credentialRecordId The id of the credential record for which to send problem report
       * @param message message to send
       * @returns credential record associated with the credential problem report message
       */
      async sendProblemReport(options) {
        const credentialRecord = await this.getById(options.credentialRecordId);
        if (!credentialRecord.connectionId) {
          throw new error_1.AriesFrameworkError(`No connectionId found for credential record '${credentialRecord.id}'.`);
        }
        const connection = await this.connectionService.getById(this.agentContext, credentialRecord.connectionId);
        const service = this.getProtocol(credentialRecord.protocolVersion);
        const problemReportMessage = service.createProblemReport(this.agentContext, { message: options.message });
        problemReportMessage.setThread({
          threadId: credentialRecord.threadId
        });
        const outboundMessageContext = new models_1.OutboundMessageContext(problemReportMessage, {
          agentContext: this.agentContext,
          connection,
          associatedRecord: credentialRecord
        });
        await this.messageSender.sendMessage(outboundMessageContext);
        return credentialRecord;
      }
      async getFormatData(credentialRecordId) {
        const credentialRecord = await this.getById(credentialRecordId);
        const service = this.getProtocol(credentialRecord.protocolVersion);
        return service.getFormatData(this.agentContext, credentialRecordId);
      }
      /**
       * Retrieve a credential record by id
       *
       * @param credentialRecordId The credential record id
       * @throws {RecordNotFoundError} If no record is found
       * @return The credential record
       *
       */
      getById(credentialRecordId) {
        return this.credentialRepository.getById(this.agentContext, credentialRecordId);
      }
      /**
       * Retrieve all credential records
       *
       * @returns List containing all credential records
       */
      getAll() {
        return this.credentialRepository.getAll(this.agentContext);
      }
      /**
       * Retrieve all credential records by specified query params
       *
       * @returns List containing all credential records matching specified query paramaters
       */
      findAllByQuery(query) {
        return this.credentialRepository.findByQuery(this.agentContext, query);
      }
      /**
       * Find a credential record by id
       *
       * @param credentialRecordId the credential record id
       * @returns The credential record or null if not found
       */
      findById(credentialRecordId) {
        return this.credentialRepository.findById(this.agentContext, credentialRecordId);
      }
      /**
       * Delete a credential record by id, also calls service to delete from wallet
       *
       * @param credentialId the credential record id
       * @param options the delete credential options for the delete operation
       */
      async deleteById(credentialId, options) {
        const credentialRecord = await this.getById(credentialId);
        const service = this.getProtocol(credentialRecord.protocolVersion);
        return service.delete(this.agentContext, credentialRecord, options);
      }
      /**
       * Update a credential exchange record
       *
       * @param credentialRecord the credential exchange record
       */
      async update(credentialRecord) {
        await this.credentialRepository.update(this.agentContext, credentialRecord);
      }
      async findProposalMessage(credentialExchangeId) {
        const service = await this.getServiceForCredentialExchangeId(credentialExchangeId);
        return service.findProposalMessage(this.agentContext, credentialExchangeId);
      }
      async findOfferMessage(credentialExchangeId) {
        const service = await this.getServiceForCredentialExchangeId(credentialExchangeId);
        return service.findOfferMessage(this.agentContext, credentialExchangeId);
      }
      async findRequestMessage(credentialExchangeId) {
        const service = await this.getServiceForCredentialExchangeId(credentialExchangeId);
        return service.findRequestMessage(this.agentContext, credentialExchangeId);
      }
      async findCredentialMessage(credentialExchangeId) {
        const service = await this.getServiceForCredentialExchangeId(credentialExchangeId);
        return service.findCredentialMessage(this.agentContext, credentialExchangeId);
      }
      async getServiceForCredentialExchangeId(credentialExchangeId) {
        const credentialExchangeRecord = await this.getById(credentialExchangeId);
        return this.getProtocol(credentialExchangeRecord.protocolVersion);
      }
    };
    CredentialsApi = __decorate([
      (0, plugins_1.injectable)(),
      __param(3, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [
        MessageSender_1.MessageSender,
        services_1.ConnectionService,
        agent_1.AgentContext,
        Object,
        CredentialRepository_1.CredentialRepository,
        RoutingService_1.RoutingService,
        DidCommMessageRepository_1.DidCommMessageRepository,
        services_2.RevocationNotificationService,
        CredentialsModuleConfig_1.CredentialsModuleConfig
      ])
    ], CredentialsApi);
    exports.CredentialsApi = CredentialsApi;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/CredentialsApiOptions.js
var require_CredentialsApiOptions = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/CredentialsApiOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/formats/CredentialFormatService.js
var require_CredentialFormatService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/formats/CredentialFormatService.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/formats/CredentialFormatServiceOptions.js
var require_CredentialFormatServiceOptions = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/formats/CredentialFormatServiceOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/formats/CredentialFormat.js
var require_CredentialFormat = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/formats/CredentialFormat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/formats/indy/models/IndyCredentialInfo.js
var require_IndyCredentialInfo = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/formats/indy/models/IndyCredentialInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyCredentialInfo = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var utils_1 = require_utils();
    var IndyCredentialInfo = class {
      constructor(options) {
        if (options) {
          this.referent = options.referent;
          this.attributes = options.attributes;
          this.schemaId = options.schemaId;
          this.credentialDefinitionId = options.credentialDefinitionId;
          this.revocationRegistryId = options.revocationRegistryId;
          this.credentialRevocationId = options.credentialRevocationId;
        }
      }
      toJSON() {
        return utils_1.JsonTransformer.toJSON(this);
      }
    };
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], IndyCredentialInfo.prototype, "referent", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "attrs" }),
      (0, class_validator_1.IsString)({ each: true }),
      __metadata("design:type", Object)
    ], IndyCredentialInfo.prototype, "attributes", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "schema_id" }),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], IndyCredentialInfo.prototype, "schemaId", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "cred_def_id" }),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], IndyCredentialInfo.prototype, "credentialDefinitionId", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "rev_reg_id" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], IndyCredentialInfo.prototype, "revocationRegistryId", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "cred_rev_id" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], IndyCredentialInfo.prototype, "credentialRevocationId", void 0);
    exports.IndyCredentialInfo = IndyCredentialInfo;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/formats/indy/models/IndyRevocationInterval.js
var require_IndyRevocationInterval = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/formats/indy/models/IndyRevocationInterval.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyRevocationInterval = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var IndyRevocationInterval = class {
      constructor(options) {
        if (options) {
          this.from = options.from;
          this.to = options.to;
        }
      }
    };
    __decorate([
      (0, class_validator_1.IsInt)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Number)
    ], IndyRevocationInterval.prototype, "from", void 0);
    __decorate([
      (0, class_validator_1.IsInt)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Number)
    ], IndyRevocationInterval.prototype, "to", void 0);
    exports.IndyRevocationInterval = IndyRevocationInterval;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/formats/indy/models/IndyCredential.js
var require_IndyCredential = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/formats/indy/models/IndyCredential.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyCredential = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var JsonTransformer_1 = require_JsonTransformer();
    var IndyCredentialInfo_1 = require_IndyCredentialInfo();
    var IndyRevocationInterval_1 = require_IndyRevocationInterval();
    var IndyCredential = class {
      constructor(options) {
        if (options) {
          this.credentialInfo = options.credentialInfo;
          this.interval = options.interval;
        }
      }
      toJSON() {
        return JsonTransformer_1.JsonTransformer.toJSON(this);
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "cred_info" }),
      (0, class_transformer_1.Type)(() => IndyCredentialInfo_1.IndyCredentialInfo),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsInstance)(IndyCredentialInfo_1.IndyCredentialInfo),
      __metadata("design:type", IndyCredentialInfo_1.IndyCredentialInfo)
    ], IndyCredential.prototype, "credentialInfo", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_transformer_1.Type)(() => IndyRevocationInterval_1.IndyRevocationInterval),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsInstance)(IndyRevocationInterval_1.IndyRevocationInterval),
      __metadata("design:type", IndyRevocationInterval_1.IndyRevocationInterval)
    ], IndyCredential.prototype, "interval", void 0);
    exports.IndyCredential = IndyCredential;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/formats/indy/models/IndyCredPropose.js
var require_IndyCredPropose = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/formats/indy/models/IndyCredPropose.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyCredPropose = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var IndyCredPropose = class {
      constructor(options) {
        if (options) {
          this.schemaIssuerDid = options.schemaIssuerDid;
          this.schemaId = options.schemaId;
          this.schemaName = options.schemaName;
          this.schemaVersion = options.schemaVersion;
          this.credentialDefinitionId = options.credentialDefinitionId;
          this.issuerDid = options.issuerDid;
        }
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "schema_issuer_did" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], IndyCredPropose.prototype, "schemaIssuerDid", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "schema_id" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], IndyCredPropose.prototype, "schemaId", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "schema_name" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], IndyCredPropose.prototype, "schemaName", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "schema_version" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], IndyCredPropose.prototype, "schemaVersion", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "cred_def_id" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], IndyCredPropose.prototype, "credentialDefinitionId", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "issuer_did" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], IndyCredPropose.prototype, "issuerDid", void 0);
    exports.IndyCredPropose = IndyCredPropose;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/formats/indy/models/index.js
var require_models7 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/formats/indy/models/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_IndyCredential(), exports);
    __exportStar(require_IndyCredentialInfo(), exports);
    __exportStar(require_IndyRevocationInterval(), exports);
    __exportStar(require_IndyCredentialView(), exports);
    __exportStar(require_IndyCredPropose(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/indy/services/IndyRevocationService.js
var require_IndyRevocationService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/indy/services/IndyRevocationService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyRevocationService = void 0;
    var constants_1 = require_constants();
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var IndySdkError_1 = require_IndySdkError();
    var plugins_1 = require_plugins();
    var indyError_1 = require_indyError();
    var ledger_1 = require_ledger();
    var IndyUtilitiesService_1 = require_IndyUtilitiesService();
    var RequestReferentType;
    (function(RequestReferentType2) {
      RequestReferentType2["Attribute"] = "attribute";
      RequestReferentType2["Predicate"] = "predicate";
      RequestReferentType2["SelfAttestedAttribute"] = "self-attested-attribute";
    })(RequestReferentType || (RequestReferentType = {}));
    var IndyRevocationService = class IndyRevocationService {
      constructor(indyUtilitiesService, ledgerService, agentDependencies, logger) {
        this.indy = agentDependencies.indy;
        this.indyUtilitiesService = indyUtilitiesService;
        this.logger = logger;
        this.ledgerService = ledgerService;
      }
      async createRevocationState(agentContext, proofRequest, requestedCredentials) {
        try {
          this.logger.debug(`Creating Revocation State(s) for proof request`, {
            proofRequest,
            requestedCredentials
          });
          const revocationStates = {};
          const referentCredentials = [];
          for (const [referent, requestedCredential] of Object.entries(requestedCredentials.requestedAttributes)) {
            referentCredentials.push({
              referent,
              credentialInfo: requestedCredential.credentialInfo,
              type: RequestReferentType.Attribute
            });
          }
          for (const [referent, requestedCredential] of Object.entries(requestedCredentials.requestedPredicates)) {
            referentCredentials.push({
              referent,
              credentialInfo: requestedCredential.credentialInfo,
              type: RequestReferentType.Predicate
            });
          }
          for (const { referent, credentialInfo, type } of referentCredentials) {
            if (!credentialInfo) {
              throw new AriesFrameworkError_1.AriesFrameworkError(`Credential for referent '${referent} does not have credential info for revocation state creation`);
            }
            const referentRevocationInterval = type === RequestReferentType.Predicate ? proofRequest.requested_predicates[referent].non_revoked : proofRequest.requested_attributes[referent].non_revoked;
            const requestRevocationInterval = referentRevocationInterval !== null && referentRevocationInterval !== void 0 ? referentRevocationInterval : proofRequest.non_revoked;
            const credentialRevocationId = credentialInfo.credentialRevocationId;
            const revocationRegistryId = credentialInfo.revocationRegistryId;
            if (requestRevocationInterval && credentialRevocationId && revocationRegistryId) {
              this.logger.trace(`Presentation is requesting proof of non revocation for ${type} referent '${referent}', creating revocation state for credential`, {
                requestRevocationInterval,
                credentialRevocationId,
                revocationRegistryId
              });
              this.assertRevocationInterval(requestRevocationInterval);
              const { revocationRegistryDefinition } = await this.ledgerService.getRevocationRegistryDefinition(agentContext, revocationRegistryId);
              const { revocationRegistryDelta, deltaTimestamp } = await this.ledgerService.getRevocationRegistryDelta(agentContext, revocationRegistryId, requestRevocationInterval === null || requestRevocationInterval === void 0 ? void 0 : requestRevocationInterval.to, 0);
              const { tailsLocation, tailsHash } = revocationRegistryDefinition.value;
              const tails = await this.indyUtilitiesService.downloadTails(tailsHash, tailsLocation);
              const revocationState = await this.indy.createRevocationState(tails, revocationRegistryDefinition, revocationRegistryDelta, deltaTimestamp, credentialRevocationId);
              const timestamp = revocationState.timestamp;
              if (!revocationStates[revocationRegistryId]) {
                revocationStates[revocationRegistryId] = {};
              }
              revocationStates[revocationRegistryId][timestamp] = revocationState;
            }
          }
          this.logger.debug(`Created Revocation States for Proof Request`, {
            revocationStates
          });
          return revocationStates;
        } catch (error) {
          this.logger.error(`Error creating Indy Revocation State for Proof Request`, {
            error,
            proofRequest,
            requestedCredentials
          });
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      // Get revocation status for credential (given a from-to)
      // Note from-to interval details: https://github.com/hyperledger/indy-hipe/blob/master/text/0011-cred-revocation/README.md#indy-node-revocation-registry-intervals
      async getRevocationStatus(agentContext, credentialRevocationId, revocationRegistryDefinitionId, requestRevocationInterval) {
        var _a;
        this.logger.trace(`Fetching Credential Revocation Status for Credential Revocation Id '${credentialRevocationId}' with revocation interval with to '${requestRevocationInterval.to}' & from '${requestRevocationInterval.from}'`);
        this.assertRevocationInterval(requestRevocationInterval);
        const { revocationRegistryDelta, deltaTimestamp } = await this.ledgerService.getRevocationRegistryDelta(agentContext, revocationRegistryDefinitionId, requestRevocationInterval.to, 0);
        const revoked = ((_a = revocationRegistryDelta.value.revoked) === null || _a === void 0 ? void 0 : _a.includes(parseInt(credentialRevocationId))) || false;
        this.logger.trace(`Credential with Credential Revocation Id '${credentialRevocationId}' is ${revoked ? "" : "not "}revoked with revocation interval with to '${requestRevocationInterval.to}' & from '${requestRevocationInterval.from}'`);
        return {
          revoked,
          deltaTimestamp
        };
      }
      // TODO: Add Test
      // Check revocation interval in accordance with https://github.com/hyperledger/aries-rfcs/blob/main/concepts/0441-present-proof-best-practices/README.md#semantics-of-non-revocation-interval-endpoints
      assertRevocationInterval(requestRevocationInterval) {
        if (!requestRevocationInterval.to) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`Presentation requests proof of non-revocation with no 'to' value specified`);
        }
        if ((requestRevocationInterval.from || requestRevocationInterval.from === 0) && requestRevocationInterval.to !== requestRevocationInterval.from) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`Presentation requests proof of non-revocation with an interval from: '${requestRevocationInterval.from}' that does not match the interval to: '${requestRevocationInterval.to}', as specified in Aries RFC 0441`);
        }
      }
    };
    IndyRevocationService = __decorate([
      (0, plugins_1.injectable)(),
      __param(2, (0, plugins_1.inject)(constants_1.InjectionSymbols.AgentDependencies)),
      __param(3, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [
        IndyUtilitiesService_1.IndyUtilitiesService,
        ledger_1.IndyLedgerService,
        Object,
        Object
      ])
    ], IndyRevocationService);
    exports.IndyRevocationService = IndyRevocationService;
  }
});

// node_modules/@aries-framework/core/build/modules/indy/services/IndyHolderService.js
var require_IndyHolderService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/indy/services/IndyHolderService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyHolderService = void 0;
    var constants_1 = require_constants();
    var IndySdkError_1 = require_IndySdkError();
    var plugins_1 = require_plugins();
    var indyError_1 = require_indyError();
    var assertIndyWallet_1 = require_assertIndyWallet();
    var IndyRevocationService_1 = require_IndyRevocationService();
    var IndyHolderService = class IndyHolderService {
      constructor(indyRevocationService, logger, agentDependencies) {
        this.indy = agentDependencies.indy;
        this.indyRevocationService = indyRevocationService;
        this.logger = logger;
      }
      /**
       * Creates an Indy Proof in response to a proof request. Will create revocation state if the proof request requests proof of non-revocation
       *
       * @param proofRequest a Indy proof request
       * @param requestedCredentials the requested credentials to use for the proof creation
       * @param schemas schemas to use in proof creation
       * @param credentialDefinitions credential definitions to use in proof creation
       * @throws {Error} if there is an error during proof generation or revocation state generation
       * @returns a promise of Indy Proof
       *
       * @todo support attribute non_revoked fields
       */
      async createProof(agentContext, { proofRequest, requestedCredentials, schemas, credentialDefinitions }) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
          this.logger.debug("Creating Indy Proof");
          const revocationStates = await this.indyRevocationService.createRevocationState(agentContext, proofRequest, requestedCredentials);
          const indyProof = await this.indy.proverCreateProof(agentContext.wallet.handle, proofRequest, requestedCredentials.toJSON(), agentContext.wallet.masterSecretId, schemas, credentialDefinitions, revocationStates);
          this.logger.trace("Created Indy Proof", {
            indyProof
          });
          return indyProof;
        } catch (error) {
          this.logger.error(`Error creating Indy Proof`, {
            error,
            proofRequest,
            requestedCredentials
          });
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      /**
       * Store a credential in the wallet.
       *
       * @returns The credential id
       */
      async storeCredential(agentContext, { credentialRequestMetadata, credential, credentialDefinition, credentialId, revocationRegistryDefinition }) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
          return await this.indy.proverStoreCredential(agentContext.wallet.handle, credentialId !== null && credentialId !== void 0 ? credentialId : null, credentialRequestMetadata, credential, credentialDefinition, revocationRegistryDefinition !== null && revocationRegistryDefinition !== void 0 ? revocationRegistryDefinition : null);
        } catch (error) {
          this.logger.error(`Error storing Indy Credential '${credentialId}'`, {
            error
          });
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      /**
       * Get a credential stored in the wallet by id.
       *
       * @param credentialId the id (referent) of the credential
       * @throws {Error} if the credential is not found
       * @returns the credential
       *
       * @todo handle record not found
       */
      async getCredential(agentContext, credentialId) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
          return await this.indy.proverGetCredential(agentContext.wallet.handle, credentialId);
        } catch (error) {
          this.logger.error(`Error getting Indy Credential '${credentialId}'`, {
            error
          });
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      /**
       * Create a credential request for the given credential offer.
       *
       * @returns The credential request and the credential request metadata
       */
      async createCredentialRequest(agentContext, { holderDid, credentialOffer, credentialDefinition }) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
          return await this.indy.proverCreateCredentialReq(agentContext.wallet.handle, holderDid, credentialOffer, credentialDefinition, agentContext.wallet.masterSecretId);
        } catch (error) {
          this.logger.error(`Error creating Indy Credential Request`, {
            error,
            credentialOffer
          });
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      /**
       * Retrieve the credentials that are available for an attribute referent in the proof request.
       *
       * @param proofRequest The proof request to retrieve the credentials for
       * @param attributeReferent An attribute referent from the proof request to retrieve the credentials for
       * @param start Starting index
       * @param limit Maximum number of records to return
       *
       * @returns List of credentials that are available for building a proof for the given proof request
       *
       */
      async getCredentialsForProofRequest(agentContext, { proofRequest, attributeReferent, start = 0, limit: limit2 = 256, extraQuery }) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
          const searchHandle = await this.indy.proverSearchCredentialsForProofReq(agentContext.wallet.handle, proofRequest, extraQuery !== null && extraQuery !== void 0 ? extraQuery : null);
          try {
            if (start > 0) {
              await this.fetchCredentialsForReferent(searchHandle, attributeReferent, start);
            }
            const credentials = await this.fetchCredentialsForReferent(searchHandle, attributeReferent, limit2);
            return credentials;
          } finally {
            await this.indy.proverCloseCredentialsSearchForProofReq(searchHandle);
          }
        } catch (error) {
          if ((0, indyError_1.isIndyError)(error)) {
            throw new IndySdkError_1.IndySdkError(error);
          }
          throw error;
        }
      }
      /**
       * Delete a credential stored in the wallet by id.
       *
       * @param credentialId the id (referent) of the credential
       *
       */
      async deleteCredential(agentContext, credentialId) {
        (0, assertIndyWallet_1.assertIndyWallet)(agentContext.wallet);
        try {
          return await this.indy.proverDeleteCredential(agentContext.wallet.handle, credentialId);
        } catch (error) {
          this.logger.error(`Error deleting Indy Credential from Wallet`, {
            error
          });
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
      async fetchCredentialsForReferent(searchHandle, referent, limit2) {
        try {
          let credentials = [];
          const chunk = limit2 ? Math.min(256, limit2) : 256;
          while (!limit2 || credentials.length < limit2) {
            const credentialsJson = await this.indy.proverFetchCredentialsForProofReq(searchHandle, referent, chunk);
            credentials = [...credentials, ...credentialsJson];
            if (credentialsJson.length < chunk) {
              return credentials;
            }
          }
          return credentials;
        } catch (error) {
          this.logger.error(`Error Fetching Indy Credentials For Referent`, {
            error
          });
          throw (0, indyError_1.isIndyError)(error) ? new IndySdkError_1.IndySdkError(error) : error;
        }
      }
    };
    IndyHolderService = __decorate([
      (0, plugins_1.injectable)(),
      __param(1, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __param(2, (0, plugins_1.inject)(constants_1.InjectionSymbols.AgentDependencies)),
      __metadata("design:paramtypes", [IndyRevocationService_1.IndyRevocationService, Object, Object])
    ], IndyHolderService);
    exports.IndyHolderService = IndyHolderService;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/messages/V1CredentialAckMessage.js
var require_V1CredentialAckMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/messages/V1CredentialAckMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1CredentialAckMessage = void 0;
    var messageType_1 = require_messageType();
    var common_1 = require_common();
    var V1CredentialAckMessage = class extends common_1.AckMessage {
      /**
       * Create new CredentialAckMessage instance.
       * @param options
       */
      constructor(options) {
        super(options);
        this.type = V1CredentialAckMessage.type.messageTypeUri;
      }
    };
    V1CredentialAckMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/issue-credential/1.0/ack");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V1CredentialAckMessage.type),
      __metadata("design:type", Object)
    ], V1CredentialAckMessage.prototype, "type", void 0);
    exports.V1CredentialAckMessage = V1CredentialAckMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/messages/V1CredentialPreview.js
var require_V1CredentialPreview = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/messages/V1CredentialPreview.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1CredentialPreview = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var JsonTransformer_1 = require_JsonTransformer();
    var messageType_1 = require_messageType();
    var CredentialPreviewAttribute_1 = require_CredentialPreviewAttribute();
    var V1CredentialPreview = class {
      constructor(options) {
        this.type = V1CredentialPreview.type.messageTypeUri;
        if (options) {
          this.attributes = options.attributes;
        }
      }
      toJSON() {
        return JsonTransformer_1.JsonTransformer.toJSON(this);
      }
      /**
       * Create a credential preview from a record with name and value entries.
       *
       * @example
       * const preview = CredentialPreview.fromRecord({
       *   name: "Bob",
       *   age: "20"
       * })
       */
      static fromRecord(record) {
        const attributes = Object.entries(record).map(([name, value]) => new CredentialPreviewAttribute_1.CredentialPreviewAttribute({
          name,
          mimeType: "text/plain",
          value
        }));
        return new V1CredentialPreview({
          attributes
        });
      }
    };
    V1CredentialPreview.type = (0, messageType_1.parseMessageType)("https://didcomm.org/issue-credential/1.0/credential-preview");
    __decorate([
      (0, class_transformer_1.Expose)({ name: "@type" }),
      (0, messageType_1.IsValidMessageType)(V1CredentialPreview.type),
      (0, class_transformer_1.Transform)(({ value }) => (0, messageType_1.replaceLegacyDidSovPrefix)(value), {
        toClassOnly: true
      }),
      __metadata("design:type", Object)
    ], V1CredentialPreview.prototype, "type", void 0);
    __decorate([
      (0, class_transformer_1.Type)(() => CredentialPreviewAttribute_1.CredentialPreviewAttribute),
      (0, class_validator_1.ValidateNested)({ each: true }),
      (0, class_validator_1.IsInstance)(CredentialPreviewAttribute_1.CredentialPreviewAttribute, { each: true }),
      __metadata("design:type", Array)
    ], V1CredentialPreview.prototype, "attributes", void 0);
    exports.V1CredentialPreview = V1CredentialPreview;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/messages/V1RequestCredentialMessage.js
var require_V1RequestCredentialMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/messages/V1RequestCredentialMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1RequestCredentialMessage = exports.INDY_CREDENTIAL_REQUEST_ATTACHMENT_ID = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var Attachment_1 = require_Attachment();
    var messageType_1 = require_messageType();
    exports.INDY_CREDENTIAL_REQUEST_ATTACHMENT_ID = "libindy-cred-request-0";
    var V1RequestCredentialMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        super();
        this.type = V1RequestCredentialMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.comment = options.comment;
          this.requestAttachments = options.requestAttachments;
          this.appendedAttachments = options.attachments;
        }
      }
      get indyCredentialRequest() {
        var _a;
        const attachment = this.requestAttachments.find((attachment2) => attachment2.id === exports.INDY_CREDENTIAL_REQUEST_ATTACHMENT_ID);
        const credentialReqJson = (_a = attachment === null || attachment === void 0 ? void 0 : attachment.getDataAsJson()) !== null && _a !== void 0 ? _a : null;
        return credentialReqJson;
      }
      getRequestAttachmentById(id) {
        return this.requestAttachments.find((attachment) => attachment.id === id);
      }
    };
    V1RequestCredentialMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/issue-credential/1.0/request-credential");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V1RequestCredentialMessage.type),
      __metadata("design:type", Object)
    ], V1RequestCredentialMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], V1RequestCredentialMessage.prototype, "comment", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "requests~attach" }),
      (0, class_transformer_1.Type)(() => Attachment_1.Attachment),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)({
        each: true
      }),
      (0, class_validator_1.IsInstance)(Attachment_1.Attachment, { each: true }),
      __metadata("design:type", Array)
    ], V1RequestCredentialMessage.prototype, "requestAttachments", void 0);
    exports.V1RequestCredentialMessage = V1RequestCredentialMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/messages/V1IssueCredentialMessage.js
var require_V1IssueCredentialMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/messages/V1IssueCredentialMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1IssueCredentialMessage = exports.INDY_CREDENTIAL_ATTACHMENT_ID = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var Attachment_1 = require_Attachment();
    var messageType_1 = require_messageType();
    exports.INDY_CREDENTIAL_ATTACHMENT_ID = "libindy-cred-0";
    var V1IssueCredentialMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a;
        super();
        this.type = V1IssueCredentialMessage.type.messageTypeUri;
        if (options) {
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.comment = options.comment;
          this.credentialAttachments = options.credentialAttachments;
          this.appendedAttachments = options.attachments;
        }
      }
      get indyCredential() {
        var _a;
        const attachment = this.credentialAttachments.find((attachment2) => attachment2.id === exports.INDY_CREDENTIAL_ATTACHMENT_ID);
        const credentialJson = (_a = attachment === null || attachment === void 0 ? void 0 : attachment.getDataAsJson()) !== null && _a !== void 0 ? _a : null;
        return credentialJson;
      }
      getCredentialAttachmentById(id) {
        return this.credentialAttachments.find((attachment) => attachment.id == id);
      }
    };
    V1IssueCredentialMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/issue-credential/1.0/issue-credential");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V1IssueCredentialMessage.type),
      __metadata("design:type", Object)
    ], V1IssueCredentialMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], V1IssueCredentialMessage.prototype, "comment", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "credentials~attach" }),
      (0, class_transformer_1.Type)(() => Attachment_1.Attachment),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)({
        each: true
      }),
      (0, class_validator_1.IsInstance)(Attachment_1.Attachment, { each: true }),
      __metadata("design:type", Array)
    ], V1IssueCredentialMessage.prototype, "credentialAttachments", void 0);
    exports.V1IssueCredentialMessage = V1IssueCredentialMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/messages/V1OfferCredentialMessage.js
var require_V1OfferCredentialMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/messages/V1OfferCredentialMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1OfferCredentialMessage = exports.INDY_CREDENTIAL_OFFER_ATTACHMENT_ID = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var Attachment_1 = require_Attachment();
    var messageType_1 = require_messageType();
    var V1CredentialPreview_1 = require_V1CredentialPreview();
    exports.INDY_CREDENTIAL_OFFER_ATTACHMENT_ID = "libindy-cred-offer-0";
    var V1OfferCredentialMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        super();
        this.type = V1OfferCredentialMessage.type.messageTypeUri;
        if (options) {
          this.id = options.id || this.generateId();
          this.comment = options.comment;
          this.credentialPreview = options.credentialPreview;
          this.offerAttachments = options.offerAttachments;
          this.appendedAttachments = options.attachments;
        }
      }
      get indyCredentialOffer() {
        var _a;
        const attachment = this.offerAttachments.find((attachment2) => attachment2.id === exports.INDY_CREDENTIAL_OFFER_ATTACHMENT_ID);
        const credentialOfferJson = (_a = attachment === null || attachment === void 0 ? void 0 : attachment.getDataAsJson()) !== null && _a !== void 0 ? _a : null;
        return credentialOfferJson;
      }
      getOfferAttachmentById(id) {
        return this.offerAttachments.find((attachment) => attachment.id == id);
      }
    };
    V1OfferCredentialMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/issue-credential/1.0/offer-credential");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V1OfferCredentialMessage.type),
      __metadata("design:type", Object)
    ], V1OfferCredentialMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], V1OfferCredentialMessage.prototype, "comment", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "credential_preview" }),
      (0, class_transformer_1.Type)(() => V1CredentialPreview_1.V1CredentialPreview),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsInstance)(V1CredentialPreview_1.V1CredentialPreview),
      __metadata("design:type", V1CredentialPreview_1.V1CredentialPreview)
    ], V1OfferCredentialMessage.prototype, "credentialPreview", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "offers~attach" }),
      (0, class_transformer_1.Type)(() => Attachment_1.Attachment),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)({
        each: true
      }),
      (0, class_validator_1.IsInstance)(Attachment_1.Attachment, { each: true }),
      __metadata("design:type", Array)
    ], V1OfferCredentialMessage.prototype, "offerAttachments", void 0);
    exports.V1OfferCredentialMessage = V1OfferCredentialMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/messages/V1ProposeCredentialMessage.js
var require_V1ProposeCredentialMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/messages/V1ProposeCredentialMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1ProposeCredentialMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var utils_1 = require_utils();
    var messageType_1 = require_messageType();
    var V1CredentialPreview_1 = require_V1CredentialPreview();
    var V1ProposeCredentialMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a;
        super();
        this.type = V1ProposeCredentialMessage.type.messageTypeUri;
        if (options) {
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.comment = options.comment;
          this.credentialPreview = options.credentialPreview;
          this.schemaIssuerDid = options.schemaIssuerDid;
          this.schemaId = options.schemaId;
          this.schemaName = options.schemaName;
          this.schemaVersion = options.schemaVersion;
          this.credentialDefinitionId = options.credentialDefinitionId;
          this.issuerDid = options.issuerDid;
          this.appendedAttachments = options.attachments;
        }
      }
      getAttachment() {
        if (this.appendedAttachments) {
          return this.appendedAttachments[0];
        } else {
          return void 0;
        }
      }
    };
    V1ProposeCredentialMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/issue-credential/1.0/propose-credential");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V1ProposeCredentialMessage.type),
      __metadata("design:type", Object)
    ], V1ProposeCredentialMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], V1ProposeCredentialMessage.prototype, "comment", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "credential_proposal" }),
      (0, class_transformer_1.Type)(() => V1CredentialPreview_1.V1CredentialPreview),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsInstance)(V1CredentialPreview_1.V1CredentialPreview),
      __metadata(
        "design:type",
        V1CredentialPreview_1.V1CredentialPreview
        /**
         * Filter to request credential based on a particular Schema issuer DID.
         */
      )
    ], V1ProposeCredentialMessage.prototype, "credentialPreview", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "schema_issuer_did" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.Matches)(utils_1.indyDidRegex),
      __metadata("design:type", String)
    ], V1ProposeCredentialMessage.prototype, "schemaIssuerDid", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "schema_id" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.Matches)(utils_1.schemaIdRegex),
      __metadata("design:type", String)
    ], V1ProposeCredentialMessage.prototype, "schemaId", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "schema_name" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], V1ProposeCredentialMessage.prototype, "schemaName", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "schema_version" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.Matches)(utils_1.schemaVersionRegex, {
        message: "Version must be X.X or X.X.X"
      }),
      __metadata("design:type", String)
    ], V1ProposeCredentialMessage.prototype, "schemaVersion", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "cred_def_id" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.Matches)(utils_1.credDefIdRegex),
      __metadata("design:type", String)
    ], V1ProposeCredentialMessage.prototype, "credentialDefinitionId", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "issuer_did" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.Matches)(utils_1.indyDidRegex),
      __metadata("design:type", String)
    ], V1ProposeCredentialMessage.prototype, "issuerDid", void 0);
    exports.V1ProposeCredentialMessage = V1ProposeCredentialMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/messages/V1CredentialProblemReportMessage.js
var require_V1CredentialProblemReportMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/messages/V1CredentialProblemReportMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1CredentialProblemReportMessage = void 0;
    var messageType_1 = require_messageType();
    var ProblemReportMessage_1 = require_ProblemReportMessage();
    var V1CredentialProblemReportMessage = class extends ProblemReportMessage_1.ProblemReportMessage {
      /**
       * Create new CredentialProblemReportMessage instance.
       * @param options
       */
      constructor(options) {
        super(options);
        this.type = V1CredentialProblemReportMessage.type.messageTypeUri;
      }
    };
    V1CredentialProblemReportMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/issue-credential/1.0/problem-report");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V1CredentialProblemReportMessage.type),
      __metadata("design:type", Object)
    ], V1CredentialProblemReportMessage.prototype, "type", void 0);
    exports.V1CredentialProblemReportMessage = V1CredentialProblemReportMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/messages/index.js
var require_messages10 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/messages/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_V1CredentialAckMessage(), exports);
    __exportStar(require_V1CredentialPreview(), exports);
    __exportStar(require_V1RequestCredentialMessage(), exports);
    __exportStar(require_V1IssueCredentialMessage(), exports);
    __exportStar(require_V1OfferCredentialMessage(), exports);
    __exportStar(require_V1ProposeCredentialMessage(), exports);
    __exportStar(require_V1CredentialProblemReportMessage(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/errors/CredentialProblemReportError.js
var require_CredentialProblemReportError = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/errors/CredentialProblemReportError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CredentialProblemReportError = void 0;
    var messages_1 = require_messages10();
    var ProblemReportError_1 = require_ProblemReportError();
    var CredentialProblemReportError = class extends ProblemReportError_1.ProblemReportError {
      constructor(message, { problemCode }) {
        super(message, { problemCode });
        this.problemReport = new messages_1.V1CredentialProblemReportMessage({
          description: {
            en: message,
            code: problemCode
          }
        });
      }
    };
    exports.CredentialProblemReportError = CredentialProblemReportError;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/errors/CredentialProblemReportReason.js
var require_CredentialProblemReportReason = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/errors/CredentialProblemReportReason.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CredentialProblemReportReason = void 0;
    var CredentialProblemReportReason;
    (function(CredentialProblemReportReason2) {
      CredentialProblemReportReason2["IssuanceAbandoned"] = "issuance-abandoned";
    })(CredentialProblemReportReason = exports.CredentialProblemReportReason || (exports.CredentialProblemReportReason = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/errors/index.js
var require_errors3 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/errors/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_CredentialProblemReportError(), exports);
    __exportStar(require_CredentialProblemReportReason(), exports);
  }
});

// browser-external:buffer
var require_buffer4 = __commonJS({
  "browser-external:buffer"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer4().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert(c >= 0 && b < mul, "Invalid character");
          r += b;
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
          BN.prototype.inspect = inspect;
        }
      } else {
        BN.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN.prototype.toBuffer = function toBuffer(endian, length2) {
          return this.toArrayLike(Buffer2, endian, length2);
        };
      }
      BN.prototype.toArray = function toArray(endian, length2) {
        return this.toArrayLike(Array, endian, length2);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length2) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length2 || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this._strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports, module) {
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER2 = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX2 = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: " ",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2))
            return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++)
                  ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v)))
                return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0)
                e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0)
                return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            else
              e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++)
            ;
          for (len = str.length; str.charCodeAt(--len) === 48; )
            ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER2 || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0)
                i += LOG_BASE;
              if (i < len) {
                if (i)
                  x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0")
                ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX2, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX2, 0, p);
                  intCheck(v[1], 0, MAX2, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX2, MAX2, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX2, -1, p);
                  intCheck(v[1], 1, MAX2, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX2, MAX2, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX2, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object")
                  FORMAT = v;
                else
                  throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true)
            return false;
          if (!BigNumber2.DEBUG)
            return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out:
            if ({}.toString.call(c) == "[object Array]") {
              if ((s === 1 || s === -1) && e >= -MAX2 && e <= MAX2 && e === mathfloor(e)) {
                if (c[0] === 0) {
                  if (e === 0 && c.length === 1)
                    return true;
                  break out;
                }
                i = (e + 1) % LOG_BASE;
                if (i < 1)
                  i += LOG_BASE;
                if (String(c[0]).length == i) {
                  for (i = 0; i < c.length; i++) {
                    n = c[i];
                    if (n < 0 || n >= BASE || n !== mathfloor(n))
                      break out;
                  }
                  if (n !== 0)
                    return true;
                }
              }
            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
              return true;
            }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, P.lt);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, P.gt);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null)
              dp = DECIMAL_PLACES;
            else
              intCheck(dp, 0, MAX2);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15)
                  c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--)
              ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
                ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
                ;
              if (i < LOG_BASE)
                e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; )
            sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null)
                    arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop())
              ;
            if (!xc[0])
              return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; )
                ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
                ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry)
              x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1))
              ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++)
              ;
            if (yc[i] > (xc[i] || 0))
              e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0)
                ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2)
                yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base)
                      n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL)
                    prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0])
                qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
                ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format2(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          if (!n.c)
            return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++)
                ;
              str = toExponential(str, e);
            } else {
              i -= ne;
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0)
                  for (str += "."; i--; str += "0")
                    ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len)
                    str += ".";
                  for (; i--; str += "0")
                    ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, method) {
          var n, i = 1, m = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            n = new BigNumber2(args[i]);
            if (!n.s) {
              m = n;
              break;
            } else if (method.call(m, n)) {
              m = n;
            }
          }
          return m;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop())
            ;
          for (j = c[0]; j >= 10; j /= 10, i++)
            ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s)
                  return new BigNumber2(s, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
                ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = n / pows10[d - j - 1] % 10 | 0;
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0))
                      ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++)
                    ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                      ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++)
                      ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE)
                        xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE)
                      break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop())
                ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null)
            return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0)
            x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX2);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c))
            return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v])
            for (; v % 10 == 0; v /= 10, n--)
              ;
          if (n < 0)
            n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null)
            m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s)
              return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp)
              x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1)
              k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg)
              n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c)
                break;
              if (k) {
                if (y.c.length > k)
                  y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0)
                  break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k)
                x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp)
            return y;
          if (nIsNeg)
            y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0))
              ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0)
            for (; b--; xc[i++] = 0)
              ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b)
                ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye)
            ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1)
            y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0))
            ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0])
              return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0))
              ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX2);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c))
            return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--)
              ;
            for (v = c[0]; v >= 10; v /= 10, n++)
              ;
          }
          if (sd && x.e + 1 > n)
            n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0)
              n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3)
              s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e)
                  --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX2);
            dp++;
          }
          return format2(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX2);
            dp = dp + this.e + 1;
          }
          return format2(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format3) {
          var str, x = this;
          if (format3 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format3 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format3 = dp;
              dp = rm = null;
            } else {
              format3 = FORMAT;
            }
          } else if (typeof format3 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format3);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format3.groupSize, g2 = +format3.secondaryGroupSize, groupSeparator = format3.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1)
                intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0)
                intPart += groupSeparator + intDigits.slice(i);
              if (isNeg)
                intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format3.decimalSeparator || "") + ((g2 = +format3.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format3.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format3.prefix || "") + str + (format3.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc)
            return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1)
              break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null)
            intCheck(sd, 1, MAX2);
          return format2(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0)
                str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0])
              str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null)
          BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s)
            ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; )
          ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j)
          return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b)
          return a ? b ? 0 : -j : i;
        if (i != j)
          return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc)
          return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b)
          return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++)
          if (xc[i] != yc[i])
            return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min2, max2, name) {
        if (n < min2 || n > max2 || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min2 || n > max2 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z)
            ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z)
              ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports);
  }
});

// node_modules/borc/src/decoder.asm.js
var require_decoder_asm = __commonJS({
  "node_modules/borc/src/decoder.asm.js"(exports, module) {
    module.exports = function decodeAsm(stdlib, foreign, buffer) {
      ;
      var heap = new stdlib.Uint8Array(buffer);
      var pushInt = foreign.pushInt;
      var pushInt32 = foreign.pushInt32;
      var pushInt32Neg = foreign.pushInt32Neg;
      var pushInt64 = foreign.pushInt64;
      var pushInt64Neg = foreign.pushInt64Neg;
      var pushFloat = foreign.pushFloat;
      var pushFloatSingle = foreign.pushFloatSingle;
      var pushFloatDouble = foreign.pushFloatDouble;
      var pushTrue = foreign.pushTrue;
      var pushFalse = foreign.pushFalse;
      var pushUndefined = foreign.pushUndefined;
      var pushNull = foreign.pushNull;
      var pushInfinity = foreign.pushInfinity;
      var pushInfinityNeg = foreign.pushInfinityNeg;
      var pushNaN = foreign.pushNaN;
      var pushNaNNeg = foreign.pushNaNNeg;
      var pushArrayStart = foreign.pushArrayStart;
      var pushArrayStartFixed = foreign.pushArrayStartFixed;
      var pushArrayStartFixed32 = foreign.pushArrayStartFixed32;
      var pushArrayStartFixed64 = foreign.pushArrayStartFixed64;
      var pushObjectStart = foreign.pushObjectStart;
      var pushObjectStartFixed = foreign.pushObjectStartFixed;
      var pushObjectStartFixed32 = foreign.pushObjectStartFixed32;
      var pushObjectStartFixed64 = foreign.pushObjectStartFixed64;
      var pushByteString = foreign.pushByteString;
      var pushByteStringStart = foreign.pushByteStringStart;
      var pushUtf8String = foreign.pushUtf8String;
      var pushUtf8StringStart = foreign.pushUtf8StringStart;
      var pushSimpleUnassigned = foreign.pushSimpleUnassigned;
      var pushTagStart = foreign.pushTagStart;
      var pushTagStart4 = foreign.pushTagStart4;
      var pushTagStart8 = foreign.pushTagStart8;
      var pushTagUnassigned = foreign.pushTagUnassigned;
      var pushBreak = foreign.pushBreak;
      var pow = stdlib.Math.pow;
      var offset = 0;
      var inputLength = 0;
      var code = 0;
      function parse4(input) {
        input = input | 0;
        offset = 0;
        inputLength = input;
        while ((offset | 0) < (inputLength | 0)) {
          code = jumpTable[heap[offset] & 255](heap[offset] | 0) | 0;
          if ((code | 0) > 0) {
            break;
          }
        }
        return code | 0;
      }
      function checkOffset(n) {
        n = n | 0;
        if (((offset | 0) + (n | 0) | 0) < (inputLength | 0)) {
          return 0;
        }
        return 1;
      }
      function readUInt16(n) {
        n = n | 0;
        return heap[n | 0] << 8 | heap[n + 1 | 0] | 0;
      }
      function readUInt32(n) {
        n = n | 0;
        return heap[n | 0] << 24 | heap[n + 1 | 0] << 16 | heap[n + 2 | 0] << 8 | heap[n + 3 | 0] | 0;
      }
      function INT_P(octet) {
        octet = octet | 0;
        pushInt(octet | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function UINT_P_8(octet) {
        octet = octet | 0;
        if (checkOffset(1) | 0) {
          return 1;
        }
        pushInt(heap[offset + 1 | 0] | 0);
        offset = offset + 2 | 0;
        return 0;
      }
      function UINT_P_16(octet) {
        octet = octet | 0;
        if (checkOffset(2) | 0) {
          return 1;
        }
        pushInt(
          readUInt16(offset + 1 | 0) | 0
        );
        offset = offset + 3 | 0;
        return 0;
      }
      function UINT_P_32(octet) {
        octet = octet | 0;
        if (checkOffset(4) | 0) {
          return 1;
        }
        pushInt32(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0
        );
        offset = offset + 5 | 0;
        return 0;
      }
      function UINT_P_64(octet) {
        octet = octet | 0;
        if (checkOffset(8) | 0) {
          return 1;
        }
        pushInt64(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0,
          readUInt16(offset + 5 | 0) | 0,
          readUInt16(offset + 7 | 0) | 0
        );
        offset = offset + 9 | 0;
        return 0;
      }
      function INT_N(octet) {
        octet = octet | 0;
        pushInt(-1 - (octet - 32 | 0) | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function UINT_N_8(octet) {
        octet = octet | 0;
        if (checkOffset(1) | 0) {
          return 1;
        }
        pushInt(
          -1 - (heap[offset + 1 | 0] | 0) | 0
        );
        offset = offset + 2 | 0;
        return 0;
      }
      function UINT_N_16(octet) {
        octet = octet | 0;
        var val = 0;
        if (checkOffset(2) | 0) {
          return 1;
        }
        val = readUInt16(offset + 1 | 0) | 0;
        pushInt(-1 - (val | 0) | 0);
        offset = offset + 3 | 0;
        return 0;
      }
      function UINT_N_32(octet) {
        octet = octet | 0;
        if (checkOffset(4) | 0) {
          return 1;
        }
        pushInt32Neg(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0
        );
        offset = offset + 5 | 0;
        return 0;
      }
      function UINT_N_64(octet) {
        octet = octet | 0;
        if (checkOffset(8) | 0) {
          return 1;
        }
        pushInt64Neg(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0,
          readUInt16(offset + 5 | 0) | 0,
          readUInt16(offset + 7 | 0) | 0
        );
        offset = offset + 9 | 0;
        return 0;
      }
      function BYTE_STRING(octet) {
        octet = octet | 0;
        var start = 0;
        var end = 0;
        var step = 0;
        step = octet - 64 | 0;
        if (checkOffset(step | 0) | 0) {
          return 1;
        }
        start = offset + 1 | 0;
        end = (offset + 1 | 0) + (step | 0) | 0;
        pushByteString(start | 0, end | 0);
        offset = end | 0;
        return 0;
      }
      function BYTE_STRING_8(octet) {
        octet = octet | 0;
        var start = 0;
        var end = 0;
        var length2 = 0;
        if (checkOffset(1) | 0) {
          return 1;
        }
        length2 = heap[offset + 1 | 0] | 0;
        start = offset + 2 | 0;
        end = (offset + 2 | 0) + (length2 | 0) | 0;
        if (checkOffset(length2 + 1 | 0) | 0) {
          return 1;
        }
        pushByteString(start | 0, end | 0);
        offset = end | 0;
        return 0;
      }
      function BYTE_STRING_16(octet) {
        octet = octet | 0;
        var start = 0;
        var end = 0;
        var length2 = 0;
        if (checkOffset(2) | 0) {
          return 1;
        }
        length2 = readUInt16(offset + 1 | 0) | 0;
        start = offset + 3 | 0;
        end = (offset + 3 | 0) + (length2 | 0) | 0;
        if (checkOffset(length2 + 2 | 0) | 0) {
          return 1;
        }
        pushByteString(start | 0, end | 0);
        offset = end | 0;
        return 0;
      }
      function BYTE_STRING_32(octet) {
        octet = octet | 0;
        var start = 0;
        var end = 0;
        var length2 = 0;
        if (checkOffset(4) | 0) {
          return 1;
        }
        length2 = readUInt32(offset + 1 | 0) | 0;
        start = offset + 5 | 0;
        end = (offset + 5 | 0) + (length2 | 0) | 0;
        if (checkOffset(length2 + 4 | 0) | 0) {
          return 1;
        }
        pushByteString(start | 0, end | 0);
        offset = end | 0;
        return 0;
      }
      function BYTE_STRING_64(octet) {
        octet = octet | 0;
        return 1;
      }
      function BYTE_STRING_BREAK(octet) {
        octet = octet | 0;
        pushByteStringStart();
        offset = offset + 1 | 0;
        return 0;
      }
      function UTF8_STRING(octet) {
        octet = octet | 0;
        var start = 0;
        var end = 0;
        var step = 0;
        step = octet - 96 | 0;
        if (checkOffset(step | 0) | 0) {
          return 1;
        }
        start = offset + 1 | 0;
        end = (offset + 1 | 0) + (step | 0) | 0;
        pushUtf8String(start | 0, end | 0);
        offset = end | 0;
        return 0;
      }
      function UTF8_STRING_8(octet) {
        octet = octet | 0;
        var start = 0;
        var end = 0;
        var length2 = 0;
        if (checkOffset(1) | 0) {
          return 1;
        }
        length2 = heap[offset + 1 | 0] | 0;
        start = offset + 2 | 0;
        end = (offset + 2 | 0) + (length2 | 0) | 0;
        if (checkOffset(length2 + 1 | 0) | 0) {
          return 1;
        }
        pushUtf8String(start | 0, end | 0);
        offset = end | 0;
        return 0;
      }
      function UTF8_STRING_16(octet) {
        octet = octet | 0;
        var start = 0;
        var end = 0;
        var length2 = 0;
        if (checkOffset(2) | 0) {
          return 1;
        }
        length2 = readUInt16(offset + 1 | 0) | 0;
        start = offset + 3 | 0;
        end = (offset + 3 | 0) + (length2 | 0) | 0;
        if (checkOffset(length2 + 2 | 0) | 0) {
          return 1;
        }
        pushUtf8String(start | 0, end | 0);
        offset = end | 0;
        return 0;
      }
      function UTF8_STRING_32(octet) {
        octet = octet | 0;
        var start = 0;
        var end = 0;
        var length2 = 0;
        if (checkOffset(4) | 0) {
          return 1;
        }
        length2 = readUInt32(offset + 1 | 0) | 0;
        start = offset + 5 | 0;
        end = (offset + 5 | 0) + (length2 | 0) | 0;
        if (checkOffset(length2 + 4 | 0) | 0) {
          return 1;
        }
        pushUtf8String(start | 0, end | 0);
        offset = end | 0;
        return 0;
      }
      function UTF8_STRING_64(octet) {
        octet = octet | 0;
        return 1;
      }
      function UTF8_STRING_BREAK(octet) {
        octet = octet | 0;
        pushUtf8StringStart();
        offset = offset + 1 | 0;
        return 0;
      }
      function ARRAY(octet) {
        octet = octet | 0;
        pushArrayStartFixed(octet - 128 | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function ARRAY_8(octet) {
        octet = octet | 0;
        if (checkOffset(1) | 0) {
          return 1;
        }
        pushArrayStartFixed(heap[offset + 1 | 0] | 0);
        offset = offset + 2 | 0;
        return 0;
      }
      function ARRAY_16(octet) {
        octet = octet | 0;
        if (checkOffset(2) | 0) {
          return 1;
        }
        pushArrayStartFixed(
          readUInt16(offset + 1 | 0) | 0
        );
        offset = offset + 3 | 0;
        return 0;
      }
      function ARRAY_32(octet) {
        octet = octet | 0;
        if (checkOffset(4) | 0) {
          return 1;
        }
        pushArrayStartFixed32(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0
        );
        offset = offset + 5 | 0;
        return 0;
      }
      function ARRAY_64(octet) {
        octet = octet | 0;
        if (checkOffset(8) | 0) {
          return 1;
        }
        pushArrayStartFixed64(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0,
          readUInt16(offset + 5 | 0) | 0,
          readUInt16(offset + 7 | 0) | 0
        );
        offset = offset + 9 | 0;
        return 0;
      }
      function ARRAY_BREAK(octet) {
        octet = octet | 0;
        pushArrayStart();
        offset = offset + 1 | 0;
        return 0;
      }
      function MAP(octet) {
        octet = octet | 0;
        var step = 0;
        step = octet - 160 | 0;
        if (checkOffset(step | 0) | 0) {
          return 1;
        }
        pushObjectStartFixed(step | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function MAP_8(octet) {
        octet = octet | 0;
        if (checkOffset(1) | 0) {
          return 1;
        }
        pushObjectStartFixed(heap[offset + 1 | 0] | 0);
        offset = offset + 2 | 0;
        return 0;
      }
      function MAP_16(octet) {
        octet = octet | 0;
        if (checkOffset(2) | 0) {
          return 1;
        }
        pushObjectStartFixed(
          readUInt16(offset + 1 | 0) | 0
        );
        offset = offset + 3 | 0;
        return 0;
      }
      function MAP_32(octet) {
        octet = octet | 0;
        if (checkOffset(4) | 0) {
          return 1;
        }
        pushObjectStartFixed32(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0
        );
        offset = offset + 5 | 0;
        return 0;
      }
      function MAP_64(octet) {
        octet = octet | 0;
        if (checkOffset(8) | 0) {
          return 1;
        }
        pushObjectStartFixed64(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0,
          readUInt16(offset + 5 | 0) | 0,
          readUInt16(offset + 7 | 0) | 0
        );
        offset = offset + 9 | 0;
        return 0;
      }
      function MAP_BREAK(octet) {
        octet = octet | 0;
        pushObjectStart();
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_KNOWN(octet) {
        octet = octet | 0;
        pushTagStart(octet - 192 | 0 | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_BIGNUM_POS(octet) {
        octet = octet | 0;
        pushTagStart(octet | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_BIGNUM_NEG(octet) {
        octet = octet | 0;
        pushTagStart(octet | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_FRAC(octet) {
        octet = octet | 0;
        pushTagStart(octet | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_BIGNUM_FLOAT(octet) {
        octet = octet | 0;
        pushTagStart(octet | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_UNASSIGNED(octet) {
        octet = octet | 0;
        pushTagStart(octet - 192 | 0 | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_BASE64_URL(octet) {
        octet = octet | 0;
        pushTagStart(octet | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_BASE64(octet) {
        octet = octet | 0;
        pushTagStart(octet | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_BASE16(octet) {
        octet = octet | 0;
        pushTagStart(octet | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_MORE_1(octet) {
        octet = octet | 0;
        if (checkOffset(1) | 0) {
          return 1;
        }
        pushTagStart(heap[offset + 1 | 0] | 0);
        offset = offset + 2 | 0;
        return 0;
      }
      function TAG_MORE_2(octet) {
        octet = octet | 0;
        if (checkOffset(2) | 0) {
          return 1;
        }
        pushTagStart(
          readUInt16(offset + 1 | 0) | 0
        );
        offset = offset + 3 | 0;
        return 0;
      }
      function TAG_MORE_4(octet) {
        octet = octet | 0;
        if (checkOffset(4) | 0) {
          return 1;
        }
        pushTagStart4(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0
        );
        offset = offset + 5 | 0;
        return 0;
      }
      function TAG_MORE_8(octet) {
        octet = octet | 0;
        if (checkOffset(8) | 0) {
          return 1;
        }
        pushTagStart8(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0,
          readUInt16(offset + 5 | 0) | 0,
          readUInt16(offset + 7 | 0) | 0
        );
        offset = offset + 9 | 0;
        return 0;
      }
      function SIMPLE_UNASSIGNED(octet) {
        octet = octet | 0;
        pushSimpleUnassigned((octet | 0) - 224 | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function SIMPLE_FALSE(octet) {
        octet = octet | 0;
        pushFalse();
        offset = offset + 1 | 0;
        return 0;
      }
      function SIMPLE_TRUE(octet) {
        octet = octet | 0;
        pushTrue();
        offset = offset + 1 | 0;
        return 0;
      }
      function SIMPLE_NULL(octet) {
        octet = octet | 0;
        pushNull();
        offset = offset + 1 | 0;
        return 0;
      }
      function SIMPLE_UNDEFINED(octet) {
        octet = octet | 0;
        pushUndefined();
        offset = offset + 1 | 0;
        return 0;
      }
      function SIMPLE_BYTE(octet) {
        octet = octet | 0;
        if (checkOffset(1) | 0) {
          return 1;
        }
        pushSimpleUnassigned(heap[offset + 1 | 0] | 0);
        offset = offset + 2 | 0;
        return 0;
      }
      function SIMPLE_FLOAT_HALF(octet) {
        octet = octet | 0;
        var f2 = 0;
        var g = 0;
        var sign = 1;
        var exp = 0;
        var mant = 0;
        var r = 0;
        if (checkOffset(2) | 0) {
          return 1;
        }
        f2 = heap[offset + 1 | 0] | 0;
        g = heap[offset + 2 | 0] | 0;
        if ((f2 | 0) & 128) {
          sign = -1;
        }
        exp = +(((f2 | 0) & 124) >> 2);
        mant = +(((f2 | 0) & 3) << 8 | g);
        if (+exp == 0) {
          pushFloat(+(+sign * 5960464477539063e-23 * +mant));
        } else if (+exp == 31) {
          if (+sign == 1) {
            if (+mant > 0) {
              pushNaN();
            } else {
              pushInfinity();
            }
          } else {
            if (+mant > 0) {
              pushNaNNeg();
            } else {
              pushInfinityNeg();
            }
          }
        } else {
          pushFloat(+(+sign * pow(2, +(+exp - 25)) * +(1024 + mant)));
        }
        offset = offset + 3 | 0;
        return 0;
      }
      function SIMPLE_FLOAT_SINGLE(octet) {
        octet = octet | 0;
        if (checkOffset(4) | 0) {
          return 1;
        }
        pushFloatSingle(
          heap[offset + 1 | 0] | 0,
          heap[offset + 2 | 0] | 0,
          heap[offset + 3 | 0] | 0,
          heap[offset + 4 | 0] | 0
        );
        offset = offset + 5 | 0;
        return 0;
      }
      function SIMPLE_FLOAT_DOUBLE(octet) {
        octet = octet | 0;
        if (checkOffset(8) | 0) {
          return 1;
        }
        pushFloatDouble(
          heap[offset + 1 | 0] | 0,
          heap[offset + 2 | 0] | 0,
          heap[offset + 3 | 0] | 0,
          heap[offset + 4 | 0] | 0,
          heap[offset + 5 | 0] | 0,
          heap[offset + 6 | 0] | 0,
          heap[offset + 7 | 0] | 0,
          heap[offset + 8 | 0] | 0
        );
        offset = offset + 9 | 0;
        return 0;
      }
      function ERROR(octet) {
        octet = octet | 0;
        return 1;
      }
      function BREAK(octet) {
        octet = octet | 0;
        pushBreak();
        offset = offset + 1 | 0;
        return 0;
      }
      var jumpTable = [
        // Integer 0x00..0x17 (0..23)
        INT_P,
        // 0x00
        INT_P,
        // 0x01
        INT_P,
        // 0x02
        INT_P,
        // 0x03
        INT_P,
        // 0x04
        INT_P,
        // 0x05
        INT_P,
        // 0x06
        INT_P,
        // 0x07
        INT_P,
        // 0x08
        INT_P,
        // 0x09
        INT_P,
        // 0x0A
        INT_P,
        // 0x0B
        INT_P,
        // 0x0C
        INT_P,
        // 0x0D
        INT_P,
        // 0x0E
        INT_P,
        // 0x0F
        INT_P,
        // 0x10
        INT_P,
        // 0x11
        INT_P,
        // 0x12
        INT_P,
        // 0x13
        INT_P,
        // 0x14
        INT_P,
        // 0x15
        INT_P,
        // 0x16
        INT_P,
        // 0x17
        // Unsigned integer (one-byte uint8_t follows)
        UINT_P_8,
        // 0x18
        // Unsigned integer (two-byte uint16_t follows)
        UINT_P_16,
        // 0x19
        // Unsigned integer (four-byte uint32_t follows)
        UINT_P_32,
        // 0x1a
        // Unsigned integer (eight-byte uint64_t follows)
        UINT_P_64,
        // 0x1b
        ERROR,
        // 0x1c
        ERROR,
        // 0x1d
        ERROR,
        // 0x1e
        ERROR,
        // 0x1f
        // Negative integer -1-0x00..-1-0x17 (-1..-24)
        INT_N,
        // 0x20
        INT_N,
        // 0x21
        INT_N,
        // 0x22
        INT_N,
        // 0x23
        INT_N,
        // 0x24
        INT_N,
        // 0x25
        INT_N,
        // 0x26
        INT_N,
        // 0x27
        INT_N,
        // 0x28
        INT_N,
        // 0x29
        INT_N,
        // 0x2A
        INT_N,
        // 0x2B
        INT_N,
        // 0x2C
        INT_N,
        // 0x2D
        INT_N,
        // 0x2E
        INT_N,
        // 0x2F
        INT_N,
        // 0x30
        INT_N,
        // 0x31
        INT_N,
        // 0x32
        INT_N,
        // 0x33
        INT_N,
        // 0x34
        INT_N,
        // 0x35
        INT_N,
        // 0x36
        INT_N,
        // 0x37
        // Negative integer -1-n (one-byte uint8_t for n follows)
        UINT_N_8,
        // 0x38
        // Negative integer -1-n (two-byte uint16_t for n follows)
        UINT_N_16,
        // 0x39
        // Negative integer -1-n (four-byte uint32_t for nfollows)
        UINT_N_32,
        // 0x3a
        // Negative integer -1-n (eight-byte uint64_t for n follows)
        UINT_N_64,
        // 0x3b
        ERROR,
        // 0x3c
        ERROR,
        // 0x3d
        ERROR,
        // 0x3e
        ERROR,
        // 0x3f
        // byte string (0x00..0x17 bytes follow)
        BYTE_STRING,
        // 0x40
        BYTE_STRING,
        // 0x41
        BYTE_STRING,
        // 0x42
        BYTE_STRING,
        // 0x43
        BYTE_STRING,
        // 0x44
        BYTE_STRING,
        // 0x45
        BYTE_STRING,
        // 0x46
        BYTE_STRING,
        // 0x47
        BYTE_STRING,
        // 0x48
        BYTE_STRING,
        // 0x49
        BYTE_STRING,
        // 0x4A
        BYTE_STRING,
        // 0x4B
        BYTE_STRING,
        // 0x4C
        BYTE_STRING,
        // 0x4D
        BYTE_STRING,
        // 0x4E
        BYTE_STRING,
        // 0x4F
        BYTE_STRING,
        // 0x50
        BYTE_STRING,
        // 0x51
        BYTE_STRING,
        // 0x52
        BYTE_STRING,
        // 0x53
        BYTE_STRING,
        // 0x54
        BYTE_STRING,
        // 0x55
        BYTE_STRING,
        // 0x56
        BYTE_STRING,
        // 0x57
        // byte string (one-byte uint8_t for n, and then n bytes follow)
        BYTE_STRING_8,
        // 0x58
        // byte string (two-byte uint16_t for n, and then n bytes follow)
        BYTE_STRING_16,
        // 0x59
        // byte string (four-byte uint32_t for n, and then n bytes follow)
        BYTE_STRING_32,
        // 0x5a
        // byte string (eight-byte uint64_t for n, and then n bytes follow)
        BYTE_STRING_64,
        // 0x5b
        ERROR,
        // 0x5c
        ERROR,
        // 0x5d
        ERROR,
        // 0x5e
        // byte string, byte strings follow, terminated by "break"
        BYTE_STRING_BREAK,
        // 0x5f
        // UTF-8 string (0x00..0x17 bytes follow)
        UTF8_STRING,
        // 0x60
        UTF8_STRING,
        // 0x61
        UTF8_STRING,
        // 0x62
        UTF8_STRING,
        // 0x63
        UTF8_STRING,
        // 0x64
        UTF8_STRING,
        // 0x65
        UTF8_STRING,
        // 0x66
        UTF8_STRING,
        // 0x67
        UTF8_STRING,
        // 0x68
        UTF8_STRING,
        // 0x69
        UTF8_STRING,
        // 0x6A
        UTF8_STRING,
        // 0x6B
        UTF8_STRING,
        // 0x6C
        UTF8_STRING,
        // 0x6D
        UTF8_STRING,
        // 0x6E
        UTF8_STRING,
        // 0x6F
        UTF8_STRING,
        // 0x70
        UTF8_STRING,
        // 0x71
        UTF8_STRING,
        // 0x72
        UTF8_STRING,
        // 0x73
        UTF8_STRING,
        // 0x74
        UTF8_STRING,
        // 0x75
        UTF8_STRING,
        // 0x76
        UTF8_STRING,
        // 0x77
        // UTF-8 string (one-byte uint8_t for n, and then n bytes follow)
        UTF8_STRING_8,
        // 0x78
        // UTF-8 string (two-byte uint16_t for n, and then n bytes follow)
        UTF8_STRING_16,
        // 0x79
        // UTF-8 string (four-byte uint32_t for n, and then n bytes follow)
        UTF8_STRING_32,
        // 0x7a
        // UTF-8 string (eight-byte uint64_t for n, and then n bytes follow)
        UTF8_STRING_64,
        // 0x7b
        // UTF-8 string, UTF-8 strings follow, terminated by "break"
        ERROR,
        // 0x7c
        ERROR,
        // 0x7d
        ERROR,
        // 0x7e
        UTF8_STRING_BREAK,
        // 0x7f
        // array (0x00..0x17 data items follow)
        ARRAY,
        // 0x80
        ARRAY,
        // 0x81
        ARRAY,
        // 0x82
        ARRAY,
        // 0x83
        ARRAY,
        // 0x84
        ARRAY,
        // 0x85
        ARRAY,
        // 0x86
        ARRAY,
        // 0x87
        ARRAY,
        // 0x88
        ARRAY,
        // 0x89
        ARRAY,
        // 0x8A
        ARRAY,
        // 0x8B
        ARRAY,
        // 0x8C
        ARRAY,
        // 0x8D
        ARRAY,
        // 0x8E
        ARRAY,
        // 0x8F
        ARRAY,
        // 0x90
        ARRAY,
        // 0x91
        ARRAY,
        // 0x92
        ARRAY,
        // 0x93
        ARRAY,
        // 0x94
        ARRAY,
        // 0x95
        ARRAY,
        // 0x96
        ARRAY,
        // 0x97
        // array (one-byte uint8_t fo, and then n data items follow)
        ARRAY_8,
        // 0x98
        // array (two-byte uint16_t for n, and then n data items follow)
        ARRAY_16,
        // 0x99
        // array (four-byte uint32_t for n, and then n data items follow)
        ARRAY_32,
        // 0x9a
        // array (eight-byte uint64_t for n, and then n data items follow)
        ARRAY_64,
        // 0x9b
        // array, data items follow, terminated by "break"
        ERROR,
        // 0x9c
        ERROR,
        // 0x9d
        ERROR,
        // 0x9e
        ARRAY_BREAK,
        // 0x9f
        // map (0x00..0x17 pairs of data items follow)
        MAP,
        // 0xa0
        MAP,
        // 0xa1
        MAP,
        // 0xa2
        MAP,
        // 0xa3
        MAP,
        // 0xa4
        MAP,
        // 0xa5
        MAP,
        // 0xa6
        MAP,
        // 0xa7
        MAP,
        // 0xa8
        MAP,
        // 0xa9
        MAP,
        // 0xaA
        MAP,
        // 0xaB
        MAP,
        // 0xaC
        MAP,
        // 0xaD
        MAP,
        // 0xaE
        MAP,
        // 0xaF
        MAP,
        // 0xb0
        MAP,
        // 0xb1
        MAP,
        // 0xb2
        MAP,
        // 0xb3
        MAP,
        // 0xb4
        MAP,
        // 0xb5
        MAP,
        // 0xb6
        MAP,
        // 0xb7
        // map (one-byte uint8_t for n, and then n pairs of data items follow)
        MAP_8,
        // 0xb8
        // map (two-byte uint16_t for n, and then n pairs of data items follow)
        MAP_16,
        // 0xb9
        // map (four-byte uint32_t for n, and then n pairs of data items follow)
        MAP_32,
        // 0xba
        // map (eight-byte uint64_t for n, and then n pairs of data items follow)
        MAP_64,
        // 0xbb
        ERROR,
        // 0xbc
        ERROR,
        // 0xbd
        ERROR,
        // 0xbe
        // map, pairs of data items follow, terminated by "break"
        MAP_BREAK,
        // 0xbf
        // Text-based date/time (data item follows; see Section 2.4.1)
        TAG_KNOWN,
        // 0xc0
        // Epoch-based date/time (data item follows; see Section 2.4.1)
        TAG_KNOWN,
        // 0xc1
        // Positive bignum (data item "byte string" follows)
        TAG_KNOWN,
        // 0xc2
        // Negative bignum (data item "byte string" follows)
        TAG_KNOWN,
        // 0xc3
        // Decimal Fraction (data item "array" follows; see Section 2.4.3)
        TAG_KNOWN,
        // 0xc4
        // Bigfloat (data item "array" follows; see Section 2.4.3)
        TAG_KNOWN,
        // 0xc5
        // (tagged item)
        TAG_UNASSIGNED,
        // 0xc6
        TAG_UNASSIGNED,
        // 0xc7
        TAG_UNASSIGNED,
        // 0xc8
        TAG_UNASSIGNED,
        // 0xc9
        TAG_UNASSIGNED,
        // 0xca
        TAG_UNASSIGNED,
        // 0xcb
        TAG_UNASSIGNED,
        // 0xcc
        TAG_UNASSIGNED,
        // 0xcd
        TAG_UNASSIGNED,
        // 0xce
        TAG_UNASSIGNED,
        // 0xcf
        TAG_UNASSIGNED,
        // 0xd0
        TAG_UNASSIGNED,
        // 0xd1
        TAG_UNASSIGNED,
        // 0xd2
        TAG_UNASSIGNED,
        // 0xd3
        TAG_UNASSIGNED,
        // 0xd4
        // Expected Conversion (data item follows; see Section 2.4.4.2)
        TAG_UNASSIGNED,
        // 0xd5
        TAG_UNASSIGNED,
        // 0xd6
        TAG_UNASSIGNED,
        // 0xd7
        // (more tagged items, 1/2/4/8 bytes and then a data item follow)
        TAG_MORE_1,
        // 0xd8
        TAG_MORE_2,
        // 0xd9
        TAG_MORE_4,
        // 0xda
        TAG_MORE_8,
        // 0xdb
        ERROR,
        // 0xdc
        ERROR,
        // 0xdd
        ERROR,
        // 0xde
        ERROR,
        // 0xdf
        // (simple value)
        SIMPLE_UNASSIGNED,
        // 0xe0
        SIMPLE_UNASSIGNED,
        // 0xe1
        SIMPLE_UNASSIGNED,
        // 0xe2
        SIMPLE_UNASSIGNED,
        // 0xe3
        SIMPLE_UNASSIGNED,
        // 0xe4
        SIMPLE_UNASSIGNED,
        // 0xe5
        SIMPLE_UNASSIGNED,
        // 0xe6
        SIMPLE_UNASSIGNED,
        // 0xe7
        SIMPLE_UNASSIGNED,
        // 0xe8
        SIMPLE_UNASSIGNED,
        // 0xe9
        SIMPLE_UNASSIGNED,
        // 0xea
        SIMPLE_UNASSIGNED,
        // 0xeb
        SIMPLE_UNASSIGNED,
        // 0xec
        SIMPLE_UNASSIGNED,
        // 0xed
        SIMPLE_UNASSIGNED,
        // 0xee
        SIMPLE_UNASSIGNED,
        // 0xef
        SIMPLE_UNASSIGNED,
        // 0xf0
        SIMPLE_UNASSIGNED,
        // 0xf1
        SIMPLE_UNASSIGNED,
        // 0xf2
        SIMPLE_UNASSIGNED,
        // 0xf3
        // False
        SIMPLE_FALSE,
        // 0xf4
        // True
        SIMPLE_TRUE,
        // 0xf5
        // Null
        SIMPLE_NULL,
        // 0xf6
        // Undefined
        SIMPLE_UNDEFINED,
        // 0xf7
        // (simple value, one byte follows)
        SIMPLE_BYTE,
        // 0xf8
        // Half-Precision Float (two-byte IEEE 754)
        SIMPLE_FLOAT_HALF,
        // 0xf9
        // Single-Precision Float (four-byte IEEE 754)
        SIMPLE_FLOAT_SINGLE,
        // 0xfa
        // Double-Precision Float (eight-byte IEEE 754)
        SIMPLE_FLOAT_DOUBLE,
        // 0xfb
        ERROR,
        // 0xfc
        ERROR,
        // 0xfd
        ERROR,
        // 0xfe
        // "break" stop code
        BREAK
        // 0xff
      ];
      return {
        parse: parse4
      };
    };
  }
});

// node_modules/borc/src/constants.js
var require_constants4 = __commonJS({
  "node_modules/borc/src/constants.js"(exports) {
    "use strict";
    var Bignumber = require_bignumber().BigNumber;
    exports.MT = {
      POS_INT: 0,
      NEG_INT: 1,
      BYTE_STRING: 2,
      UTF8_STRING: 3,
      ARRAY: 4,
      MAP: 5,
      TAG: 6,
      SIMPLE_FLOAT: 7
    };
    exports.TAG = {
      DATE_STRING: 0,
      DATE_EPOCH: 1,
      POS_BIGINT: 2,
      NEG_BIGINT: 3,
      DECIMAL_FRAC: 4,
      BIGFLOAT: 5,
      BASE64URL_EXPECTED: 21,
      BASE64_EXPECTED: 22,
      BASE16_EXPECTED: 23,
      CBOR: 24,
      URI: 32,
      BASE64URL: 33,
      BASE64: 34,
      REGEXP: 35,
      MIME: 36
    };
    exports.NUMBYTES = {
      ZERO: 0,
      ONE: 24,
      TWO: 25,
      FOUR: 26,
      EIGHT: 27,
      INDEFINITE: 31
    };
    exports.SIMPLE = {
      FALSE: 20,
      TRUE: 21,
      NULL: 22,
      UNDEFINED: 23
    };
    exports.SYMS = {
      NULL: Symbol("null"),
      UNDEFINED: Symbol("undef"),
      PARENT: Symbol("parent"),
      BREAK: Symbol("break"),
      STREAM: Symbol("stream")
    };
    exports.SHIFT32 = Math.pow(2, 32);
    exports.SHIFT16 = Math.pow(2, 16);
    exports.MAX_SAFE_HIGH = 2097151;
    exports.NEG_ONE = new Bignumber(-1);
    exports.TEN = new Bignumber(10);
    exports.TWO = new Bignumber(2);
    exports.PARENT = {
      ARRAY: 0,
      OBJECT: 1,
      MAP: 2,
      TAG: 3,
      BYTE_STRING: 4,
      UTF8_STRING: 5
    };
  }
});

// node_modules/borc/src/utils.js
var require_utils2 = __commonJS({
  "node_modules/borc/src/utils.js"(exports) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var Bignumber = require_bignumber().BigNumber;
    var constants = require_constants4();
    var SHIFT32 = constants.SHIFT32;
    var SHIFT16 = constants.SHIFT16;
    var MAX_SAFE_HIGH = 2097151;
    exports.parseHalf = function parseHalf(buf) {
      const sign = buf[0] & 128 ? -1 : 1;
      const exp = (buf[0] & 124) >> 2;
      const mant = (buf[0] & 3) << 8 | buf[1];
      if (!exp) {
        return sign * 5960464477539063e-23 * mant;
      } else if (exp === 31) {
        return sign * (mant ? 0 / 0 : Infinity);
      } else {
        return sign * Math.pow(2, exp - 25) * (1024 + mant);
      }
    };
    function toHex(n) {
      if (n < 16) {
        return "0" + n.toString(16);
      }
      return n.toString(16);
    }
    exports.arrayBufferToBignumber = function(buf) {
      const len = buf.byteLength;
      let res = "";
      for (let i = 0; i < len; i++) {
        res += toHex(buf[i]);
      }
      return new Bignumber(res, 16);
    };
    exports.buildMap = (obj) => {
      const res = /* @__PURE__ */ new Map();
      const keys = Object.keys(obj);
      const length2 = keys.length;
      for (let i = 0; i < length2; i++) {
        res.set(keys[i], obj[keys[i]]);
      }
      return res;
    };
    exports.buildInt32 = (f2, g) => {
      return f2 * SHIFT16 + g;
    };
    exports.buildInt64 = (f1, f2, g1, g2) => {
      const f3 = exports.buildInt32(f1, f2);
      const g = exports.buildInt32(g1, g2);
      if (f3 > MAX_SAFE_HIGH) {
        return new Bignumber(f3).times(SHIFT32).plus(g);
      } else {
        return f3 * SHIFT32 + g;
      }
    };
    exports.writeHalf = function writeHalf(buf, half) {
      const u32 = Buffer2.allocUnsafe(4);
      u32.writeFloatBE(half, 0);
      const u = u32.readUInt32BE(0);
      if ((u & 8191) !== 0) {
        return false;
      }
      let s16 = u >> 16 & 32768;
      const exp = u >> 23 & 255;
      const mant = u & 8388607;
      if (exp >= 113 && exp <= 142) {
        s16 += (exp - 112 << 10) + (mant >> 13);
      } else if (exp >= 103 && exp < 113) {
        if (mant & (1 << 126 - exp) - 1) {
          return false;
        }
        s16 += mant + 8388608 >> 126 - exp;
      } else {
        return false;
      }
      buf.writeUInt16BE(s16, 0);
      return true;
    };
    exports.keySorter = function(a, b) {
      const lenA = a[0].byteLength;
      const lenB = b[0].byteLength;
      if (lenA > lenB) {
        return 1;
      }
      if (lenB > lenA) {
        return -1;
      }
      return a[0].compare(b[0]);
    };
    exports.isNegativeZero = (x) => {
      return x === 0 && 1 / x < 0;
    };
    exports.nextPowerOf2 = (n) => {
      let count = 0;
      if (n && !(n & n - 1)) {
        return n;
      }
      while (n !== 0) {
        n >>= 1;
        count += 1;
      }
      return 1 << count;
    };
  }
});

// node_modules/borc/src/simple.js
var require_simple = __commonJS({
  "node_modules/borc/src/simple.js"(exports, module) {
    "use strict";
    var constants = require_constants4();
    var MT = constants.MT;
    var SIMPLE = constants.SIMPLE;
    var SYMS = constants.SYMS;
    var Simple = class {
      /**
       * Creates an instance of Simple.
       *
       * @param {integer} value - the simple value's integer value
       */
      constructor(value) {
        if (typeof value !== "number") {
          throw new Error("Invalid Simple type: " + typeof value);
        }
        if (value < 0 || value > 255 || (value | 0) !== value) {
          throw new Error("value must be a small positive integer: " + value);
        }
        this.value = value;
      }
      /**
       * Debug string for simple value
       *
       * @returns {string} simple(value)
       */
      toString() {
        return "simple(" + this.value + ")";
      }
      /**
       * Debug string for simple value
       *
       * @returns {string} simple(value)
       */
      inspect() {
        return "simple(" + this.value + ")";
      }
      /**
       * Push the simple value onto the CBOR stream
       *
       * @param {cbor.Encoder} gen - The generator to push onto
       * @returns {number}
       */
      encodeCBOR(gen) {
        return gen._pushInt(this.value, MT.SIMPLE_FLOAT);
      }
      /**
       * Is the given object a Simple?
       *
       * @param {any} obj - object to test
       * @returns {bool} - is it Simple?
       */
      static isSimple(obj) {
        return obj instanceof Simple;
      }
      /**
       * Decode from the CBOR additional information into a JavaScript value.
       * If the CBOR item has no parent, return a "safe" symbol instead of
       * `null` or `undefined`, so that the value can be passed through a
       * stream in object mode.
       *
       * @param {number} val - the CBOR additional info to convert
       * @param {bool} hasParent - Does the CBOR item have a parent?
       * @returns {(null | undefined | boolean | symbol)} - the decoded value
       */
      static decode(val, hasParent) {
        if (hasParent == null) {
          hasParent = true;
        }
        switch (val) {
          case SIMPLE.FALSE:
            return false;
          case SIMPLE.TRUE:
            return true;
          case SIMPLE.NULL:
            if (hasParent) {
              return null;
            } else {
              return SYMS.NULL;
            }
          case SIMPLE.UNDEFINED:
            if (hasParent) {
              return void 0;
            } else {
              return SYMS.UNDEFINED;
            }
          case -1:
            if (!hasParent) {
              throw new Error("Invalid BREAK");
            }
            return SYMS.BREAK;
          default:
            return new Simple(val);
        }
      }
    };
    module.exports = Simple;
  }
});

// node_modules/borc/src/tagged.js
var require_tagged = __commonJS({
  "node_modules/borc/src/tagged.js"(exports, module) {
    "use strict";
    var Tagged = class {
      /**
       * Creates an instance of Tagged.
       *
       * @param {number} tag - the number of the tag
       * @param {any} value - the value inside the tag
       * @param {Error} err - the error that was thrown parsing the tag, or null
       */
      constructor(tag, value, err) {
        this.tag = tag;
        this.value = value;
        this.err = err;
        if (typeof this.tag !== "number") {
          throw new Error("Invalid tag type (" + typeof this.tag + ")");
        }
        if (this.tag < 0 || (this.tag | 0) !== this.tag) {
          throw new Error("Tag must be a positive integer: " + this.tag);
        }
      }
      /**
       * Convert to a String
       *
       * @returns {string} string of the form '1(2)'
       */
      toString() {
        return `${this.tag}(${JSON.stringify(this.value)})`;
      }
      /**
       * Push the simple value onto the CBOR stream
       *
       * @param {cbor.Encoder} gen - The generator to push onto
       * @returns {number}
       */
      encodeCBOR(gen) {
        gen._pushTag(this.tag);
        return gen.pushAny(this.value);
      }
      /**
       * If we have a converter for this type, do the conversion.  Some converters
       * are built-in.  Additional ones can be passed in.  If you want to remove
       * a built-in converter, pass a converter in whose value is 'null' instead
       * of a function.
       *
       * @param {Object} converters - keys in the object are a tag number, the value
       * is a function that takes the decoded CBOR and returns a JavaScript value
       * of the appropriate type.  Throw an exception in the function on errors.
       * @returns {any} - the converted item
       */
      convert(converters) {
        let er, f2;
        f2 = converters != null ? converters[this.tag] : void 0;
        if (typeof f2 !== "function") {
          f2 = Tagged["_tag" + this.tag];
          if (typeof f2 !== "function") {
            return this;
          }
        }
        try {
          return f2.call(Tagged, this.value);
        } catch (error) {
          er = error;
          this.err = er;
          return this;
        }
      }
    };
    module.exports = Tagged;
  }
});

// node_modules/iso-url/src/url-browser.js
var require_url_browser = __commonJS({
  "node_modules/iso-url/src/url-browser.js"(exports, module) {
    "use strict";
    var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    function getDefaultBase() {
      if (isReactNative) {
        return "http://localhost";
      }
      if (!self.location) {
        return "";
      }
      return self.location.protocol + "//" + self.location.host;
    }
    var URL3 = self.URL;
    var defaultBase = getDefaultBase();
    var URLWithLegacySupport = class {
      constructor(url = "", base = defaultBase) {
        this.super = new URL3(url, base);
        this.path = this.pathname + this.search;
        this.auth = this.username && this.password ? this.username + ":" + this.password : null;
        this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
      }
      get hash() {
        return this.super.hash;
      }
      get host() {
        return this.super.host;
      }
      get hostname() {
        return this.super.hostname;
      }
      get href() {
        return this.super.href;
      }
      get origin() {
        return this.super.origin;
      }
      get password() {
        return this.super.password;
      }
      get pathname() {
        return this.super.pathname;
      }
      get port() {
        return this.super.port;
      }
      get protocol() {
        return this.super.protocol;
      }
      get search() {
        return this.super.search;
      }
      get searchParams() {
        return this.super.searchParams;
      }
      get username() {
        return this.super.username;
      }
      set hash(hash) {
        this.super.hash = hash;
      }
      set host(host) {
        this.super.host = host;
      }
      set hostname(hostname) {
        this.super.hostname = hostname;
      }
      set href(href) {
        this.super.href = href;
      }
      set password(password) {
        this.super.password = password;
      }
      set pathname(pathname) {
        this.super.pathname = pathname;
      }
      set port(port) {
        this.super.port = port;
      }
      set protocol(protocol) {
        this.super.protocol = protocol;
      }
      set search(search) {
        this.super.search = search;
      }
      set username(username) {
        this.super.username = username;
      }
      /**
       * @param {any} o
       */
      static createObjectURL(o) {
        return URL3.createObjectURL(o);
      }
      /**
       * @param {string} o
       */
      static revokeObjectURL(o) {
        URL3.revokeObjectURL(o);
      }
      toJSON() {
        return this.super.toJSON();
      }
      toString() {
        return this.super.toString();
      }
      format() {
        return this.toString();
      }
    };
    function format2(obj) {
      if (typeof obj === "string") {
        const url = new URL3(obj);
        return url.toString();
      }
      if (!(obj instanceof URL3)) {
        const userPass = (
          // @ts-ignore its not supported in node but we normalise
          obj.username && obj.password ? `${obj.username}:${obj.password}@` : ""
        );
        const auth = obj.auth ? obj.auth + "@" : "";
        const port = obj.port ? ":" + obj.port : "";
        const protocol = obj.protocol ? obj.protocol + "//" : "";
        const host = obj.host || "";
        const hostname = obj.hostname || "";
        const search = obj.search || (obj.query ? "?" + obj.query : "");
        const hash = obj.hash || "";
        const pathname = obj.pathname || "";
        const path = obj.path || pathname + search;
        return `${protocol}${userPass || auth}${host || hostname + port}${path}${hash}`;
      }
    }
    module.exports = {
      URLWithLegacySupport,
      URLSearchParams: self.URLSearchParams,
      defaultBase,
      format: format2
    };
  }
});

// node_modules/iso-url/src/relative.js
var require_relative = __commonJS({
  "node_modules/iso-url/src/relative.js"(exports, module) {
    "use strict";
    var { URLWithLegacySupport, format: format2 } = require_url_browser();
    module.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {
      let protocol = location.protocol ? location.protocol.replace(":", "") : "http";
      protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
      let urlParsed;
      try {
        urlParsed = new URLWithLegacySupport(url);
      } catch (err) {
        urlParsed = {};
      }
      const base = Object.assign({}, location, {
        protocol: protocol || urlParsed.protocol,
        host: location.host || urlParsed.host
      });
      return new URLWithLegacySupport(url, format2(base)).toString();
    };
  }
});

// node_modules/iso-url/index.js
var require_iso_url = __commonJS({
  "node_modules/iso-url/index.js"(exports, module) {
    "use strict";
    var {
      URLWithLegacySupport,
      format: format2,
      URLSearchParams: URLSearchParams2,
      defaultBase
    } = require_url_browser();
    var relative = require_relative();
    module.exports = {
      URL: URLWithLegacySupport,
      URLSearchParams: URLSearchParams2,
      format: format2,
      relative,
      defaultBase
    };
  }
});

// node_modules/borc/src/decoder.js
var require_decoder = __commonJS({
  "node_modules/borc/src/decoder.js"(exports, module) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var ieee754 = require_ieee754();
    var Bignumber = require_bignumber().BigNumber;
    var parser = require_decoder_asm();
    var utils = require_utils2();
    var c = require_constants4();
    var Simple = require_simple();
    var Tagged = require_tagged();
    var { URL: URL3 } = require_iso_url();
    var Decoder = class {
      /**
       * @param {Object} [opts={}]
       * @param {number} [opts.size=65536] - Size of the allocated heap.
       */
      constructor(opts) {
        opts = opts || {};
        if (!opts.size || opts.size < 65536) {
          opts.size = 65536;
        } else {
          opts.size = utils.nextPowerOf2(opts.size);
        }
        this._heap = new ArrayBuffer(opts.size);
        this._heap8 = new Uint8Array(this._heap);
        this._buffer = Buffer2.from(this._heap);
        this._reset();
        this._knownTags = Object.assign({
          0: (val) => new Date(val),
          1: (val) => new Date(val * 1e3),
          2: (val) => utils.arrayBufferToBignumber(val),
          3: (val) => c.NEG_ONE.minus(utils.arrayBufferToBignumber(val)),
          4: (v) => {
            return c.TEN.pow(v[0]).times(v[1]);
          },
          5: (v) => {
            return c.TWO.pow(v[0]).times(v[1]);
          },
          32: (val) => new URL3(val),
          35: (val) => new RegExp(val)
        }, opts.tags);
        this.parser = parser(global, {
          // eslint-disable-next-line no-console
          log: console.log.bind(console),
          pushInt: this.pushInt.bind(this),
          pushInt32: this.pushInt32.bind(this),
          pushInt32Neg: this.pushInt32Neg.bind(this),
          pushInt64: this.pushInt64.bind(this),
          pushInt64Neg: this.pushInt64Neg.bind(this),
          pushFloat: this.pushFloat.bind(this),
          pushFloatSingle: this.pushFloatSingle.bind(this),
          pushFloatDouble: this.pushFloatDouble.bind(this),
          pushTrue: this.pushTrue.bind(this),
          pushFalse: this.pushFalse.bind(this),
          pushUndefined: this.pushUndefined.bind(this),
          pushNull: this.pushNull.bind(this),
          pushInfinity: this.pushInfinity.bind(this),
          pushInfinityNeg: this.pushInfinityNeg.bind(this),
          pushNaN: this.pushNaN.bind(this),
          pushNaNNeg: this.pushNaNNeg.bind(this),
          pushArrayStart: this.pushArrayStart.bind(this),
          pushArrayStartFixed: this.pushArrayStartFixed.bind(this),
          pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this),
          pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this),
          pushObjectStart: this.pushObjectStart.bind(this),
          pushObjectStartFixed: this.pushObjectStartFixed.bind(this),
          pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this),
          pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this),
          pushByteString: this.pushByteString.bind(this),
          pushByteStringStart: this.pushByteStringStart.bind(this),
          pushUtf8String: this.pushUtf8String.bind(this),
          pushUtf8StringStart: this.pushUtf8StringStart.bind(this),
          pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this),
          pushTagUnassigned: this.pushTagUnassigned.bind(this),
          pushTagStart: this.pushTagStart.bind(this),
          pushTagStart4: this.pushTagStart4.bind(this),
          pushTagStart8: this.pushTagStart8.bind(this),
          pushBreak: this.pushBreak.bind(this)
        }, this._heap);
      }
      get _depth() {
        return this._parents.length;
      }
      get _currentParent() {
        return this._parents[this._depth - 1];
      }
      get _ref() {
        return this._currentParent.ref;
      }
      // Finish the current parent
      _closeParent() {
        const p = this._parents.pop();
        if (p.length > 0) {
          throw new Error(`Missing ${p.length} elements`);
        }
        switch (p.type) {
          case c.PARENT.TAG:
            this._push(
              this.createTag(p.ref[0], p.ref[1])
            );
            break;
          case c.PARENT.BYTE_STRING:
            this._push(this.createByteString(p.ref, p.length));
            break;
          case c.PARENT.UTF8_STRING:
            this._push(this.createUtf8String(p.ref, p.length));
            break;
          case c.PARENT.MAP:
            if (p.values % 2 > 0) {
              throw new Error("Odd number of elements in the map");
            }
            this._push(this.createMap(p.ref, p.length));
            break;
          case c.PARENT.OBJECT:
            if (p.values % 2 > 0) {
              throw new Error("Odd number of elements in the map");
            }
            this._push(this.createObject(p.ref, p.length));
            break;
          case c.PARENT.ARRAY:
            this._push(this.createArray(p.ref, p.length));
            break;
          default:
            break;
        }
        if (this._currentParent && this._currentParent.type === c.PARENT.TAG) {
          this._dec();
        }
      }
      // Reduce the expected length of the current parent by one
      _dec() {
        const p = this._currentParent;
        if (p.length < 0) {
          return;
        }
        p.length--;
        if (p.length === 0) {
          this._closeParent();
        }
      }
      // Push any value to the current parent
      _push(val, hasChildren) {
        const p = this._currentParent;
        p.values++;
        switch (p.type) {
          case c.PARENT.ARRAY:
          case c.PARENT.BYTE_STRING:
          case c.PARENT.UTF8_STRING:
            if (p.length > -1) {
              this._ref[this._ref.length - p.length] = val;
            } else {
              this._ref.push(val);
            }
            this._dec();
            break;
          case c.PARENT.OBJECT:
            if (p.tmpKey != null) {
              this._ref[p.tmpKey] = val;
              p.tmpKey = null;
              this._dec();
            } else {
              p.tmpKey = val;
              if (typeof p.tmpKey !== "string") {
                p.type = c.PARENT.MAP;
                p.ref = utils.buildMap(p.ref);
              }
            }
            break;
          case c.PARENT.MAP:
            if (p.tmpKey != null) {
              this._ref.set(p.tmpKey, val);
              p.tmpKey = null;
              this._dec();
            } else {
              p.tmpKey = val;
            }
            break;
          case c.PARENT.TAG:
            this._ref.push(val);
            if (!hasChildren) {
              this._dec();
            }
            break;
          default:
            throw new Error("Unknown parent type");
        }
      }
      // Create a new parent in the parents list
      _createParent(obj, type, len) {
        this._parents[this._depth] = {
          type,
          length: len,
          ref: obj,
          values: 0,
          tmpKey: null
        };
      }
      // Reset all state back to the beginning, also used for initiatlization
      _reset() {
        this._res = [];
        this._parents = [{
          type: c.PARENT.ARRAY,
          length: -1,
          ref: this._res,
          values: 0,
          tmpKey: null
        }];
      }
      // -- Interface to customize deoding behaviour
      createTag(tagNumber, value) {
        const typ = this._knownTags[tagNumber];
        if (!typ) {
          return new Tagged(tagNumber, value);
        }
        return typ(value);
      }
      createMap(obj, len) {
        return obj;
      }
      createObject(obj, len) {
        return obj;
      }
      createArray(arr, len) {
        return arr;
      }
      createByteString(raw, len) {
        return Buffer2.concat(raw);
      }
      createByteStringFromHeap(start, end) {
        if (start === end) {
          return Buffer2.alloc(0);
        }
        return Buffer2.from(this._heap.slice(start, end));
      }
      createInt(val) {
        return val;
      }
      createInt32(f2, g) {
        return utils.buildInt32(f2, g);
      }
      createInt64(f1, f2, g1, g2) {
        return utils.buildInt64(f1, f2, g1, g2);
      }
      createFloat(val) {
        return val;
      }
      createFloatSingle(a, b, c2, d) {
        return ieee754.read([a, b, c2, d], 0, false, 23, 4);
      }
      createFloatDouble(a, b, c2, d, e, f2, g, h) {
        return ieee754.read([a, b, c2, d, e, f2, g, h], 0, false, 52, 8);
      }
      createInt32Neg(f2, g) {
        return -1 - utils.buildInt32(f2, g);
      }
      createInt64Neg(f1, f2, g1, g2) {
        const f3 = utils.buildInt32(f1, f2);
        const g = utils.buildInt32(g1, g2);
        if (f3 > c.MAX_SAFE_HIGH) {
          return c.NEG_ONE.minus(new Bignumber(f3).times(c.SHIFT32).plus(g));
        }
        return -1 - (f3 * c.SHIFT32 + g);
      }
      createTrue() {
        return true;
      }
      createFalse() {
        return false;
      }
      createNull() {
        return null;
      }
      createUndefined() {
        return void 0;
      }
      createInfinity() {
        return Infinity;
      }
      createInfinityNeg() {
        return -Infinity;
      }
      createNaN() {
        return NaN;
      }
      createNaNNeg() {
        return NaN;
      }
      createUtf8String(raw, len) {
        return raw.join("");
      }
      createUtf8StringFromHeap(start, end) {
        if (start === end) {
          return "";
        }
        return this._buffer.toString("utf8", start, end);
      }
      createSimpleUnassigned(val) {
        return new Simple(val);
      }
      // -- Interface for decoder.asm.js
      pushInt(val) {
        this._push(this.createInt(val));
      }
      pushInt32(f2, g) {
        this._push(this.createInt32(f2, g));
      }
      pushInt64(f1, f2, g1, g2) {
        this._push(this.createInt64(f1, f2, g1, g2));
      }
      pushFloat(val) {
        this._push(this.createFloat(val));
      }
      pushFloatSingle(a, b, c2, d) {
        this._push(this.createFloatSingle(a, b, c2, d));
      }
      pushFloatDouble(a, b, c2, d, e, f2, g, h) {
        this._push(this.createFloatDouble(a, b, c2, d, e, f2, g, h));
      }
      pushInt32Neg(f2, g) {
        this._push(this.createInt32Neg(f2, g));
      }
      pushInt64Neg(f1, f2, g1, g2) {
        this._push(this.createInt64Neg(f1, f2, g1, g2));
      }
      pushTrue() {
        this._push(this.createTrue());
      }
      pushFalse() {
        this._push(this.createFalse());
      }
      pushNull() {
        this._push(this.createNull());
      }
      pushUndefined() {
        this._push(this.createUndefined());
      }
      pushInfinity() {
        this._push(this.createInfinity());
      }
      pushInfinityNeg() {
        this._push(this.createInfinityNeg());
      }
      pushNaN() {
        this._push(this.createNaN());
      }
      pushNaNNeg() {
        this._push(this.createNaNNeg());
      }
      pushArrayStart() {
        this._createParent([], c.PARENT.ARRAY, -1);
      }
      pushArrayStartFixed(len) {
        this._createArrayStartFixed(len);
      }
      pushArrayStartFixed32(len1, len2) {
        const len = utils.buildInt32(len1, len2);
        this._createArrayStartFixed(len);
      }
      pushArrayStartFixed64(len1, len2, len3, len4) {
        const len = utils.buildInt64(len1, len2, len3, len4);
        this._createArrayStartFixed(len);
      }
      pushObjectStart() {
        this._createObjectStartFixed(-1);
      }
      pushObjectStartFixed(len) {
        this._createObjectStartFixed(len);
      }
      pushObjectStartFixed32(len1, len2) {
        const len = utils.buildInt32(len1, len2);
        this._createObjectStartFixed(len);
      }
      pushObjectStartFixed64(len1, len2, len3, len4) {
        const len = utils.buildInt64(len1, len2, len3, len4);
        this._createObjectStartFixed(len);
      }
      pushByteStringStart() {
        this._parents[this._depth] = {
          type: c.PARENT.BYTE_STRING,
          length: -1,
          ref: [],
          values: 0,
          tmpKey: null
        };
      }
      pushByteString(start, end) {
        this._push(this.createByteStringFromHeap(start, end));
      }
      pushUtf8StringStart() {
        this._parents[this._depth] = {
          type: c.PARENT.UTF8_STRING,
          length: -1,
          ref: [],
          values: 0,
          tmpKey: null
        };
      }
      pushUtf8String(start, end) {
        this._push(this.createUtf8StringFromHeap(start, end));
      }
      pushSimpleUnassigned(val) {
        this._push(this.createSimpleUnassigned(val));
      }
      pushTagStart(tag) {
        this._parents[this._depth] = {
          type: c.PARENT.TAG,
          length: 1,
          ref: [tag]
        };
      }
      pushTagStart4(f2, g) {
        this.pushTagStart(utils.buildInt32(f2, g));
      }
      pushTagStart8(f1, f2, g1, g2) {
        this.pushTagStart(utils.buildInt64(f1, f2, g1, g2));
      }
      pushTagUnassigned(tagNumber) {
        this._push(this.createTag(tagNumber));
      }
      pushBreak() {
        if (this._currentParent.length > -1) {
          throw new Error("Unexpected break");
        }
        this._closeParent();
      }
      _createObjectStartFixed(len) {
        if (len === 0) {
          this._push(this.createObject({}));
          return;
        }
        this._createParent({}, c.PARENT.OBJECT, len);
      }
      _createArrayStartFixed(len) {
        if (len === 0) {
          this._push(this.createArray([]));
          return;
        }
        this._createParent(new Array(len), c.PARENT.ARRAY, len);
      }
      _decode(input) {
        if (input.byteLength === 0) {
          throw new Error("Input too short");
        }
        this._reset();
        this._heap8.set(input);
        const code = this.parser.parse(input.byteLength);
        if (this._depth > 1) {
          while (this._currentParent.length === 0) {
            this._closeParent();
          }
          if (this._depth > 1) {
            throw new Error("Undeterminated nesting");
          }
        }
        if (code > 0) {
          throw new Error("Failed to parse");
        }
        if (this._res.length === 0) {
          throw new Error("No valid result");
        }
      }
      // -- Public Interface
      decodeFirst(input) {
        this._decode(input);
        return this._res[0];
      }
      decodeAll(input) {
        this._decode(input);
        return this._res;
      }
      /**
       * Decode the first cbor object.
       *
       * @param {Buffer|string} input
       * @param {string} [enc='hex'] - Encoding used if a string is passed.
       * @returns {*}
       */
      static decode(input, enc) {
        if (typeof input === "string") {
          input = Buffer2.from(input, enc || "hex");
        }
        const dec = new Decoder({ size: input.length });
        return dec.decodeFirst(input);
      }
      /**
       * Decode all cbor objects.
       *
       * @param {Buffer|string} input
       * @param {string} [enc='hex'] - Encoding used if a string is passed.
       * @returns {Array<*>}
       */
      static decodeAll(input, enc) {
        if (typeof input === "string") {
          input = Buffer2.from(input, enc || "hex");
        }
        const dec = new Decoder({ size: input.length });
        return dec.decodeAll(input);
      }
    };
    Decoder.decodeFirst = Decoder.decode;
    module.exports = Decoder;
  }
});

// node_modules/borc/src/diagnose.js
var require_diagnose = __commonJS({
  "node_modules/borc/src/diagnose.js"(exports, module) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var Decoder = require_decoder();
    var utils = require_utils2();
    var Diagnose = class extends Decoder {
      createTag(tagNumber, value) {
        return `${tagNumber}(${value})`;
      }
      createInt(val) {
        return super.createInt(val).toString();
      }
      createInt32(f2, g) {
        return super.createInt32(f2, g).toString();
      }
      createInt64(f1, f2, g1, g2) {
        return super.createInt64(f1, f2, g1, g2).toString();
      }
      createInt32Neg(f2, g) {
        return super.createInt32Neg(f2, g).toString();
      }
      createInt64Neg(f1, f2, g1, g2) {
        return super.createInt64Neg(f1, f2, g1, g2).toString();
      }
      createTrue() {
        return "true";
      }
      createFalse() {
        return "false";
      }
      createFloat(val) {
        const fl = super.createFloat(val);
        if (utils.isNegativeZero(val)) {
          return "-0_1";
        }
        return `${fl}_1`;
      }
      createFloatSingle(a, b, c, d) {
        const fl = super.createFloatSingle(a, b, c, d);
        return `${fl}_2`;
      }
      createFloatDouble(a, b, c, d, e, f2, g, h) {
        const fl = super.createFloatDouble(a, b, c, d, e, f2, g, h);
        return `${fl}_3`;
      }
      createByteString(raw, len) {
        const val = raw.join(", ");
        if (len === -1) {
          return `(_ ${val})`;
        }
        return `h'${val}`;
      }
      createByteStringFromHeap(start, end) {
        const val = Buffer2.from(
          super.createByteStringFromHeap(start, end)
        ).toString("hex");
        return `h'${val}'`;
      }
      createInfinity() {
        return "Infinity_1";
      }
      createInfinityNeg() {
        return "-Infinity_1";
      }
      createNaN() {
        return "NaN_1";
      }
      createNaNNeg() {
        return "-NaN_1";
      }
      createNull() {
        return "null";
      }
      createUndefined() {
        return "undefined";
      }
      createSimpleUnassigned(val) {
        return `simple(${val})`;
      }
      createArray(arr, len) {
        const val = super.createArray(arr, len);
        if (len === -1) {
          return `[_ ${val.join(", ")}]`;
        }
        return `[${val.join(", ")}]`;
      }
      createMap(map, len) {
        const val = super.createMap(map);
        const list = Array.from(val.keys()).reduce(collectObject(val), "");
        if (len === -1) {
          return `{_ ${list}}`;
        }
        return `{${list}}`;
      }
      createObject(obj, len) {
        const val = super.createObject(obj);
        const map = Object.keys(val).reduce(collectObject(val), "");
        if (len === -1) {
          return `{_ ${map}}`;
        }
        return `{${map}}`;
      }
      createUtf8String(raw, len) {
        const val = raw.join(", ");
        if (len === -1) {
          return `(_ ${val})`;
        }
        return `"${val}"`;
      }
      createUtf8StringFromHeap(start, end) {
        const val = Buffer2.from(
          super.createUtf8StringFromHeap(start, end)
        ).toString("utf8");
        return `"${val}"`;
      }
      static diagnose(input, enc) {
        if (typeof input === "string") {
          input = Buffer2.from(input, enc || "hex");
        }
        const dec = new Diagnose();
        return dec.decodeFirst(input);
      }
    };
    module.exports = Diagnose;
    function collectObject(val) {
      return (acc, key) => {
        if (acc) {
          return `${acc}, ${key}: ${val[key]}`;
        }
        return `${key}: ${val[key]}`;
      };
    }
  }
});

// node_modules/borc/src/encoder.js
var require_encoder = __commonJS({
  "node_modules/borc/src/encoder.js"(exports, module) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var { URL: URL3 } = require_iso_url();
    var Bignumber = require_bignumber().BigNumber;
    var utils = require_utils2();
    var constants = require_constants4();
    var MT = constants.MT;
    var NUMBYTES = constants.NUMBYTES;
    var SHIFT32 = constants.SHIFT32;
    var SYMS = constants.SYMS;
    var TAG = constants.TAG;
    var HALF = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.TWO;
    var FLOAT = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.FOUR;
    var DOUBLE = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.EIGHT;
    var TRUE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.TRUE;
    var FALSE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.FALSE;
    var UNDEFINED = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.UNDEFINED;
    var NULL = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.NULL;
    var MAXINT_BN = new Bignumber("0x20000000000000");
    var BUF_NAN = Buffer2.from("f97e00", "hex");
    var BUF_INF_NEG = Buffer2.from("f9fc00", "hex");
    var BUF_INF_POS = Buffer2.from("f97c00", "hex");
    function toType(obj) {
      return {}.toString.call(obj).slice(8, -1);
    }
    var Encoder = class {
      /**
       * @param {Object} [options={}]
       * @param {function(Buffer)} options.stream
       */
      constructor(options) {
        options = options || {};
        this.streaming = typeof options.stream === "function";
        this.onData = options.stream;
        this.semanticTypes = [
          [URL3, this._pushUrl],
          [Bignumber, this._pushBigNumber]
        ];
        const addTypes = options.genTypes || [];
        const len = addTypes.length;
        for (let i = 0; i < len; i++) {
          this.addSemanticType(
            addTypes[i][0],
            addTypes[i][1]
          );
        }
        this._reset();
      }
      addSemanticType(type, fun) {
        const len = this.semanticTypes.length;
        for (let i = 0; i < len; i++) {
          const typ = this.semanticTypes[i][0];
          if (typ === type) {
            const old = this.semanticTypes[i][1];
            this.semanticTypes[i][1] = fun;
            return old;
          }
        }
        this.semanticTypes.push([type, fun]);
        return null;
      }
      push(val) {
        if (!val) {
          return true;
        }
        this.result[this.offset] = val;
        this.resultMethod[this.offset] = 0;
        this.resultLength[this.offset] = val.length;
        this.offset++;
        if (this.streaming) {
          this.onData(this.finalize());
        }
        return true;
      }
      pushWrite(val, method, len) {
        this.result[this.offset] = val;
        this.resultMethod[this.offset] = method;
        this.resultLength[this.offset] = len;
        this.offset++;
        if (this.streaming) {
          this.onData(this.finalize());
        }
        return true;
      }
      _pushUInt8(val) {
        return this.pushWrite(val, 1, 1);
      }
      _pushUInt16BE(val) {
        return this.pushWrite(val, 2, 2);
      }
      _pushUInt32BE(val) {
        return this.pushWrite(val, 3, 4);
      }
      _pushDoubleBE(val) {
        return this.pushWrite(val, 4, 8);
      }
      _pushNaN() {
        return this.push(BUF_NAN);
      }
      _pushInfinity(obj) {
        const half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;
        return this.push(half);
      }
      _pushFloat(obj) {
        const b2 = Buffer2.allocUnsafe(2);
        if (utils.writeHalf(b2, obj)) {
          if (utils.parseHalf(b2) === obj) {
            return this._pushUInt8(HALF) && this.push(b2);
          }
        }
        const b4 = Buffer2.allocUnsafe(4);
        b4.writeFloatBE(obj, 0);
        if (b4.readFloatBE(0) === obj) {
          return this._pushUInt8(FLOAT) && this.push(b4);
        }
        return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);
      }
      _pushInt(obj, mt, orig) {
        const m = mt << 5;
        if (obj < 24) {
          return this._pushUInt8(m | obj);
        }
        if (obj <= 255) {
          return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);
        }
        if (obj <= 65535) {
          return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);
        }
        if (obj <= 4294967295) {
          return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);
        }
        if (obj <= Number.MAX_SAFE_INTEGER) {
          return this._pushUInt8(m | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);
        }
        if (mt === MT.NEG_INT) {
          return this._pushFloat(orig);
        }
        return this._pushFloat(obj);
      }
      _pushIntNum(obj) {
        if (obj < 0) {
          return this._pushInt(-obj - 1, MT.NEG_INT, obj);
        } else {
          return this._pushInt(obj, MT.POS_INT);
        }
      }
      _pushNumber(obj) {
        switch (false) {
          case obj === obj:
            return this._pushNaN(obj);
          case isFinite(obj):
            return this._pushInfinity(obj);
          case obj % 1 !== 0:
            return this._pushIntNum(obj);
          default:
            return this._pushFloat(obj);
        }
      }
      _pushString(obj) {
        const len = Buffer2.byteLength(obj, "utf8");
        return this._pushInt(len, MT.UTF8_STRING) && this.pushWrite(obj, 5, len);
      }
      _pushBoolean(obj) {
        return this._pushUInt8(obj ? TRUE : FALSE);
      }
      _pushUndefined(obj) {
        return this._pushUInt8(UNDEFINED);
      }
      _pushArray(gen, obj) {
        const len = obj.length;
        if (!gen._pushInt(len, MT.ARRAY)) {
          return false;
        }
        for (let j = 0; j < len; j++) {
          if (!gen.pushAny(obj[j])) {
            return false;
          }
        }
        return true;
      }
      _pushTag(tag) {
        return this._pushInt(tag, MT.TAG);
      }
      _pushDate(gen, obj) {
        return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(Math.round(obj / 1e3));
      }
      _pushBuffer(gen, obj) {
        return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);
      }
      _pushNoFilter(gen, obj) {
        return gen._pushBuffer(gen, obj.slice());
      }
      _pushRegexp(gen, obj) {
        return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);
      }
      _pushSet(gen, obj) {
        if (!gen._pushInt(obj.size, MT.ARRAY)) {
          return false;
        }
        for (const x of obj) {
          if (!gen.pushAny(x)) {
            return false;
          }
        }
        return true;
      }
      _pushUrl(gen, obj) {
        return gen._pushTag(TAG.URI) && gen.pushAny(obj.format());
      }
      _pushBigint(obj) {
        let tag = TAG.POS_BIGINT;
        if (obj.isNegative()) {
          obj = obj.negated().minus(1);
          tag = TAG.NEG_BIGINT;
        }
        let str = obj.toString(16);
        if (str.length % 2) {
          str = "0" + str;
        }
        const buf = Buffer2.from(str, "hex");
        return this._pushTag(tag) && this._pushBuffer(this, buf);
      }
      _pushBigNumber(gen, obj) {
        if (obj.isNaN()) {
          return gen._pushNaN();
        }
        if (!obj.isFinite()) {
          return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity);
        }
        if (obj.isInteger()) {
          return gen._pushBigint(obj);
        }
        if (!(gen._pushTag(TAG.DECIMAL_FRAC) && gen._pushInt(2, MT.ARRAY))) {
          return false;
        }
        const dec = obj.decimalPlaces();
        const slide = obj.multipliedBy(new Bignumber(10).pow(dec));
        if (!gen._pushIntNum(-dec)) {
          return false;
        }
        if (slide.abs().isLessThan(MAXINT_BN)) {
          return gen._pushIntNum(slide.toNumber());
        } else {
          return gen._pushBigint(slide);
        }
      }
      _pushMap(gen, obj) {
        if (!gen._pushInt(obj.size, MT.MAP)) {
          return false;
        }
        return this._pushRawMap(
          obj.size,
          Array.from(obj)
        );
      }
      _pushObject(obj) {
        if (!obj) {
          return this._pushUInt8(NULL);
        }
        const len = this.semanticTypes.length;
        for (let i = 0; i < len; i++) {
          if (obj instanceof this.semanticTypes[i][0]) {
            return this.semanticTypes[i][1].call(obj, this, obj);
          }
        }
        const f2 = obj.encodeCBOR;
        if (typeof f2 === "function") {
          return f2.call(obj, this);
        }
        const keys = Object.keys(obj);
        const keyLength = keys.length;
        if (!this._pushInt(keyLength, MT.MAP)) {
          return false;
        }
        return this._pushRawMap(
          keyLength,
          keys.map((k) => [k, obj[k]])
        );
      }
      _pushRawMap(len, map) {
        map = map.map(function(a) {
          a[0] = Encoder.encode(a[0]);
          return a;
        }).sort(utils.keySorter);
        for (let j = 0; j < len; j++) {
          if (!this.push(map[j][0])) {
            return false;
          }
          if (!this.pushAny(map[j][1])) {
            return false;
          }
        }
        return true;
      }
      /**
       * Alias for `.pushAny`
       *
       * @param {*} obj
       * @returns {boolean} true on success
       */
      write(obj) {
        return this.pushAny(obj);
      }
      /**
       * Push any supported type onto the encoded stream
       *
       * @param {any} obj
       * @returns {boolean} true on success
       */
      pushAny(obj) {
        const typ = toType(obj);
        switch (typ) {
          case "Number":
            return this._pushNumber(obj);
          case "String":
            return this._pushString(obj);
          case "Boolean":
            return this._pushBoolean(obj);
          case "Object":
            return this._pushObject(obj);
          case "Array":
            return this._pushArray(this, obj);
          case "Uint8Array":
            return this._pushBuffer(this, Buffer2.isBuffer(obj) ? obj : Buffer2.from(obj));
          case "Null":
            return this._pushUInt8(NULL);
          case "Undefined":
            return this._pushUndefined(obj);
          case "Map":
            return this._pushMap(this, obj);
          case "Set":
            return this._pushSet(this, obj);
          case "URL":
            return this._pushUrl(this, obj);
          case "BigNumber":
            return this._pushBigNumber(this, obj);
          case "Date":
            return this._pushDate(this, obj);
          case "RegExp":
            return this._pushRegexp(this, obj);
          case "Symbol":
            switch (obj) {
              case SYMS.NULL:
                return this._pushObject(null);
              case SYMS.UNDEFINED:
                return this._pushUndefined(void 0);
              default:
                throw new Error("Unknown symbol: " + obj.toString());
            }
          default:
            throw new Error("Unknown type: " + typeof obj + ", " + (obj ? obj.toString() : ""));
        }
      }
      finalize() {
        if (this.offset === 0) {
          return null;
        }
        const result2 = this.result;
        const resultLength = this.resultLength;
        const resultMethod = this.resultMethod;
        const offset = this.offset;
        let size = 0;
        let i = 0;
        for (; i < offset; i++) {
          size += resultLength[i];
        }
        const res = Buffer2.allocUnsafe(size);
        let index = 0;
        let length2 = 0;
        for (i = 0; i < offset; i++) {
          length2 = resultLength[i];
          switch (resultMethod[i]) {
            case 0:
              result2[i].copy(res, index);
              break;
            case 1:
              res.writeUInt8(result2[i], index, true);
              break;
            case 2:
              res.writeUInt16BE(result2[i], index, true);
              break;
            case 3:
              res.writeUInt32BE(result2[i], index, true);
              break;
            case 4:
              res.writeDoubleBE(result2[i], index, true);
              break;
            case 5:
              res.write(result2[i], index, length2, "utf8");
              break;
            default:
              throw new Error("unkown method");
          }
          index += length2;
        }
        const tmp = res;
        this._reset();
        return tmp;
      }
      _reset() {
        this.result = [];
        this.resultMethod = [];
        this.resultLength = [];
        this.offset = 0;
      }
      /**
       * Encode the given value
       *
       * @param {*} o
       * @returns {Buffer}
       */
      static encode(o) {
        const enc = new Encoder();
        const ret = enc.pushAny(o);
        if (!ret) {
          throw new Error("Failed to encode input");
        }
        return enc.finalize();
      }
    };
    module.exports = Encoder;
  }
});

// node_modules/borc/src/index.js
var require_src2 = __commonJS({
  "node_modules/borc/src/index.js"(exports) {
    "use strict";
    exports.Diagnose = require_diagnose();
    exports.Decoder = require_decoder();
    exports.Encoder = require_encoder();
    exports.Simple = require_simple();
    exports.Tagged = require_tagged();
    exports.decodeAll = exports.Decoder.decodeAll;
    exports.decodeFirst = exports.Decoder.decodeFirst;
    exports.diagnose = exports.Diagnose.diagnose;
    exports.encode = exports.Encoder.encode;
    exports.decode = exports.Decoder.decode;
    exports.leveldb = {
      decode: exports.Decoder.decodeAll,
      encode: exports.Encoder.encode,
      buffer: true,
      name: "cbor"
    };
  }
});

// node_modules/@aries-framework/core/build/utils/HashlinkEncoder.js
var require_HashlinkEncoder = __commonJS({
  "node_modules/@aries-framework/core/build/utils/HashlinkEncoder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashlinkEncoder = void 0;
    var borc_1 = __importDefault(require_src2());
    var MultiBaseEncoder_1 = require_MultiBaseEncoder();
    var MultiHashEncoder_1 = require_MultiHashEncoder();
    var hexTable = {
      urls: 15,
      contentType: 14
    };
    var HashlinkEncoder = class {
      /**
       * Encodes a buffer, with optional metadata, into a hashlink
       *
       * @param buffer the buffer to encode into a hashlink
       * @param hashAlgorithm the name of the hashing algorithm 'sha2-256'
       * @param baseEncoding the name of the base encoding algorithm 'base58btc'
       * @param metadata the optional metadata in the hashlink
       *
       * @returns hashlink hashlink with optional metadata
       */
      static encode(buffer, hashAlgorithm, baseEncoding = "base58btc", metadata) {
        const checksum = this.encodeMultiHash(buffer, hashAlgorithm, baseEncoding);
        const mbMetadata = metadata && Object.keys(metadata).length > 0 ? this.encodeMetadata(metadata, baseEncoding) : null;
        return mbMetadata ? `hl:${checksum}:${mbMetadata}` : `hl:${checksum}`;
      }
      /**
       * Decodes a hashlink into HashlinkData object
       *
       * @param hashlink the hashlink that needs decoding
       *
       * @returns object the decoded hashlink
       */
      static decode(hashlink) {
        if (this.isValid(hashlink)) {
          const hashlinkList = hashlink.split(":");
          const [, checksum, encodedMetadata] = hashlinkList;
          return encodedMetadata ? { checksum, metadata: this.decodeMetadata(encodedMetadata) } : { checksum };
        } else {
          throw new Error(`Invalid hashlink: ${hashlink}`);
        }
      }
      /**
       * Validates a hashlink
       *
       * @param hashlink the hashlink that needs validating
       *
       * @returns a boolean whether the hashlink is valid
       *
       * */
      static isValid(hashlink) {
        const hashlinkList = hashlink.split(":");
        const validMultiBase = MultiBaseEncoder_1.MultiBaseEncoder.isValid(hashlinkList[1]);
        if (!validMultiBase) {
          return false;
        }
        const { data } = MultiBaseEncoder_1.MultiBaseEncoder.decode(hashlinkList[1]);
        const validMultiHash = MultiHashEncoder_1.MultiHashEncoder.isValid(data);
        return validMultiHash ? true : false;
      }
      static encodeMultiHash(data, hashName, baseEncoding = "base58btc") {
        const mh = MultiHashEncoder_1.MultiHashEncoder.encode(data, hashName);
        const mb = MultiBaseEncoder_1.MultiBaseEncoder.encode(mh, baseEncoding);
        return mb;
      }
      static encodeMetadata(metadata, baseEncoding) {
        const metadataMap = /* @__PURE__ */ new Map();
        for (const key of Object.keys(metadata)) {
          if (key === "urls" || key === "contentType") {
            metadataMap.set(hexTable[key], metadata[key]);
          } else {
            throw new Error(`Invalid metadata: ${metadata}`);
          }
        }
        const cborData = borc_1.default.encode(metadataMap);
        const multibaseMetadata = MultiBaseEncoder_1.MultiBaseEncoder.encode(cborData, baseEncoding);
        return multibaseMetadata;
      }
      static decodeMetadata(mb) {
        const obj = { urls: [], contentType: "" };
        const { data } = MultiBaseEncoder_1.MultiBaseEncoder.decode(mb);
        try {
          const cborData = borc_1.default.decode(data);
          cborData.forEach((value, key) => {
            if (key === hexTable.urls) {
              obj.urls = value;
            } else if (key === hexTable.contentType) {
              obj.contentType = value;
            } else {
              throw new Error(`Invalid metadata property: ${key}:${value}`);
            }
          });
          return obj;
        } catch (error) {
          throw new Error(`Invalid metadata: ${mb}, ${error}`);
        }
      }
    };
    exports.HashlinkEncoder = HashlinkEncoder;
  }
});

// node_modules/@aries-framework/core/build/utils/attachment.js
var require_attachment = __commonJS({
  "node_modules/@aries-framework/core/build/utils/attachment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isLinkedAttachment = exports.encodeAttachment = void 0;
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var HashlinkEncoder_1 = require_HashlinkEncoder();
    var TypedArrayEncoder_1 = require_TypedArrayEncoder();
    function encodeAttachment(attachment, hashAlgorithm = "sha2-256", baseName = "base58btc") {
      if (attachment.data.sha256) {
        return `hl:${attachment.data.sha256}`;
      } else if (attachment.data.base64) {
        return HashlinkEncoder_1.HashlinkEncoder.encode(TypedArrayEncoder_1.TypedArrayEncoder.fromBase64(attachment.data.base64), hashAlgorithm, baseName);
      } else if (attachment.data.json) {
        throw new AriesFrameworkError_1.AriesFrameworkError(`Attachment: (${attachment.id}) has json encoded data. This is currently not supported`);
      } else {
        throw new AriesFrameworkError_1.AriesFrameworkError(`Attachment: (${attachment.id}) has no data to create a link with`);
      }
    }
    exports.encodeAttachment = encodeAttachment;
    function isLinkedAttachment(attachment) {
      return HashlinkEncoder_1.HashlinkEncoder.isValid(`hl:${attachment.id}`);
    }
    exports.isLinkedAttachment = isLinkedAttachment;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/formats/indy/IndyCredentialUtils.js
var require_IndyCredentialUtils = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/formats/indy/IndyCredentialUtils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyCredentialUtils = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var utils_1 = require_utils();
    var attachment_1 = require_attachment();
    var buffer_1 = require_buffer2();
    var type_1 = require_type();
    var CredentialPreviewAttribute_1 = require_CredentialPreviewAttribute();
    var IndyCredentialUtils = class {
      /**
       * Adds attribute(s) to the credential preview that is linked to the given attachment(s)
       *
       * @param attachments a list of the attachments that need to be linked to a credential
       * @param preview the credential previews where the new linked credential has to be appended to
       *
       * @returns a modified version of the credential preview with the linked credentials
       * */
      static createAndLinkAttachmentsToPreview(attachments, previewAttributes) {
        const credentialPreviewAttributeNames = previewAttributes.map((attribute) => attribute.name);
        const newPreviewAttributes = [...previewAttributes];
        attachments.forEach((linkedAttachment) => {
          if (credentialPreviewAttributeNames.includes(linkedAttachment.attributeName)) {
            throw new AriesFrameworkError_1.AriesFrameworkError(`linkedAttachment ${linkedAttachment.attributeName} already exists in the preview`);
          } else {
            const credentialPreviewAttribute = new CredentialPreviewAttribute_1.CredentialPreviewAttribute({
              name: linkedAttachment.attributeName,
              mimeType: linkedAttachment.attachment.mimeType,
              value: (0, attachment_1.encodeAttachment)(linkedAttachment.attachment)
            });
            newPreviewAttributes.push(credentialPreviewAttribute);
          }
        });
        return newPreviewAttributes;
      }
      /**
       * Converts int value to string
       * Converts string value:
       * - hash with sha256,
       * - convert to byte array and reverse it
       * - convert it to BigInteger and return as a string
       * @param attributes
       *
       * @returns CredValues
       */
      static convertAttributesToValues(attributes) {
        return attributes.reduce((credentialValues, attribute) => {
          return Object.assign({ [attribute.name]: {
            raw: attribute.value,
            encoded: IndyCredentialUtils.encode(attribute.value)
          } }, credentialValues);
        }, {});
      }
      /**
       * Check whether the values of two credentials match (using {@link assertValuesMatch})
       *
       * @returns a boolean whether the values are equal
       *
       */
      static checkValuesMatch(firstValues, secondValues) {
        try {
          this.assertValuesMatch(firstValues, secondValues);
          return true;
        } catch (_a) {
          return false;
        }
      }
      /**
       * Assert two credential values objects match.
       *
       * @param firstValues The first values object
       * @param secondValues The second values object
       *
       * @throws If not all values match
       */
      static assertValuesMatch(firstValues, secondValues) {
        const firstValuesKeys = Object.keys(firstValues);
        const secondValuesKeys = Object.keys(secondValues);
        if (firstValuesKeys.length !== secondValuesKeys.length) {
          throw new Error(`Number of values in first entry (${firstValuesKeys.length}) does not match number of values in second entry (${secondValuesKeys.length})`);
        }
        for (const key of firstValuesKeys) {
          const firstValue = firstValues[key];
          const secondValue = secondValues[key];
          if (!secondValue) {
            throw new Error(`Second cred values object has no value for key '${key}'`);
          }
          if (firstValue.encoded !== secondValue.encoded) {
            throw new Error(`Encoded credential values for key '${key}' do not match`);
          }
          if (firstValue.raw !== secondValue.raw) {
            throw new Error(`Raw credential values for key '${key}' do not match`);
          }
        }
      }
      /**
       * Check whether the raw value matches the encoded version according to the encoding format described in Aries RFC 0037
       * Use this method to ensure the received proof (over the encoded) value is the same as the raw value of the data.
       *
       * @param raw
       * @param encoded
       * @returns Whether raw and encoded value match
       *
       * @see https://github.com/hyperledger/aries-framework-dotnet/blob/a18bef91e5b9e4a1892818df7408e2383c642dfa/src/Hyperledger.Aries/Utils/CredentialUtils.cs#L78-L89
       * @see https://github.com/hyperledger/aries-rfcs/blob/be4ad0a6fb2823bb1fc109364c96f077d5d8dffa/features/0037-present-proof/README.md#verifying-claims-of-indy-based-verifiable-credentials
       */
      static checkValidEncoding(raw, encoded) {
        return encoded === IndyCredentialUtils.encode(raw);
      }
      /**
       * Encode value according to the encoding format described in Aries RFC 0036/0037
       *
       * @param value
       * @returns Encoded version of value
       *
       * @see https://github.com/hyperledger/aries-cloudagent-python/blob/0000f924a50b6ac5e6342bff90e64864672ee935/aries_cloudagent/messaging/util.py#L106-L136
       * @see https://github.com/hyperledger/aries-rfcs/blob/be4ad0a6fb2823bb1fc109364c96f077d5d8dffa/features/0037-present-proof/README.md#verifying-claims-of-indy-based-verifiable-credentials
       * @see https://github.com/hyperledger/aries-rfcs/blob/be4ad0a6fb2823bb1fc109364c96f077d5d8dffa/features/0036-issue-credential/README.md#encoding-claims-for-indy-based-verifiable-credentials
       */
      static encode(value) {
        const isEmpty2 = (value2) => (0, type_1.isString)(value2) && value2 === "";
        if ((0, type_1.isBoolean)(value)) {
          return Number(value).toString();
        }
        if ((0, type_1.isNumber)(value) && this.isInt32(value)) {
          return value.toString();
        }
        if ((0, type_1.isString)(value) && !isEmpty2(value) && !isNaN(Number(value)) && this.isNumeric(value) && this.isInt32(Number(value))) {
          return Number(value).toString();
        }
        if ((0, type_1.isNumber)(value)) {
          value = value.toString();
        }
        if (value === null || value === void 0) {
          value = "None";
        }
        return new bn_js_1.default(utils_1.Hasher.hash(buffer_1.Buffer.from(value), "sha2-256")).toString();
      }
      static checkAttributesMatch(schema, attributes) {
        const schemaAttributes = schema.attrNames;
        const credAttributes = attributes.map((a) => a.name);
        const difference = credAttributes.filter((x) => !schemaAttributes.includes(x)).concat(schemaAttributes.filter((x) => !credAttributes.includes(x)));
        if (difference.length > 0) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`The credential preview attributes do not match the schema attributes (difference is: ${difference}, needs: ${schemaAttributes})`);
        }
      }
      static isInt32(number) {
        const minI32 = -2147483648;
        const maxI32 = 2147483647;
        return Number.isInteger(number) && number >= minI32 && number <= maxI32;
      }
      static isNumeric(value) {
        return /^-?\d+$/.test(value);
      }
    };
    exports.IndyCredentialUtils = IndyCredentialUtils;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/formats/indy/IndyCredentialFormatService.js
var require_IndyCredentialFormatService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/formats/indy/IndyCredentialFormatService.js"(exports) {
    "use strict";
    var __rest2 = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyCredentialFormatService = void 0;
    var crypto_1 = require_crypto();
    var Attachment_1 = require_Attachment();
    var error_1 = require_error();
    var JsonEncoder_1 = require_JsonEncoder();
    var JsonTransformer_1 = require_JsonTransformer();
    var MessageValidator_1 = require_MessageValidator();
    var TypedArrayEncoder_1 = require_TypedArrayEncoder();
    var did_1 = require_did2();
    var uuid_1 = require_uuid();
    var connections_1 = require_connections();
    var dids_1 = require_dids();
    var IndyHolderService_1 = require_IndyHolderService();
    var IndyIssuerService_1 = require_IndyIssuerService();
    var ledger_1 = require_ledger();
    var errors_1 = require_errors3();
    var CredentialFormatSpec_1 = require_CredentialFormatSpec();
    var CredentialPreviewAttribute_1 = require_CredentialPreviewAttribute();
    var CredentialMetadataTypes_1 = require_CredentialMetadataTypes();
    var IndyCredentialUtils_1 = require_IndyCredentialUtils();
    var IndyCredPropose_1 = require_IndyCredPropose();
    var INDY_CRED_ABSTRACT = "hlindy/cred-abstract@v2.0";
    var INDY_CRED_REQUEST = "hlindy/cred-req@v2.0";
    var INDY_CRED_FILTER = "hlindy/cred-filter@v2.0";
    var INDY_CRED = "hlindy/cred@v2.0";
    var IndyCredentialFormatService = class {
      constructor() {
        this.formatKey = "indy";
        this.credentialRecordType = "indy";
      }
      /**
       * Create a {@link AttachmentFormats} object dependent on the message type.
       *
       * @param options The object containing all the options for the proposed credential
       * @returns object containing associated attachment, format and optionally the credential preview
       *
       */
      async createProposal(agentContext, { credentialFormats, credentialRecord }) {
        const format2 = new CredentialFormatSpec_1.CredentialFormatSpec({
          format: INDY_CRED_FILTER
        });
        const indyFormat = credentialFormats.indy;
        if (!indyFormat) {
          throw new error_1.AriesFrameworkError("Missing indy payload in createProposal");
        }
        const { attributes, linkedAttachments } = indyFormat, indyCredentialProposal = __rest2(indyFormat, ["attributes", "linkedAttachments"]);
        const proposal = new IndyCredPropose_1.IndyCredPropose(indyCredentialProposal);
        try {
          MessageValidator_1.MessageValidator.validateSync(proposal);
        } catch (error) {
          throw new error_1.AriesFrameworkError(`Invalid proposal supplied: ${indyCredentialProposal} in Indy Format Service`);
        }
        const proposalJson = JsonTransformer_1.JsonTransformer.toJSON(proposal);
        const attachment = this.getFormatData(proposalJson, format2.attachId);
        const { previewAttributes } = this.getCredentialLinkedAttachments(indyFormat.attributes, indyFormat.linkedAttachments);
        credentialRecord.metadata.set(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
          schemaId: proposal.schemaId,
          credentialDefinitionId: proposal.credentialDefinitionId
        });
        return { format: format2, attachment, previewAttributes };
      }
      async processProposal(agentContext, { attachment }) {
        const proposalJson = attachment.getDataAsJson();
        JsonTransformer_1.JsonTransformer.fromJSON(proposalJson, IndyCredPropose_1.IndyCredPropose);
      }
      async acceptProposal(agentContext, { attachId, credentialFormats, credentialRecord, proposalAttachment }) {
        var _a, _b;
        const indyFormat = credentialFormats === null || credentialFormats === void 0 ? void 0 : credentialFormats.indy;
        const credentialProposal = JsonTransformer_1.JsonTransformer.fromJSON(proposalAttachment.getDataAsJson(), IndyCredPropose_1.IndyCredPropose);
        const credentialDefinitionId = (_a = indyFormat === null || indyFormat === void 0 ? void 0 : indyFormat.credentialDefinitionId) !== null && _a !== void 0 ? _a : credentialProposal.credentialDefinitionId;
        const attributes = (_b = indyFormat === null || indyFormat === void 0 ? void 0 : indyFormat.attributes) !== null && _b !== void 0 ? _b : credentialRecord.credentialAttributes;
        if (!credentialDefinitionId) {
          throw new error_1.AriesFrameworkError("No credentialDefinitionId in proposal or provided as input to accept proposal method.");
        }
        if (!attributes) {
          throw new error_1.AriesFrameworkError("No attributes in proposal or provided as input to accept proposal method.");
        }
        const { format: format2, attachment, previewAttributes } = await this.createIndyOffer(agentContext, {
          credentialRecord,
          attachId,
          attributes,
          credentialDefinitionId,
          linkedAttachments: indyFormat === null || indyFormat === void 0 ? void 0 : indyFormat.linkedAttachments
        });
        return { format: format2, attachment, previewAttributes };
      }
      /**
       * Create a credential attachment format for a credential request.
       *
       * @param options The object containing all the options for the credential offer
       * @returns object containing associated attachment, formats and offersAttach elements
       *
       */
      async createOffer(agentContext, { credentialFormats, credentialRecord, attachId }) {
        const indyFormat = credentialFormats.indy;
        if (!indyFormat) {
          throw new error_1.AriesFrameworkError("Missing indy credentialFormat data");
        }
        const { format: format2, attachment, previewAttributes } = await this.createIndyOffer(agentContext, {
          credentialRecord,
          attachId,
          attributes: indyFormat.attributes,
          credentialDefinitionId: indyFormat.credentialDefinitionId,
          linkedAttachments: indyFormat.linkedAttachments
        });
        return { format: format2, attachment, previewAttributes };
      }
      async processOffer(agentContext, { attachment, credentialRecord }) {
        agentContext.config.logger.debug(`Processing indy credential offer for credential record ${credentialRecord.id}`);
        const credOffer = attachment.getDataAsJson();
        if (!credOffer.schema_id || !credOffer.cred_def_id) {
          throw new errors_1.CredentialProblemReportError("Invalid credential offer", {
            problemCode: errors_1.CredentialProblemReportReason.IssuanceAbandoned
          });
        }
      }
      async acceptOffer(agentContext, { credentialFormats, credentialRecord, attachId, offerAttachment }) {
        var _a;
        const indyFormat = credentialFormats === null || credentialFormats === void 0 ? void 0 : credentialFormats.indy;
        const indyLedgerService = agentContext.dependencyManager.resolve(ledger_1.IndyLedgerService);
        const indyHolderService = agentContext.dependencyManager.resolve(IndyHolderService_1.IndyHolderService);
        const holderDid = (_a = indyFormat === null || indyFormat === void 0 ? void 0 : indyFormat.holderDid) !== null && _a !== void 0 ? _a : await this.getIndyHolderDid(agentContext, credentialRecord);
        const credentialOffer = offerAttachment.getDataAsJson();
        const credentialDefinition = await indyLedgerService.getCredentialDefinition(agentContext, credentialOffer.cred_def_id);
        const [credentialRequest, credentialRequestMetadata] = await indyHolderService.createCredentialRequest(agentContext, {
          holderDid,
          credentialOffer,
          credentialDefinition
        });
        credentialRecord.metadata.set(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyRequest, credentialRequestMetadata);
        credentialRecord.metadata.set(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
          credentialDefinitionId: credentialOffer.cred_def_id,
          schemaId: credentialOffer.schema_id
        });
        const format2 = new CredentialFormatSpec_1.CredentialFormatSpec({
          attachId,
          format: INDY_CRED_REQUEST
        });
        const attachment = this.getFormatData(credentialRequest, format2.attachId);
        return { format: format2, attachment };
      }
      /**
       * Starting from a request is not supported for indy credentials, this method only throws an error.
       */
      async createRequest() {
        throw new error_1.AriesFrameworkError("Starting from a request is not supported for indy credentials");
      }
      /**
       * We don't have any models to validate an indy request object, for now this method does nothing
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async processRequest(agentContext, options) {
      }
      async acceptRequest(agentContext, { credentialRecord, attachId, offerAttachment, requestAttachment }) {
        const credentialAttributes = credentialRecord.credentialAttributes;
        if (!credentialAttributes) {
          throw new errors_1.CredentialProblemReportError(`Missing required credential attribute values on credential record with id ${credentialRecord.id}`, { problemCode: errors_1.CredentialProblemReportReason.IssuanceAbandoned });
        }
        const indyIssuerService = agentContext.dependencyManager.resolve(IndyIssuerService_1.IndyIssuerService);
        const credentialOffer = offerAttachment === null || offerAttachment === void 0 ? void 0 : offerAttachment.getDataAsJson();
        const credentialRequest = requestAttachment.getDataAsJson();
        if (!credentialOffer || !credentialRequest) {
          throw new error_1.AriesFrameworkError("Missing indy credential offer or credential request in createCredential");
        }
        const [credential, credentialRevocationId] = await indyIssuerService.createCredential(agentContext, {
          credentialOffer,
          credentialRequest,
          credentialValues: IndyCredentialUtils_1.IndyCredentialUtils.convertAttributesToValues(credentialAttributes)
        });
        if (credential.rev_reg_id) {
          credentialRecord.metadata.add(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
            indyCredentialRevocationId: credentialRevocationId,
            indyRevocationRegistryId: credential.rev_reg_id
          });
        }
        const format2 = new CredentialFormatSpec_1.CredentialFormatSpec({
          attachId,
          format: INDY_CRED
        });
        const attachment = this.getFormatData(credential, format2.attachId);
        return { format: format2, attachment };
      }
      /**
       * Processes an incoming credential - retrieve metadata, retrieve payload and store it in the Indy wallet
       * @param options the issue credential message wrapped inside this object
       * @param credentialRecord the credential exchange record for this credential
       */
      async processCredential(agentContext, { credentialRecord, attachment }) {
        const credentialRequestMetadata = credentialRecord.metadata.get(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyRequest);
        const indyLedgerService = agentContext.dependencyManager.resolve(ledger_1.IndyLedgerService);
        const indyHolderService = agentContext.dependencyManager.resolve(IndyHolderService_1.IndyHolderService);
        if (!credentialRequestMetadata) {
          throw new errors_1.CredentialProblemReportError(`Missing required request metadata for credential with id ${credentialRecord.id}`, { problemCode: errors_1.CredentialProblemReportReason.IssuanceAbandoned });
        }
        const indyCredential = attachment.getDataAsJson();
        const credentialDefinition = await indyLedgerService.getCredentialDefinition(agentContext, indyCredential.cred_def_id);
        const revocationRegistry = indyCredential.rev_reg_id ? await indyLedgerService.getRevocationRegistryDefinition(agentContext, indyCredential.rev_reg_id) : null;
        if (!credentialRecord.credentialAttributes) {
          throw new error_1.AriesFrameworkError("Missing credential attributes on credential record. Unable to check credential attributes");
        }
        const recordCredentialValues = IndyCredentialUtils_1.IndyCredentialUtils.convertAttributesToValues(credentialRecord.credentialAttributes);
        IndyCredentialUtils_1.IndyCredentialUtils.assertValuesMatch(indyCredential.values, recordCredentialValues);
        const credentialId = await indyHolderService.storeCredential(agentContext, {
          credentialId: (0, uuid_1.uuid)(),
          credentialRequestMetadata,
          credential: indyCredential,
          credentialDefinition,
          revocationRegistryDefinition: revocationRegistry === null || revocationRegistry === void 0 ? void 0 : revocationRegistry.revocationRegistryDefinition
        });
        if (indyCredential.rev_reg_id) {
          const credential = await indyHolderService.getCredential(agentContext, credentialId);
          credentialRecord.metadata.add(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
            indyCredentialRevocationId: credential.cred_rev_id,
            indyRevocationRegistryId: indyCredential.rev_reg_id
          });
        }
        credentialRecord.credentials.push({
          credentialRecordType: this.credentialRecordType,
          credentialRecordId: credentialId
        });
      }
      supportsFormat(format2) {
        const supportedFormats = [INDY_CRED_ABSTRACT, INDY_CRED_REQUEST, INDY_CRED_FILTER, INDY_CRED];
        return supportedFormats.includes(format2);
      }
      /**
       * Gets the attachment object for a given attachId. We need to get out the correct attachId for
       * indy and then find the corresponding attachment (if there is one)
       * @param formats the formats object containing the attachId
       * @param messageAttachments the attachments containing the payload
       * @returns The Attachment if found or undefined
       *
       */
      getAttachment(formats, messageAttachments) {
        const supportedAttachmentIds = formats.filter((f2) => this.supportsFormat(f2.format)).map((f2) => f2.attachId);
        const supportedAttachments = messageAttachments.filter((attachment) => supportedAttachmentIds.includes(attachment.id));
        return supportedAttachments[0];
      }
      async deleteCredentialById(agentContext, credentialRecordId) {
        const indyHolderService = agentContext.dependencyManager.resolve(IndyHolderService_1.IndyHolderService);
        await indyHolderService.deleteCredential(agentContext, credentialRecordId);
      }
      shouldAutoRespondToProposal(agentContext, { offerAttachment, proposalAttachment }) {
        const credentialProposalJson = proposalAttachment.getDataAsJson();
        const credentialProposal = JsonTransformer_1.JsonTransformer.fromJSON(credentialProposalJson, IndyCredPropose_1.IndyCredPropose);
        const credentialOfferJson = offerAttachment.getDataAsJson();
        return credentialProposal.credentialDefinitionId === credentialOfferJson.cred_def_id;
      }
      shouldAutoRespondToOffer(agentContext, { offerAttachment, proposalAttachment }) {
        const credentialProposalJson = proposalAttachment.getDataAsJson();
        const credentialProposal = JsonTransformer_1.JsonTransformer.fromJSON(credentialProposalJson, IndyCredPropose_1.IndyCredPropose);
        const credentialOfferJson = offerAttachment.getDataAsJson();
        return credentialProposal.credentialDefinitionId === credentialOfferJson.cred_def_id;
      }
      shouldAutoRespondToRequest(agentContext, { offerAttachment, requestAttachment }) {
        const credentialOfferJson = offerAttachment.getDataAsJson();
        const credentialRequestJson = requestAttachment.getDataAsJson();
        return credentialOfferJson.cred_def_id == credentialRequestJson.cred_def_id;
      }
      shouldAutoRespondToCredential(agentContext, { credentialRecord, requestAttachment, credentialAttachment }) {
        const credentialJson = credentialAttachment.getDataAsJson();
        const credentialRequestJson = requestAttachment.getDataAsJson();
        if (credentialJson.cred_def_id !== credentialRequestJson.cred_def_id)
          return false;
        if (!credentialRecord.credentialAttributes)
          return false;
        const attributeValues = IndyCredentialUtils_1.IndyCredentialUtils.convertAttributesToValues(credentialRecord.credentialAttributes);
        return IndyCredentialUtils_1.IndyCredentialUtils.checkValuesMatch(attributeValues, credentialJson.values);
      }
      async createIndyOffer(agentContext, { credentialRecord, attachId, credentialDefinitionId, attributes, linkedAttachments }) {
        const indyIssuerService = agentContext.dependencyManager.resolve(IndyIssuerService_1.IndyIssuerService);
        const format2 = new CredentialFormatSpec_1.CredentialFormatSpec({
          attachId,
          format: INDY_CRED_ABSTRACT
        });
        const offer = await indyIssuerService.createCredentialOffer(agentContext, credentialDefinitionId);
        const { previewAttributes } = this.getCredentialLinkedAttachments(attributes, linkedAttachments);
        if (!previewAttributes) {
          throw new error_1.AriesFrameworkError("Missing required preview attributes for indy offer");
        }
        await this.assertPreviewAttributesMatchSchemaAttributes(agentContext, offer, previewAttributes);
        credentialRecord.metadata.set(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
          schemaId: offer.schema_id,
          credentialDefinitionId: offer.cred_def_id
        });
        const attachment = this.getFormatData(offer, format2.attachId);
        return { format: format2, attachment, previewAttributes };
      }
      async assertPreviewAttributesMatchSchemaAttributes(agentContext, offer, attributes) {
        const indyLedgerService = agentContext.dependencyManager.resolve(ledger_1.IndyLedgerService);
        const schema = await indyLedgerService.getSchema(agentContext, offer.schema_id);
        IndyCredentialUtils_1.IndyCredentialUtils.checkAttributesMatch(schema, attributes);
      }
      async getIndyHolderDid(agentContext, credentialRecord) {
        const connectionService = agentContext.dependencyManager.resolve(connections_1.ConnectionService);
        const didResolver = agentContext.dependencyManager.resolve(dids_1.DidResolverService);
        if (credentialRecord.connectionId) {
          const connection = await connectionService.getById(agentContext, credentialRecord.connectionId);
          if (!connection.did) {
            throw new error_1.AriesFrameworkError(`Connection record ${connection.id} has no 'did'`);
          }
          const resolved = await didResolver.resolve(agentContext, connection.did);
          if (resolved.didDocument) {
            const verificationMethod = await (0, dids_1.findVerificationMethodByKeyType)("Ed25519VerificationKey2018", resolved.didDocument);
            if (verificationMethod) {
              return (0, did_1.getIndyDidFromVerificationMethod)(verificationMethod);
            }
          }
        }
        const key = await agentContext.wallet.createKey({ keyType: crypto_1.KeyType.Ed25519 });
        const did = TypedArrayEncoder_1.TypedArrayEncoder.toBase58(key.publicKey.slice(0, 16));
        return did;
      }
      /**
       * Get linked attachments for indy format from a proposal message. This allows attachments
       * to be copied across to old style credential records
       *
       * @param options ProposeCredentialOptions object containing (optionally) the linked attachments
       * @return array of linked attachments or undefined if none present
       */
      getCredentialLinkedAttachments(attributes, linkedAttachments) {
        var _a;
        if (!linkedAttachments && !attributes) {
          return {};
        }
        let previewAttributes = (_a = attributes === null || attributes === void 0 ? void 0 : attributes.map((attribute) => new CredentialPreviewAttribute_1.CredentialPreviewAttribute(attribute))) !== null && _a !== void 0 ? _a : [];
        let attachments;
        if (linkedAttachments) {
          previewAttributes = IndyCredentialUtils_1.IndyCredentialUtils.createAndLinkAttachmentsToPreview(linkedAttachments, previewAttributes);
          attachments = linkedAttachments.map((linkedAttachment) => linkedAttachment.attachment);
        }
        return { attachments, previewAttributes };
      }
      /**
       * Returns an object of type {@link Attachment} for use in credential exchange messages.
       * It looks up the correct format identifier and encodes the data as a base64 attachment.
       *
       * @param data The data to include in the attach object
       * @param id the attach id from the formats component of the message
       */
      getFormatData(data, id) {
        const attachment = new Attachment_1.Attachment({
          id,
          mimeType: "application/json",
          data: new Attachment_1.AttachmentData({
            base64: JsonEncoder_1.JsonEncoder.toBase64(data)
          })
        });
        return attachment;
      }
    };
    exports.IndyCredentialFormatService = IndyCredentialFormatService;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/formats/indy/IndyCredentialFormat.js
var require_IndyCredentialFormat = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/formats/indy/IndyCredentialFormat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/formats/indy/index.js
var require_indy = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/formats/indy/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_models7(), exports);
    __exportStar(require_IndyCredentialFormatService(), exports);
    __exportStar(require_IndyCredentialFormat(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/vc/models/LdKeyPair.js
var require_LdKeyPair = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/models/LdKeyPair.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LdKeyPair = void 0;
    var LdKeyPair = class {
      constructor(options) {
        this.id = options.id;
        this.controller = options.controller;
      }
      static async generate() {
        throw new Error("Not implemented");
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      static async from(verificationMethod) {
        throw new Error("Abstract method from() must be implemented in subclass.");
      }
      export(publicKey = false, privateKey = false) {
        if (!publicKey && !privateKey) {
          throw new Error('Export requires specifying either "publicKey" or "privateKey".');
        }
        const key = {
          id: this.id,
          type: this.type,
          controller: this.controller
        };
        return key;
      }
    };
    exports.LdKeyPair = LdKeyPair;
  }
});

// node_modules/@aries-framework/core/build/crypto/WalletKeyPair.js
var require_WalletKeyPair = __commonJS({
  "node_modules/@aries-framework/core/build/crypto/WalletKeyPair.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createWalletKeyPairClass = void 0;
    var dids_1 = require_dids();
    var keyDidMapping_1 = require_keyDidMapping();
    var LdKeyPair_1 = require_LdKeyPair();
    var utils_1 = require_utils();
    var MessageValidator_1 = require_MessageValidator();
    var buffer_1 = require_buffer2();
    function createWalletKeyPairClass(wallet) {
      return class WalletKeyPair extends LdKeyPair_1.LdKeyPair {
        constructor(options) {
          super(options);
          this.wallet = options.wallet;
          this.key = options.key;
          this.type = options.key.keyType;
        }
        static async generate() {
          throw new Error("Not implemented");
        }
        fingerprint() {
          throw new Error("Method not implemented.");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        verifyFingerprint(fingerprint) {
          throw new Error("Method not implemented.");
        }
        static async from(verificationMethod) {
          const vMethod = utils_1.JsonTransformer.fromJSON(verificationMethod, dids_1.VerificationMethod);
          MessageValidator_1.MessageValidator.validateSync(vMethod);
          const { getKeyFromVerificationMethod } = (0, keyDidMapping_1.getKeyDidMappingByVerificationMethod)(vMethod);
          const key = getKeyFromVerificationMethod(vMethod);
          return new WalletKeyPair({
            id: vMethod.id,
            controller: vMethod.controller,
            wallet,
            key
          });
        }
        /**
         * This method returns a wrapped wallet.sign method. The method is being wrapped so we can covert between Uint8Array and Buffer. This is to make it compatible with the external signature libraries.
         */
        signer() {
          const wrappedSign = async (data) => {
            let converted = [];
            if (Array.isArray(data.data)) {
              converted = data.data.map((d) => buffer_1.Buffer.from(d));
            } else {
              converted = buffer_1.Buffer.from(data.data);
            }
            const result2 = await wallet.sign({
              data: converted,
              key: this.key
            });
            return Uint8Array.from(result2);
          };
          return {
            sign: wrappedSign.bind(this)
          };
        }
        /**
         * This method returns a wrapped wallet.verify method. The method is being wrapped so we can covert between Uint8Array and Buffer. This is to make it compatible with the external signature libraries.
         */
        verifier() {
          const wrappedVerify = async (data) => {
            let converted = [];
            if (Array.isArray(data.data)) {
              converted = data.data.map((d) => buffer_1.Buffer.from(d));
            } else {
              converted = buffer_1.Buffer.from(data.data);
            }
            return wallet.verify({
              data: converted,
              signature: buffer_1.Buffer.from(data.signature),
              key: this.key
            });
          };
          return {
            verify: wrappedVerify.bind(this)
          };
        }
        get publicKeyBuffer() {
          return new Uint8Array(this.key.publicKey);
        }
      };
    }
    exports.createWalletKeyPairClass = createWalletKeyPairClass;
  }
});

// node_modules/@digitalbazaar/security-context/dist/context.js
var require_context2 = __commonJS({
  "node_modules/@digitalbazaar/security-context/dist/context.js"(exports) {
    !function(e, t) {
      for (var i in t)
        e[i] = t[i];
    }(exports, function(e) {
      var t = {};
      function i(r) {
        if (t[r])
          return t[r].exports;
        var a = t[r] = { i: r, l: false, exports: {} };
        return e[r].call(a.exports, a, a.exports, i), a.l = true, a.exports;
      }
      return i.m = e, i.c = t, i.d = function(e2, t2, r) {
        i.o(e2, t2) || Object.defineProperty(e2, t2, { enumerable: true, get: r });
      }, i.r = function(e2) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      }, i.t = function(e2, t2) {
        if (1 & t2 && (e2 = i(e2)), 8 & t2)
          return e2;
        if (4 & t2 && "object" == typeof e2 && e2 && e2.__esModule)
          return e2;
        var r = /* @__PURE__ */ Object.create(null);
        if (i.r(r), Object.defineProperty(r, "default", { enumerable: true, value: e2 }), 2 & t2 && "string" != typeof e2)
          for (var a in e2)
            i.d(r, a, function(t3) {
              return e2[t3];
            }.bind(null, a));
        return r;
      }, i.n = function(e2) {
        var t2 = e2 && e2.__esModule ? function() {
          return e2.default;
        } : function() {
          return e2;
        };
        return i.d(t2, "a", t2), t2;
      }, i.o = function(e2, t2) {
        return Object.prototype.hasOwnProperty.call(e2, t2);
      }, i.p = "", i(i.s = 0);
    }([function(e, t, i) {
      "use strict";
      const r = i(1), a = i(2), c = i(3), { CONTEXT_URL: n, SECURITY_CONTEXT_V1_URL: o, SECURITY_CONTEXT_V2_URL: s } = c, p = /* @__PURE__ */ new Map();
      p.set(o, r), p.set(s, a), e.exports = { constants: c, contexts: p, SECURITY_CONTEXT_V1_URL: o, SECURITY_CONTEXT_V2_URL: s, CONTEXT_URL: n, CONTEXT: a };
    }, function(e, t, i) {
      "use strict";
      e.exports = { "@context": { id: "@id", type: "@type", dc: "http://purl.org/dc/terms/", sec: "https://w3id.org/security#", xsd: "http://www.w3.org/2001/XMLSchema#", EcdsaKoblitzSignature2016: "sec:EcdsaKoblitzSignature2016", Ed25519Signature2018: "sec:Ed25519Signature2018", EncryptedMessage: "sec:EncryptedMessage", GraphSignature2012: "sec:GraphSignature2012", LinkedDataSignature2015: "sec:LinkedDataSignature2015", LinkedDataSignature2016: "sec:LinkedDataSignature2016", CryptographicKey: "sec:Key", authenticationTag: "sec:authenticationTag", canonicalizationAlgorithm: "sec:canonicalizationAlgorithm", cipherAlgorithm: "sec:cipherAlgorithm", cipherData: "sec:cipherData", cipherKey: "sec:cipherKey", created: { "@id": "dc:created", "@type": "xsd:dateTime" }, creator: { "@id": "dc:creator", "@type": "@id" }, digestAlgorithm: "sec:digestAlgorithm", digestValue: "sec:digestValue", domain: "sec:domain", encryptionKey: "sec:encryptionKey", expiration: { "@id": "sec:expiration", "@type": "xsd:dateTime" }, expires: { "@id": "sec:expiration", "@type": "xsd:dateTime" }, initializationVector: "sec:initializationVector", iterationCount: "sec:iterationCount", nonce: "sec:nonce", normalizationAlgorithm: "sec:normalizationAlgorithm", owner: { "@id": "sec:owner", "@type": "@id" }, password: "sec:password", privateKey: { "@id": "sec:privateKey", "@type": "@id" }, privateKeyPem: "sec:privateKeyPem", publicKey: { "@id": "sec:publicKey", "@type": "@id" }, publicKeyBase58: "sec:publicKeyBase58", publicKeyPem: "sec:publicKeyPem", publicKeyWif: "sec:publicKeyWif", publicKeyService: { "@id": "sec:publicKeyService", "@type": "@id" }, revoked: { "@id": "sec:revoked", "@type": "xsd:dateTime" }, salt: "sec:salt", signature: "sec:signature", signatureAlgorithm: "sec:signingAlgorithm", signatureValue: "sec:signatureValue" } };
    }, function(e, t, i) {
      "use strict";
      e.exports = { "@context": [{ "@version": 1.1 }, "https://w3id.org/security/v1", { AesKeyWrappingKey2019: "sec:AesKeyWrappingKey2019", DeleteKeyOperation: "sec:DeleteKeyOperation", DeriveSecretOperation: "sec:DeriveSecretOperation", EcdsaSecp256k1Signature2019: "sec:EcdsaSecp256k1Signature2019", EcdsaSecp256r1Signature2019: "sec:EcdsaSecp256r1Signature2019", EcdsaSecp256k1VerificationKey2019: "sec:EcdsaSecp256k1VerificationKey2019", EcdsaSecp256r1VerificationKey2019: "sec:EcdsaSecp256r1VerificationKey2019", Ed25519Signature2018: "sec:Ed25519Signature2018", Ed25519VerificationKey2018: "sec:Ed25519VerificationKey2018", EquihashProof2018: "sec:EquihashProof2018", ExportKeyOperation: "sec:ExportKeyOperation", GenerateKeyOperation: "sec:GenerateKeyOperation", KmsOperation: "sec:KmsOperation", RevokeKeyOperation: "sec:RevokeKeyOperation", RsaSignature2018: "sec:RsaSignature2018", RsaVerificationKey2018: "sec:RsaVerificationKey2018", Sha256HmacKey2019: "sec:Sha256HmacKey2019", SignOperation: "sec:SignOperation", UnwrapKeyOperation: "sec:UnwrapKeyOperation", VerifyOperation: "sec:VerifyOperation", WrapKeyOperation: "sec:WrapKeyOperation", X25519KeyAgreementKey2019: "sec:X25519KeyAgreementKey2019", allowedAction: "sec:allowedAction", assertionMethod: { "@id": "sec:assertionMethod", "@type": "@id", "@container": "@set" }, authentication: { "@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set" }, capability: { "@id": "sec:capability", "@type": "@id" }, capabilityAction: "sec:capabilityAction", capabilityChain: { "@id": "sec:capabilityChain", "@type": "@id", "@container": "@list" }, capabilityDelegation: { "@id": "sec:capabilityDelegationMethod", "@type": "@id", "@container": "@set" }, capabilityInvocation: { "@id": "sec:capabilityInvocationMethod", "@type": "@id", "@container": "@set" }, caveat: { "@id": "sec:caveat", "@type": "@id", "@container": "@set" }, challenge: "sec:challenge", ciphertext: "sec:ciphertext", controller: { "@id": "sec:controller", "@type": "@id" }, delegator: { "@id": "sec:delegator", "@type": "@id" }, equihashParameterK: { "@id": "sec:equihashParameterK", "@type": "xsd:integer" }, equihashParameterN: { "@id": "sec:equihashParameterN", "@type": "xsd:integer" }, invocationTarget: { "@id": "sec:invocationTarget", "@type": "@id" }, invoker: { "@id": "sec:invoker", "@type": "@id" }, jws: "sec:jws", keyAgreement: { "@id": "sec:keyAgreementMethod", "@type": "@id", "@container": "@set" }, kmsModule: { "@id": "sec:kmsModule" }, parentCapability: { "@id": "sec:parentCapability", "@type": "@id" }, plaintext: "sec:plaintext", proof: { "@id": "sec:proof", "@type": "@id", "@container": "@graph" }, proofPurpose: { "@id": "sec:proofPurpose", "@type": "@vocab" }, proofValue: "sec:proofValue", referenceId: "sec:referenceId", unwrappedKey: "sec:unwrappedKey", verificationMethod: { "@id": "sec:verificationMethod", "@type": "@id" }, verifyData: "sec:verifyData", wrappedKey: "sec:wrappedKey" }] };
    }, function(e, t, i) {
      "use strict";
      e.exports = { SECURITY_CONTEXT_V1_URL: "https://w3id.org/security/v1", SECURITY_CONTEXT_V2_URL: "https://w3id.org/security/v2", CONTEXT_URL: "https://w3id.org/security/v2" };
    }]));
  }
});

// node_modules/@digitalcredentials/jsonld-signatures/lib/constants.js
var require_constants5 = __commonJS({
  "node_modules/@digitalcredentials/jsonld-signatures/lib/constants.js"(exports, module) {
    "use strict";
    var {
      constants: securityConstants
    } = require_context2();
    module.exports = {
      SECURITY_CONTEXT_URL: securityConstants.SECURITY_CONTEXT_V2_URL,
      SECURITY_CONTEXT_V1_URL: securityConstants.SECURITY_CONTEXT_V1_URL,
      SECURITY_CONTEXT_V2_URL: securityConstants.SECURITY_CONTEXT_V2_URL,
      SECURITY_PROOF_URL: "https://w3id.org/security#proof",
      SECURITY_SIGNATURE_URL: "https://w3id.org/security#signature"
    };
  }
});

// node_modules/@digitalcredentials/rdf-canonize/lib/IdentifierIssuer.js
var require_IdentifierIssuer = __commonJS({
  "node_modules/@digitalcredentials/rdf-canonize/lib/IdentifierIssuer.js"(exports, module) {
    "use strict";
    module.exports = class IdentifierIssuer {
      /**
       * Creates a new IdentifierIssuer. A IdentifierIssuer issues unique
       * identifiers, keeping track of any previously issued identifiers.
       *
       * @param prefix the prefix to use ('<prefix><counter>').
       * @param existing an existing Map to use.
       * @param counter the counter to use.
       */
      constructor(prefix, existing = /* @__PURE__ */ new Map(), counter = 0) {
        this.prefix = prefix;
        this._existing = existing;
        this.counter = counter;
      }
      /**
       * Copies this IdentifierIssuer.
       *
       * @return a copy of this IdentifierIssuer.
       */
      clone() {
        const { prefix, _existing, counter } = this;
        return new IdentifierIssuer(prefix, new Map(_existing), counter);
      }
      /**
       * Gets the new identifier for the given old identifier, where if no old
       * identifier is given a new identifier will be generated.
       *
       * @param [old] the old identifier to get the new identifier for.
       *
       * @return the new identifier.
       */
      getId(old) {
        const existing = old && this._existing.get(old);
        if (existing) {
          return existing;
        }
        const identifier = this.prefix + this.counter;
        this.counter++;
        if (old) {
          this._existing.set(old, identifier);
        }
        return identifier;
      }
      /**
       * Returns true if the given old identifer has already been assigned a new
       * identifier.
       *
       * @param old the old identifier to check.
       *
       * @return true if the old identifier has been assigned a new identifier,
       *   false if not.
       */
      hasId(old) {
        return this._existing.has(old);
      }
      /**
       * Returns all of the IDs that have been issued new IDs in the order in
       * which they were issued new IDs.
       *
       * @return the list of old IDs that has been issued new IDs in order.
       */
      getOldIds() {
        return [...this._existing.keys()];
      }
    };
  }
});

// node_modules/@digitalcredentials/rdf-canonize/lib/MessageDigest-browser.js
var require_MessageDigest_browser = __commonJS({
  "node_modules/@digitalcredentials/rdf-canonize/lib/MessageDigest-browser.js"(exports, module) {
    "use strict";
    var crypto2 = self.crypto || self.msCrypto;
    module.exports = class MessageDigest {
      /**
       * Creates a new MessageDigest.
       *
       * @param algorithm the algorithm to use.
       */
      constructor(algorithm) {
        if (!(crypto2 && crypto2.subtle)) {
          throw new Error("crypto.subtle not found.");
        }
        if (algorithm === "sha256") {
          this.algorithm = { name: "SHA-256" };
        } else if (algorithm === "sha1") {
          this.algorithm = { name: "SHA-1" };
        } else {
          throw new Error(`Unsupported algorithm "${algorithm}".`);
        }
        this._content = "";
      }
      update(msg) {
        this._content += msg;
      }
      async digest() {
        const data = new TextEncoder().encode(this._content);
        const buffer = new Uint8Array(
          await crypto2.subtle.digest(this.algorithm, data)
        );
        let hex = "";
        for (let i = 0; i < buffer.length; ++i) {
          hex += buffer[i].toString(16).padStart(2, "0");
        }
        return hex;
      }
    };
  }
});

// node_modules/@digitalcredentials/rdf-canonize/lib/Permuter.js
var require_Permuter = __commonJS({
  "node_modules/@digitalcredentials/rdf-canonize/lib/Permuter.js"(exports, module) {
    "use strict";
    module.exports = class Permuter {
      /**
       * A Permuter iterates over all possible permutations of the given array
       * of elements.
       *
       * @param list the array of elements to iterate over.
       */
      constructor(list) {
        this.current = list.sort();
        this.done = false;
        this.dir = /* @__PURE__ */ new Map();
        for (let i = 0; i < list.length; ++i) {
          this.dir.set(list[i], true);
        }
      }
      /**
       * Returns true if there is another permutation.
       *
       * @return true if there is another permutation, false if not.
       */
      hasNext() {
        return !this.done;
      }
      /**
       * Gets the next permutation. Call hasNext() to ensure there is another one
       * first.
       *
       * @return the next permutation.
       */
      next() {
        const { current, dir } = this;
        const rval = current.slice();
        let k = null;
        let pos = 0;
        const length2 = current.length;
        for (let i = 0; i < length2; ++i) {
          const element = current[i];
          const left = dir.get(element);
          if ((k === null || element > k) && (left && i > 0 && element > current[i - 1] || !left && i < length2 - 1 && element > current[i + 1])) {
            k = element;
            pos = i;
          }
        }
        if (k === null) {
          this.done = true;
        } else {
          const swap = dir.get(k) ? pos - 1 : pos + 1;
          current[pos] = current[swap];
          current[swap] = k;
          for (const element of current) {
            if (element > k) {
              dir.set(element, !dir.get(element));
            }
          }
        }
        return rval;
      }
    };
  }
});

// node_modules/@digitalcredentials/rdf-canonize/lib/NQuads.js
var require_NQuads = __commonJS({
  "node_modules/@digitalcredentials/rdf-canonize/lib/NQuads.js"(exports, module) {
    "use strict";
    var RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
    var RDF_LANGSTRING = RDF + "langString";
    var XSD_STRING = "http://www.w3.org/2001/XMLSchema#string";
    var TYPE_NAMED_NODE = "NamedNode";
    var TYPE_BLANK_NODE = "BlankNode";
    var TYPE_LITERAL = "Literal";
    var TYPE_DEFAULT_GRAPH = "DefaultGraph";
    var REGEX = {};
    (() => {
      const iri = "(?:<([^:]+:[^>]*)>)";
      const PN_CHARS_BASE = "A-Za-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�";
      const PN_CHARS_U = PN_CHARS_BASE + "_";
      const PN_CHARS = PN_CHARS_U + "0-9-·̀-ͯ‿-⁀";
      const BLANK_NODE_LABEL = "(_:(?:[" + PN_CHARS_U + "0-9])(?:(?:[" + PN_CHARS + ".])*(?:[" + PN_CHARS + "]))?)";
      const bnode = BLANK_NODE_LABEL;
      const plain = '"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"';
      const datatype = "(?:\\^\\^" + iri + ")";
      const language = "(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))";
      const literal = "(?:" + plain + "(?:" + datatype + "|" + language + ")?)";
      const ws = "[ \\t]+";
      const wso = "[ \\t]*";
      const subject = "(?:" + iri + "|" + bnode + ")" + ws;
      const property = iri + ws;
      const object = "(?:" + iri + "|" + bnode + "|" + literal + ")" + wso;
      const graphName = "(?:\\.|(?:(?:" + iri + "|" + bnode + ")" + wso + "\\.))";
      REGEX.eoln = /(?:\r\n)|(?:\n)|(?:\r)/g;
      REGEX.empty = new RegExp("^" + wso + "$");
      REGEX.quad = new RegExp(
        "^" + wso + subject + property + object + graphName + wso + "$"
      );
    })();
    module.exports = class NQuads {
      /**
       * Parses RDF in the form of N-Quads.
       *
       * @param input the N-Quads input to parse.
       *
       * @return an RDF dataset (an array of quads per http://rdf.js.org/).
       */
      static parse(input) {
        const dataset = [];
        const graphs = {};
        const lines = input.split(REGEX.eoln);
        let lineNumber = 0;
        for (const line of lines) {
          lineNumber++;
          if (REGEX.empty.test(line)) {
            continue;
          }
          const match = line.match(REGEX.quad);
          if (match === null) {
            throw new Error("N-Quads parse error on line " + lineNumber + ".");
          }
          const quad = { subject: null, predicate: null, object: null, graph: null };
          if (match[1] !== void 0) {
            quad.subject = { termType: TYPE_NAMED_NODE, value: match[1] };
          } else {
            quad.subject = { termType: TYPE_BLANK_NODE, value: match[2] };
          }
          quad.predicate = { termType: TYPE_NAMED_NODE, value: match[3] };
          if (match[4] !== void 0) {
            quad.object = { termType: TYPE_NAMED_NODE, value: match[4] };
          } else if (match[5] !== void 0) {
            quad.object = { termType: TYPE_BLANK_NODE, value: match[5] };
          } else {
            quad.object = {
              termType: TYPE_LITERAL,
              value: void 0,
              datatype: {
                termType: TYPE_NAMED_NODE
              }
            };
            if (match[7] !== void 0) {
              quad.object.datatype.value = match[7];
            } else if (match[8] !== void 0) {
              quad.object.datatype.value = RDF_LANGSTRING;
              quad.object.language = match[8];
            } else {
              quad.object.datatype.value = XSD_STRING;
            }
            quad.object.value = _unescape(match[6]);
          }
          if (match[9] !== void 0) {
            quad.graph = {
              termType: TYPE_NAMED_NODE,
              value: match[9]
            };
          } else if (match[10] !== void 0) {
            quad.graph = {
              termType: TYPE_BLANK_NODE,
              value: match[10]
            };
          } else {
            quad.graph = {
              termType: TYPE_DEFAULT_GRAPH,
              value: ""
            };
          }
          if (!(quad.graph.value in graphs)) {
            graphs[quad.graph.value] = [quad];
            dataset.push(quad);
          } else {
            let unique = true;
            const quads = graphs[quad.graph.value];
            for (const q of quads) {
              if (_compareTriples(q, quad)) {
                unique = false;
                break;
              }
            }
            if (unique) {
              quads.push(quad);
              dataset.push(quad);
            }
          }
        }
        return dataset;
      }
      /**
       * Converts an RDF dataset to N-Quads.
       *
       * @param dataset (array of quads) the RDF dataset to convert.
       *
       * @return the N-Quads string.
       */
      static serialize(dataset) {
        if (!Array.isArray(dataset)) {
          dataset = NQuads.legacyDatasetToQuads(dataset);
        }
        const quads = [];
        for (const quad of dataset) {
          quads.push(NQuads.serializeQuad(quad));
        }
        return quads.sort().join("");
      }
      /**
       * Converts an RDF quad to an N-Quad string (a single quad).
       *
       * @param quad the RDF quad convert.
       *
       * @return the N-Quad string.
       */
      static serializeQuad(quad) {
        const s = quad.subject;
        const p = quad.predicate;
        const o = quad.object;
        const g = quad.graph;
        let nquad = "";
        if (s.termType === TYPE_NAMED_NODE) {
          nquad += `<${s.value}>`;
        } else {
          nquad += `${s.value}`;
        }
        nquad += ` <${p.value}> `;
        if (o.termType === TYPE_NAMED_NODE) {
          nquad += `<${o.value}>`;
        } else if (o.termType === TYPE_BLANK_NODE) {
          nquad += o.value;
        } else {
          nquad += `"${_escape(o.value)}"`;
          if (o.datatype.value === RDF_LANGSTRING) {
            if (o.language) {
              nquad += `@${o.language}`;
            }
          } else if (o.datatype.value !== XSD_STRING) {
            nquad += `^^<${o.datatype.value}>`;
          }
        }
        if (g.termType === TYPE_NAMED_NODE) {
          nquad += ` <${g.value}>`;
        } else if (g.termType === TYPE_BLANK_NODE) {
          nquad += ` ${g.value}`;
        }
        nquad += " .\n";
        return nquad;
      }
      /**
       * Converts a legacy-formatted dataset to an array of quads dataset per
       * http://rdf.js.org/.
       *
       * @param dataset the legacy dataset to convert.
       *
       * @return the array of quads dataset.
       */
      static legacyDatasetToQuads(dataset) {
        const quads = [];
        const termTypeMap = {
          "blank node": TYPE_BLANK_NODE,
          IRI: TYPE_NAMED_NODE,
          literal: TYPE_LITERAL
        };
        for (const graphName in dataset) {
          const triples = dataset[graphName];
          triples.forEach((triple) => {
            const quad = {};
            for (const componentName in triple) {
              const oldComponent = triple[componentName];
              const newComponent = {
                termType: termTypeMap[oldComponent.type],
                value: oldComponent.value
              };
              if (newComponent.termType === TYPE_LITERAL) {
                newComponent.datatype = {
                  termType: TYPE_NAMED_NODE
                };
                if ("datatype" in oldComponent) {
                  newComponent.datatype.value = oldComponent.datatype;
                }
                if ("language" in oldComponent) {
                  if (!("datatype" in oldComponent)) {
                    newComponent.datatype.value = RDF_LANGSTRING;
                  }
                  newComponent.language = oldComponent.language;
                } else if (!("datatype" in oldComponent)) {
                  newComponent.datatype.value = XSD_STRING;
                }
              }
              quad[componentName] = newComponent;
            }
            if (graphName === "@default") {
              quad.graph = {
                termType: TYPE_DEFAULT_GRAPH,
                value: ""
              };
            } else {
              quad.graph = {
                termType: graphName.startsWith("_:") ? TYPE_BLANK_NODE : TYPE_NAMED_NODE,
                value: graphName
              };
            }
            quads.push(quad);
          });
        }
        return quads;
      }
    };
    function _compareTriples(t1, t2) {
      if (!(t1.subject.termType === t2.subject.termType && t1.object.termType === t2.object.termType)) {
        return false;
      }
      if (!(t1.subject.value === t2.subject.value && t1.predicate.value === t2.predicate.value && t1.object.value === t2.object.value)) {
        return false;
      }
      if (t1.object.termType !== TYPE_LITERAL) {
        return true;
      }
      return t1.object.datatype.termType === t2.object.datatype.termType && t1.object.language === t2.object.language && t1.object.datatype.value === t2.object.datatype.value;
    }
    var _escapeRegex = /["\\\n\r]/g;
    function _escape(s) {
      return s.replace(_escapeRegex, function(match) {
        switch (match) {
          case '"':
            return '\\"';
          case "\\":
            return "\\\\";
          case "\n":
            return "\\n";
          case "\r":
            return "\\r";
        }
      });
    }
    var _unescapeRegex = /(?:\\([tbnrf"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g;
    function _unescape(s) {
      return s.replace(_unescapeRegex, function(match, code, u, U) {
        if (code) {
          switch (code) {
            case "t":
              return "	";
            case "b":
              return "\b";
            case "n":
              return "\n";
            case "r":
              return "\r";
            case "f":
              return "\f";
            case '"':
              return '"';
            case "'":
              return "'";
            case "\\":
              return "\\";
          }
        }
        if (u) {
          return String.fromCharCode(parseInt(u, 16));
        }
        if (U) {
          throw new Error("Unsupported U escape");
        }
      });
    }
  }
});

// node_modules/@digitalcredentials/rdf-canonize/lib/URDNA2015.js
var require_URDNA2015 = __commonJS({
  "node_modules/@digitalcredentials/rdf-canonize/lib/URDNA2015.js"(exports, module) {
    "use strict";
    var IdentifierIssuer = require_IdentifierIssuer();
    var MessageDigest = require_MessageDigest_browser();
    var Permuter = require_Permuter();
    var NQuads = require_NQuads();
    module.exports = class URDNA2015 {
      constructor() {
        this.name = "URDNA2015";
        this.blankNodeInfo = /* @__PURE__ */ new Map();
        this.canonicalIssuer = new IdentifierIssuer("_:c14n");
        this.hashAlgorithm = "sha256";
        this.quads = null;
      }
      // 4.4) Normalization Algorithm
      async main(dataset) {
        this.quads = dataset;
        for (const quad of dataset) {
          this._addBlankNodeQuadInfo({ quad, component: quad.subject });
          this._addBlankNodeQuadInfo({ quad, component: quad.object });
          this._addBlankNodeQuadInfo({ quad, component: quad.graph });
        }
        const hashToBlankNodes = /* @__PURE__ */ new Map();
        const nonNormalized = [...this.blankNodeInfo.keys()];
        let i = 0;
        for (const id of nonNormalized) {
          if (++i % 100 === 0) {
            await this._yield();
          }
          await this._hashAndTrackBlankNode({ id, hashToBlankNodes });
        }
        const hashes = [...hashToBlankNodes.keys()].sort();
        const nonUnique = [];
        for (const hash of hashes) {
          const idList = hashToBlankNodes.get(hash);
          if (idList.length > 1) {
            nonUnique.push(idList);
            continue;
          }
          const id = idList[0];
          this.canonicalIssuer.getId(id);
        }
        for (const idList of nonUnique) {
          const hashPathList = [];
          for (const id of idList) {
            if (this.canonicalIssuer.hasId(id)) {
              continue;
            }
            const issuer = new IdentifierIssuer("_:b");
            issuer.getId(id);
            const result2 = await this.hashNDegreeQuads(id, issuer);
            hashPathList.push(result2);
          }
          hashPathList.sort(_stringHashCompare);
          for (const result2 of hashPathList) {
            const oldIds = result2.issuer.getOldIds();
            for (const id of oldIds) {
              this.canonicalIssuer.getId(id);
            }
          }
        }
        const normalized = [];
        for (const quad of this.quads) {
          const q = { ...quad };
          q.subject = this._useCanonicalId({ component: q.subject });
          q.object = this._useCanonicalId({ component: q.object });
          q.graph = this._useCanonicalId({ component: q.graph });
          normalized.push(NQuads.serializeQuad(q));
        }
        normalized.sort();
        return normalized.join("");
      }
      // 4.6) Hash First Degree Quads
      async hashFirstDegreeQuads(id) {
        const nquads = [];
        const info = this.blankNodeInfo.get(id);
        const quads = info.quads;
        for (const quad of quads) {
          const copy = {
            subject: null,
            predicate: quad.predicate,
            object: null,
            graph: null
          };
          copy.subject = this.modifyFirstDegreeComponent(
            id,
            quad.subject,
            "subject"
          );
          copy.object = this.modifyFirstDegreeComponent(
            id,
            quad.object,
            "object"
          );
          copy.graph = this.modifyFirstDegreeComponent(
            id,
            quad.graph,
            "graph"
          );
          nquads.push(NQuads.serializeQuad(copy));
        }
        nquads.sort();
        const md = new MessageDigest(this.hashAlgorithm);
        for (const nquad of nquads) {
          md.update(nquad);
        }
        info.hash = await md.digest();
        return info.hash;
      }
      // 4.7) Hash Related Blank Node
      async hashRelatedBlankNode(related, quad, issuer, position) {
        let id;
        if (this.canonicalIssuer.hasId(related)) {
          id = this.canonicalIssuer.getId(related);
        } else if (issuer.hasId(related)) {
          id = issuer.getId(related);
        } else {
          id = this.blankNodeInfo.get(related).hash;
        }
        const md = new MessageDigest(this.hashAlgorithm);
        md.update(position);
        if (position !== "g") {
          md.update(this.getRelatedPredicate(quad));
        }
        md.update(id);
        return md.digest();
      }
      // 4.8) Hash N-Degree Quads
      async hashNDegreeQuads(id, issuer) {
        const md = new MessageDigest(this.hashAlgorithm);
        const hashToRelated = await this.createHashToRelated(id, issuer);
        const hashes = [...hashToRelated.keys()].sort();
        for (const hash of hashes) {
          md.update(hash);
          let chosenPath = "";
          let chosenIssuer;
          const permuter = new Permuter(hashToRelated.get(hash));
          let i = 0;
          while (permuter.hasNext()) {
            const permutation = permuter.next();
            if (++i % 3 === 0) {
              await this._yield();
            }
            let issuerCopy = issuer.clone();
            let path = "";
            const recursionList = [];
            let nextPermutation = false;
            for (const related of permutation) {
              if (this.canonicalIssuer.hasId(related)) {
                path += this.canonicalIssuer.getId(related);
              } else {
                if (!issuerCopy.hasId(related)) {
                  recursionList.push(related);
                }
                path += issuerCopy.getId(related);
              }
              if (chosenPath.length !== 0 && path > chosenPath) {
                nextPermutation = true;
                break;
              }
            }
            if (nextPermutation) {
              continue;
            }
            for (const related of recursionList) {
              const result2 = await this.hashNDegreeQuads(related, issuerCopy);
              path += issuerCopy.getId(related);
              path += `<${result2.hash}>`;
              issuerCopy = result2.issuer;
              if (chosenPath.length !== 0 && path > chosenPath) {
                nextPermutation = true;
                break;
              }
            }
            if (nextPermutation) {
              continue;
            }
            if (chosenPath.length === 0 || path < chosenPath) {
              chosenPath = path;
              chosenIssuer = issuerCopy;
            }
          }
          md.update(chosenPath);
          issuer = chosenIssuer;
        }
        return { hash: await md.digest(), issuer };
      }
      // helper for modifying component during Hash First Degree Quads
      modifyFirstDegreeComponent(id, component) {
        if (component.termType !== "BlankNode") {
          return component;
        }
        return {
          termType: "BlankNode",
          value: component.value === id ? "_:a" : "_:z"
        };
      }
      // helper for getting a related predicate
      getRelatedPredicate(quad) {
        return `<${quad.predicate.value}>`;
      }
      // helper for creating hash to related blank nodes map
      async createHashToRelated(id, issuer) {
        const hashToRelated = /* @__PURE__ */ new Map();
        const quads = this.blankNodeInfo.get(id).quads;
        let i = 0;
        for (const quad of quads) {
          if (++i % 100 === 0) {
            await this._yield();
          }
          await Promise.all([
            this._addRelatedBlankNodeHash({
              quad,
              component: quad.subject,
              position: "s",
              id,
              issuer,
              hashToRelated
            }),
            this._addRelatedBlankNodeHash({
              quad,
              component: quad.object,
              position: "o",
              id,
              issuer,
              hashToRelated
            }),
            this._addRelatedBlankNodeHash({
              quad,
              component: quad.graph,
              position: "g",
              id,
              issuer,
              hashToRelated
            })
          ]);
        }
        return hashToRelated;
      }
      async _hashAndTrackBlankNode({ id, hashToBlankNodes }) {
        const hash = await this.hashFirstDegreeQuads(id);
        const idList = hashToBlankNodes.get(hash);
        if (!idList) {
          hashToBlankNodes.set(hash, [id]);
        } else {
          idList.push(id);
        }
      }
      _addBlankNodeQuadInfo({ quad, component }) {
        if (component.termType !== "BlankNode") {
          return;
        }
        const id = component.value;
        const info = this.blankNodeInfo.get(id);
        if (info) {
          info.quads.add(quad);
        } else {
          this.blankNodeInfo.set(id, { quads: /* @__PURE__ */ new Set([quad]), hash: null });
        }
      }
      async _addRelatedBlankNodeHash({ quad, component, position, id, issuer, hashToRelated }) {
        if (!(component.termType === "BlankNode" && component.value !== id)) {
          return;
        }
        const related = component.value;
        const hash = await this.hashRelatedBlankNode(
          related,
          quad,
          issuer,
          position
        );
        const entries = hashToRelated.get(hash);
        if (entries) {
          entries.push(related);
        } else {
          hashToRelated.set(hash, [related]);
        }
      }
      _useCanonicalId({ component }) {
        if (component.termType === "BlankNode" && !component.value.startsWith(this.canonicalIssuer.prefix)) {
          return {
            termType: "BlankNode",
            value: this.canonicalIssuer.getId(component.value)
          };
        }
        return component;
      }
      async _yield() {
        return new Promise((resolve) => setImmediate(resolve));
      }
    };
    function _stringHashCompare(a, b) {
      return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;
    }
  }
});

// node_modules/@digitalcredentials/rdf-canonize/lib/URGNA2012.js
var require_URGNA2012 = __commonJS({
  "node_modules/@digitalcredentials/rdf-canonize/lib/URGNA2012.js"(exports, module) {
    "use strict";
    var URDNA2015 = require_URDNA2015();
    module.exports = class URDNA2012 extends URDNA2015 {
      constructor() {
        super();
        this.name = "URGNA2012";
        this.hashAlgorithm = "sha1";
      }
      // helper for modifying component during Hash First Degree Quads
      modifyFirstDegreeComponent(id, component, key) {
        if (component.termType !== "BlankNode") {
          return component;
        }
        if (key === "graph") {
          return {
            termType: "BlankNode",
            value: "_:g"
          };
        }
        return {
          termType: "BlankNode",
          value: component.value === id ? "_:a" : "_:z"
        };
      }
      // helper for getting a related predicate
      getRelatedPredicate(quad) {
        return quad.predicate.value;
      }
      // helper for creating hash to related blank nodes map
      async createHashToRelated(id, issuer) {
        const hashToRelated = /* @__PURE__ */ new Map();
        const quads = this.blankNodeInfo.get(id).quads;
        let i = 0;
        for (const quad of quads) {
          let position;
          let related;
          if (quad.subject.termType === "BlankNode" && quad.subject.value !== id) {
            related = quad.subject.value;
            position = "p";
          } else if (quad.object.termType === "BlankNode" && quad.object.value !== id) {
            related = quad.object.value;
            position = "r";
          } else {
            continue;
          }
          if (++i % 100 === 0) {
            await this._yield();
          }
          const hash = await this.hashRelatedBlankNode(
            related,
            quad,
            issuer,
            position
          );
          const entries = hashToRelated.get(hash);
          if (entries) {
            entries.push(related);
          } else {
            hashToRelated.set(hash, [related]);
          }
        }
        return hashToRelated;
      }
    };
  }
});

// node_modules/@digitalcredentials/rdf-canonize/lib/URDNA2015Sync.js
var require_URDNA2015Sync = __commonJS({
  "node_modules/@digitalcredentials/rdf-canonize/lib/URDNA2015Sync.js"(exports, module) {
    "use strict";
    var IdentifierIssuer = require_IdentifierIssuer();
    var MessageDigest = require_MessageDigest_browser();
    var Permuter = require_Permuter();
    var NQuads = require_NQuads();
    module.exports = class URDNA2015Sync {
      constructor() {
        this.name = "URDNA2015";
        this.blankNodeInfo = /* @__PURE__ */ new Map();
        this.canonicalIssuer = new IdentifierIssuer("_:c14n");
        this.hashAlgorithm = "sha256";
        this.quads = null;
      }
      // 4.4) Normalization Algorithm
      main(dataset) {
        this.quads = dataset;
        for (const quad of dataset) {
          this._addBlankNodeQuadInfo({ quad, component: quad.subject });
          this._addBlankNodeQuadInfo({ quad, component: quad.object });
          this._addBlankNodeQuadInfo({ quad, component: quad.graph });
        }
        const hashToBlankNodes = /* @__PURE__ */ new Map();
        const nonNormalized = [...this.blankNodeInfo.keys()];
        for (const id of nonNormalized) {
          this._hashAndTrackBlankNode({ id, hashToBlankNodes });
        }
        const hashes = [...hashToBlankNodes.keys()].sort();
        const nonUnique = [];
        for (const hash of hashes) {
          const idList = hashToBlankNodes.get(hash);
          if (idList.length > 1) {
            nonUnique.push(idList);
            continue;
          }
          const id = idList[0];
          this.canonicalIssuer.getId(id);
        }
        for (const idList of nonUnique) {
          const hashPathList = [];
          for (const id of idList) {
            if (this.canonicalIssuer.hasId(id)) {
              continue;
            }
            const issuer = new IdentifierIssuer("_:b");
            issuer.getId(id);
            const result2 = this.hashNDegreeQuads(id, issuer);
            hashPathList.push(result2);
          }
          hashPathList.sort(_stringHashCompare);
          for (const result2 of hashPathList) {
            const oldIds = result2.issuer.getOldIds();
            for (const id of oldIds) {
              this.canonicalIssuer.getId(id);
            }
          }
        }
        const normalized = [];
        for (const quad of this.quads) {
          const q = { ...quad };
          q.subject = this._useCanonicalId({ component: q.subject });
          q.object = this._useCanonicalId({ component: q.object });
          q.graph = this._useCanonicalId({ component: q.graph });
          normalized.push(NQuads.serializeQuad(q));
        }
        normalized.sort();
        return normalized.join("");
      }
      // 4.6) Hash First Degree Quads
      hashFirstDegreeQuads(id) {
        const nquads = [];
        const info = this.blankNodeInfo.get(id);
        const quads = info.quads;
        for (const quad of quads) {
          const copy = {
            subject: null,
            predicate: quad.predicate,
            object: null,
            graph: null
          };
          copy.subject = this.modifyFirstDegreeComponent(
            id,
            quad.subject,
            "subject"
          );
          copy.object = this.modifyFirstDegreeComponent(
            id,
            quad.object,
            "object"
          );
          copy.graph = this.modifyFirstDegreeComponent(
            id,
            quad.graph,
            "graph"
          );
          nquads.push(NQuads.serializeQuad(copy));
        }
        nquads.sort();
        const md = new MessageDigest(this.hashAlgorithm);
        for (const nquad of nquads) {
          md.update(nquad);
        }
        info.hash = md.digest();
        return info.hash;
      }
      // 4.7) Hash Related Blank Node
      hashRelatedBlankNode(related, quad, issuer, position) {
        let id;
        if (this.canonicalIssuer.hasId(related)) {
          id = this.canonicalIssuer.getId(related);
        } else if (issuer.hasId(related)) {
          id = issuer.getId(related);
        } else {
          id = this.blankNodeInfo.get(related).hash;
        }
        const md = new MessageDigest(this.hashAlgorithm);
        md.update(position);
        if (position !== "g") {
          md.update(this.getRelatedPredicate(quad));
        }
        md.update(id);
        return md.digest();
      }
      // 4.8) Hash N-Degree Quads
      hashNDegreeQuads(id, issuer) {
        const md = new MessageDigest(this.hashAlgorithm);
        const hashToRelated = this.createHashToRelated(id, issuer);
        const hashes = [...hashToRelated.keys()].sort();
        for (const hash of hashes) {
          md.update(hash);
          let chosenPath = "";
          let chosenIssuer;
          const permuter = new Permuter(hashToRelated.get(hash));
          while (permuter.hasNext()) {
            const permutation = permuter.next();
            let issuerCopy = issuer.clone();
            let path = "";
            const recursionList = [];
            let nextPermutation = false;
            for (const related of permutation) {
              if (this.canonicalIssuer.hasId(related)) {
                path += this.canonicalIssuer.getId(related);
              } else {
                if (!issuerCopy.hasId(related)) {
                  recursionList.push(related);
                }
                path += issuerCopy.getId(related);
              }
              if (chosenPath.length !== 0 && path > chosenPath) {
                nextPermutation = true;
                break;
              }
            }
            if (nextPermutation) {
              continue;
            }
            for (const related of recursionList) {
              const result2 = this.hashNDegreeQuads(related, issuerCopy);
              path += issuerCopy.getId(related);
              path += `<${result2.hash}>`;
              issuerCopy = result2.issuer;
              if (chosenPath.length !== 0 && path > chosenPath) {
                nextPermutation = true;
                break;
              }
            }
            if (nextPermutation) {
              continue;
            }
            if (chosenPath.length === 0 || path < chosenPath) {
              chosenPath = path;
              chosenIssuer = issuerCopy;
            }
          }
          md.update(chosenPath);
          issuer = chosenIssuer;
        }
        return { hash: md.digest(), issuer };
      }
      // helper for modifying component during Hash First Degree Quads
      modifyFirstDegreeComponent(id, component) {
        if (component.termType !== "BlankNode") {
          return component;
        }
        return {
          termType: "BlankNode",
          value: component.value === id ? "_:a" : "_:z"
        };
      }
      // helper for getting a related predicate
      getRelatedPredicate(quad) {
        return `<${quad.predicate.value}>`;
      }
      // helper for creating hash to related blank nodes map
      createHashToRelated(id, issuer) {
        const hashToRelated = /* @__PURE__ */ new Map();
        const quads = this.blankNodeInfo.get(id).quads;
        for (const quad of quads) {
          this._addRelatedBlankNodeHash({
            quad,
            component: quad.subject,
            position: "s",
            id,
            issuer,
            hashToRelated
          });
          this._addRelatedBlankNodeHash({
            quad,
            component: quad.object,
            position: "o",
            id,
            issuer,
            hashToRelated
          });
          this._addRelatedBlankNodeHash({
            quad,
            component: quad.graph,
            position: "g",
            id,
            issuer,
            hashToRelated
          });
        }
        return hashToRelated;
      }
      _hashAndTrackBlankNode({ id, hashToBlankNodes }) {
        const hash = this.hashFirstDegreeQuads(id);
        const idList = hashToBlankNodes.get(hash);
        if (!idList) {
          hashToBlankNodes.set(hash, [id]);
        } else {
          idList.push(id);
        }
      }
      _addBlankNodeQuadInfo({ quad, component }) {
        if (component.termType !== "BlankNode") {
          return;
        }
        const id = component.value;
        const info = this.blankNodeInfo.get(id);
        if (info) {
          info.quads.add(quad);
        } else {
          this.blankNodeInfo.set(id, { quads: /* @__PURE__ */ new Set([quad]), hash: null });
        }
      }
      _addRelatedBlankNodeHash({ quad, component, position, id, issuer, hashToRelated }) {
        if (!(component.termType === "BlankNode" && component.value !== id)) {
          return;
        }
        const related = component.value;
        const hash = this.hashRelatedBlankNode(related, quad, issuer, position);
        const entries = hashToRelated.get(hash);
        if (entries) {
          entries.push(related);
        } else {
          hashToRelated.set(hash, [related]);
        }
      }
      _useCanonicalId({ component }) {
        if (component.termType === "BlankNode" && !component.value.startsWith(this.canonicalIssuer.prefix)) {
          return {
            termType: "BlankNode",
            value: this.canonicalIssuer.getId(component.value)
          };
        }
        return component;
      }
    };
    function _stringHashCompare(a, b) {
      return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;
    }
  }
});

// node_modules/@digitalcredentials/rdf-canonize/lib/URGNA2012Sync.js
var require_URGNA2012Sync = __commonJS({
  "node_modules/@digitalcredentials/rdf-canonize/lib/URGNA2012Sync.js"(exports, module) {
    "use strict";
    var URDNA2015Sync = require_URDNA2015Sync();
    module.exports = class URDNA2012Sync extends URDNA2015Sync {
      constructor() {
        super();
        this.name = "URGNA2012";
        this.hashAlgorithm = "sha1";
      }
      // helper for modifying component during Hash First Degree Quads
      modifyFirstDegreeComponent(id, component, key) {
        if (component.termType !== "BlankNode") {
          return component;
        }
        if (key === "graph") {
          return {
            termType: "BlankNode",
            value: "_:g"
          };
        }
        return {
          termType: "BlankNode",
          value: component.value === id ? "_:a" : "_:z"
        };
      }
      // helper for getting a related predicate
      getRelatedPredicate(quad) {
        return quad.predicate.value;
      }
      // helper for creating hash to related blank nodes map
      createHashToRelated(id, issuer) {
        const hashToRelated = /* @__PURE__ */ new Map();
        const quads = this.blankNodeInfo.get(id).quads;
        for (const quad of quads) {
          let position;
          let related;
          if (quad.subject.termType === "BlankNode" && quad.subject.value !== id) {
            related = quad.subject.value;
            position = "p";
          } else if (quad.object.termType === "BlankNode" && quad.object.value !== id) {
            related = quad.object.value;
            position = "r";
          } else {
            continue;
          }
          const hash = this.hashRelatedBlankNode(related, quad, issuer, position);
          const entries = hashToRelated.get(hash);
          if (entries) {
            entries.push(related);
          } else {
            hashToRelated.set(hash, [related]);
          }
        }
        return hashToRelated;
      }
    };
  }
});

// browser-external:rdf-canonize-native
var require_rdf_canonize_native = __commonJS({
  "browser-external:rdf-canonize-native"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "rdf-canonize-native" has been externalized for browser compatibility. Cannot access "rdf-canonize-native.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@digitalcredentials/rdf-canonize/lib/index.js
var require_lib = __commonJS({
  "node_modules/@digitalcredentials/rdf-canonize/lib/index.js"(exports, module) {
    "use strict";
    var URDNA2015 = require_URDNA2015();
    var URGNA2012 = require_URGNA2012();
    var URDNA2015Sync = require_URDNA2015Sync();
    var URGNA2012Sync = require_URGNA2012Sync();
    var rdfCanonizeNative;
    try {
      rdfCanonizeNative = require_rdf_canonize_native();
    } catch (e) {
    }
    var api = {};
    module.exports = api;
    api.NQuads = require_NQuads();
    api.IdentifierIssuer = require_IdentifierIssuer();
    api._rdfCanonizeNative = function(api2) {
      if (api2) {
        rdfCanonizeNative = api2;
      }
      return rdfCanonizeNative;
    };
    api.canonize = async function(dataset, options) {
      if (!Array.isArray(dataset)) {
        dataset = api.NQuads.legacyDatasetToQuads(dataset);
      }
      if (options.useNative) {
        if (!rdfCanonizeNative) {
          throw new Error("rdf-canonize-native not available");
        }
        return new Promise((resolve, reject) => rdfCanonizeNative.canonize(dataset, options, (err, canonical) => err ? reject(err) : resolve(canonical)));
      }
      if (options.algorithm === "URDNA2015") {
        return new URDNA2015(options).main(dataset);
      }
      if (options.algorithm === "URGNA2012") {
        return new URGNA2012(options).main(dataset);
      }
      if (!("algorithm" in options)) {
        throw new Error("No RDF Dataset Canonicalization algorithm specified.");
      }
      throw new Error(
        "Invalid RDF Dataset Canonicalization algorithm: " + options.algorithm
      );
    };
    api._canonizeSync = function(dataset, options) {
      if (!Array.isArray(dataset)) {
        dataset = api.NQuads.legacyDatasetToQuads(dataset);
      }
      if (options.useNative) {
        if (rdfCanonizeNative) {
          return rdfCanonizeNative.canonizeSync(dataset, options);
        }
        throw new Error("rdf-canonize-native not available");
      }
      if (options.algorithm === "URDNA2015") {
        return new URDNA2015Sync(options).main(dataset);
      }
      if (options.algorithm === "URGNA2012") {
        return new URGNA2012Sync(options).main(dataset);
      }
      if (!("algorithm" in options)) {
        throw new Error("No RDF Dataset Canonicalization algorithm specified.");
      }
      throw new Error(
        "Invalid RDF Dataset Canonicalization algorithm: " + options.algorithm
      );
    };
  }
});

// node_modules/@digitalcredentials/rdf-canonize/index.js
var require_rdf_canonize = __commonJS({
  "node_modules/@digitalcredentials/rdf-canonize/index.js"(exports, module) {
    module.exports = require_lib();
  }
});

// node_modules/@digitalcredentials/jsonld/lib/types.js
var require_types5 = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/types.js"(exports, module) {
    "use strict";
    var api = {};
    module.exports = api;
    api.isArray = Array.isArray;
    api.isBoolean = (v) => typeof v === "boolean" || Object.prototype.toString.call(v) === "[object Boolean]";
    api.isDouble = (v) => api.isNumber(v) && (String(v).indexOf(".") !== -1 || Math.abs(v) >= 1e21);
    api.isEmptyObject = (v) => api.isObject(v) && Object.keys(v).length === 0;
    api.isNumber = (v) => typeof v === "number" || Object.prototype.toString.call(v) === "[object Number]";
    api.isNumeric = (v) => !isNaN(parseFloat(v)) && isFinite(v);
    api.isObject = (v) => Object.prototype.toString.call(v) === "[object Object]";
    api.isString = (v) => typeof v === "string" || Object.prototype.toString.call(v) === "[object String]";
    api.isUndefined = (v) => typeof v === "undefined";
  }
});

// node_modules/@digitalcredentials/jsonld/lib/graphTypes.js
var require_graphTypes = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/graphTypes.js"(exports, module) {
    "use strict";
    var types = require_types5();
    var api = {};
    module.exports = api;
    api.isSubject = (v) => {
      if (types.isObject(v) && !("@value" in v || "@set" in v || "@list" in v)) {
        const keyCount = Object.keys(v).length;
        return keyCount > 1 || !("@id" in v);
      }
      return false;
    };
    api.isSubjectReference = (v) => (
      // Note: A value is a subject reference if all of these hold true:
      // 1. It is an Object.
      // 2. It has a single key: @id.
      types.isObject(v) && Object.keys(v).length === 1 && "@id" in v
    );
    api.isValue = (v) => (
      // Note: A value is a @value if all of these hold true:
      // 1. It is an Object.
      // 2. It has the @value property.
      types.isObject(v) && "@value" in v
    );
    api.isList = (v) => (
      // Note: A value is a @list if all of these hold true:
      // 1. It is an Object.
      // 2. It has the @list property.
      types.isObject(v) && "@list" in v
    );
    api.isGraph = (v) => {
      return types.isObject(v) && "@graph" in v && Object.keys(v).filter((key) => key !== "@id" && key !== "@index").length === 1;
    };
    api.isSimpleGraph = (v) => {
      return api.isGraph(v) && !("@id" in v);
    };
    api.isBlankNode = (v) => {
      if (types.isObject(v)) {
        if ("@id" in v) {
          return v["@id"].indexOf("_:") === 0;
        }
        return Object.keys(v).length === 0 || !("@value" in v || "@set" in v || "@list" in v);
      }
      return false;
    };
  }
});

// node_modules/@digitalcredentials/jsonld/lib/JsonLdError.js
var require_JsonLdError = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/JsonLdError.js"(exports, module) {
    "use strict";
    module.exports = class JsonLdError extends Error {
      /**
       * Creates a JSON-LD Error.
       *
       * @param msg the error message.
       * @param type the error type.
       * @param details the error details.
       */
      constructor(message = "An unspecified JSON-LD error occurred.", name = "jsonld.Error", details = {}) {
        super(message);
        this.name = name;
        this.message = message;
        this.details = details;
      }
    };
  }
});

// node_modules/@digitalcredentials/jsonld/lib/util.js
var require_util3 = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/util.js"(exports, module) {
    "use strict";
    var graphTypes = require_graphTypes();
    var types = require_types5();
    var IdentifierIssuer = require_rdf_canonize().IdentifierIssuer;
    var JsonLdError = require_JsonLdError();
    var REGEX_LINK_HEADERS = /(?:<[^>]*?>|"[^"]*?"|[^,])+/g;
    var REGEX_LINK_HEADER = /\s*<([^>]*?)>\s*(?:;\s*(.*))?/;
    var REGEX_LINK_HEADER_PARAMS = /(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g;
    var DEFAULTS = {
      headers: {
        accept: "application/ld+json, application/json"
      }
    };
    var api = {};
    module.exports = api;
    api.IdentifierIssuer = IdentifierIssuer;
    api.clone = function(value) {
      if (value && typeof value === "object") {
        let rval;
        if (types.isArray(value)) {
          rval = [];
          for (let i = 0; i < value.length; ++i) {
            rval[i] = api.clone(value[i]);
          }
        } else if (value instanceof Map) {
          rval = /* @__PURE__ */ new Map();
          for (const [k, v] of value) {
            rval.set(k, api.clone(v));
          }
        } else if (value instanceof Set) {
          rval = /* @__PURE__ */ new Set();
          for (const v of value) {
            rval.add(api.clone(v));
          }
        } else if (types.isObject(value)) {
          rval = {};
          for (const key in value) {
            rval[key] = api.clone(value[key]);
          }
        } else {
          rval = value.toString();
        }
        return rval;
      }
      return value;
    };
    api.asArray = function(value) {
      return Array.isArray(value) ? value : [value];
    };
    api.buildHeaders = (headers = {}) => {
      const hasAccept = Object.keys(headers).some(
        (h) => h.toLowerCase() === "accept"
      );
      if (hasAccept) {
        throw new RangeError(
          'Accept header may not be specified; only "' + DEFAULTS.headers.accept + '" is supported.'
        );
      }
      return Object.assign({ Accept: DEFAULTS.headers.accept }, headers);
    };
    api.parseLinkHeader = (header) => {
      const rval = {};
      const entries = header.match(REGEX_LINK_HEADERS);
      for (let i = 0; i < entries.length; ++i) {
        let match = entries[i].match(REGEX_LINK_HEADER);
        if (!match) {
          continue;
        }
        const result2 = { target: match[1] };
        const params = match[2];
        while (match = REGEX_LINK_HEADER_PARAMS.exec(params)) {
          result2[match[1]] = match[2] === void 0 ? match[3] : match[2];
        }
        const rel = result2.rel || "";
        if (Array.isArray(rval[rel])) {
          rval[rel].push(result2);
        } else if (rval.hasOwnProperty(rel)) {
          rval[rel] = [rval[rel], result2];
        } else {
          rval[rel] = result2;
        }
      }
      return rval;
    };
    api.validateTypeValue = (v, isFrame) => {
      if (types.isString(v)) {
        return;
      }
      if (types.isArray(v) && v.every((vv) => types.isString(vv))) {
        return;
      }
      if (isFrame && types.isObject(v)) {
        switch (Object.keys(v).length) {
          case 0:
            return;
          case 1:
            if ("@default" in v && api.asArray(v["@default"]).every((vv) => types.isString(vv))) {
              return;
            }
        }
      }
      throw new JsonLdError(
        'Invalid JSON-LD syntax; "@type" value must a string, an array of strings, an empty object, or a default object.',
        "jsonld.SyntaxError",
        { code: "invalid type value", value: v }
      );
    };
    api.hasProperty = (subject, property) => {
      if (subject.hasOwnProperty(property)) {
        const value = subject[property];
        return !types.isArray(value) || value.length > 0;
      }
      return false;
    };
    api.hasValue = (subject, property, value) => {
      if (api.hasProperty(subject, property)) {
        let val = subject[property];
        const isList = graphTypes.isList(val);
        if (types.isArray(val) || isList) {
          if (isList) {
            val = val["@list"];
          }
          for (let i = 0; i < val.length; ++i) {
            if (api.compareValues(value, val[i])) {
              return true;
            }
          }
        } else if (!types.isArray(value)) {
          return api.compareValues(value, val);
        }
      }
      return false;
    };
    api.addValue = (subject, property, value, options) => {
      options = options || {};
      if (!("propertyIsArray" in options)) {
        options.propertyIsArray = false;
      }
      if (!("valueIsArray" in options)) {
        options.valueIsArray = false;
      }
      if (!("allowDuplicate" in options)) {
        options.allowDuplicate = true;
      }
      if (!("prependValue" in options)) {
        options.prependValue = false;
      }
      if (options.valueIsArray) {
        subject[property] = value;
      } else if (types.isArray(value)) {
        if (value.length === 0 && options.propertyIsArray && !subject.hasOwnProperty(property)) {
          subject[property] = [];
        }
        if (options.prependValue) {
          value = value.concat(subject[property]);
          subject[property] = [];
        }
        for (let i = 0; i < value.length; ++i) {
          api.addValue(subject, property, value[i], options);
        }
      } else if (subject.hasOwnProperty(property)) {
        const hasValue = !options.allowDuplicate && api.hasValue(subject, property, value);
        if (!types.isArray(subject[property]) && (!hasValue || options.propertyIsArray)) {
          subject[property] = [subject[property]];
        }
        if (!hasValue) {
          if (options.prependValue) {
            subject[property].unshift(value);
          } else {
            subject[property].push(value);
          }
        }
      } else {
        subject[property] = options.propertyIsArray ? [value] : value;
      }
    };
    api.getValues = (subject, property) => [].concat(subject[property] || []);
    api.removeProperty = (subject, property) => {
      delete subject[property];
    };
    api.removeValue = (subject, property, value, options) => {
      options = options || {};
      if (!("propertyIsArray" in options)) {
        options.propertyIsArray = false;
      }
      const values = api.getValues(subject, property).filter(
        (e) => !api.compareValues(e, value)
      );
      if (values.length === 0) {
        api.removeProperty(subject, property);
      } else if (values.length === 1 && !options.propertyIsArray) {
        subject[property] = values[0];
      } else {
        subject[property] = values;
      }
    };
    api.relabelBlankNodes = (input, options) => {
      options = options || {};
      const issuer = options.issuer || new IdentifierIssuer("_:b");
      return _labelBlankNodes(issuer, input);
    };
    api.compareValues = (v12, v2) => {
      if (v12 === v2) {
        return true;
      }
      if (graphTypes.isValue(v12) && graphTypes.isValue(v2) && v12["@value"] === v2["@value"] && v12["@type"] === v2["@type"] && v12["@language"] === v2["@language"] && v12["@index"] === v2["@index"]) {
        return true;
      }
      if (types.isObject(v12) && "@id" in v12 && types.isObject(v2) && "@id" in v2) {
        return v12["@id"] === v2["@id"];
      }
      return false;
    };
    api.compareShortestLeast = (a, b) => {
      if (a.length < b.length) {
        return -1;
      }
      if (b.length < a.length) {
        return 1;
      }
      if (a === b) {
        return 0;
      }
      return a < b ? -1 : 1;
    };
    function _labelBlankNodes(issuer, element) {
      if (types.isArray(element)) {
        for (let i = 0; i < element.length; ++i) {
          element[i] = _labelBlankNodes(issuer, element[i]);
        }
      } else if (graphTypes.isList(element)) {
        element["@list"] = _labelBlankNodes(issuer, element["@list"]);
      } else if (types.isObject(element)) {
        if (graphTypes.isBlankNode(element)) {
          element["@id"] = issuer.getId(element["@id"]);
        }
        const keys = Object.keys(element).sort();
        for (let ki = 0; ki < keys.length; ++ki) {
          const key = keys[ki];
          if (key !== "@id") {
            element[key] = _labelBlankNodes(issuer, element[key]);
          }
        }
      }
      return element;
    }
  }
});

// node_modules/@digitalcredentials/jsonld/lib/constants.js
var require_constants6 = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/constants.js"(exports, module) {
    "use strict";
    var RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
    var XSD = "http://www.w3.org/2001/XMLSchema#";
    module.exports = {
      // TODO: Deprecated and will be removed later. Use LINK_HEADER_CONTEXT.
      LINK_HEADER_REL: "http://www.w3.org/ns/json-ld#context",
      LINK_HEADER_CONTEXT: "http://www.w3.org/ns/json-ld#context",
      RDF,
      RDF_LIST: RDF + "List",
      RDF_FIRST: RDF + "first",
      RDF_REST: RDF + "rest",
      RDF_NIL: RDF + "nil",
      RDF_TYPE: RDF + "type",
      RDF_PLAIN_LITERAL: RDF + "PlainLiteral",
      RDF_XML_LITERAL: RDF + "XMLLiteral",
      RDF_JSON_LITERAL: RDF + "JSON",
      RDF_OBJECT: RDF + "object",
      RDF_LANGSTRING: RDF + "langString",
      XSD,
      XSD_BOOLEAN: XSD + "boolean",
      XSD_DOUBLE: XSD + "double",
      XSD_INTEGER: XSD + "integer",
      XSD_STRING: XSD + "string"
    };
  }
});

// node_modules/@digitalcredentials/jsonld/lib/RequestQueue.js
var require_RequestQueue = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/RequestQueue.js"(exports, module) {
    "use strict";
    module.exports = class RequestQueue {
      /**
       * Creates a simple queue for requesting documents.
       */
      constructor() {
        this._requests = {};
      }
      wrapLoader(loader) {
        const self2 = this;
        self2._loader = loader;
        return function() {
          return self2.add.apply(self2, arguments);
        };
      }
      async add(url) {
        let promise = this._requests[url];
        if (promise) {
          return Promise.resolve(promise);
        }
        promise = this._requests[url] = this._loader(url);
        try {
          return await promise;
        } finally {
          delete this._requests[url];
        }
      }
    };
  }
});

// node_modules/@digitalcredentials/jsonld/lib/url.js
var require_url = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/url.js"(exports, module) {
    "use strict";
    var types = require_types5();
    var api = {};
    module.exports = api;
    api.parsers = {
      simple: {
        // RFC 3986 basic parts
        keys: [
          "href",
          "scheme",
          "authority",
          "path",
          "query",
          "fragment"
        ],
        /* eslint-disable-next-line max-len */
        regex: /^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/
      },
      full: {
        keys: [
          "href",
          "protocol",
          "scheme",
          "authority",
          "auth",
          "user",
          "password",
          "hostname",
          "port",
          "path",
          "directory",
          "file",
          "query",
          "fragment"
        ],
        /* eslint-disable-next-line max-len */
        regex: /^(([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/
      }
    };
    api.parse = (str, parser) => {
      const parsed = {};
      const o = api.parsers[parser || "full"];
      const m = o.regex.exec(str);
      let i = o.keys.length;
      while (i--) {
        parsed[o.keys[i]] = m[i] === void 0 ? null : m[i];
      }
      if (parsed.scheme === "https" && parsed.port === "443" || parsed.scheme === "http" && parsed.port === "80") {
        parsed.href = parsed.href.replace(":" + parsed.port, "");
        parsed.authority = parsed.authority.replace(":" + parsed.port, "");
        parsed.port = null;
      }
      parsed.normalizedPath = api.removeDotSegments(parsed.path);
      return parsed;
    };
    api.prependBase = (base, iri) => {
      if (base === null) {
        return iri;
      }
      if (api.isAbsolute(iri)) {
        return iri;
      }
      if (!base || types.isString(base)) {
        base = api.parse(base || "");
      }
      const rel = api.parse(iri);
      const transform = {
        protocol: base.protocol || ""
      };
      if (rel.authority !== null) {
        transform.authority = rel.authority;
        transform.path = rel.path;
        transform.query = rel.query;
      } else {
        transform.authority = base.authority;
        if (rel.path === "") {
          transform.path = base.path;
          if (rel.query !== null) {
            transform.query = rel.query;
          } else {
            transform.query = base.query;
          }
        } else {
          if (rel.path.indexOf("/") === 0) {
            transform.path = rel.path;
          } else {
            let path = base.path;
            path = path.substr(0, path.lastIndexOf("/") + 1);
            if ((path.length > 0 || base.authority) && path.substr(-1) !== "/") {
              path += "/";
            }
            path += rel.path;
            transform.path = path;
          }
          transform.query = rel.query;
        }
      }
      if (rel.path !== "") {
        transform.path = api.removeDotSegments(transform.path);
      }
      let rval = transform.protocol;
      if (transform.authority !== null) {
        rval += "//" + transform.authority;
      }
      rval += transform.path;
      if (transform.query !== null) {
        rval += "?" + transform.query;
      }
      if (rel.fragment !== null) {
        rval += "#" + rel.fragment;
      }
      if (rval === "") {
        rval = "./";
      }
      return rval;
    };
    api.removeBase = (base, iri) => {
      if (base === null) {
        return iri;
      }
      if (!base || types.isString(base)) {
        base = api.parse(base || "");
      }
      let root = "";
      if (base.href !== "") {
        root += (base.protocol || "") + "//" + (base.authority || "");
      } else if (iri.indexOf("//")) {
        root += "//";
      }
      if (iri.indexOf(root) !== 0) {
        return iri;
      }
      const rel = api.parse(iri.substr(root.length));
      const baseSegments = base.normalizedPath.split("/");
      const iriSegments = rel.normalizedPath.split("/");
      const last = rel.fragment || rel.query ? 0 : 1;
      while (baseSegments.length > 0 && iriSegments.length > last) {
        if (baseSegments[0] !== iriSegments[0]) {
          break;
        }
        baseSegments.shift();
        iriSegments.shift();
      }
      let rval = "";
      if (baseSegments.length > 0) {
        baseSegments.pop();
        for (let i = 0; i < baseSegments.length; ++i) {
          rval += "../";
        }
      }
      rval += iriSegments.join("/");
      if (rel.query !== null) {
        rval += "?" + rel.query;
      }
      if (rel.fragment !== null) {
        rval += "#" + rel.fragment;
      }
      if (rval === "") {
        rval = "./";
      }
      return rval;
    };
    api.removeDotSegments = (path) => {
      if (path.length === 0) {
        return "";
      }
      const input = path.split("/");
      const output = [];
      while (input.length > 0) {
        const next = input.shift();
        const done = input.length === 0;
        if (next === ".") {
          if (done) {
            output.push("");
          }
          continue;
        }
        if (next === "..") {
          output.pop();
          if (done) {
            output.push("");
          }
          continue;
        }
        output.push(next);
      }
      if (path[0] === "/" && output.length > 0 && output[0] !== "") {
        output.unshift("");
      }
      if (output.length === 1 && output[0] === "") {
        return "/";
      }
      return output.join("/");
    };
    var isAbsoluteRegex = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;
    api.isAbsolute = (v) => types.isString(v) && isAbsoluteRegex.test(v);
    api.isRelative = (v) => types.isString(v);
  }
});

// node_modules/@digitalcredentials/jsonld/lib/documentLoaders/xhr.js
var require_xhr = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/documentLoaders/xhr.js"(exports, module) {
    "use strict";
    var { parseLinkHeader, buildHeaders } = require_util3();
    var { LINK_HEADER_CONTEXT } = require_constants6();
    var JsonLdError = require_JsonLdError();
    var RequestQueue = require_RequestQueue();
    var { prependBase } = require_url();
    var REGEX_LINK_HEADER = /(^|(\r\n))link:/i;
    module.exports = ({
      secure,
      headers = {},
      xhr
    } = { headers: {} }) => {
      headers = buildHeaders(headers);
      const queue = new RequestQueue();
      return queue.wrapLoader(loader);
      async function loader(url) {
        if (url.indexOf("http:") !== 0 && url.indexOf("https:") !== 0) {
          throw new JsonLdError(
            'URL could not be dereferenced; only "http" and "https" URLs are supported.',
            "jsonld.InvalidUrl",
            { code: "loading document failed", url }
          );
        }
        if (secure && url.indexOf("https") !== 0) {
          throw new JsonLdError(
            `URL could not be dereferenced; secure mode is enabled and the URL's scheme is not "https".`,
            "jsonld.InvalidUrl",
            { code: "loading document failed", url }
          );
        }
        let req;
        try {
          req = await _get(xhr, url, headers);
        } catch (e) {
          throw new JsonLdError(
            "URL could not be dereferenced, an error occurred.",
            "jsonld.LoadDocumentError",
            { code: "loading document failed", url, cause: e }
          );
        }
        if (req.status >= 400) {
          throw new JsonLdError(
            "URL could not be dereferenced: " + req.statusText,
            "jsonld.LoadDocumentError",
            {
              code: "loading document failed",
              url,
              httpStatusCode: req.status
            }
          );
        }
        let doc = { contextUrl: null, documentUrl: url, document: req.response };
        let alternate = null;
        const contentType = req.getResponseHeader("Content-Type");
        let linkHeader;
        if (REGEX_LINK_HEADER.test(req.getAllResponseHeaders())) {
          linkHeader = req.getResponseHeader("Link");
        }
        if (linkHeader && contentType !== "application/ld+json") {
          const linkHeaders = parseLinkHeader(linkHeader);
          const linkedContext = linkHeaders[LINK_HEADER_CONTEXT];
          if (Array.isArray(linkedContext)) {
            throw new JsonLdError(
              "URL could not be dereferenced, it has more than one associated HTTP Link Header.",
              "jsonld.InvalidUrl",
              { code: "multiple context link headers", url }
            );
          }
          if (linkedContext) {
            doc.contextUrl = linkedContext.target;
          }
          alternate = linkHeaders["alternate"];
          if (alternate && alternate.type == "application/ld+json" && !(contentType || "").match(/^application\/(\w*\+)?json$/)) {
            doc = await loader(prependBase(url, alternate.target));
          }
        }
        return doc;
      }
    };
    function _get(xhr, url, headers) {
      xhr = xhr || XMLHttpRequest;
      const req = new xhr();
      return new Promise((resolve, reject) => {
        req.onload = () => resolve(req);
        req.onerror = (err) => reject(err);
        req.open("GET", url, true);
        for (const k in headers) {
          req.setRequestHeader(k, headers[k]);
        }
        req.send();
      });
    }
  }
});

// node_modules/@digitalcredentials/jsonld/lib/platform-browser.js
var require_platform_browser = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/platform-browser.js"(exports, module) {
    "use strict";
    var xhrLoader = require_xhr();
    var api = {};
    module.exports = api;
    api.setupDocumentLoaders = function(jsonld2) {
      if (typeof XMLHttpRequest !== "undefined") {
        jsonld2.documentLoaders.xhr = xhrLoader;
        jsonld2.useDocumentLoader("xhr");
      }
    };
    api.setupGlobals = function(jsonld2) {
      if (typeof globalThis.JsonLdProcessor === "undefined") {
        Object.defineProperty(globalThis, "JsonLdProcessor", {
          writable: true,
          enumerable: false,
          configurable: true,
          value: jsonld2.JsonLdProcessor
        });
      }
    };
  }
});

// node_modules/yallist/iterator.js
var require_iterator2 = __commonJS({
  "node_modules/yallist/iterator.js"(exports, module) {
    "use strict";
    module.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/yallist/yallist.js"(exports, module) {
    "use strict";
    module.exports = Yallist;
    Yallist.Node = Node3;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node3(value, null, node, self2) : new Node3(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node3(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node3(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node3(value, prev, next, list) {
      if (!(this instanceof Node3)) {
        return new Node3(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator2()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/lru-cache/index.js"(exports, module) {
    "use strict";
    var Yallist = require_yallist();
    var MAX2 = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache2 = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max2 = this[MAX2] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX2] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX2];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX2]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX2]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX2]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX2] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length2, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length2;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module.exports = LRUCache2;
  }
});

// node_modules/@digitalcredentials/jsonld/lib/ResolvedContext.js
var require_ResolvedContext = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/ResolvedContext.js"(exports, module) {
    "use strict";
    var LRU = require_lru_cache();
    var MAX_ACTIVE_CONTEXTS = 10;
    module.exports = class ResolvedContext {
      /**
       * Creates a ResolvedContext.
       *
       * @param document the context document.
       */
      constructor({ document }) {
        this.document = document;
        this.cache = new LRU({ max: MAX_ACTIVE_CONTEXTS });
      }
      getProcessed(activeCtx) {
        return this.cache.get(activeCtx);
      }
      setProcessed(activeCtx, processedCtx) {
        this.cache.set(activeCtx, processedCtx);
      }
    };
  }
});

// node_modules/@digitalcredentials/jsonld/lib/ContextResolver.js
var require_ContextResolver = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/ContextResolver.js"(exports, module) {
    "use strict";
    var {
      isArray: _isArray,
      isObject: _isObject,
      isString: _isString
    } = require_types5();
    var {
      asArray: _asArray
    } = require_util3();
    var { prependBase } = require_url();
    var JsonLdError = require_JsonLdError();
    var ResolvedContext = require_ResolvedContext();
    var MAX_CONTEXT_URLS = 10;
    module.exports = class ContextResolver {
      /**
       * Creates a ContextResolver.
       *
       * @param sharedCache a shared LRU cache with `get` and `set` APIs.
       */
      constructor({ sharedCache }) {
        this.perOpCache = /* @__PURE__ */ new Map();
        this.sharedCache = sharedCache;
      }
      async resolve({
        activeCtx,
        context: context2,
        documentLoader,
        base,
        cycles = /* @__PURE__ */ new Set()
      }) {
        if (context2 && _isObject(context2) && context2["@context"]) {
          context2 = context2["@context"];
        }
        context2 = _asArray(context2);
        const allResolved = [];
        for (const ctx of context2) {
          if (_isString(ctx)) {
            let resolved2 = this._get(ctx);
            if (!resolved2) {
              resolved2 = await this._resolveRemoteContext(
                { activeCtx, url: ctx, documentLoader, base, cycles }
              );
            }
            if (_isArray(resolved2)) {
              allResolved.push(...resolved2);
            } else {
              allResolved.push(resolved2);
            }
            continue;
          }
          if (ctx === null) {
            allResolved.push(new ResolvedContext({ document: null }));
            continue;
          }
          if (!_isObject(ctx)) {
            _throwInvalidLocalContext(context2);
          }
          const key = JSON.stringify(ctx);
          let resolved = this._get(key);
          if (!resolved) {
            resolved = new ResolvedContext({ document: ctx });
            this._cacheResolvedContext({ key, resolved, tag: "static" });
          }
          allResolved.push(resolved);
        }
        return allResolved;
      }
      _get(key) {
        let resolved = this.perOpCache.get(key);
        if (!resolved) {
          const tagMap = this.sharedCache.get(key);
          if (tagMap) {
            resolved = tagMap.get("static");
            if (resolved) {
              this.perOpCache.set(key, resolved);
            }
          }
        }
        return resolved;
      }
      _cacheResolvedContext({ key, resolved, tag }) {
        this.perOpCache.set(key, resolved);
        if (tag !== void 0) {
          let tagMap = this.sharedCache.get(key);
          if (!tagMap) {
            tagMap = /* @__PURE__ */ new Map();
            this.sharedCache.set(key, tagMap);
          }
          tagMap.set(tag, resolved);
        }
        return resolved;
      }
      async _resolveRemoteContext({ activeCtx, url, documentLoader, base, cycles }) {
        url = prependBase(base, url);
        const { context: context2, remoteDoc } = await this._fetchContext(
          { activeCtx, url, documentLoader, cycles }
        );
        base = remoteDoc.documentUrl || url;
        _resolveContextUrls({ context: context2, base });
        const resolved = await this.resolve(
          { activeCtx, context: context2, documentLoader, base, cycles }
        );
        this._cacheResolvedContext({ key: url, resolved, tag: remoteDoc.tag });
        return resolved;
      }
      async _fetchContext({ activeCtx, url, documentLoader, cycles }) {
        if (cycles.size > MAX_CONTEXT_URLS) {
          throw new JsonLdError(
            "Maximum number of @context URLs exceeded.",
            "jsonld.ContextUrlError",
            {
              code: activeCtx.processingMode === "json-ld-1.0" ? "loading remote context failed" : "context overflow",
              max: MAX_CONTEXT_URLS
            }
          );
        }
        if (cycles.has(url)) {
          throw new JsonLdError(
            "Cyclical @context URLs detected.",
            "jsonld.ContextUrlError",
            {
              code: activeCtx.processingMode === "json-ld-1.0" ? "recursive context inclusion" : "context overflow",
              url
            }
          );
        }
        cycles.add(url);
        let context2;
        let remoteDoc;
        try {
          remoteDoc = await documentLoader(url);
          context2 = remoteDoc.document || null;
          if (_isString(context2)) {
            context2 = JSON.parse(context2);
          }
        } catch (e) {
          throw new JsonLdError(
            "Dereferencing a URL did not result in a valid JSON-LD object. Possible causes are an inaccessible URL perhaps due to a same-origin policy (ensure the server uses CORS if you are using client-side JavaScript), too many redirects, a non-JSON response, or more than one HTTP Link Header was provided for a remote context.",
            "jsonld.InvalidUrl",
            { code: "loading remote context failed", url, cause: e }
          );
        }
        if (!_isObject(context2)) {
          throw new JsonLdError(
            "Dereferencing a URL did not result in a JSON object. The response was valid JSON, but it was not a JSON object.",
            "jsonld.InvalidUrl",
            { code: "invalid remote context", url }
          );
        }
        if (!("@context" in context2)) {
          context2 = { "@context": {} };
        } else {
          context2 = { "@context": context2["@context"] };
        }
        if (remoteDoc.contextUrl) {
          if (!_isArray(context2["@context"])) {
            context2["@context"] = [context2["@context"]];
          }
          context2["@context"].push(remoteDoc.contextUrl);
        }
        return { context: context2, remoteDoc };
      }
    };
    function _throwInvalidLocalContext(ctx) {
      throw new JsonLdError(
        "Invalid JSON-LD syntax; @context must be an object.",
        "jsonld.SyntaxError",
        {
          code: "invalid local context",
          context: ctx
        }
      );
    }
    function _resolveContextUrls({ context: context2, base }) {
      if (!context2) {
        return;
      }
      const ctx = context2["@context"];
      if (_isString(ctx)) {
        context2["@context"] = prependBase(base, ctx);
        return;
      }
      if (_isArray(ctx)) {
        for (let i = 0; i < ctx.length; ++i) {
          const element = ctx[i];
          if (_isString(element)) {
            ctx[i] = prependBase(base, element);
            continue;
          }
          if (_isObject(element)) {
            _resolveContextUrls({ context: { "@context": element }, base });
          }
        }
        return;
      }
      if (!_isObject(ctx)) {
        return;
      }
      for (const term in ctx) {
        _resolveContextUrls({ context: ctx[term], base });
      }
    }
  }
});

// node_modules/@digitalcredentials/jsonld/lib/NQuads.js
var require_NQuads2 = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/NQuads.js"(exports, module) {
    "use strict";
    module.exports = require_rdf_canonize().NQuads;
  }
});

// node_modules/@digitalcredentials/jsonld/lib/context.js
var require_context3 = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/context.js"(exports, module) {
    "use strict";
    var util2 = require_util3();
    var JsonLdError = require_JsonLdError();
    var {
      isArray: _isArray,
      isObject: _isObject,
      isString: _isString,
      isUndefined: _isUndefined
    } = require_types5();
    var {
      isAbsolute: _isAbsoluteIri,
      isRelative: _isRelativeIri,
      prependBase
    } = require_url();
    var {
      asArray: _asArray,
      compareShortestLeast: _compareShortestLeast
    } = require_util3();
    var INITIAL_CONTEXT_CACHE = /* @__PURE__ */ new Map();
    var INITIAL_CONTEXT_CACHE_MAX_SIZE = 1e4;
    var KEYWORD_PATTERN = /^@[a-zA-Z]+$/;
    var api = {};
    module.exports = api;
    api.process = async ({
      activeCtx,
      localCtx,
      options,
      propagate = true,
      overrideProtected = false,
      cycles = /* @__PURE__ */ new Set()
    }) => {
      if (_isObject(localCtx) && "@context" in localCtx && _isArray(localCtx["@context"])) {
        localCtx = localCtx["@context"];
      }
      const ctxs = _asArray(localCtx);
      if (ctxs.length === 0) {
        return activeCtx;
      }
      const resolved = await options.contextResolver.resolve({
        activeCtx,
        context: localCtx,
        documentLoader: options.documentLoader,
        base: options.base
      });
      if (_isObject(resolved[0].document) && typeof resolved[0].document["@propagate"] === "boolean") {
        propagate = resolved[0].document["@propagate"];
      }
      let rval = activeCtx;
      if (!propagate && !rval.previousContext) {
        rval = rval.clone();
        rval.previousContext = activeCtx;
      }
      for (const resolvedContext of resolved) {
        let { document: ctx } = resolvedContext;
        activeCtx = rval;
        if (ctx === null) {
          if (!overrideProtected && Object.keys(activeCtx.protected).length !== 0) {
            const protectedMode = options && options.protectedMode || "error";
            if (protectedMode === "error") {
              throw new JsonLdError(
                "Tried to nullify a context with protected terms outside of a term definition.",
                "jsonld.SyntaxError",
                { code: "invalid context nullification" }
              );
            } else if (protectedMode === "warn") {
              console.warn("WARNING: invalid context nullification");
              const processed2 = resolvedContext.getProcessed(activeCtx);
              if (processed2) {
                rval = activeCtx = processed2;
                continue;
              }
              const oldActiveCtx = activeCtx;
              rval = activeCtx = api.getInitialContext(options).clone();
              for (const [term, _protected] of Object.entries(oldActiveCtx.protected)) {
                if (_protected) {
                  activeCtx.mappings[term] = util2.clone(oldActiveCtx.mappings[term]);
                }
              }
              activeCtx.protected = util2.clone(oldActiveCtx.protected);
              resolvedContext.setProcessed(oldActiveCtx, rval);
              continue;
            }
            throw new JsonLdError(
              "Invalid protectedMode.",
              "jsonld.SyntaxError",
              { code: "invalid protected mode", context: localCtx, protectedMode }
            );
          }
          rval = activeCtx = api.getInitialContext(options).clone();
          continue;
        }
        const processed = resolvedContext.getProcessed(activeCtx);
        if (processed) {
          rval = activeCtx = processed;
          continue;
        }
        if (_isObject(ctx) && "@context" in ctx) {
          ctx = ctx["@context"];
        }
        if (!_isObject(ctx)) {
          throw new JsonLdError(
            "Invalid JSON-LD syntax; @context must be an object.",
            "jsonld.SyntaxError",
            { code: "invalid local context", context: ctx }
          );
        }
        rval = rval.clone();
        const defined = /* @__PURE__ */ new Map();
        if ("@version" in ctx) {
          if (ctx["@version"] !== 1.1) {
            throw new JsonLdError(
              "Unsupported JSON-LD version: " + ctx["@version"],
              "jsonld.UnsupportedVersion",
              { code: "invalid @version value", context: ctx }
            );
          }
          if (activeCtx.processingMode && activeCtx.processingMode === "json-ld-1.0") {
            throw new JsonLdError(
              "@version: " + ctx["@version"] + " not compatible with " + activeCtx.processingMode,
              "jsonld.ProcessingModeConflict",
              { code: "processing mode conflict", context: ctx }
            );
          }
          rval.processingMode = "json-ld-1.1";
          rval["@version"] = ctx["@version"];
          defined.set("@version", true);
        }
        rval.processingMode = rval.processingMode || activeCtx.processingMode;
        if ("@base" in ctx) {
          let base = ctx["@base"];
          if (base === null || _isAbsoluteIri(base)) {
          } else if (_isRelativeIri(base)) {
            base = prependBase(rval["@base"], base);
          } else {
            throw new JsonLdError(
              'Invalid JSON-LD syntax; the value of "@base" in a @context must be an absolute IRI, a relative IRI, or null.',
              "jsonld.SyntaxError",
              { code: "invalid base IRI", context: ctx }
            );
          }
          rval["@base"] = base;
          defined.set("@base", true);
        }
        if ("@vocab" in ctx) {
          const value = ctx["@vocab"];
          if (value === null) {
            delete rval["@vocab"];
          } else if (!_isString(value)) {
            throw new JsonLdError(
              'Invalid JSON-LD syntax; the value of "@vocab" in a @context must be a string or null.',
              "jsonld.SyntaxError",
              { code: "invalid vocab mapping", context: ctx }
            );
          } else if (!_isAbsoluteIri(value) && api.processingMode(rval, 1)) {
            throw new JsonLdError(
              'Invalid JSON-LD syntax; the value of "@vocab" in a @context must be an absolute IRI.',
              "jsonld.SyntaxError",
              { code: "invalid vocab mapping", context: ctx }
            );
          } else {
            rval["@vocab"] = _expandIri(
              rval,
              value,
              { vocab: true, base: true },
              void 0,
              void 0,
              options
            );
          }
          defined.set("@vocab", true);
        }
        if ("@language" in ctx) {
          const value = ctx["@language"];
          if (value === null) {
            delete rval["@language"];
          } else if (!_isString(value)) {
            throw new JsonLdError(
              'Invalid JSON-LD syntax; the value of "@language" in a @context must be a string or null.',
              "jsonld.SyntaxError",
              { code: "invalid default language", context: ctx }
            );
          } else {
            rval["@language"] = value.toLowerCase();
          }
          defined.set("@language", true);
        }
        if ("@direction" in ctx) {
          const value = ctx["@direction"];
          if (activeCtx.processingMode === "json-ld-1.0") {
            throw new JsonLdError(
              "Invalid JSON-LD syntax; @direction not compatible with " + activeCtx.processingMode,
              "jsonld.SyntaxError",
              { code: "invalid context member", context: ctx }
            );
          }
          if (value === null) {
            delete rval["@direction"];
          } else if (value !== "ltr" && value !== "rtl") {
            throw new JsonLdError(
              'Invalid JSON-LD syntax; the value of "@direction" in a @context must be null, "ltr", or "rtl".',
              "jsonld.SyntaxError",
              { code: "invalid base direction", context: ctx }
            );
          } else {
            rval["@direction"] = value;
          }
          defined.set("@direction", true);
        }
        if ("@propagate" in ctx) {
          const value = ctx["@propagate"];
          if (activeCtx.processingMode === "json-ld-1.0") {
            throw new JsonLdError(
              "Invalid JSON-LD syntax; @propagate not compatible with " + activeCtx.processingMode,
              "jsonld.SyntaxError",
              { code: "invalid context entry", context: ctx }
            );
          }
          if (typeof value !== "boolean") {
            throw new JsonLdError(
              "Invalid JSON-LD syntax; @propagate value must be a boolean.",
              "jsonld.SyntaxError",
              { code: "invalid @propagate value", context: localCtx }
            );
          }
          defined.set("@propagate", true);
        }
        if ("@import" in ctx) {
          const value = ctx["@import"];
          if (activeCtx.processingMode === "json-ld-1.0") {
            throw new JsonLdError(
              "Invalid JSON-LD syntax; @import not compatible with " + activeCtx.processingMode,
              "jsonld.SyntaxError",
              { code: "invalid context entry", context: ctx }
            );
          }
          if (!_isString(value)) {
            throw new JsonLdError(
              "Invalid JSON-LD syntax; @import must be a string.",
              "jsonld.SyntaxError",
              { code: "invalid @import value", context: localCtx }
            );
          }
          const resolvedImport = await options.contextResolver.resolve({
            activeCtx,
            context: value,
            documentLoader: options.documentLoader,
            base: options.base
          });
          if (resolvedImport.length !== 1) {
            throw new JsonLdError(
              "Invalid JSON-LD syntax; @import must reference a single context.",
              "jsonld.SyntaxError",
              { code: "invalid remote context", context: localCtx }
            );
          }
          const processedImport = resolvedImport[0].getProcessed(activeCtx);
          if (processedImport) {
            ctx = processedImport;
          } else {
            const importCtx = resolvedImport[0].document;
            if ("@import" in importCtx) {
              throw new JsonLdError(
                "Invalid JSON-LD syntax: imported context must not include @import.",
                "jsonld.SyntaxError",
                { code: "invalid context entry", context: localCtx }
              );
            }
            for (const key in importCtx) {
              if (!ctx.hasOwnProperty(key)) {
                ctx[key] = importCtx[key];
              }
            }
            resolvedImport[0].setProcessed(activeCtx, ctx);
          }
          defined.set("@import", true);
        }
        defined.set("@protected", ctx["@protected"] || false);
        for (const key in ctx) {
          api.createTermDefinition({
            activeCtx: rval,
            localCtx: ctx,
            term: key,
            defined,
            options,
            overrideProtected
          });
          if (_isObject(ctx[key]) && "@context" in ctx[key]) {
            const keyCtx = ctx[key]["@context"];
            let process2 = true;
            if (_isString(keyCtx)) {
              const url = prependBase(options.base, keyCtx);
              if (cycles.has(url)) {
                process2 = false;
              } else {
                cycles.add(url);
              }
            }
            if (process2) {
              try {
                await api.process({
                  activeCtx: rval.clone(),
                  localCtx: ctx[key]["@context"],
                  overrideProtected: true,
                  options,
                  cycles
                });
              } catch (e) {
                throw new JsonLdError(
                  "Invalid JSON-LD syntax; invalid scoped context.",
                  "jsonld.SyntaxError",
                  {
                    code: "invalid scoped context",
                    context: ctx[key]["@context"],
                    term: key
                  }
                );
              }
            }
          }
        }
        resolvedContext.setProcessed(activeCtx, rval);
      }
      return rval;
    };
    api.createTermDefinition = ({
      activeCtx,
      localCtx,
      term,
      defined,
      options,
      overrideProtected = false
    }) => {
      if (defined.has(term)) {
        if (defined.get(term)) {
          return;
        }
        throw new JsonLdError(
          "Cyclical context definition detected.",
          "jsonld.CyclicalContext",
          { code: "cyclic IRI mapping", context: localCtx, term }
        );
      }
      defined.set(term, false);
      let value;
      if (localCtx.hasOwnProperty(term)) {
        value = localCtx[term];
      }
      if (term === "@type" && _isObject(value) && (value["@container"] || "@set") === "@set" && api.processingMode(activeCtx, 1.1)) {
        const validKeys2 = ["@container", "@id", "@protected"];
        const keys = Object.keys(value);
        if (keys.length === 0 || keys.some((k) => !validKeys2.includes(k))) {
          throw new JsonLdError(
            "Invalid JSON-LD syntax; keywords cannot be overridden.",
            "jsonld.SyntaxError",
            { code: "keyword redefinition", context: localCtx, term }
          );
        }
      } else if (api.isKeyword(term)) {
        throw new JsonLdError(
          "Invalid JSON-LD syntax; keywords cannot be overridden.",
          "jsonld.SyntaxError",
          { code: "keyword redefinition", context: localCtx, term }
        );
      } else if (term.match(KEYWORD_PATTERN)) {
        console.warn('WARNING: terms beginning with "@" are reserved for future use and ignored', { term });
        return;
      } else if (term === "") {
        throw new JsonLdError(
          "Invalid JSON-LD syntax; a term cannot be an empty string.",
          "jsonld.SyntaxError",
          { code: "invalid term definition", context: localCtx }
        );
      }
      const previousMapping = activeCtx.mappings.get(term);
      if (activeCtx.mappings.has(term)) {
        activeCtx.mappings.delete(term);
      }
      let simpleTerm = false;
      if (_isString(value) || value === null) {
        simpleTerm = true;
        value = { "@id": value };
      }
      if (!_isObject(value)) {
        throw new JsonLdError(
          "Invalid JSON-LD syntax; @context term values must be strings or objects.",
          "jsonld.SyntaxError",
          { code: "invalid term definition", context: localCtx }
        );
      }
      const mapping = {};
      activeCtx.mappings.set(term, mapping);
      mapping.reverse = false;
      const validKeys = ["@container", "@id", "@language", "@reverse", "@type"];
      if (api.processingMode(activeCtx, 1.1)) {
        validKeys.push(
          "@context",
          "@direction",
          "@index",
          "@nest",
          "@prefix",
          "@protected"
        );
      }
      for (const kw in value) {
        if (!validKeys.includes(kw)) {
          throw new JsonLdError(
            "Invalid JSON-LD syntax; a term definition must not contain " + kw,
            "jsonld.SyntaxError",
            { code: "invalid term definition", context: localCtx }
          );
        }
      }
      const colon = term.indexOf(":");
      mapping._termHasColon = colon > 0;
      if ("@reverse" in value) {
        if ("@id" in value) {
          throw new JsonLdError(
            "Invalid JSON-LD syntax; a @reverse term definition must not contain @id.",
            "jsonld.SyntaxError",
            { code: "invalid reverse property", context: localCtx }
          );
        }
        if ("@nest" in value) {
          throw new JsonLdError(
            "Invalid JSON-LD syntax; a @reverse term definition must not contain @nest.",
            "jsonld.SyntaxError",
            { code: "invalid reverse property", context: localCtx }
          );
        }
        const reverse = value["@reverse"];
        if (!_isString(reverse)) {
          throw new JsonLdError(
            "Invalid JSON-LD syntax; a @context @reverse value must be a string.",
            "jsonld.SyntaxError",
            { code: "invalid IRI mapping", context: localCtx }
          );
        }
        if (!api.isKeyword(reverse) && reverse.match(KEYWORD_PATTERN)) {
          console.warn('WARNING: values beginning with "@" are reserved for future use and ignored', { reverse });
          if (previousMapping) {
            activeCtx.mappings.set(term, previousMapping);
          } else {
            activeCtx.mappings.delete(term);
          }
          return;
        }
        const id2 = _expandIri(
          activeCtx,
          reverse,
          { vocab: true, base: false },
          localCtx,
          defined,
          options
        );
        if (!_isAbsoluteIri(id2)) {
          throw new JsonLdError(
            "Invalid JSON-LD syntax; a @context @reverse value must be an absolute IRI or a blank node identifier.",
            "jsonld.SyntaxError",
            { code: "invalid IRI mapping", context: localCtx }
          );
        }
        mapping["@id"] = id2;
        mapping.reverse = true;
      } else if ("@id" in value) {
        let id2 = value["@id"];
        if (id2 && !_isString(id2)) {
          throw new JsonLdError(
            "Invalid JSON-LD syntax; a @context @id value must be an array of strings or a string.",
            "jsonld.SyntaxError",
            { code: "invalid IRI mapping", context: localCtx }
          );
        }
        if (id2 === null) {
          mapping["@id"] = null;
        } else if (!api.isKeyword(id2) && id2.match(KEYWORD_PATTERN)) {
          console.warn('WARNING: values beginning with "@" are reserved for future use and ignored', { id: id2 });
          if (previousMapping) {
            activeCtx.mappings.set(term, previousMapping);
          } else {
            activeCtx.mappings.delete(term);
          }
          return;
        } else if (id2 !== term) {
          id2 = _expandIri(
            activeCtx,
            id2,
            { vocab: true, base: false },
            localCtx,
            defined,
            options
          );
          if (!_isAbsoluteIri(id2) && !api.isKeyword(id2)) {
            throw new JsonLdError(
              "Invalid JSON-LD syntax; a @context @id value must be an absolute IRI, a blank node identifier, or a keyword.",
              "jsonld.SyntaxError",
              { code: "invalid IRI mapping", context: localCtx }
            );
          }
          if (term.match(/(?::[^:])|\//)) {
            const termDefined = new Map(defined).set(term, true);
            const termIri = _expandIri(
              activeCtx,
              term,
              { vocab: true, base: false },
              localCtx,
              termDefined,
              options
            );
            if (termIri !== id2) {
              throw new JsonLdError(
                "Invalid JSON-LD syntax; term in form of IRI must expand to definition.",
                "jsonld.SyntaxError",
                { code: "invalid IRI mapping", context: localCtx }
              );
            }
          }
          mapping["@id"] = id2;
          mapping._prefix = simpleTerm && !mapping._termHasColon && id2.match(/[:\/\?#\[\]@]$/);
        }
      }
      if (!("@id" in mapping)) {
        if (mapping._termHasColon) {
          const prefix = term.substr(0, colon);
          if (localCtx.hasOwnProperty(prefix)) {
            api.createTermDefinition({
              activeCtx,
              localCtx,
              term: prefix,
              defined,
              options
            });
          }
          if (activeCtx.mappings.has(prefix)) {
            const suffix = term.substr(colon + 1);
            mapping["@id"] = activeCtx.mappings.get(prefix)["@id"] + suffix;
          } else {
            mapping["@id"] = term;
          }
        } else if (term === "@type") {
          mapping["@id"] = term;
        } else {
          if (!("@vocab" in activeCtx)) {
            throw new JsonLdError(
              "Invalid JSON-LD syntax; @context terms must define an @id.",
              "jsonld.SyntaxError",
              { code: "invalid IRI mapping", context: localCtx, term }
            );
          }
          mapping["@id"] = activeCtx["@vocab"] + term;
        }
      }
      if (value["@protected"] === true || defined.get("@protected") === true && value["@protected"] !== false) {
        activeCtx.protected[term] = true;
        mapping.protected = true;
      }
      defined.set(term, true);
      if ("@type" in value) {
        let type = value["@type"];
        if (!_isString(type)) {
          throw new JsonLdError(
            "Invalid JSON-LD syntax; an @context @type value must be a string.",
            "jsonld.SyntaxError",
            { code: "invalid type mapping", context: localCtx }
          );
        }
        if (type === "@json" || type === "@none") {
          if (api.processingMode(activeCtx, 1)) {
            throw new JsonLdError(
              `Invalid JSON-LD syntax; an @context @type value must not be "${type}" in JSON-LD 1.0 mode.`,
              "jsonld.SyntaxError",
              { code: "invalid type mapping", context: localCtx }
            );
          }
        } else if (type !== "@id" && type !== "@vocab") {
          type = _expandIri(
            activeCtx,
            type,
            { vocab: true, base: false },
            localCtx,
            defined,
            options
          );
          if (!_isAbsoluteIri(type)) {
            throw new JsonLdError(
              "Invalid JSON-LD syntax; an @context @type value must be an absolute IRI.",
              "jsonld.SyntaxError",
              { code: "invalid type mapping", context: localCtx }
            );
          }
          if (type.indexOf("_:") === 0) {
            throw new JsonLdError(
              "Invalid JSON-LD syntax; an @context @type value must be an IRI, not a blank node identifier.",
              "jsonld.SyntaxError",
              { code: "invalid type mapping", context: localCtx }
            );
          }
        }
        mapping["@type"] = type;
      }
      if ("@container" in value) {
        const container = _isString(value["@container"]) ? [value["@container"]] : value["@container"] || [];
        const validContainers = ["@list", "@set", "@index", "@language"];
        let isValid = true;
        const hasSet = container.includes("@set");
        if (api.processingMode(activeCtx, 1.1)) {
          validContainers.push("@graph", "@id", "@type");
          if (container.includes("@list")) {
            if (container.length !== 1) {
              throw new JsonLdError(
                "Invalid JSON-LD syntax; @context @container with @list must have no other values",
                "jsonld.SyntaxError",
                { code: "invalid container mapping", context: localCtx }
              );
            }
          } else if (container.includes("@graph")) {
            if (container.some((key) => key !== "@graph" && key !== "@id" && key !== "@index" && key !== "@set")) {
              throw new JsonLdError(
                "Invalid JSON-LD syntax; @context @container with @graph must have no other values other than @id, @index, and @set",
                "jsonld.SyntaxError",
                { code: "invalid container mapping", context: localCtx }
              );
            }
          } else {
            isValid &= container.length <= (hasSet ? 2 : 1);
          }
          if (container.includes("@type")) {
            mapping["@type"] = mapping["@type"] || "@id";
            if (!["@id", "@vocab"].includes(mapping["@type"])) {
              throw new JsonLdError(
                "Invalid JSON-LD syntax; container: @type requires @type to be @id or @vocab.",
                "jsonld.SyntaxError",
                { code: "invalid type mapping", context: localCtx }
              );
            }
          }
        } else {
          isValid &= !_isArray(value["@container"]);
          isValid &= container.length <= 1;
        }
        isValid &= container.every((c) => validContainers.includes(c));
        isValid &= !(hasSet && container.includes("@list"));
        if (!isValid) {
          throw new JsonLdError(
            "Invalid JSON-LD syntax; @context @container value must be one of the following: " + validContainers.join(", "),
            "jsonld.SyntaxError",
            { code: "invalid container mapping", context: localCtx }
          );
        }
        if (mapping.reverse && !container.every((c) => ["@index", "@set"].includes(c))) {
          throw new JsonLdError(
            "Invalid JSON-LD syntax; @context @container value for a @reverse type definition must be @index or @set.",
            "jsonld.SyntaxError",
            { code: "invalid reverse property", context: localCtx }
          );
        }
        mapping["@container"] = container;
      }
      if ("@index" in value) {
        if (!("@container" in value) || !mapping["@container"].includes("@index")) {
          throw new JsonLdError(
            `Invalid JSON-LD syntax; @index without @index in @container: "${value["@index"]}" on term "${term}".`,
            "jsonld.SyntaxError",
            { code: "invalid term definition", context: localCtx }
          );
        }
        if (!_isString(value["@index"]) || value["@index"].indexOf("@") === 0) {
          throw new JsonLdError(
            `Invalid JSON-LD syntax; @index must expand to an IRI: "${value["@index"]}" on term "${term}".`,
            "jsonld.SyntaxError",
            { code: "invalid term definition", context: localCtx }
          );
        }
        mapping["@index"] = value["@index"];
      }
      if ("@context" in value) {
        mapping["@context"] = value["@context"];
      }
      if ("@language" in value && !("@type" in value)) {
        let language = value["@language"];
        if (language !== null && !_isString(language)) {
          throw new JsonLdError(
            "Invalid JSON-LD syntax; @context @language value must be a string or null.",
            "jsonld.SyntaxError",
            { code: "invalid language mapping", context: localCtx }
          );
        }
        if (language !== null) {
          language = language.toLowerCase();
        }
        mapping["@language"] = language;
      }
      if ("@prefix" in value) {
        if (term.match(/:|\//)) {
          throw new JsonLdError(
            "Invalid JSON-LD syntax; @context @prefix used on a compact IRI term",
            "jsonld.SyntaxError",
            { code: "invalid term definition", context: localCtx }
          );
        }
        if (api.isKeyword(mapping["@id"])) {
          throw new JsonLdError(
            "Invalid JSON-LD syntax; keywords may not be used as prefixes",
            "jsonld.SyntaxError",
            { code: "invalid term definition", context: localCtx }
          );
        }
        if (typeof value["@prefix"] === "boolean") {
          mapping._prefix = value["@prefix"] === true;
        } else {
          throw new JsonLdError(
            "Invalid JSON-LD syntax; @context value for @prefix must be boolean",
            "jsonld.SyntaxError",
            { code: "invalid @prefix value", context: localCtx }
          );
        }
      }
      if ("@direction" in value) {
        const direction = value["@direction"];
        if (direction !== null && direction !== "ltr" && direction !== "rtl") {
          throw new JsonLdError(
            'Invalid JSON-LD syntax; @direction value must be null, "ltr", or "rtl".',
            "jsonld.SyntaxError",
            { code: "invalid base direction", context: localCtx }
          );
        }
        mapping["@direction"] = direction;
      }
      if ("@nest" in value) {
        const nest = value["@nest"];
        if (!_isString(nest) || nest !== "@nest" && nest.indexOf("@") === 0) {
          throw new JsonLdError(
            "Invalid JSON-LD syntax; @context @nest value must be a string which is not a keyword other than @nest.",
            "jsonld.SyntaxError",
            { code: "invalid @nest value", context: localCtx }
          );
        }
        mapping["@nest"] = nest;
      }
      const id = mapping["@id"];
      if (id === "@context" || id === "@preserve") {
        throw new JsonLdError(
          "Invalid JSON-LD syntax; @context and @preserve cannot be aliased.",
          "jsonld.SyntaxError",
          { code: "invalid keyword alias", context: localCtx }
        );
      }
      if (previousMapping && previousMapping.protected && !overrideProtected) {
        activeCtx.protected[term] = true;
        mapping.protected = true;
        if (!_deepCompare(previousMapping, mapping)) {
          const protectedMode = options && options.protectedMode || "error";
          if (protectedMode === "error") {
            throw new JsonLdError(
              `Invalid JSON-LD syntax; tried to redefine "${term}" which is a protected term.`,
              "jsonld.SyntaxError",
              { code: "protected term redefinition", context: localCtx, term }
            );
          } else if (protectedMode === "warn") {
            console.warn("WARNING: protected term redefinition", { term });
            return;
          }
          throw new JsonLdError(
            "Invalid protectedMode.",
            "jsonld.SyntaxError",
            {
              code: "invalid protected mode",
              context: localCtx,
              term,
              protectedMode
            }
          );
        }
      }
    };
    api.expandIri = (activeCtx, value, relativeTo, options) => {
      return _expandIri(
        activeCtx,
        value,
        relativeTo,
        void 0,
        void 0,
        options
      );
    };
    function _expandIri(activeCtx, value, relativeTo, localCtx, defined, options) {
      if (value === null || !_isString(value) || api.isKeyword(value)) {
        return value;
      }
      if (value.match(KEYWORD_PATTERN)) {
        return null;
      }
      if (localCtx && localCtx.hasOwnProperty(value) && defined.get(value) !== true) {
        api.createTermDefinition({
          activeCtx,
          localCtx,
          term: value,
          defined,
          options
        });
      }
      relativeTo = relativeTo || {};
      if (relativeTo.vocab) {
        const mapping = activeCtx.mappings.get(value);
        if (mapping === null) {
          return null;
        }
        if (_isObject(mapping) && "@id" in mapping) {
          return mapping["@id"];
        }
      }
      const colon = value.indexOf(":");
      if (colon > 0) {
        const prefix = value.substr(0, colon);
        const suffix = value.substr(colon + 1);
        if (prefix === "_" || suffix.indexOf("//") === 0) {
          return value;
        }
        if (localCtx && localCtx.hasOwnProperty(prefix)) {
          api.createTermDefinition({
            activeCtx,
            localCtx,
            term: prefix,
            defined,
            options
          });
        }
        const mapping = activeCtx.mappings.get(prefix);
        if (mapping && mapping._prefix) {
          return mapping["@id"] + suffix;
        }
        if (_isAbsoluteIri(value)) {
          return value;
        }
      }
      let typeExpansion = false;
      if (options !== void 0 && options.typeExpansion !== void 0) {
        typeExpansion = options.typeExpansion;
      }
      if (relativeTo.vocab && "@vocab" in activeCtx) {
        const prependedResult = activeCtx["@vocab"] + value;
        let expansionMapResult = void 0;
        if (options && options.expansionMap) {
          expansionMapResult = options.expansionMap({
            prependedIri: {
              type: "@vocab",
              vocab: activeCtx["@vocab"],
              value,
              result: prependedResult,
              typeExpansion
            },
            activeCtx,
            options
          });
        }
        if (expansionMapResult !== void 0) {
          value = expansionMapResult;
        } else {
          value = prependedResult;
        }
      } else if (relativeTo.base) {
        let prependedResult;
        let expansionMapResult;
        let base;
        if ("@base" in activeCtx) {
          if (activeCtx["@base"]) {
            base = prependBase(options.base, activeCtx["@base"]);
            prependedResult = prependBase(base, value);
          } else {
            base = activeCtx["@base"];
            prependedResult = value;
          }
        } else {
          base = options.base;
          prependedResult = prependBase(options.base, value);
        }
        if (options && options.expansionMap) {
          expansionMapResult = options.expansionMap({
            prependedIri: {
              type: "@base",
              base,
              value,
              result: prependedResult,
              typeExpansion
            },
            activeCtx,
            options
          });
        }
        if (expansionMapResult !== void 0) {
          value = expansionMapResult;
        } else {
          value = prependedResult;
        }
      }
      if (!_isAbsoluteIri(value) && options && options.expansionMap) {
        const expandedResult = options.expansionMap({
          relativeIri: value,
          activeCtx,
          typeExpansion,
          options
        });
        if (expandedResult !== void 0) {
          value = expandedResult;
        }
      }
      return value;
    }
    api.getInitialContext = (options) => {
      const key = JSON.stringify({ processingMode: options.processingMode });
      const cached = INITIAL_CONTEXT_CACHE.get(key);
      if (cached) {
        return cached;
      }
      const initialContext = {
        processingMode: options.processingMode,
        mappings: /* @__PURE__ */ new Map(),
        inverse: null,
        getInverse: _createInverseContext,
        clone: _cloneActiveContext,
        revertToPreviousContext: _revertToPreviousContext,
        protected: {}
      };
      if (INITIAL_CONTEXT_CACHE.size === INITIAL_CONTEXT_CACHE_MAX_SIZE) {
        INITIAL_CONTEXT_CACHE.clear();
      }
      INITIAL_CONTEXT_CACHE.set(key, initialContext);
      return initialContext;
      function _createInverseContext() {
        const activeCtx = this;
        if (activeCtx.inverse) {
          return activeCtx.inverse;
        }
        const inverse = activeCtx.inverse = {};
        const fastCurieMap = activeCtx.fastCurieMap = {};
        const irisToTerms = {};
        const defaultLanguage = (activeCtx["@language"] || "@none").toLowerCase();
        const defaultDirection = activeCtx["@direction"];
        const mappings = activeCtx.mappings;
        const terms = [...mappings.keys()].sort(_compareShortestLeast);
        for (const term of terms) {
          const mapping = mappings.get(term);
          if (mapping === null) {
            continue;
          }
          let container = mapping["@container"] || "@none";
          container = [].concat(container).sort().join("");
          if (mapping["@id"] === null) {
            continue;
          }
          const ids = _asArray(mapping["@id"]);
          for (const iri of ids) {
            let entry = inverse[iri];
            const isKeyword = api.isKeyword(iri);
            if (!entry) {
              inverse[iri] = entry = {};
              if (!isKeyword && !mapping._termHasColon) {
                irisToTerms[iri] = [term];
                const fastCurieEntry = { iri, terms: irisToTerms[iri] };
                if (iri[0] in fastCurieMap) {
                  fastCurieMap[iri[0]].push(fastCurieEntry);
                } else {
                  fastCurieMap[iri[0]] = [fastCurieEntry];
                }
              }
            } else if (!isKeyword && !mapping._termHasColon) {
              irisToTerms[iri].push(term);
            }
            if (!entry[container]) {
              entry[container] = {
                "@language": {},
                "@type": {},
                "@any": {}
              };
            }
            entry = entry[container];
            _addPreferredTerm(term, entry["@any"], "@none");
            if (mapping.reverse) {
              _addPreferredTerm(term, entry["@type"], "@reverse");
            } else if (mapping["@type"] === "@none") {
              _addPreferredTerm(term, entry["@any"], "@none");
              _addPreferredTerm(term, entry["@language"], "@none");
              _addPreferredTerm(term, entry["@type"], "@none");
            } else if ("@type" in mapping) {
              _addPreferredTerm(term, entry["@type"], mapping["@type"]);
            } else if ("@language" in mapping && "@direction" in mapping) {
              const language = mapping["@language"];
              const direction = mapping["@direction"];
              if (language && direction) {
                _addPreferredTerm(
                  term,
                  entry["@language"],
                  `${language}_${direction}`.toLowerCase()
                );
              } else if (language) {
                _addPreferredTerm(term, entry["@language"], language.toLowerCase());
              } else if (direction) {
                _addPreferredTerm(term, entry["@language"], `_${direction}`);
              } else {
                _addPreferredTerm(term, entry["@language"], "@null");
              }
            } else if ("@language" in mapping) {
              _addPreferredTerm(
                term,
                entry["@language"],
                (mapping["@language"] || "@null").toLowerCase()
              );
            } else if ("@direction" in mapping) {
              if (mapping["@direction"]) {
                _addPreferredTerm(
                  term,
                  entry["@language"],
                  `_${mapping["@direction"]}`
                );
              } else {
                _addPreferredTerm(term, entry["@language"], "@none");
              }
            } else if (defaultDirection) {
              _addPreferredTerm(term, entry["@language"], `_${defaultDirection}`);
              _addPreferredTerm(term, entry["@language"], "@none");
              _addPreferredTerm(term, entry["@type"], "@none");
            } else {
              _addPreferredTerm(term, entry["@language"], defaultLanguage);
              _addPreferredTerm(term, entry["@language"], "@none");
              _addPreferredTerm(term, entry["@type"], "@none");
            }
          }
        }
        for (const key2 in fastCurieMap) {
          _buildIriMap(fastCurieMap, key2, 1);
        }
        return inverse;
      }
      function _buildIriMap(iriMap, key2, idx) {
        const entries = iriMap[key2];
        const next = iriMap[key2] = {};
        let iri;
        let letter;
        for (const entry of entries) {
          iri = entry.iri;
          if (idx >= iri.length) {
            letter = "";
          } else {
            letter = iri[idx];
          }
          if (letter in next) {
            next[letter].push(entry);
          } else {
            next[letter] = [entry];
          }
        }
        for (const key3 in next) {
          if (key3 === "") {
            continue;
          }
          _buildIriMap(next, key3, idx + 1);
        }
      }
      function _addPreferredTerm(term, entry, typeOrLanguageValue) {
        if (!entry.hasOwnProperty(typeOrLanguageValue)) {
          entry[typeOrLanguageValue] = term;
        }
      }
      function _cloneActiveContext() {
        const child = {};
        child.mappings = util2.clone(this.mappings);
        child.clone = this.clone;
        child.inverse = null;
        child.getInverse = this.getInverse;
        child.protected = util2.clone(this.protected);
        if (this.previousContext) {
          child.previousContext = this.previousContext.clone();
        }
        child.revertToPreviousContext = this.revertToPreviousContext;
        if ("@base" in this) {
          child["@base"] = this["@base"];
        }
        if ("@language" in this) {
          child["@language"] = this["@language"];
        }
        if ("@vocab" in this) {
          child["@vocab"] = this["@vocab"];
        }
        return child;
      }
      function _revertToPreviousContext() {
        if (!this.previousContext) {
          return this;
        }
        return this.previousContext.clone();
      }
    };
    api.getContextValue = (ctx, key, type) => {
      if (key === null) {
        if (type === "@context") {
          return void 0;
        }
        return null;
      }
      if (ctx.mappings.has(key)) {
        const entry = ctx.mappings.get(key);
        if (_isUndefined(type)) {
          return entry;
        }
        if (entry.hasOwnProperty(type)) {
          return entry[type];
        }
      }
      if (type === "@language" && type in ctx) {
        return ctx[type];
      }
      if (type === "@direction" && type in ctx) {
        return ctx[type];
      }
      if (type === "@context") {
        return void 0;
      }
      return null;
    };
    api.processingMode = (activeCtx, version2) => {
      if (version2.toString() >= "1.1") {
        return !activeCtx.processingMode || activeCtx.processingMode >= "json-ld-" + version2.toString();
      } else {
        return activeCtx.processingMode === "json-ld-1.0";
      }
    };
    api.isKeyword = (v) => {
      if (!_isString(v) || v[0] !== "@") {
        return false;
      }
      switch (v) {
        case "@base":
        case "@container":
        case "@context":
        case "@default":
        case "@direction":
        case "@embed":
        case "@explicit":
        case "@graph":
        case "@id":
        case "@included":
        case "@index":
        case "@json":
        case "@language":
        case "@list":
        case "@nest":
        case "@none":
        case "@omitDefault":
        case "@prefix":
        case "@preserve":
        case "@protected":
        case "@requireAll":
        case "@reverse":
        case "@set":
        case "@type":
        case "@value":
        case "@version":
        case "@vocab":
          return true;
      }
      return false;
    };
    function _deepCompare(x1, x2) {
      if (!(x1 && typeof x1 === "object") || !(x2 && typeof x2 === "object")) {
        return x1 === x2;
      }
      const x1Array = Array.isArray(x1);
      if (x1Array !== Array.isArray(x2)) {
        return false;
      }
      if (x1Array) {
        if (x1.length !== x2.length) {
          return false;
        }
        for (let i = 0; i < x1.length; ++i) {
          if (!_deepCompare(x1[i], x2[i])) {
            return false;
          }
        }
        return true;
      }
      const k1s = Object.keys(x1);
      const k2s = Object.keys(x2);
      if (k1s.length !== k2s.length) {
        return false;
      }
      for (const k1 in x1) {
        let v12 = x1[k1];
        let v2 = x2[k1];
        if (k1 === "@container") {
          if (Array.isArray(v12) && Array.isArray(v2)) {
            v12 = v12.slice().sort();
            v2 = v2.slice().sort();
          }
        }
        if (!_deepCompare(v12, v2)) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/@digitalcredentials/jsonld/lib/expand.js
var require_expand2 = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/expand.js"(exports, module) {
    "use strict";
    var JsonLdError = require_JsonLdError();
    var {
      isArray: _isArray,
      isObject: _isObject,
      isEmptyObject: _isEmptyObject,
      isString: _isString,
      isUndefined: _isUndefined
    } = require_types5();
    var {
      isList: _isList,
      isValue: _isValue,
      isGraph: _isGraph,
      isSubject: _isSubject
    } = require_graphTypes();
    var {
      expandIri: _expandIri,
      getContextValue: _getContextValue,
      isKeyword: _isKeyword,
      process: _processContext,
      processingMode: _processingMode
    } = require_context3();
    var {
      isAbsolute: _isAbsoluteIri
    } = require_url();
    var {
      addValue: _addValue,
      asArray: _asArray,
      getValues: _getValues,
      validateTypeValue: _validateTypeValue
    } = require_util3();
    var api = {};
    module.exports = api;
    var REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;
    api.expand = async ({
      activeCtx,
      activeProperty = null,
      element,
      options = {},
      insideList = false,
      insideIndex = false,
      typeScopedContext = null,
      expansionMap = () => void 0
    }) => {
      options = { ...options, expansionMap };
      if (element === null || element === void 0) {
        return null;
      }
      if (activeProperty === "@default") {
        options = Object.assign({}, options, { isFrame: false });
      }
      if (!_isArray(element) && !_isObject(element)) {
        if (!insideList && (activeProperty === null || _expandIri(
          activeCtx,
          activeProperty,
          { vocab: true },
          options
        ) === "@graph")) {
          const mapped = await expansionMap({
            unmappedValue: element,
            activeCtx,
            activeProperty,
            options,
            insideList
          });
          if (mapped === void 0) {
            return null;
          }
          return mapped;
        }
        return _expandValue({ activeCtx, activeProperty, value: element, options });
      }
      if (_isArray(element)) {
        let rval2 = [];
        const container = _getContextValue(
          activeCtx,
          activeProperty,
          "@container"
        ) || [];
        insideList = insideList || container.includes("@list");
        for (let i = 0; i < element.length; ++i) {
          let e = await api.expand({
            activeCtx,
            activeProperty,
            element: element[i],
            options,
            expansionMap,
            insideIndex,
            typeScopedContext
          });
          if (insideList && _isArray(e)) {
            e = { "@list": e };
          }
          if (e === null) {
            e = await expansionMap({
              unmappedValue: element[i],
              activeCtx,
              activeProperty,
              parent: element,
              index: i,
              options,
              expandedParent: rval2,
              insideList
            });
            if (e === void 0) {
              continue;
            }
          }
          if (_isArray(e)) {
            rval2 = rval2.concat(e);
          } else {
            rval2.push(e);
          }
        }
        return rval2;
      }
      const expandedActiveProperty = _expandIri(
        activeCtx,
        activeProperty,
        { vocab: true },
        options
      );
      const propertyScopedCtx = _getContextValue(activeCtx, activeProperty, "@context");
      typeScopedContext = typeScopedContext || (activeCtx.previousContext ? activeCtx : null);
      let keys = Object.keys(element).sort();
      let mustRevert = !insideIndex;
      if (mustRevert && typeScopedContext && keys.length <= 2 && !keys.includes("@context")) {
        for (const key of keys) {
          const expandedProperty = _expandIri(
            typeScopedContext,
            key,
            { vocab: true },
            options
          );
          if (expandedProperty === "@value") {
            mustRevert = false;
            activeCtx = typeScopedContext;
            break;
          }
          if (expandedProperty === "@id" && keys.length === 1) {
            mustRevert = false;
            break;
          }
        }
      }
      if (mustRevert) {
        activeCtx = activeCtx.revertToPreviousContext();
      }
      if (!_isUndefined(propertyScopedCtx)) {
        activeCtx = await _processContext({
          activeCtx,
          localCtx: propertyScopedCtx,
          propagate: true,
          overrideProtected: true,
          options
        });
      }
      if ("@context" in element) {
        activeCtx = await _processContext(
          { activeCtx, localCtx: element["@context"], options }
        );
      }
      typeScopedContext = activeCtx;
      let typeKey = null;
      for (const key of keys) {
        const expandedProperty = _expandIri(activeCtx, key, { vocab: true }, options);
        if (expandedProperty === "@type") {
          typeKey = typeKey || key;
          const value = element[key];
          const types = Array.isArray(value) ? value.length > 1 ? value.slice().sort() : value : [value];
          for (const type of types) {
            const ctx = _getContextValue(typeScopedContext, type, "@context");
            if (!_isUndefined(ctx)) {
              activeCtx = await _processContext({
                activeCtx,
                localCtx: ctx,
                options,
                propagate: false
              });
            }
          }
        }
      }
      let rval = {};
      await _expandObject({
        activeCtx,
        activeProperty,
        expandedActiveProperty,
        element,
        expandedParent: rval,
        options,
        insideList,
        typeKey,
        typeScopedContext,
        expansionMap
      });
      keys = Object.keys(rval);
      let count = keys.length;
      if ("@value" in rval) {
        if ("@type" in rval && ("@language" in rval || "@direction" in rval)) {
          throw new JsonLdError(
            'Invalid JSON-LD syntax; an element containing "@value" may not contain both "@type" and either "@language" or "@direction".',
            "jsonld.SyntaxError",
            { code: "invalid value object", element: rval }
          );
        }
        let validCount = count - 1;
        if ("@type" in rval) {
          validCount -= 1;
        }
        if ("@index" in rval) {
          validCount -= 1;
        }
        if ("@language" in rval) {
          validCount -= 1;
        }
        if ("@direction" in rval) {
          validCount -= 1;
        }
        if (validCount !== 0) {
          throw new JsonLdError(
            'Invalid JSON-LD syntax; an element containing "@value" may only have an "@index" property and either "@type" or either or both "@language" or "@direction".',
            "jsonld.SyntaxError",
            { code: "invalid value object", element: rval }
          );
        }
        const values = rval["@value"] === null ? [] : _asArray(rval["@value"]);
        const types = _getValues(rval, "@type");
        if (_processingMode(activeCtx, 1.1) && types.includes("@json") && types.length === 1) {
        } else if (values.length === 0) {
          const mapped = await expansionMap({
            unmappedValue: rval,
            activeCtx,
            activeProperty,
            element,
            options,
            insideList
          });
          if (mapped !== void 0) {
            rval = mapped;
          } else {
            rval = null;
          }
        } else if (!values.every((v) => _isString(v) || _isEmptyObject(v)) && "@language" in rval) {
          throw new JsonLdError(
            "Invalid JSON-LD syntax; only strings may be language-tagged.",
            "jsonld.SyntaxError",
            { code: "invalid language-tagged value", element: rval }
          );
        } else if (!types.every((t) => _isAbsoluteIri(t) && !(_isString(t) && t.indexOf("_:") === 0) || _isEmptyObject(t))) {
          throw new JsonLdError(
            'Invalid JSON-LD syntax; an element containing "@value" and "@type" must have an absolute IRI for the value of "@type".',
            "jsonld.SyntaxError",
            { code: "invalid typed value", element: rval }
          );
        }
      } else if ("@type" in rval && !_isArray(rval["@type"])) {
        rval["@type"] = [rval["@type"]];
      } else if ("@set" in rval || "@list" in rval) {
        if (count > 1 && !(count === 2 && "@index" in rval)) {
          throw new JsonLdError(
            'Invalid JSON-LD syntax; if an element has the property "@set" or "@list", then it can have at most one other property that is "@index".',
            "jsonld.SyntaxError",
            { code: "invalid set or list object", element: rval }
          );
        }
        if ("@set" in rval) {
          rval = rval["@set"];
          keys = Object.keys(rval);
          count = keys.length;
        }
      } else if (count === 1 && "@language" in rval) {
        const mapped = await expansionMap(rval, {
          unmappedValue: rval,
          activeCtx,
          activeProperty,
          element,
          options,
          insideList
        });
        if (mapped !== void 0) {
          rval = mapped;
        } else {
          rval = null;
        }
      }
      if (_isObject(rval) && !options.keepFreeFloatingNodes && !insideList && (activeProperty === null || expandedActiveProperty === "@graph")) {
        if (count === 0 || "@value" in rval || "@list" in rval || count === 1 && "@id" in rval) {
          const mapped = await expansionMap({
            unmappedValue: rval,
            activeCtx,
            activeProperty,
            element,
            options,
            insideList
          });
          if (mapped !== void 0) {
            rval = mapped;
          } else {
            rval = null;
          }
        }
      }
      return rval;
    };
    async function _expandObject({
      activeCtx,
      activeProperty,
      expandedActiveProperty,
      element,
      expandedParent,
      options = {},
      insideList,
      typeKey,
      typeScopedContext,
      expansionMap
    }) {
      const keys = Object.keys(element).sort();
      const nests = [];
      let unexpandedValue;
      options = { ...options, expansionMap };
      const isJsonType = element[typeKey] && _expandIri(
        activeCtx,
        _isArray(element[typeKey]) ? element[typeKey][0] : element[typeKey],
        { vocab: true },
        { ...options, typeExpansion: true }
      ) === "@json";
      for (const key of keys) {
        let value = element[key];
        let expandedValue;
        if (key === "@context") {
          continue;
        }
        let expandedProperty = _expandIri(activeCtx, key, { vocab: true }, options);
        if (expandedProperty === null || !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty))) {
          expandedProperty = expansionMap({
            unmappedProperty: key,
            activeCtx,
            activeProperty,
            parent: element,
            options,
            insideList,
            value,
            expandedParent
          });
          if (expandedProperty === void 0) {
            continue;
          }
        }
        if (_isKeyword(expandedProperty)) {
          if (expandedActiveProperty === "@reverse") {
            throw new JsonLdError(
              "Invalid JSON-LD syntax; a keyword cannot be used as a @reverse property.",
              "jsonld.SyntaxError",
              { code: "invalid reverse property map", value }
            );
          }
          if (expandedProperty in expandedParent && expandedProperty !== "@included" && expandedProperty !== "@type") {
            throw new JsonLdError(
              "Invalid JSON-LD syntax; colliding keywords detected.",
              "jsonld.SyntaxError",
              { code: "colliding keywords", keyword: expandedProperty }
            );
          }
        }
        if (expandedProperty === "@id") {
          if (!_isString(value)) {
            if (!options.isFrame) {
              throw new JsonLdError(
                'Invalid JSON-LD syntax; "@id" value must a string.',
                "jsonld.SyntaxError",
                { code: "invalid @id value", value }
              );
            }
            if (_isObject(value)) {
              if (!_isEmptyObject(value)) {
                throw new JsonLdError(
                  'Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',
                  "jsonld.SyntaxError",
                  { code: "invalid @id value", value }
                );
              }
            } else if (_isArray(value)) {
              if (!value.every((v) => _isString(v))) {
                throw new JsonLdError(
                  'Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',
                  "jsonld.SyntaxError",
                  { code: "invalid @id value", value }
                );
              }
            } else {
              throw new JsonLdError(
                'Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',
                "jsonld.SyntaxError",
                { code: "invalid @id value", value }
              );
            }
          }
          _addValue(
            expandedParent,
            "@id",
            _asArray(value).map((v) => _isString(v) ? _expandIri(activeCtx, v, { base: true }, options) : v),
            { propertyIsArray: options.isFrame }
          );
          continue;
        }
        if (expandedProperty === "@type") {
          if (_isObject(value)) {
            value = Object.fromEntries(Object.entries(value).map(([k, v]) => [
              _expandIri(typeScopedContext, k, { vocab: true }),
              _asArray(v).map(
                (vv) => _expandIri(
                  typeScopedContext,
                  vv,
                  { base: true, vocab: true },
                  { ...options, typeExpansion: true }
                )
              )
            ]));
          }
          _validateTypeValue(value, options.isFrame);
          _addValue(
            expandedParent,
            "@type",
            _asArray(value).map((v) => _isString(v) ? _expandIri(
              typeScopedContext,
              v,
              { base: true, vocab: true },
              { ...options, typeExpansion: true }
            ) : v),
            { propertyIsArray: options.isFrame }
          );
          continue;
        }
        if (expandedProperty === "@included" && _processingMode(activeCtx, 1.1)) {
          const includedResult = _asArray(await api.expand({
            activeCtx,
            activeProperty,
            element: value,
            options,
            expansionMap
          }));
          if (!includedResult.every((v) => _isSubject(v))) {
            throw new JsonLdError(
              "Invalid JSON-LD syntax; values of @included must expand to node objects.",
              "jsonld.SyntaxError",
              { code: "invalid @included value", value }
            );
          }
          _addValue(
            expandedParent,
            "@included",
            includedResult,
            { propertyIsArray: true }
          );
          continue;
        }
        if (expandedProperty === "@graph" && !(_isObject(value) || _isArray(value))) {
          throw new JsonLdError(
            'Invalid JSON-LD syntax; "@graph" value must not be an object or an array.',
            "jsonld.SyntaxError",
            { code: "invalid @graph value", value }
          );
        }
        if (expandedProperty === "@value") {
          unexpandedValue = value;
          if (isJsonType && _processingMode(activeCtx, 1.1)) {
            expandedParent["@value"] = value;
          } else {
            _addValue(
              expandedParent,
              "@value",
              value,
              { propertyIsArray: options.isFrame }
            );
          }
          continue;
        }
        if (expandedProperty === "@language") {
          if (value === null) {
            continue;
          }
          if (!_isString(value) && !options.isFrame) {
            throw new JsonLdError(
              'Invalid JSON-LD syntax; "@language" value must be a string.',
              "jsonld.SyntaxError",
              { code: "invalid language-tagged string", value }
            );
          }
          value = _asArray(value).map((v) => _isString(v) ? v.toLowerCase() : v);
          for (const lang of value) {
            if (_isString(lang) && !lang.match(REGEX_BCP47)) {
              console.warn(`@language must be valid BCP47: ${lang}`);
            }
          }
          _addValue(
            expandedParent,
            "@language",
            value,
            { propertyIsArray: options.isFrame }
          );
          continue;
        }
        if (expandedProperty === "@direction") {
          if (!_isString(value) && !options.isFrame) {
            throw new JsonLdError(
              'Invalid JSON-LD syntax; "@direction" value must be a string.',
              "jsonld.SyntaxError",
              { code: "invalid base direction", value }
            );
          }
          value = _asArray(value);
          for (const dir of value) {
            if (_isString(dir) && dir !== "ltr" && dir !== "rtl") {
              throw new JsonLdError(
                'Invalid JSON-LD syntax; "@direction" must be "ltr" or "rtl".',
                "jsonld.SyntaxError",
                { code: "invalid base direction", value }
              );
            }
          }
          _addValue(
            expandedParent,
            "@direction",
            value,
            { propertyIsArray: options.isFrame }
          );
          continue;
        }
        if (expandedProperty === "@index") {
          if (!_isString(value)) {
            throw new JsonLdError(
              'Invalid JSON-LD syntax; "@index" value must be a string.',
              "jsonld.SyntaxError",
              { code: "invalid @index value", value }
            );
          }
          _addValue(expandedParent, "@index", value);
          continue;
        }
        if (expandedProperty === "@reverse") {
          if (!_isObject(value)) {
            throw new JsonLdError(
              'Invalid JSON-LD syntax; "@reverse" value must be an object.',
              "jsonld.SyntaxError",
              { code: "invalid @reverse value", value }
            );
          }
          expandedValue = await api.expand({
            activeCtx,
            activeProperty: "@reverse",
            element: value,
            options,
            expansionMap
          });
          if ("@reverse" in expandedValue) {
            for (const property in expandedValue["@reverse"]) {
              _addValue(
                expandedParent,
                property,
                expandedValue["@reverse"][property],
                { propertyIsArray: true }
              );
            }
          }
          let reverseMap = expandedParent["@reverse"] || null;
          for (const property in expandedValue) {
            if (property === "@reverse") {
              continue;
            }
            if (reverseMap === null) {
              reverseMap = expandedParent["@reverse"] = {};
            }
            _addValue(reverseMap, property, [], { propertyIsArray: true });
            const items = expandedValue[property];
            for (let ii = 0; ii < items.length; ++ii) {
              const item = items[ii];
              if (_isValue(item) || _isList(item)) {
                throw new JsonLdError(
                  'Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',
                  "jsonld.SyntaxError",
                  { code: "invalid reverse property value", value: expandedValue }
                );
              }
              _addValue(reverseMap, property, item, { propertyIsArray: true });
            }
          }
          continue;
        }
        if (expandedProperty === "@nest") {
          nests.push(key);
          continue;
        }
        let termCtx = activeCtx;
        const ctx = _getContextValue(activeCtx, key, "@context");
        if (!_isUndefined(ctx)) {
          termCtx = await _processContext({
            activeCtx,
            localCtx: ctx,
            propagate: true,
            overrideProtected: true,
            options
          });
        }
        const container = _getContextValue(termCtx, key, "@container") || [];
        if (container.includes("@language") && _isObject(value)) {
          const direction = _getContextValue(termCtx, key, "@direction");
          expandedValue = _expandLanguageMap(termCtx, value, direction, options);
        } else if (container.includes("@index") && _isObject(value)) {
          const asGraph = container.includes("@graph");
          const indexKey = _getContextValue(termCtx, key, "@index") || "@index";
          const propertyIndex = indexKey !== "@index" && _expandIri(activeCtx, indexKey, { vocab: true }, options);
          expandedValue = await _expandIndexMap({
            activeCtx: termCtx,
            options,
            activeProperty: key,
            value,
            expansionMap,
            asGraph,
            indexKey,
            propertyIndex
          });
        } else if (container.includes("@id") && _isObject(value)) {
          const asGraph = container.includes("@graph");
          expandedValue = await _expandIndexMap({
            activeCtx: termCtx,
            options,
            activeProperty: key,
            value,
            expansionMap,
            asGraph,
            indexKey: "@id"
          });
        } else if (container.includes("@type") && _isObject(value)) {
          expandedValue = await _expandIndexMap({
            // since container is `@type`, revert type scoped context when expanding
            activeCtx: termCtx.revertToPreviousContext(),
            options,
            activeProperty: key,
            value,
            expansionMap,
            asGraph: false,
            indexKey: "@type"
          });
        } else {
          const isList = expandedProperty === "@list";
          if (isList || expandedProperty === "@set") {
            let nextActiveProperty = activeProperty;
            if (isList && expandedActiveProperty === "@graph") {
              nextActiveProperty = null;
            }
            expandedValue = await api.expand({
              activeCtx: termCtx,
              activeProperty: nextActiveProperty,
              element: value,
              options,
              insideList: isList,
              expansionMap
            });
          } else if (_getContextValue(activeCtx, key, "@type") === "@json") {
            expandedValue = {
              "@type": "@json",
              "@value": value
            };
          } else {
            expandedValue = await api.expand({
              activeCtx: termCtx,
              activeProperty: key,
              element: value,
              options,
              insideList: false,
              expansionMap
            });
          }
        }
        if (expandedValue === null && expandedProperty !== "@value") {
          expandedValue = expansionMap({
            unmappedValue: value,
            expandedProperty,
            activeCtx: termCtx,
            activeProperty,
            parent: element,
            options,
            insideList,
            key,
            expandedParent
          });
          if (expandedValue === void 0) {
            continue;
          }
        }
        if (expandedProperty !== "@list" && !_isList(expandedValue) && container.includes("@list")) {
          expandedValue = { "@list": _asArray(expandedValue) };
        }
        if (container.includes("@graph") && !container.some((key2) => key2 === "@id" || key2 === "@index")) {
          expandedValue = _asArray(expandedValue).map((v) => ({ "@graph": _asArray(v) }));
        }
        if (termCtx.mappings.has(key) && termCtx.mappings.get(key).reverse) {
          const reverseMap = expandedParent["@reverse"] = expandedParent["@reverse"] || {};
          expandedValue = _asArray(expandedValue);
          for (let ii = 0; ii < expandedValue.length; ++ii) {
            const item = expandedValue[ii];
            if (_isValue(item) || _isList(item)) {
              throw new JsonLdError(
                'Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',
                "jsonld.SyntaxError",
                { code: "invalid reverse property value", value: expandedValue }
              );
            }
            _addValue(reverseMap, expandedProperty, item, { propertyIsArray: true });
          }
          continue;
        }
        _addValue(expandedParent, expandedProperty, expandedValue, {
          propertyIsArray: true
        });
      }
      if ("@value" in expandedParent) {
        if (expandedParent["@type"] === "@json" && _processingMode(activeCtx, 1.1)) {
        } else if ((_isObject(unexpandedValue) || _isArray(unexpandedValue)) && !options.isFrame) {
          throw new JsonLdError(
            'Invalid JSON-LD syntax; "@value" value must not be an object or an array.',
            "jsonld.SyntaxError",
            { code: "invalid value object value", value: unexpandedValue }
          );
        }
      }
      for (const key of nests) {
        const nestedValues = _isArray(element[key]) ? element[key] : [element[key]];
        for (const nv of nestedValues) {
          if (!_isObject(nv) || Object.keys(nv).some((k) => _expandIri(activeCtx, k, { vocab: true }, options) === "@value")) {
            throw new JsonLdError(
              "Invalid JSON-LD syntax; nested value must be a node object.",
              "jsonld.SyntaxError",
              { code: "invalid @nest value", value: nv }
            );
          }
          await _expandObject({
            activeCtx,
            activeProperty,
            expandedActiveProperty,
            element: nv,
            expandedParent,
            options,
            insideList,
            typeScopedContext,
            typeKey,
            expansionMap
          });
        }
      }
    }
    function _expandValue({ activeCtx, activeProperty, value, options }) {
      if (value === null || value === void 0) {
        return null;
      }
      const expandedProperty = _expandIri(
        activeCtx,
        activeProperty,
        { vocab: true },
        options
      );
      if (expandedProperty === "@id") {
        return _expandIri(activeCtx, value, { base: true }, options);
      } else if (expandedProperty === "@type") {
        return _expandIri(
          activeCtx,
          value,
          { vocab: true, base: true },
          { ...options, typeExpansion: true }
        );
      }
      const type = _getContextValue(activeCtx, activeProperty, "@type");
      if ((type === "@id" || expandedProperty === "@graph") && _isString(value)) {
        return { "@id": _expandIri(activeCtx, value, { base: true }, options) };
      }
      if (type === "@vocab" && _isString(value)) {
        return {
          "@id": _expandIri(activeCtx, value, { vocab: true, base: true }, options)
        };
      }
      if (_isKeyword(expandedProperty)) {
        return value;
      }
      const rval = {};
      if (type && !["@id", "@vocab", "@none"].includes(type)) {
        rval["@type"] = type;
      } else if (_isString(value)) {
        const language = _getContextValue(activeCtx, activeProperty, "@language");
        if (language !== null) {
          rval["@language"] = language;
        }
        const direction = _getContextValue(activeCtx, activeProperty, "@direction");
        if (direction !== null) {
          rval["@direction"] = direction;
        }
      }
      if (!["boolean", "number", "string"].includes(typeof value)) {
        value = value.toString();
      }
      rval["@value"] = value;
      return rval;
    }
    function _expandLanguageMap(activeCtx, languageMap, direction, options) {
      const rval = [];
      const keys = Object.keys(languageMap).sort();
      for (const key of keys) {
        const expandedKey = _expandIri(activeCtx, key, { vocab: true }, options);
        let val = languageMap[key];
        if (!_isArray(val)) {
          val = [val];
        }
        for (const item of val) {
          if (item === null) {
            continue;
          }
          if (!_isString(item)) {
            throw new JsonLdError(
              "Invalid JSON-LD syntax; language map values must be strings.",
              "jsonld.SyntaxError",
              { code: "invalid language map value", languageMap }
            );
          }
          const val2 = { "@value": item };
          if (expandedKey !== "@none") {
            val2["@language"] = key.toLowerCase();
          }
          if (direction) {
            val2["@direction"] = direction;
          }
          rval.push(val2);
        }
      }
      return rval;
    }
    async function _expandIndexMap({
      activeCtx,
      options,
      activeProperty,
      value,
      expansionMap,
      asGraph,
      indexKey,
      propertyIndex
    }) {
      const rval = [];
      const keys = Object.keys(value).sort();
      const isTypeIndex = indexKey === "@type";
      for (let key of keys) {
        if (isTypeIndex) {
          const ctx = _getContextValue(activeCtx, key, "@context");
          if (!_isUndefined(ctx)) {
            activeCtx = await _processContext({
              activeCtx,
              localCtx: ctx,
              propagate: false,
              options
            });
          }
        }
        let val = value[key];
        if (!_isArray(val)) {
          val = [val];
        }
        val = await api.expand({
          activeCtx,
          activeProperty,
          element: val,
          options,
          insideList: false,
          insideIndex: true,
          expansionMap
        });
        let expandedKey;
        if (propertyIndex) {
          if (key === "@none") {
            expandedKey = "@none";
          } else {
            expandedKey = _expandValue(
              { activeCtx, activeProperty: indexKey, value: key, options }
            );
          }
        } else {
          expandedKey = _expandIri(activeCtx, key, { vocab: true }, options);
        }
        if (indexKey === "@id") {
          key = _expandIri(activeCtx, key, { base: true }, options);
        } else if (isTypeIndex) {
          key = expandedKey;
        }
        for (let item of val) {
          if (asGraph && !_isGraph(item)) {
            item = { "@graph": [item] };
          }
          if (indexKey === "@type") {
            if (expandedKey === "@none") {
            } else if (item["@type"]) {
              item["@type"] = [key].concat(item["@type"]);
            } else {
              item["@type"] = [key];
            }
          } else if (_isValue(item) && !["@language", "@type", "@index"].includes(indexKey)) {
            throw new JsonLdError(
              `Invalid JSON-LD syntax; Attempt to add illegal key to value object: "${indexKey}".`,
              "jsonld.SyntaxError",
              { code: "invalid value object", value: item }
            );
          } else if (propertyIndex) {
            if (expandedKey !== "@none") {
              _addValue(item, propertyIndex, expandedKey, {
                propertyIsArray: true,
                prependValue: true
              });
            }
          } else if (expandedKey !== "@none" && !(indexKey in item)) {
            item[indexKey] = key;
          }
          rval.push(item);
        }
      }
      return rval;
    }
  }
});

// node_modules/@digitalcredentials/jsonld/lib/nodeMap.js
var require_nodeMap = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/nodeMap.js"(exports, module) {
    "use strict";
    var { isKeyword } = require_context3();
    var graphTypes = require_graphTypes();
    var types = require_types5();
    var util2 = require_util3();
    var JsonLdError = require_JsonLdError();
    var api = {};
    module.exports = api;
    api.createMergedNodeMap = (input, options) => {
      options = options || {};
      const issuer = options.issuer || new util2.IdentifierIssuer("_:b");
      const graphs = { "@default": {} };
      api.createNodeMap(input, graphs, "@default", issuer);
      return api.mergeNodeMaps(graphs);
    };
    api.createNodeMap = (input, graphs, graph, issuer, name, list) => {
      if (types.isArray(input)) {
        for (const node of input) {
          api.createNodeMap(node, graphs, graph, issuer, void 0, list);
        }
        return;
      }
      if (!types.isObject(input)) {
        if (list) {
          list.push(input);
        }
        return;
      }
      if (graphTypes.isValue(input)) {
        if ("@type" in input) {
          let type = input["@type"];
          if (type.indexOf("_:") === 0) {
            input["@type"] = type = issuer.getId(type);
          }
        }
        if (list) {
          list.push(input);
        }
        return;
      } else if (list && graphTypes.isList(input)) {
        const _list = [];
        api.createNodeMap(input["@list"], graphs, graph, issuer, name, _list);
        list.push({ "@list": _list });
        return;
      }
      if ("@type" in input) {
        const types2 = input["@type"];
        for (const type of types2) {
          if (type.indexOf("_:") === 0) {
            issuer.getId(type);
          }
        }
      }
      if (types.isUndefined(name)) {
        name = graphTypes.isBlankNode(input) ? issuer.getId(input["@id"]) : input["@id"];
      }
      if (list) {
        list.push({ "@id": name });
      }
      const subjects = graphs[graph];
      const subject = subjects[name] = subjects[name] || {};
      subject["@id"] = name;
      const properties = Object.keys(input).sort();
      for (let property of properties) {
        if (property === "@id") {
          continue;
        }
        if (property === "@reverse") {
          const referencedNode = { "@id": name };
          const reverseMap = input["@reverse"];
          for (const reverseProperty in reverseMap) {
            const items = reverseMap[reverseProperty];
            for (const item of items) {
              let itemName = item["@id"];
              if (graphTypes.isBlankNode(item)) {
                itemName = issuer.getId(itemName);
              }
              api.createNodeMap(item, graphs, graph, issuer, itemName);
              util2.addValue(
                subjects[itemName],
                reverseProperty,
                referencedNode,
                { propertyIsArray: true, allowDuplicate: false }
              );
            }
          }
          continue;
        }
        if (property === "@graph") {
          if (!(name in graphs)) {
            graphs[name] = {};
          }
          api.createNodeMap(input[property], graphs, name, issuer);
          continue;
        }
        if (property === "@included") {
          api.createNodeMap(input[property], graphs, graph, issuer);
          continue;
        }
        if (property !== "@type" && isKeyword(property)) {
          if (property === "@index" && property in subject && (input[property] !== subject[property] || input[property]["@id"] !== subject[property]["@id"])) {
            throw new JsonLdError(
              "Invalid JSON-LD syntax; conflicting @index property detected.",
              "jsonld.SyntaxError",
              { code: "conflicting indexes", subject }
            );
          }
          subject[property] = input[property];
          continue;
        }
        const objects = input[property];
        if (property.indexOf("_:") === 0) {
          property = issuer.getId(property);
        }
        if (objects.length === 0) {
          util2.addValue(subject, property, [], { propertyIsArray: true });
          continue;
        }
        for (let o of objects) {
          if (property === "@type") {
            o = o.indexOf("_:") === 0 ? issuer.getId(o) : o;
          }
          if (graphTypes.isSubject(o) || graphTypes.isSubjectReference(o)) {
            if ("@id" in o && !o["@id"]) {
              continue;
            }
            const id = graphTypes.isBlankNode(o) ? issuer.getId(o["@id"]) : o["@id"];
            util2.addValue(
              subject,
              property,
              { "@id": id },
              { propertyIsArray: true, allowDuplicate: false }
            );
            api.createNodeMap(o, graphs, graph, issuer, id);
          } else if (graphTypes.isValue(o)) {
            util2.addValue(
              subject,
              property,
              o,
              { propertyIsArray: true, allowDuplicate: false }
            );
          } else if (graphTypes.isList(o)) {
            const _list = [];
            api.createNodeMap(o["@list"], graphs, graph, issuer, name, _list);
            o = { "@list": _list };
            util2.addValue(
              subject,
              property,
              o,
              { propertyIsArray: true, allowDuplicate: false }
            );
          } else {
            api.createNodeMap(o, graphs, graph, issuer, name);
            util2.addValue(
              subject,
              property,
              o,
              { propertyIsArray: true, allowDuplicate: false }
            );
          }
        }
      }
    };
    api.mergeNodeMapGraphs = (graphs) => {
      const merged = {};
      for (const name of Object.keys(graphs).sort()) {
        for (const id of Object.keys(graphs[name]).sort()) {
          const node = graphs[name][id];
          if (!(id in merged)) {
            merged[id] = { "@id": id };
          }
          const mergedNode = merged[id];
          for (const property of Object.keys(node).sort()) {
            if (isKeyword(property) && property !== "@type") {
              mergedNode[property] = util2.clone(node[property]);
            } else {
              for (const value of node[property]) {
                util2.addValue(
                  mergedNode,
                  property,
                  util2.clone(value),
                  { propertyIsArray: true, allowDuplicate: false }
                );
              }
            }
          }
        }
      }
      return merged;
    };
    api.mergeNodeMaps = (graphs) => {
      const defaultGraph = graphs["@default"];
      const graphNames = Object.keys(graphs).sort();
      for (const graphName of graphNames) {
        if (graphName === "@default") {
          continue;
        }
        const nodeMap = graphs[graphName];
        let subject = defaultGraph[graphName];
        if (!subject) {
          defaultGraph[graphName] = subject = {
            "@id": graphName,
            "@graph": []
          };
        } else if (!("@graph" in subject)) {
          subject["@graph"] = [];
        }
        const graph = subject["@graph"];
        for (const id of Object.keys(nodeMap).sort()) {
          const node = nodeMap[id];
          if (!graphTypes.isSubjectReference(node)) {
            graph.push(node);
          }
        }
      }
      return defaultGraph;
    };
  }
});

// node_modules/@digitalcredentials/jsonld/lib/flatten.js
var require_flatten = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/flatten.js"(exports, module) {
    "use strict";
    var {
      isSubjectReference: _isSubjectReference
    } = require_graphTypes();
    var {
      createMergedNodeMap: _createMergedNodeMap
    } = require_nodeMap();
    var api = {};
    module.exports = api;
    api.flatten = (input) => {
      const defaultGraph = _createMergedNodeMap(input);
      const flattened = [];
      const keys = Object.keys(defaultGraph).sort();
      for (let ki = 0; ki < keys.length; ++ki) {
        const node = defaultGraph[keys[ki]];
        if (!_isSubjectReference(node)) {
          flattened.push(node);
        }
      }
      return flattened;
    };
  }
});

// node_modules/@digitalcredentials/jsonld/lib/fromRdf.js
var require_fromRdf = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/fromRdf.js"(exports, module) {
    "use strict";
    var JsonLdError = require_JsonLdError();
    var graphTypes = require_graphTypes();
    var types = require_types5();
    var util2 = require_util3();
    var {
      // RDF,
      RDF_LIST,
      RDF_FIRST,
      RDF_REST,
      RDF_NIL,
      RDF_TYPE,
      // RDF_PLAIN_LITERAL,
      // RDF_XML_LITERAL,
      RDF_JSON_LITERAL,
      // RDF_OBJECT,
      // RDF_LANGSTRING,
      // XSD,
      XSD_BOOLEAN,
      XSD_DOUBLE,
      XSD_INTEGER,
      XSD_STRING
    } = require_constants6();
    var REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;
    var api = {};
    module.exports = api;
    api.fromRDF = async (dataset, {
      useRdfType = false,
      useNativeTypes = false,
      rdfDirection = null
    }) => {
      const defaultGraph = {};
      const graphMap = { "@default": defaultGraph };
      const referencedOnce = {};
      for (const quad of dataset) {
        const name = quad.graph.termType === "DefaultGraph" ? "@default" : quad.graph.value;
        if (!(name in graphMap)) {
          graphMap[name] = {};
        }
        if (name !== "@default" && !(name in defaultGraph)) {
          defaultGraph[name] = { "@id": name };
        }
        const nodeMap = graphMap[name];
        const s = quad.subject.value;
        const p = quad.predicate.value;
        const o = quad.object;
        if (!(s in nodeMap)) {
          nodeMap[s] = { "@id": s };
        }
        const node = nodeMap[s];
        const objectIsNode = o.termType.endsWith("Node");
        if (objectIsNode && !(o.value in nodeMap)) {
          nodeMap[o.value] = { "@id": o.value };
        }
        if (p === RDF_TYPE && !useRdfType && objectIsNode) {
          util2.addValue(node, "@type", o.value, { propertyIsArray: true });
          continue;
        }
        const value = _RDFToObject(o, useNativeTypes, rdfDirection);
        util2.addValue(node, p, value, { propertyIsArray: true });
        if (objectIsNode) {
          if (o.value === RDF_NIL) {
            const object = nodeMap[o.value];
            if (!("usages" in object)) {
              object.usages = [];
            }
            object.usages.push({
              node,
              property: p,
              value
            });
          } else if (o.value in referencedOnce) {
            referencedOnce[o.value] = false;
          } else {
            referencedOnce[o.value] = {
              node,
              property: p,
              value
            };
          }
        }
      }
      for (const name in graphMap) {
        const graphObject = graphMap[name];
        if (!(RDF_NIL in graphObject)) {
          continue;
        }
        const nil = graphObject[RDF_NIL];
        if (!nil.usages) {
          continue;
        }
        for (let usage of nil.usages) {
          let node = usage.node;
          let property = usage.property;
          let head = usage.value;
          const list = [];
          const listNodes = [];
          let nodeKeyCount = Object.keys(node).length;
          while (property === RDF_REST && types.isObject(referencedOnce[node["@id"]]) && types.isArray(node[RDF_FIRST]) && node[RDF_FIRST].length === 1 && types.isArray(node[RDF_REST]) && node[RDF_REST].length === 1 && (nodeKeyCount === 3 || nodeKeyCount === 4 && types.isArray(node["@type"]) && node["@type"].length === 1 && node["@type"][0] === RDF_LIST)) {
            list.push(node[RDF_FIRST][0]);
            listNodes.push(node["@id"]);
            usage = referencedOnce[node["@id"]];
            node = usage.node;
            property = usage.property;
            head = usage.value;
            nodeKeyCount = Object.keys(node).length;
            if (!graphTypes.isBlankNode(node)) {
              break;
            }
          }
          delete head["@id"];
          head["@list"] = list.reverse();
          for (const listNode of listNodes) {
            delete graphObject[listNode];
          }
        }
        delete nil.usages;
      }
      const result2 = [];
      const subjects = Object.keys(defaultGraph).sort();
      for (const subject of subjects) {
        const node = defaultGraph[subject];
        if (subject in graphMap) {
          const graph = node["@graph"] = [];
          const graphObject = graphMap[subject];
          const graphSubjects = Object.keys(graphObject).sort();
          for (const graphSubject of graphSubjects) {
            const node2 = graphObject[graphSubject];
            if (!graphTypes.isSubjectReference(node2)) {
              graph.push(node2);
            }
          }
        }
        if (!graphTypes.isSubjectReference(node)) {
          result2.push(node);
        }
      }
      return result2;
    };
    function _RDFToObject(o, useNativeTypes, rdfDirection) {
      if (o.termType.endsWith("Node")) {
        return { "@id": o.value };
      }
      const rval = { "@value": o.value };
      if (o.language) {
        rval["@language"] = o.language;
      } else {
        let type = o.datatype.value;
        if (!type) {
          type = XSD_STRING;
        }
        if (type === RDF_JSON_LITERAL) {
          type = "@json";
          try {
            rval["@value"] = JSON.parse(rval["@value"]);
          } catch (e) {
            throw new JsonLdError(
              "JSON literal could not be parsed.",
              "jsonld.InvalidJsonLiteral",
              { code: "invalid JSON literal", value: rval["@value"], cause: e }
            );
          }
        }
        if (useNativeTypes) {
          if (type === XSD_BOOLEAN) {
            if (rval["@value"] === "true") {
              rval["@value"] = true;
            } else if (rval["@value"] === "false") {
              rval["@value"] = false;
            }
          } else if (types.isNumeric(rval["@value"])) {
            if (type === XSD_INTEGER) {
              const i = parseInt(rval["@value"], 10);
              if (i.toFixed(0) === rval["@value"]) {
                rval["@value"] = i;
              }
            } else if (type === XSD_DOUBLE) {
              rval["@value"] = parseFloat(rval["@value"]);
            }
          }
          if (![XSD_BOOLEAN, XSD_INTEGER, XSD_DOUBLE, XSD_STRING].includes(type)) {
            rval["@type"] = type;
          }
        } else if (rdfDirection === "i18n-datatype" && type.startsWith("https://www.w3.org/ns/i18n#")) {
          const [, language, direction] = type.split(/[#_]/);
          if (language.length > 0) {
            rval["@language"] = language;
            if (!language.match(REGEX_BCP47)) {
              console.warn(`@language must be valid BCP47: ${language}`);
            }
          }
          rval["@direction"] = direction;
        } else if (type !== XSD_STRING) {
          rval["@type"] = type;
        }
      }
      return rval;
    }
  }
});

// node_modules/canonicalize/lib/canonicalize.js
var require_canonicalize = __commonJS({
  "node_modules/canonicalize/lib/canonicalize.js"(exports, module) {
    "use strict";
    module.exports = function serialize2(object) {
      if (object === null || typeof object !== "object" || object.toJSON != null) {
        return JSON.stringify(object);
      }
      if (Array.isArray(object)) {
        return "[" + object.reduce((t, cv, ci) => {
          const comma = ci === 0 ? "" : ",";
          const value = cv === void 0 || typeof cv === "symbol" ? null : cv;
          return t + comma + serialize2(value);
        }, "") + "]";
      }
      return "{" + Object.keys(object).sort().reduce((t, cv, ci) => {
        if (object[cv] === void 0 || typeof object[cv] === "symbol") {
          return t;
        }
        const comma = t.length === 0 ? "" : ",";
        return t + comma + serialize2(cv) + ":" + serialize2(object[cv]);
      }, "") + "}";
    };
  }
});

// node_modules/@digitalcredentials/jsonld/lib/toRdf.js
var require_toRdf = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/toRdf.js"(exports, module) {
    "use strict";
    var { createNodeMap } = require_nodeMap();
    var { isKeyword } = require_context3();
    var graphTypes = require_graphTypes();
    var jsonCanonicalize = require_canonicalize();
    var types = require_types5();
    var util2 = require_util3();
    var {
      // RDF,
      // RDF_LIST,
      RDF_FIRST,
      RDF_REST,
      RDF_NIL,
      RDF_TYPE,
      // RDF_PLAIN_LITERAL,
      // RDF_XML_LITERAL,
      RDF_JSON_LITERAL,
      // RDF_OBJECT,
      RDF_LANGSTRING,
      // XSD,
      XSD_BOOLEAN,
      XSD_DOUBLE,
      XSD_INTEGER,
      XSD_STRING
    } = require_constants6();
    var {
      isAbsolute: _isAbsoluteIri
    } = require_url();
    var api = {};
    module.exports = api;
    api.toRDF = (input, options) => {
      const issuer = new util2.IdentifierIssuer("_:b");
      const nodeMap = { "@default": {} };
      createNodeMap(input, nodeMap, "@default", issuer);
      const dataset = [];
      const graphNames = Object.keys(nodeMap).sort();
      for (const graphName of graphNames) {
        let graphTerm;
        if (graphName === "@default") {
          graphTerm = { termType: "DefaultGraph", value: "" };
        } else if (_isAbsoluteIri(graphName)) {
          if (graphName.startsWith("_:")) {
            graphTerm = { termType: "BlankNode" };
          } else {
            graphTerm = { termType: "NamedNode" };
          }
          graphTerm.value = graphName;
        } else {
          continue;
        }
        _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);
      }
      return dataset;
    };
    function _graphToRDF(dataset, graph, graphTerm, issuer, options) {
      const ids = Object.keys(graph).sort();
      for (const id of ids) {
        const node = graph[id];
        const properties = Object.keys(node).sort();
        for (let property of properties) {
          const items = node[property];
          if (property === "@type") {
            property = RDF_TYPE;
          } else if (isKeyword(property)) {
            continue;
          }
          for (const item of items) {
            const subject = {
              termType: id.startsWith("_:") ? "BlankNode" : "NamedNode",
              value: id
            };
            if (!_isAbsoluteIri(id)) {
              continue;
            }
            const predicate = {
              termType: property.startsWith("_:") ? "BlankNode" : "NamedNode",
              value: property
            };
            if (!_isAbsoluteIri(property)) {
              continue;
            }
            if (predicate.termType === "BlankNode" && !options.produceGeneralizedRdf) {
              continue;
            }
            const object = _objectToRDF(item, issuer, dataset, graphTerm, options.rdfDirection);
            if (object) {
              dataset.push({
                subject,
                predicate,
                object,
                graph: graphTerm
              });
            }
          }
        }
      }
    }
    function _listToRDF(list, issuer, dataset, graphTerm, rdfDirection) {
      const first = { termType: "NamedNode", value: RDF_FIRST };
      const rest = { termType: "NamedNode", value: RDF_REST };
      const nil = { termType: "NamedNode", value: RDF_NIL };
      const last = list.pop();
      const result2 = last ? { termType: "BlankNode", value: issuer.getId() } : nil;
      let subject = result2;
      for (const item of list) {
        const object = _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection);
        const next = { termType: "BlankNode", value: issuer.getId() };
        dataset.push({
          subject,
          predicate: first,
          object,
          graph: graphTerm
        });
        dataset.push({
          subject,
          predicate: rest,
          object: next,
          graph: graphTerm
        });
        subject = next;
      }
      if (last) {
        const object = _objectToRDF(last, issuer, dataset, graphTerm, rdfDirection);
        dataset.push({
          subject,
          predicate: first,
          object,
          graph: graphTerm
        });
        dataset.push({
          subject,
          predicate: rest,
          object: nil,
          graph: graphTerm
        });
      }
      return result2;
    }
    function _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection) {
      const object = {};
      if (graphTypes.isValue(item)) {
        object.termType = "Literal";
        object.value = void 0;
        object.datatype = {
          termType: "NamedNode"
        };
        let value = item["@value"];
        const datatype = item["@type"] || null;
        if (datatype === "@json") {
          object.value = jsonCanonicalize(value);
          object.datatype.value = RDF_JSON_LITERAL;
        } else if (types.isBoolean(value)) {
          object.value = value.toString();
          object.datatype.value = datatype || XSD_BOOLEAN;
        } else if (types.isDouble(value) || datatype === XSD_DOUBLE) {
          if (!types.isDouble(value)) {
            value = parseFloat(value);
          }
          object.value = value.toExponential(15).replace(/(\d)0*e\+?/, "$1E");
          object.datatype.value = datatype || XSD_DOUBLE;
        } else if (types.isNumber(value)) {
          object.value = value.toFixed(0);
          object.datatype.value = datatype || XSD_INTEGER;
        } else if (rdfDirection === "i18n-datatype" && "@direction" in item) {
          const datatype2 = "https://www.w3.org/ns/i18n#" + (item["@language"] || "") + `_${item["@direction"]}`;
          object.datatype.value = datatype2;
          object.value = value;
        } else if ("@language" in item) {
          object.value = value;
          object.datatype.value = datatype || RDF_LANGSTRING;
          object.language = item["@language"];
        } else {
          object.value = value;
          object.datatype.value = datatype || XSD_STRING;
        }
      } else if (graphTypes.isList(item)) {
        const _list = _listToRDF(item["@list"], issuer, dataset, graphTerm, rdfDirection);
        object.termType = _list.termType;
        object.value = _list.value;
      } else {
        const id = types.isObject(item) ? item["@id"] : item;
        object.termType = id.startsWith("_:") ? "BlankNode" : "NamedNode";
        object.value = id;
      }
      if (object.termType === "NamedNode" && !_isAbsoluteIri(object.value)) {
        return null;
      }
      return object;
    }
  }
});

// node_modules/@digitalcredentials/jsonld/lib/frame.js
var require_frame = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/frame.js"(exports, module) {
    "use strict";
    var { isKeyword } = require_context3();
    var graphTypes = require_graphTypes();
    var types = require_types5();
    var util2 = require_util3();
    var url = require_url();
    var JsonLdError = require_JsonLdError();
    var {
      createNodeMap: _createNodeMap,
      mergeNodeMapGraphs: _mergeNodeMapGraphs
    } = require_nodeMap();
    var api = {};
    module.exports = api;
    api.frameMergedOrDefault = (input, frame, options) => {
      const state = {
        options,
        embedded: false,
        graph: "@default",
        graphMap: { "@default": {} },
        subjectStack: [],
        link: {},
        bnodeMap: {}
      };
      const issuer = new util2.IdentifierIssuer("_:b");
      _createNodeMap(input, state.graphMap, "@default", issuer);
      if (options.merged) {
        state.graphMap["@merged"] = _mergeNodeMapGraphs(state.graphMap);
        state.graph = "@merged";
      }
      state.subjects = state.graphMap[state.graph];
      const framed = [];
      api.frame(state, Object.keys(state.subjects).sort(), frame, framed);
      if (options.pruneBlankNodeIdentifiers) {
        options.bnodesToClear = Object.keys(state.bnodeMap).filter((id) => state.bnodeMap[id].length === 1);
      }
      options.link = {};
      return _cleanupPreserve(framed, options);
    };
    api.frame = (state, subjects, frame, parent, property = null) => {
      _validateFrame(frame);
      frame = frame[0];
      const options = state.options;
      const flags = {
        embed: _getFrameFlag(frame, options, "embed"),
        explicit: _getFrameFlag(frame, options, "explicit"),
        requireAll: _getFrameFlag(frame, options, "requireAll")
      };
      if (!state.link.hasOwnProperty(state.graph)) {
        state.link[state.graph] = {};
      }
      const link = state.link[state.graph];
      const matches2 = _filterSubjects(state, subjects, frame, flags);
      const ids = Object.keys(matches2).sort();
      for (const id of ids) {
        const subject = matches2[id];
        if (property === null) {
          state.uniqueEmbeds = { [state.graph]: {} };
        } else {
          state.uniqueEmbeds[state.graph] = state.uniqueEmbeds[state.graph] || {};
        }
        if (flags.embed === "@link" && id in link) {
          _addFrameOutput(parent, property, link[id]);
          continue;
        }
        const output = { "@id": id };
        if (id.indexOf("_:") === 0) {
          util2.addValue(state.bnodeMap, id, output, { propertyIsArray: true });
        }
        link[id] = output;
        if ((flags.embed === "@first" || flags.embed === "@last") && state.is11) {
          throw new JsonLdError(
            "Invalid JSON-LD syntax; invalid value of @embed.",
            "jsonld.SyntaxError",
            { code: "invalid @embed value", frame }
          );
        }
        if (!state.embedded && state.uniqueEmbeds[state.graph].hasOwnProperty(id)) {
          continue;
        }
        if (state.embedded && (flags.embed === "@never" || _createsCircularReference(subject, state.graph, state.subjectStack))) {
          _addFrameOutput(parent, property, output);
          continue;
        }
        if (state.embedded && (flags.embed == "@first" || flags.embed == "@once") && state.uniqueEmbeds[state.graph].hasOwnProperty(id)) {
          _addFrameOutput(parent, property, output);
          continue;
        }
        if (flags.embed === "@last") {
          if (id in state.uniqueEmbeds[state.graph]) {
            _removeEmbed(state, id);
          }
        }
        state.uniqueEmbeds[state.graph][id] = { parent, property };
        state.subjectStack.push({ subject, graph: state.graph });
        if (id in state.graphMap) {
          let recurse = false;
          let subframe = null;
          if (!("@graph" in frame)) {
            recurse = state.graph !== "@merged";
            subframe = {};
          } else {
            subframe = frame["@graph"][0];
            recurse = !(id === "@merged" || id === "@default");
            if (!types.isObject(subframe)) {
              subframe = {};
            }
          }
          if (recurse) {
            api.frame(
              { ...state, graph: id, embedded: false },
              Object.keys(state.graphMap[id]).sort(),
              [subframe],
              output,
              "@graph"
            );
          }
        }
        if ("@included" in frame) {
          api.frame(
            { ...state, embedded: false },
            subjects,
            frame["@included"],
            output,
            "@included"
          );
        }
        for (const prop of Object.keys(subject).sort()) {
          if (isKeyword(prop)) {
            output[prop] = util2.clone(subject[prop]);
            if (prop === "@type") {
              for (const type of subject["@type"]) {
                if (type.indexOf("_:") === 0) {
                  util2.addValue(
                    state.bnodeMap,
                    type,
                    output,
                    { propertyIsArray: true }
                  );
                }
              }
            }
            continue;
          }
          if (flags.explicit && !(prop in frame)) {
            continue;
          }
          for (const o of subject[prop]) {
            const subframe = prop in frame ? frame[prop] : _createImplicitFrame(flags);
            if (graphTypes.isList(o)) {
              const subframe2 = frame[prop] && frame[prop][0] && frame[prop][0]["@list"] ? frame[prop][0]["@list"] : _createImplicitFrame(flags);
              const list = { "@list": [] };
              _addFrameOutput(output, prop, list);
              const src = o["@list"];
              for (const oo of src) {
                if (graphTypes.isSubjectReference(oo)) {
                  api.frame(
                    { ...state, embedded: true },
                    [oo["@id"]],
                    subframe2,
                    list,
                    "@list"
                  );
                } else {
                  _addFrameOutput(list, "@list", util2.clone(oo));
                }
              }
            } else if (graphTypes.isSubjectReference(o)) {
              api.frame(
                { ...state, embedded: true },
                [o["@id"]],
                subframe,
                output,
                prop
              );
            } else if (_valueMatch(subframe[0], o)) {
              _addFrameOutput(output, prop, util2.clone(o));
            }
          }
        }
        for (const prop of Object.keys(frame).sort()) {
          if (prop === "@type") {
            if (!types.isObject(frame[prop][0]) || !("@default" in frame[prop][0])) {
              continue;
            }
          } else if (isKeyword(prop)) {
            continue;
          }
          const next = frame[prop][0] || {};
          const omitDefaultOn = _getFrameFlag(next, options, "omitDefault");
          if (!omitDefaultOn && !(prop in output)) {
            let preserve = "@null";
            if ("@default" in next) {
              preserve = util2.clone(next["@default"]);
            }
            if (!types.isArray(preserve)) {
              preserve = [preserve];
            }
            output[prop] = [{ "@preserve": preserve }];
          }
        }
        for (const reverseProp of Object.keys(frame["@reverse"] || {}).sort()) {
          const subframe = frame["@reverse"][reverseProp];
          for (const subject2 of Object.keys(state.subjects)) {
            const nodeValues = util2.getValues(state.subjects[subject2], reverseProp);
            if (nodeValues.some((v) => v["@id"] === id)) {
              output["@reverse"] = output["@reverse"] || {};
              util2.addValue(
                output["@reverse"],
                reverseProp,
                [],
                { propertyIsArray: true }
              );
              api.frame(
                { ...state, embedded: true },
                [subject2],
                subframe,
                output["@reverse"][reverseProp],
                property
              );
            }
          }
        }
        _addFrameOutput(parent, property, output);
        state.subjectStack.pop();
      }
    };
    api.cleanupNull = (input, options) => {
      if (types.isArray(input)) {
        const noNulls = input.map((v) => api.cleanupNull(v, options));
        return noNulls.filter((v) => v);
      }
      if (input === "@null") {
        return null;
      }
      if (types.isObject(input)) {
        if ("@id" in input) {
          const id = input["@id"];
          if (options.link.hasOwnProperty(id)) {
            const idx = options.link[id].indexOf(input);
            if (idx !== -1) {
              return options.link[id][idx];
            }
            options.link[id].push(input);
          } else {
            options.link[id] = [input];
          }
        }
        for (const key in input) {
          input[key] = api.cleanupNull(input[key], options);
        }
      }
      return input;
    };
    function _createImplicitFrame(flags) {
      const frame = {};
      for (const key in flags) {
        if (flags[key] !== void 0) {
          frame["@" + key] = [flags[key]];
        }
      }
      return [frame];
    }
    function _createsCircularReference(subjectToEmbed, graph, subjectStack) {
      for (let i = subjectStack.length - 1; i >= 0; --i) {
        const subject = subjectStack[i];
        if (subject.graph === graph && subject.subject["@id"] === subjectToEmbed["@id"]) {
          return true;
        }
      }
      return false;
    }
    function _getFrameFlag(frame, options, name) {
      const flag = "@" + name;
      let rval = flag in frame ? frame[flag][0] : options[name];
      if (name === "embed") {
        if (rval === true) {
          rval = "@once";
        } else if (rval === false) {
          rval = "@never";
        } else if (rval !== "@always" && rval !== "@never" && rval !== "@link" && rval !== "@first" && rval !== "@last" && rval !== "@once") {
          throw new JsonLdError(
            "Invalid JSON-LD syntax; invalid value of @embed.",
            "jsonld.SyntaxError",
            { code: "invalid @embed value", frame }
          );
        }
      }
      return rval;
    }
    function _validateFrame(frame) {
      if (!types.isArray(frame) || frame.length !== 1 || !types.isObject(frame[0])) {
        throw new JsonLdError(
          "Invalid JSON-LD syntax; a JSON-LD frame must be a single object.",
          "jsonld.SyntaxError",
          { frame }
        );
      }
      if ("@id" in frame[0]) {
        for (const id of util2.asArray(frame[0]["@id"])) {
          if (!(types.isObject(id) || url.isAbsolute(id)) || types.isString(id) && id.indexOf("_:") === 0) {
            throw new JsonLdError(
              "Invalid JSON-LD syntax; invalid @id in frame.",
              "jsonld.SyntaxError",
              { code: "invalid frame", frame }
            );
          }
        }
      }
      if ("@type" in frame[0]) {
        for (const type of util2.asArray(frame[0]["@type"])) {
          if (!(types.isObject(type) || url.isAbsolute(type)) || types.isString(type) && type.indexOf("_:") === 0) {
            throw new JsonLdError(
              "Invalid JSON-LD syntax; invalid @type in frame.",
              "jsonld.SyntaxError",
              { code: "invalid frame", frame }
            );
          }
        }
      }
    }
    function _filterSubjects(state, subjects, frame, flags) {
      const rval = {};
      for (const id of subjects) {
        const subject = state.graphMap[state.graph][id];
        if (_filterSubject(state, subject, frame, flags)) {
          rval[id] = subject;
        }
      }
      return rval;
    }
    function _filterSubject(state, subject, frame, flags) {
      let wildcard = true;
      let matchesSome = false;
      for (const key in frame) {
        let matchThis = false;
        const nodeValues = util2.getValues(subject, key);
        const isEmpty2 = util2.getValues(frame, key).length === 0;
        if (key === "@id") {
          if (types.isEmptyObject(frame["@id"][0] || {})) {
            matchThis = true;
          } else if (frame["@id"].length >= 0) {
            matchThis = frame["@id"].includes(nodeValues[0]);
          }
          if (!flags.requireAll) {
            return matchThis;
          }
        } else if (key === "@type") {
          wildcard = false;
          if (isEmpty2) {
            if (nodeValues.length > 0) {
              return false;
            }
            matchThis = true;
          } else if (frame["@type"].length === 1 && types.isEmptyObject(frame["@type"][0])) {
            matchThis = nodeValues.length > 0;
          } else {
            for (const type of frame["@type"]) {
              if (types.isObject(type) && "@default" in type) {
                matchThis = true;
              } else {
                matchThis = matchThis || nodeValues.some((tt) => tt === type);
              }
            }
          }
          if (!flags.requireAll) {
            return matchThis;
          }
        } else if (isKeyword(key)) {
          continue;
        } else {
          const thisFrame = util2.getValues(frame, key)[0];
          let hasDefault = false;
          if (thisFrame) {
            _validateFrame([thisFrame]);
            hasDefault = "@default" in thisFrame;
          }
          wildcard = false;
          if (nodeValues.length === 0 && hasDefault) {
            continue;
          }
          if (nodeValues.length > 0 && isEmpty2) {
            return false;
          }
          if (thisFrame === void 0) {
            if (nodeValues.length > 0) {
              return false;
            }
            matchThis = true;
          } else {
            if (graphTypes.isList(thisFrame)) {
              const listValue = thisFrame["@list"][0];
              if (graphTypes.isList(nodeValues[0])) {
                const nodeListValues = nodeValues[0]["@list"];
                if (graphTypes.isValue(listValue)) {
                  matchThis = nodeListValues.some((lv) => _valueMatch(listValue, lv));
                } else if (graphTypes.isSubject(listValue) || graphTypes.isSubjectReference(listValue)) {
                  matchThis = nodeListValues.some((lv) => _nodeMatch(
                    state,
                    listValue,
                    lv,
                    flags
                  ));
                }
              }
            } else if (graphTypes.isValue(thisFrame)) {
              matchThis = nodeValues.some((nv) => _valueMatch(thisFrame, nv));
            } else if (graphTypes.isSubjectReference(thisFrame)) {
              matchThis = nodeValues.some((nv) => _nodeMatch(state, thisFrame, nv, flags));
            } else if (types.isObject(thisFrame)) {
              matchThis = nodeValues.length > 0;
            } else {
              matchThis = false;
            }
          }
        }
        if (!matchThis && flags.requireAll) {
          return false;
        }
        matchesSome = matchesSome || matchThis;
      }
      return wildcard || matchesSome;
    }
    function _removeEmbed(state, id) {
      const embeds = state.uniqueEmbeds[state.graph];
      const embed = embeds[id];
      const parent = embed.parent;
      const property = embed.property;
      const subject = { "@id": id };
      if (types.isArray(parent)) {
        for (let i = 0; i < parent.length; ++i) {
          if (util2.compareValues(parent[i], subject)) {
            parent[i] = subject;
            break;
          }
        }
      } else {
        const useArray = types.isArray(parent[property]);
        util2.removeValue(parent, property, subject, { propertyIsArray: useArray });
        util2.addValue(parent, property, subject, { propertyIsArray: useArray });
      }
      const removeDependents = (id2) => {
        const ids = Object.keys(embeds);
        for (const next of ids) {
          if (next in embeds && types.isObject(embeds[next].parent) && embeds[next].parent["@id"] === id2) {
            delete embeds[next];
            removeDependents(next);
          }
        }
      };
      removeDependents(id);
    }
    function _cleanupPreserve(input, options) {
      if (types.isArray(input)) {
        return input.map((value) => _cleanupPreserve(value, options));
      }
      if (types.isObject(input)) {
        if ("@preserve" in input) {
          return input["@preserve"][0];
        }
        if (graphTypes.isValue(input)) {
          return input;
        }
        if (graphTypes.isList(input)) {
          input["@list"] = _cleanupPreserve(input["@list"], options);
          return input;
        }
        if ("@id" in input) {
          const id = input["@id"];
          if (options.link.hasOwnProperty(id)) {
            const idx = options.link[id].indexOf(input);
            if (idx !== -1) {
              return options.link[id][idx];
            }
            options.link[id].push(input);
          } else {
            options.link[id] = [input];
          }
        }
        for (const prop in input) {
          if (prop === "@id" && options.bnodesToClear.includes(input[prop])) {
            delete input["@id"];
            continue;
          }
          input[prop] = _cleanupPreserve(input[prop], options);
        }
      }
      return input;
    }
    function _addFrameOutput(parent, property, output) {
      if (types.isObject(parent)) {
        util2.addValue(parent, property, output, { propertyIsArray: true });
      } else {
        parent.push(output);
      }
    }
    function _nodeMatch(state, pattern, value, flags) {
      if (!("@id" in value)) {
        return false;
      }
      const nodeObject = state.subjects[value["@id"]];
      return nodeObject && _filterSubject(state, nodeObject, pattern, flags);
    }
    function _valueMatch(pattern, value) {
      const v12 = value["@value"];
      const t1 = value["@type"];
      const l1 = value["@language"];
      const v2 = pattern["@value"] ? types.isArray(pattern["@value"]) ? pattern["@value"] : [pattern["@value"]] : [];
      const t2 = pattern["@type"] ? types.isArray(pattern["@type"]) ? pattern["@type"] : [pattern["@type"]] : [];
      const l2 = pattern["@language"] ? types.isArray(pattern["@language"]) ? pattern["@language"] : [pattern["@language"]] : [];
      if (v2.length === 0 && t2.length === 0 && l2.length === 0) {
        return true;
      }
      if (!(v2.includes(v12) || types.isEmptyObject(v2[0]))) {
        return false;
      }
      if (!(!t1 && t2.length === 0 || t2.includes(t1) || t1 && types.isEmptyObject(t2[0]))) {
        return false;
      }
      if (!(!l1 && l2.length === 0 || l2.includes(l1) || l1 && types.isEmptyObject(l2[0]))) {
        return false;
      }
      return true;
    }
  }
});

// node_modules/@digitalcredentials/jsonld/lib/compact.js
var require_compact = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/compact.js"(exports, module) {
    "use strict";
    var JsonLdError = require_JsonLdError();
    var {
      isArray: _isArray,
      isObject: _isObject,
      isString: _isString,
      isUndefined: _isUndefined
    } = require_types5();
    var {
      isList: _isList,
      isValue: _isValue,
      isGraph: _isGraph,
      isSimpleGraph: _isSimpleGraph,
      isSubjectReference: _isSubjectReference
    } = require_graphTypes();
    var {
      expandIri: _expandIri,
      getContextValue: _getContextValue,
      isKeyword: _isKeyword,
      process: _processContext,
      processingMode: _processingMode
    } = require_context3();
    var {
      removeBase: _removeBase,
      prependBase: _prependBase
    } = require_url();
    var {
      addValue: _addValue,
      asArray: _asArray,
      compareShortestLeast: _compareShortestLeast
    } = require_util3();
    var api = {};
    module.exports = api;
    api.compact = async ({
      activeCtx,
      activeProperty = null,
      element,
      options = {},
      compactionMap = () => void 0
    }) => {
      if (_isArray(element)) {
        let rval = [];
        for (let i = 0; i < element.length; ++i) {
          let compacted = await api.compact({
            activeCtx,
            activeProperty,
            element: element[i],
            options,
            compactionMap
          });
          if (compacted === null) {
            compacted = await compactionMap({
              unmappedValue: element[i],
              activeCtx,
              activeProperty,
              parent: element,
              index: i,
              options
            });
            if (compacted === void 0) {
              continue;
            }
          }
          rval.push(compacted);
        }
        if (options.compactArrays && rval.length === 1) {
          const container = _getContextValue(
            activeCtx,
            activeProperty,
            "@container"
          ) || [];
          if (container.length === 0) {
            rval = rval[0];
          }
        }
        return rval;
      }
      const ctx = _getContextValue(activeCtx, activeProperty, "@context");
      if (!_isUndefined(ctx)) {
        activeCtx = await _processContext({
          activeCtx,
          localCtx: ctx,
          propagate: true,
          overrideProtected: true,
          options
        });
      }
      if (_isObject(element)) {
        if (options.link && "@id" in element && options.link.hasOwnProperty(element["@id"])) {
          const linked = options.link[element["@id"]];
          for (let i = 0; i < linked.length; ++i) {
            if (linked[i].expanded === element) {
              return linked[i].compacted;
            }
          }
        }
        if (_isValue(element) || _isSubjectReference(element)) {
          const rval2 = api.compactValue({ activeCtx, activeProperty, value: element, options });
          if (options.link && _isSubjectReference(element)) {
            if (!options.link.hasOwnProperty(element["@id"])) {
              options.link[element["@id"]] = [];
            }
            options.link[element["@id"]].push({ expanded: element, compacted: rval2 });
          }
          return rval2;
        }
        if (_isList(element)) {
          const container = _getContextValue(
            activeCtx,
            activeProperty,
            "@container"
          ) || [];
          if (container.includes("@list")) {
            return api.compact({
              activeCtx,
              activeProperty,
              element: element["@list"],
              options,
              compactionMap
            });
          }
        }
        const insideReverse = activeProperty === "@reverse";
        const rval = {};
        const inputCtx = activeCtx;
        if (!_isValue(element) && !_isSubjectReference(element)) {
          activeCtx = activeCtx.revertToPreviousContext();
        }
        const propertyScopedCtx = _getContextValue(inputCtx, activeProperty, "@context");
        if (!_isUndefined(propertyScopedCtx)) {
          activeCtx = await _processContext({
            activeCtx,
            localCtx: propertyScopedCtx,
            propagate: true,
            overrideProtected: true,
            options
          });
        }
        if (options.link && "@id" in element) {
          if (!options.link.hasOwnProperty(element["@id"])) {
            options.link[element["@id"]] = [];
          }
          options.link[element["@id"]].push({ expanded: element, compacted: rval });
        }
        let types = element["@type"] || [];
        if (types.length > 1) {
          types = Array.from(types).sort();
        }
        const typeContext = activeCtx;
        for (const type of types) {
          const compactedType = api.compactIri(
            { activeCtx: typeContext, iri: type, relativeTo: { vocab: true } }
          );
          const ctx2 = _getContextValue(inputCtx, compactedType, "@context");
          if (!_isUndefined(ctx2)) {
            activeCtx = await _processContext({
              activeCtx,
              localCtx: ctx2,
              options,
              propagate: false
            });
          }
        }
        const keys = Object.keys(element).sort();
        for (const expandedProperty of keys) {
          const expandedValue = element[expandedProperty];
          if (expandedProperty === "@id") {
            let compactedValue = _asArray(expandedValue).map(
              (expandedIri) => api.compactIri({
                activeCtx,
                iri: expandedIri,
                relativeTo: { vocab: false },
                base: options.base
              })
            );
            if (compactedValue.length === 1) {
              compactedValue = compactedValue[0];
            }
            const alias = api.compactIri(
              { activeCtx, iri: "@id", relativeTo: { vocab: true } }
            );
            rval[alias] = compactedValue;
            continue;
          }
          if (expandedProperty === "@type") {
            let compactedValue = _asArray(expandedValue).map(
              (expandedIri) => api.compactIri({
                activeCtx: inputCtx,
                iri: expandedIri,
                relativeTo: { vocab: true }
              })
            );
            if (compactedValue.length === 1) {
              compactedValue = compactedValue[0];
            }
            const alias = api.compactIri(
              { activeCtx, iri: "@type", relativeTo: { vocab: true } }
            );
            const container = _getContextValue(
              activeCtx,
              alias,
              "@container"
            ) || [];
            const typeAsSet = container.includes("@set") && _processingMode(activeCtx, 1.1);
            const isArray2 = typeAsSet || _isArray(compactedValue) && expandedValue.length === 0;
            _addValue(rval, alias, compactedValue, { propertyIsArray: isArray2 });
            continue;
          }
          if (expandedProperty === "@reverse") {
            const compactedValue = await api.compact({
              activeCtx,
              activeProperty: "@reverse",
              element: expandedValue,
              options,
              compactionMap
            });
            for (const compactedProperty in compactedValue) {
              if (activeCtx.mappings.has(compactedProperty) && activeCtx.mappings.get(compactedProperty).reverse) {
                const value = compactedValue[compactedProperty];
                const container = _getContextValue(
                  activeCtx,
                  compactedProperty,
                  "@container"
                ) || [];
                const useArray = container.includes("@set") || !options.compactArrays;
                _addValue(
                  rval,
                  compactedProperty,
                  value,
                  { propertyIsArray: useArray }
                );
                delete compactedValue[compactedProperty];
              }
            }
            if (Object.keys(compactedValue).length > 0) {
              const alias = api.compactIri({
                activeCtx,
                iri: expandedProperty,
                relativeTo: { vocab: true }
              });
              _addValue(rval, alias, compactedValue);
            }
            continue;
          }
          if (expandedProperty === "@preserve") {
            const compactedValue = await api.compact({
              activeCtx,
              activeProperty,
              element: expandedValue,
              options,
              compactionMap
            });
            if (!(_isArray(compactedValue) && compactedValue.length === 0)) {
              _addValue(rval, expandedProperty, compactedValue);
            }
            continue;
          }
          if (expandedProperty === "@index") {
            const container = _getContextValue(
              activeCtx,
              activeProperty,
              "@container"
            ) || [];
            if (container.includes("@index")) {
              continue;
            }
            const alias = api.compactIri({
              activeCtx,
              iri: expandedProperty,
              relativeTo: { vocab: true }
            });
            _addValue(rval, alias, expandedValue);
            continue;
          }
          if (expandedProperty !== "@graph" && expandedProperty !== "@list" && expandedProperty !== "@included" && _isKeyword(expandedProperty)) {
            const alias = api.compactIri({
              activeCtx,
              iri: expandedProperty,
              relativeTo: { vocab: true }
            });
            _addValue(rval, alias, expandedValue);
            continue;
          }
          if (!_isArray(expandedValue)) {
            throw new JsonLdError(
              "JSON-LD expansion error; expanded value must be an array.",
              "jsonld.SyntaxError"
            );
          }
          if (expandedValue.length === 0) {
            const itemActiveProperty = api.compactIri({
              activeCtx,
              iri: expandedProperty,
              value: expandedValue,
              relativeTo: { vocab: true },
              reverse: insideReverse
            });
            const nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)["@nest"] : null;
            let nestResult = rval;
            if (nestProperty) {
              _checkNestProperty(activeCtx, nestProperty, options);
              if (!_isObject(rval[nestProperty])) {
                rval[nestProperty] = {};
              }
              nestResult = rval[nestProperty];
            }
            _addValue(
              nestResult,
              itemActiveProperty,
              expandedValue,
              {
                propertyIsArray: true
              }
            );
          }
          for (const expandedItem of expandedValue) {
            const itemActiveProperty = api.compactIri({
              activeCtx,
              iri: expandedProperty,
              value: expandedItem,
              relativeTo: { vocab: true },
              reverse: insideReverse
            });
            const nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)["@nest"] : null;
            let nestResult = rval;
            if (nestProperty) {
              _checkNestProperty(activeCtx, nestProperty, options);
              if (!_isObject(rval[nestProperty])) {
                rval[nestProperty] = {};
              }
              nestResult = rval[nestProperty];
            }
            const container = _getContextValue(
              activeCtx,
              itemActiveProperty,
              "@container"
            ) || [];
            const isGraph = _isGraph(expandedItem);
            const isList = _isList(expandedItem);
            let inner;
            if (isList) {
              inner = expandedItem["@list"];
            } else if (isGraph) {
              inner = expandedItem["@graph"];
            }
            let compactedItem = await api.compact({
              activeCtx,
              activeProperty: itemActiveProperty,
              element: isList || isGraph ? inner : expandedItem,
              options,
              compactionMap
            });
            if (isList) {
              if (!_isArray(compactedItem)) {
                compactedItem = [compactedItem];
              }
              if (!container.includes("@list")) {
                compactedItem = {
                  [api.compactIri({
                    activeCtx,
                    iri: "@list",
                    relativeTo: { vocab: true }
                  })]: compactedItem
                };
                if ("@index" in expandedItem) {
                  compactedItem[api.compactIri({
                    activeCtx,
                    iri: "@index",
                    relativeTo: { vocab: true }
                  })] = expandedItem["@index"];
                }
              } else {
                _addValue(nestResult, itemActiveProperty, compactedItem, {
                  valueIsArray: true,
                  allowDuplicate: true
                });
                continue;
              }
            }
            if (isGraph) {
              if (container.includes("@graph") && (container.includes("@id") || container.includes("@index") && _isSimpleGraph(expandedItem))) {
                let mapObject;
                if (nestResult.hasOwnProperty(itemActiveProperty)) {
                  mapObject = nestResult[itemActiveProperty];
                } else {
                  nestResult[itemActiveProperty] = mapObject = {};
                }
                const key = (container.includes("@id") ? expandedItem["@id"] : expandedItem["@index"]) || api.compactIri({
                  activeCtx,
                  iri: "@none",
                  relativeTo: { vocab: true }
                });
                _addValue(
                  mapObject,
                  key,
                  compactedItem,
                  {
                    propertyIsArray: !options.compactArrays || container.includes("@set")
                  }
                );
              } else if (container.includes("@graph") && _isSimpleGraph(expandedItem)) {
                if (_isArray(compactedItem) && compactedItem.length > 1) {
                  compactedItem = { "@included": compactedItem };
                }
                _addValue(
                  nestResult,
                  itemActiveProperty,
                  compactedItem,
                  {
                    propertyIsArray: !options.compactArrays || container.includes("@set")
                  }
                );
              } else {
                if (_isArray(compactedItem) && compactedItem.length === 1 && options.compactArrays) {
                  compactedItem = compactedItem[0];
                }
                compactedItem = {
                  [api.compactIri({
                    activeCtx,
                    iri: "@graph",
                    relativeTo: { vocab: true }
                  })]: compactedItem
                };
                if ("@id" in expandedItem) {
                  compactedItem[api.compactIri({
                    activeCtx,
                    iri: "@id",
                    relativeTo: { vocab: true }
                  })] = expandedItem["@id"];
                }
                if ("@index" in expandedItem) {
                  compactedItem[api.compactIri({
                    activeCtx,
                    iri: "@index",
                    relativeTo: { vocab: true }
                  })] = expandedItem["@index"];
                }
                _addValue(
                  nestResult,
                  itemActiveProperty,
                  compactedItem,
                  {
                    propertyIsArray: !options.compactArrays || container.includes("@set")
                  }
                );
              }
            } else if (container.includes("@language") || container.includes("@index") || container.includes("@id") || container.includes("@type")) {
              let mapObject;
              if (nestResult.hasOwnProperty(itemActiveProperty)) {
                mapObject = nestResult[itemActiveProperty];
              } else {
                nestResult[itemActiveProperty] = mapObject = {};
              }
              let key;
              if (container.includes("@language")) {
                if (_isValue(compactedItem)) {
                  compactedItem = compactedItem["@value"];
                }
                key = expandedItem["@language"];
              } else if (container.includes("@index")) {
                const indexKey = _getContextValue(
                  activeCtx,
                  itemActiveProperty,
                  "@index"
                ) || "@index";
                const containerKey = api.compactIri(
                  { activeCtx, iri: indexKey, relativeTo: { vocab: true } }
                );
                if (indexKey === "@index") {
                  key = expandedItem["@index"];
                  delete compactedItem[containerKey];
                } else {
                  let others;
                  [key, ...others] = _asArray(compactedItem[indexKey] || []);
                  if (!_isString(key)) {
                    key = null;
                  } else {
                    switch (others.length) {
                      case 0:
                        delete compactedItem[indexKey];
                        break;
                      case 1:
                        compactedItem[indexKey] = others[0];
                        break;
                      default:
                        compactedItem[indexKey] = others;
                        break;
                    }
                  }
                }
              } else if (container.includes("@id")) {
                const idKey = api.compactIri({
                  activeCtx,
                  iri: "@id",
                  relativeTo: { vocab: true }
                });
                key = compactedItem[idKey];
                delete compactedItem[idKey];
              } else if (container.includes("@type")) {
                const typeKey = api.compactIri({
                  activeCtx,
                  iri: "@type",
                  relativeTo: { vocab: true }
                });
                let types2;
                [key, ...types2] = _asArray(compactedItem[typeKey] || []);
                switch (types2.length) {
                  case 0:
                    delete compactedItem[typeKey];
                    break;
                  case 1:
                    compactedItem[typeKey] = types2[0];
                    break;
                  default:
                    compactedItem[typeKey] = types2;
                    break;
                }
                if (Object.keys(compactedItem).length === 1 && "@id" in expandedItem) {
                  compactedItem = await api.compact({
                    activeCtx,
                    activeProperty: itemActiveProperty,
                    element: { "@id": expandedItem["@id"] },
                    options,
                    compactionMap
                  });
                }
              }
              if (!key) {
                key = api.compactIri({
                  activeCtx,
                  iri: "@none",
                  relativeTo: { vocab: true }
                });
              }
              _addValue(
                mapObject,
                key,
                compactedItem,
                {
                  propertyIsArray: container.includes("@set")
                }
              );
            } else {
              const isArray2 = !options.compactArrays || container.includes("@set") || container.includes("@list") || _isArray(compactedItem) && compactedItem.length === 0 || expandedProperty === "@list" || expandedProperty === "@graph";
              _addValue(
                nestResult,
                itemActiveProperty,
                compactedItem,
                { propertyIsArray: isArray2 }
              );
            }
          }
        }
        return rval;
      }
      return element;
    };
    api.compactIri = ({
      activeCtx,
      iri,
      value = null,
      relativeTo = { vocab: false },
      reverse = false,
      base = null
    }) => {
      if (iri === null) {
        return iri;
      }
      if (activeCtx.isPropertyTermScoped && activeCtx.previousContext) {
        activeCtx = activeCtx.previousContext;
      }
      const inverseCtx = activeCtx.getInverse();
      if (_isKeyword(iri) && iri in inverseCtx && "@none" in inverseCtx[iri] && "@type" in inverseCtx[iri]["@none"] && "@none" in inverseCtx[iri]["@none"]["@type"]) {
        return inverseCtx[iri]["@none"]["@type"]["@none"];
      }
      if (relativeTo.vocab && iri in inverseCtx) {
        const defaultLanguage = activeCtx["@language"] || "@none";
        const containers = [];
        if (_isObject(value) && "@index" in value && !("@graph" in value)) {
          containers.push("@index", "@index@set");
        }
        if (_isObject(value) && "@preserve" in value) {
          value = value["@preserve"][0];
        }
        if (_isGraph(value)) {
          if ("@index" in value) {
            containers.push(
              "@graph@index",
              "@graph@index@set",
              "@index",
              "@index@set"
            );
          }
          if ("@id" in value) {
            containers.push(
              "@graph@id",
              "@graph@id@set"
            );
          }
          containers.push("@graph", "@graph@set", "@set");
          if (!("@index" in value)) {
            containers.push(
              "@graph@index",
              "@graph@index@set",
              "@index",
              "@index@set"
            );
          }
          if (!("@id" in value)) {
            containers.push("@graph@id", "@graph@id@set");
          }
        } else if (_isObject(value) && !_isValue(value)) {
          containers.push("@id", "@id@set", "@type", "@set@type");
        }
        let typeOrLanguage = "@language";
        let typeOrLanguageValue = "@null";
        if (reverse) {
          typeOrLanguage = "@type";
          typeOrLanguageValue = "@reverse";
          containers.push("@set");
        } else if (_isList(value)) {
          if (!("@index" in value)) {
            containers.push("@list");
          }
          const list = value["@list"];
          if (list.length === 0) {
            typeOrLanguage = "@any";
            typeOrLanguageValue = "@none";
          } else {
            let commonLanguage = list.length === 0 ? defaultLanguage : null;
            let commonType = null;
            for (let i = 0; i < list.length; ++i) {
              const item = list[i];
              let itemLanguage = "@none";
              let itemType = "@none";
              if (_isValue(item)) {
                if ("@direction" in item) {
                  const lang = (item["@language"] || "").toLowerCase();
                  const dir = item["@direction"];
                  itemLanguage = `${lang}_${dir}`;
                } else if ("@language" in item) {
                  itemLanguage = item["@language"].toLowerCase();
                } else if ("@type" in item) {
                  itemType = item["@type"];
                } else {
                  itemLanguage = "@null";
                }
              } else {
                itemType = "@id";
              }
              if (commonLanguage === null) {
                commonLanguage = itemLanguage;
              } else if (itemLanguage !== commonLanguage && _isValue(item)) {
                commonLanguage = "@none";
              }
              if (commonType === null) {
                commonType = itemType;
              } else if (itemType !== commonType) {
                commonType = "@none";
              }
              if (commonLanguage === "@none" && commonType === "@none") {
                break;
              }
            }
            commonLanguage = commonLanguage || "@none";
            commonType = commonType || "@none";
            if (commonType !== "@none") {
              typeOrLanguage = "@type";
              typeOrLanguageValue = commonType;
            } else {
              typeOrLanguageValue = commonLanguage;
            }
          }
        } else {
          if (_isValue(value)) {
            if ("@language" in value && !("@index" in value)) {
              containers.push("@language", "@language@set");
              typeOrLanguageValue = value["@language"];
              const dir = value["@direction"];
              if (dir) {
                typeOrLanguageValue = `${typeOrLanguageValue}_${dir}`;
              }
            } else if ("@direction" in value && !("@index" in value)) {
              typeOrLanguageValue = `_${value["@direction"]}`;
            } else if ("@type" in value) {
              typeOrLanguage = "@type";
              typeOrLanguageValue = value["@type"];
            }
          } else {
            typeOrLanguage = "@type";
            typeOrLanguageValue = "@id";
          }
          containers.push("@set");
        }
        containers.push("@none");
        if (_isObject(value) && !("@index" in value)) {
          containers.push("@index", "@index@set");
        }
        if (_isValue(value) && Object.keys(value).length === 1) {
          containers.push("@language", "@language@set");
        }
        const term = _selectTerm(
          activeCtx,
          iri,
          value,
          containers,
          typeOrLanguage,
          typeOrLanguageValue
        );
        if (term !== null) {
          return term;
        }
      }
      if (relativeTo.vocab) {
        if ("@vocab" in activeCtx) {
          const vocab = activeCtx["@vocab"];
          if (iri.indexOf(vocab) === 0 && iri !== vocab) {
            const suffix = iri.substr(vocab.length);
            if (!activeCtx.mappings.has(suffix)) {
              return suffix;
            }
          }
        }
      }
      let choice = null;
      const partialMatches = [];
      let iriMap = activeCtx.fastCurieMap;
      const maxPartialLength = iri.length - 1;
      for (let i = 0; i < maxPartialLength && iri[i] in iriMap; ++i) {
        iriMap = iriMap[iri[i]];
        if ("" in iriMap) {
          partialMatches.push(iriMap[""][0]);
        }
      }
      for (let i = partialMatches.length - 1; i >= 0; --i) {
        const entry = partialMatches[i];
        const terms = entry.terms;
        for (const term of terms) {
          const curie = term + ":" + iri.substr(entry.iri.length);
          const isUsableCurie = activeCtx.mappings.get(term)._prefix && (!activeCtx.mappings.has(curie) || value === null && activeCtx.mappings.get(curie)["@id"] === iri);
          if (isUsableCurie && (choice === null || _compareShortestLeast(curie, choice) < 0)) {
            choice = curie;
          }
        }
      }
      if (choice !== null) {
        return choice;
      }
      for (const [term, td] of activeCtx.mappings) {
        if (td && td._prefix && iri.startsWith(term + ":")) {
          throw new JsonLdError(
            `Absolute IRI "${iri}" confused with prefix "${term}".`,
            "jsonld.SyntaxError",
            { code: "IRI confused with prefix", context: activeCtx }
          );
        }
      }
      if (!relativeTo.vocab) {
        if ("@base" in activeCtx) {
          if (!activeCtx["@base"]) {
            return iri;
          } else {
            return _removeBase(_prependBase(base, activeCtx["@base"]), iri);
          }
        } else {
          return _removeBase(base, iri);
        }
      }
      return iri;
    };
    api.compactValue = ({ activeCtx, activeProperty, value, options }) => {
      if (_isValue(value)) {
        const type2 = _getContextValue(activeCtx, activeProperty, "@type");
        const language = _getContextValue(activeCtx, activeProperty, "@language");
        const direction = _getContextValue(activeCtx, activeProperty, "@direction");
        const container = _getContextValue(activeCtx, activeProperty, "@container") || [];
        const preserveIndex = "@index" in value && !container.includes("@index");
        if (!preserveIndex && type2 !== "@none") {
          if (value["@type"] === type2) {
            return value["@value"];
          }
          if ("@language" in value && value["@language"] === language && "@direction" in value && value["@direction"] === direction) {
            return value["@value"];
          }
          if ("@language" in value && value["@language"] === language) {
            return value["@value"];
          }
          if ("@direction" in value && value["@direction"] === direction) {
            return value["@value"];
          }
        }
        const keyCount = Object.keys(value).length;
        const isValueOnlyKey = keyCount === 1 || keyCount === 2 && "@index" in value && !preserveIndex;
        const hasDefaultLanguage = "@language" in activeCtx;
        const isValueString = _isString(value["@value"]);
        const hasNullMapping = activeCtx.mappings.has(activeProperty) && activeCtx.mappings.get(activeProperty)["@language"] === null;
        if (isValueOnlyKey && type2 !== "@none" && (!hasDefaultLanguage || !isValueString || hasNullMapping)) {
          return value["@value"];
        }
        const rval = {};
        if (preserveIndex) {
          rval[api.compactIri({
            activeCtx,
            iri: "@index",
            relativeTo: { vocab: true }
          })] = value["@index"];
        }
        if ("@type" in value) {
          rval[api.compactIri({
            activeCtx,
            iri: "@type",
            relativeTo: { vocab: true }
          })] = api.compactIri(
            { activeCtx, iri: value["@type"], relativeTo: { vocab: true } }
          );
        } else if ("@language" in value) {
          rval[api.compactIri({
            activeCtx,
            iri: "@language",
            relativeTo: { vocab: true }
          })] = value["@language"];
        }
        if ("@direction" in value) {
          rval[api.compactIri({
            activeCtx,
            iri: "@direction",
            relativeTo: { vocab: true }
          })] = value["@direction"];
        }
        rval[api.compactIri({
          activeCtx,
          iri: "@value",
          relativeTo: { vocab: true }
        })] = value["@value"];
        return rval;
      }
      const expandedProperty = _expandIri(
        activeCtx,
        activeProperty,
        { vocab: true },
        options
      );
      const type = _getContextValue(activeCtx, activeProperty, "@type");
      const compacted = api.compactIri({
        activeCtx,
        iri: value["@id"],
        relativeTo: { vocab: type === "@vocab" },
        base: options.base
      });
      if (type === "@id" || type === "@vocab" || expandedProperty === "@graph") {
        return compacted;
      }
      return {
        [api.compactIri({
          activeCtx,
          iri: "@id",
          relativeTo: { vocab: true }
        })]: compacted
      };
    };
    function _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {
      if (typeOrLanguageValue === null) {
        typeOrLanguageValue = "@null";
      }
      const prefs = [];
      if ((typeOrLanguageValue === "@id" || typeOrLanguageValue === "@reverse") && _isObject(value) && "@id" in value) {
        if (typeOrLanguageValue === "@reverse") {
          prefs.push("@reverse");
        }
        const term = api.compactIri(
          { activeCtx, iri: value["@id"], relativeTo: { vocab: true } }
        );
        if (activeCtx.mappings.has(term) && activeCtx.mappings.get(term) && activeCtx.mappings.get(term)["@id"] === value["@id"]) {
          prefs.push.apply(prefs, ["@vocab", "@id"]);
        } else {
          prefs.push.apply(prefs, ["@id", "@vocab"]);
        }
      } else {
        prefs.push(typeOrLanguageValue);
        const langDir = prefs.find((el) => el.includes("_"));
        if (langDir) {
          prefs.push(langDir.replace(/^[^_]+_/, "_"));
        }
      }
      prefs.push("@none");
      const containerMap = activeCtx.inverse[iri];
      for (const container of containers) {
        if (!(container in containerMap)) {
          continue;
        }
        const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];
        for (const pref of prefs) {
          if (!(pref in typeOrLanguageValueMap)) {
            continue;
          }
          return typeOrLanguageValueMap[pref];
        }
      }
      return null;
    }
    function _checkNestProperty(activeCtx, nestProperty, options) {
      if (_expandIri(activeCtx, nestProperty, { vocab: true }, options) !== "@nest") {
        throw new JsonLdError(
          "JSON-LD compact error; nested property must have an @nest value resolving to @nest.",
          "jsonld.SyntaxError",
          { code: "invalid @nest value" }
        );
      }
    }
  }
});

// node_modules/@digitalcredentials/jsonld/lib/JsonLdProcessor.js
var require_JsonLdProcessor = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/JsonLdProcessor.js"(exports, module) {
    "use strict";
    module.exports = (jsonld2) => {
      class JsonLdProcessor {
        toString() {
          return "[object JsonLdProcessor]";
        }
      }
      Object.defineProperty(JsonLdProcessor, "prototype", {
        writable: false,
        enumerable: false
      });
      Object.defineProperty(JsonLdProcessor.prototype, "constructor", {
        writable: true,
        enumerable: false,
        configurable: true,
        value: JsonLdProcessor
      });
      JsonLdProcessor.compact = function(input, ctx) {
        if (arguments.length < 2) {
          return Promise.reject(
            new TypeError("Could not compact, too few arguments.")
          );
        }
        return jsonld2.compact(input, ctx);
      };
      JsonLdProcessor.expand = function(input) {
        if (arguments.length < 1) {
          return Promise.reject(
            new TypeError("Could not expand, too few arguments.")
          );
        }
        return jsonld2.expand(input);
      };
      JsonLdProcessor.flatten = function(input) {
        if (arguments.length < 1) {
          return Promise.reject(
            new TypeError("Could not flatten, too few arguments.")
          );
        }
        return jsonld2.flatten(input);
      };
      return JsonLdProcessor;
    };
  }
});

// node_modules/@digitalcredentials/jsonld/lib/jsonld.js
var require_jsonld = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/jsonld.js"(exports, module) {
    var canonize = require_rdf_canonize();
    var platform = require_platform_browser();
    var util2 = require_util3();
    var ContextResolver = require_ContextResolver();
    var IdentifierIssuer = util2.IdentifierIssuer;
    var JsonLdError = require_JsonLdError();
    var LRU = require_lru_cache();
    var NQuads = require_NQuads2();
    var { expand: _expand } = require_expand2();
    var { flatten: _flatten } = require_flatten();
    var { fromRDF: _fromRDF } = require_fromRdf();
    var { toRDF: _toRDF } = require_toRdf();
    var {
      frameMergedOrDefault: _frameMergedOrDefault,
      cleanupNull: _cleanupNull
    } = require_frame();
    var {
      isArray: _isArray,
      isObject: _isObject,
      isString: _isString
    } = require_types5();
    var {
      isSubjectReference: _isSubjectReference
    } = require_graphTypes();
    var {
      expandIri: _expandIri,
      getInitialContext: _getInitialContext,
      process: _processContext,
      processingMode: _processingMode
    } = require_context3();
    var {
      compact: _compact,
      compactIri: _compactIri
    } = require_compact();
    var {
      createNodeMap: _createNodeMap,
      createMergedNodeMap: _createMergedNodeMap,
      mergeNodeMaps: _mergeNodeMaps
    } = require_nodeMap();
    var wrapper = function(jsonld2) {
      const _rdfParsers = {};
      const RESOLVED_CONTEXT_CACHE_MAX_SIZE = 100;
      const _resolvedContextCache = new LRU({ max: RESOLVED_CONTEXT_CACHE_MAX_SIZE });
      jsonld2.compact = async function(input, ctx, options) {
        if (arguments.length < 2) {
          throw new TypeError("Could not compact, too few arguments.");
        }
        if (ctx === null) {
          throw new JsonLdError(
            "The compaction context must not be null.",
            "jsonld.CompactError",
            { code: "invalid local context" }
          );
        }
        if (input === null) {
          return null;
        }
        options = _setDefaults(options, {
          base: _isString(input) ? input : "",
          compactArrays: true,
          compactToRelative: true,
          graph: false,
          skipExpansion: false,
          link: false,
          issuer: new IdentifierIssuer("_:b"),
          contextResolver: new ContextResolver(
            { sharedCache: _resolvedContextCache }
          )
        });
        if (options.link) {
          options.skipExpansion = true;
        }
        if (!options.compactToRelative) {
          delete options.base;
        }
        let expanded;
        if (options.skipExpansion) {
          expanded = input;
        } else {
          expanded = await jsonld2.expand(input, options);
        }
        const activeCtx = await jsonld2.processContext(
          _getInitialContext(options),
          ctx,
          options
        );
        let compacted = await _compact({
          activeCtx,
          element: expanded,
          options,
          compactionMap: options.compactionMap
        });
        if (options.compactArrays && !options.graph && _isArray(compacted)) {
          if (compacted.length === 1) {
            compacted = compacted[0];
          } else if (compacted.length === 0) {
            compacted = {};
          }
        } else if (options.graph && _isObject(compacted)) {
          compacted = [compacted];
        }
        if (_isObject(ctx) && "@context" in ctx) {
          ctx = ctx["@context"];
        }
        ctx = util2.clone(ctx);
        if (!_isArray(ctx)) {
          ctx = [ctx];
        }
        const tmp = ctx;
        ctx = [];
        for (let i = 0; i < tmp.length; ++i) {
          if (!_isObject(tmp[i]) || Object.keys(tmp[i]).length > 0) {
            ctx.push(tmp[i]);
          }
        }
        const hasContext = ctx.length > 0;
        if (ctx.length === 1) {
          ctx = ctx[0];
        }
        if (_isArray(compacted)) {
          const graphAlias = _compactIri({
            activeCtx,
            iri: "@graph",
            relativeTo: { vocab: true }
          });
          const graph = compacted;
          compacted = {};
          if (hasContext) {
            compacted["@context"] = ctx;
          }
          compacted[graphAlias] = graph;
        } else if (_isObject(compacted) && hasContext) {
          const graph = compacted;
          compacted = { "@context": ctx };
          for (const key in graph) {
            compacted[key] = graph[key];
          }
        }
        return compacted;
      };
      jsonld2.expand = async function(input, options) {
        if (arguments.length < 1) {
          throw new TypeError("Could not expand, too few arguments.");
        }
        options = _setDefaults(options, {
          keepFreeFloatingNodes: false,
          contextResolver: new ContextResolver(
            { sharedCache: _resolvedContextCache }
          )
        });
        if (options.expansionMap === false) {
          options.expansionMap = void 0;
        }
        const toResolve = {};
        const contextsToProcess = [];
        if ("expandContext" in options) {
          const expandContext = util2.clone(options.expandContext);
          if (_isObject(expandContext) && "@context" in expandContext) {
            toResolve.expandContext = expandContext;
          } else {
            toResolve.expandContext = { "@context": expandContext };
          }
          contextsToProcess.push(toResolve.expandContext);
        }
        let defaultBase;
        if (!_isString(input)) {
          toResolve.input = util2.clone(input);
        } else {
          const remoteDoc = await jsonld2.get(input, options);
          defaultBase = remoteDoc.documentUrl;
          toResolve.input = remoteDoc.document;
          if (remoteDoc.contextUrl) {
            toResolve.remoteContext = { "@context": remoteDoc.contextUrl };
            contextsToProcess.push(toResolve.remoteContext);
          }
        }
        if (!("base" in options)) {
          options.base = defaultBase || "";
        }
        let activeCtx = _getInitialContext(options);
        for (const localCtx of contextsToProcess) {
          activeCtx = await _processContext({ activeCtx, localCtx, options });
        }
        let expanded = await _expand({
          activeCtx,
          element: toResolve.input,
          options,
          expansionMap: options.expansionMap
        });
        if (_isObject(expanded) && "@graph" in expanded && Object.keys(expanded).length === 1) {
          expanded = expanded["@graph"];
        } else if (expanded === null) {
          expanded = [];
        }
        if (!_isArray(expanded)) {
          expanded = [expanded];
        }
        return expanded;
      };
      jsonld2.flatten = async function(input, ctx, options) {
        if (arguments.length < 1) {
          return new TypeError("Could not flatten, too few arguments.");
        }
        if (typeof ctx === "function") {
          ctx = null;
        } else {
          ctx = ctx || null;
        }
        options = _setDefaults(options, {
          base: _isString(input) ? input : "",
          contextResolver: new ContextResolver(
            { sharedCache: _resolvedContextCache }
          )
        });
        const expanded = await jsonld2.expand(input, options);
        const flattened = _flatten(expanded);
        if (ctx === null) {
          return flattened;
        }
        options.graph = true;
        options.skipExpansion = true;
        const compacted = await jsonld2.compact(flattened, ctx, options);
        return compacted;
      };
      jsonld2.frame = async function(input, frame, options) {
        if (arguments.length < 2) {
          throw new TypeError("Could not frame, too few arguments.");
        }
        options = _setDefaults(options, {
          base: _isString(input) ? input : "",
          embed: "@once",
          explicit: false,
          requireAll: false,
          omitDefault: false,
          bnodesToClear: [],
          contextResolver: new ContextResolver(
            { sharedCache: _resolvedContextCache }
          )
        });
        if (_isString(frame)) {
          const remoteDoc = await jsonld2.get(frame, options);
          frame = remoteDoc.document;
          if (remoteDoc.contextUrl) {
            let ctx = frame["@context"];
            if (!ctx) {
              ctx = remoteDoc.contextUrl;
            } else if (_isArray(ctx)) {
              ctx.push(remoteDoc.contextUrl);
            } else {
              ctx = [ctx, remoteDoc.contextUrl];
            }
            frame["@context"] = ctx;
          }
        }
        const frameContext = frame ? frame["@context"] || {} : {};
        const activeCtx = await jsonld2.processContext(
          _getInitialContext(options),
          frameContext,
          options
        );
        if (!options.hasOwnProperty("omitGraph")) {
          options.omitGraph = _processingMode(activeCtx, 1.1);
        }
        if (!options.hasOwnProperty("pruneBlankNodeIdentifiers")) {
          options.pruneBlankNodeIdentifiers = _processingMode(activeCtx, 1.1);
        }
        const expanded = await jsonld2.expand(input, options);
        const opts = { ...options };
        opts.isFrame = true;
        opts.keepFreeFloatingNodes = true;
        const expandedFrame = await jsonld2.expand(frame, opts);
        const frameKeys = Object.keys(frame).map((key) => _expandIri(activeCtx, key, { vocab: true }));
        opts.merged = !frameKeys.includes("@graph");
        opts.is11 = _processingMode(activeCtx, 1.1);
        const framed = _frameMergedOrDefault(expanded, expandedFrame, opts);
        opts.graph = !options.omitGraph;
        opts.skipExpansion = true;
        opts.link = {};
        opts.framing = true;
        let compacted = await jsonld2.compact(framed, frameContext, opts);
        opts.link = {};
        compacted = _cleanupNull(compacted, opts);
        return compacted;
      };
      jsonld2.link = async function(input, ctx, options) {
        const frame = {};
        if (ctx) {
          frame["@context"] = ctx;
        }
        frame["@embed"] = "@link";
        return jsonld2.frame(input, frame, options);
      };
      jsonld2.normalize = jsonld2.canonize = async function(input, options) {
        if (arguments.length < 1) {
          throw new TypeError("Could not canonize, too few arguments.");
        }
        options = _setDefaults(options, {
          base: _isString(input) ? input : "",
          algorithm: "URDNA2015",
          skipExpansion: false,
          contextResolver: new ContextResolver(
            { sharedCache: _resolvedContextCache }
          )
        });
        if ("inputFormat" in options) {
          if (options.inputFormat !== "application/n-quads" && options.inputFormat !== "application/nquads") {
            throw new JsonLdError(
              "Unknown canonicalization input format.",
              "jsonld.CanonizeError"
            );
          }
          const parsedInput = NQuads.parse(input);
          return canonize.canonize(parsedInput, options);
        }
        const opts = { ...options };
        delete opts.format;
        opts.produceGeneralizedRdf = false;
        const dataset = await jsonld2.toRDF(input, opts);
        return canonize.canonize(dataset, options);
      };
      jsonld2.fromRDF = async function(dataset, options) {
        if (arguments.length < 1) {
          throw new TypeError("Could not convert from RDF, too few arguments.");
        }
        options = _setDefaults(options, {
          format: _isString(dataset) ? "application/n-quads" : void 0
        });
        const { format: format2 } = options;
        let { rdfParser } = options;
        if (format2) {
          rdfParser = rdfParser || _rdfParsers[format2];
          if (!rdfParser) {
            throw new JsonLdError(
              "Unknown input format.",
              "jsonld.UnknownFormat",
              { format: format2 }
            );
          }
        } else {
          rdfParser = () => dataset;
        }
        const parsedDataset = await rdfParser(dataset);
        return _fromRDF(parsedDataset, options);
      };
      jsonld2.toRDF = async function(input, options) {
        if (arguments.length < 1) {
          throw new TypeError("Could not convert to RDF, too few arguments.");
        }
        options = _setDefaults(options, {
          base: _isString(input) ? input : "",
          skipExpansion: false,
          contextResolver: new ContextResolver(
            { sharedCache: _resolvedContextCache }
          )
        });
        let expanded;
        if (options.skipExpansion) {
          expanded = input;
        } else {
          expanded = await jsonld2.expand(input, options);
        }
        const dataset = _toRDF(expanded, options);
        if (options.format) {
          if (options.format === "application/n-quads" || options.format === "application/nquads") {
            return NQuads.serialize(dataset);
          }
          throw new JsonLdError(
            "Unknown output format.",
            "jsonld.UnknownFormat",
            { format: options.format }
          );
        }
        return dataset;
      };
      jsonld2.createNodeMap = async function(input, options) {
        if (arguments.length < 1) {
          throw new TypeError("Could not create node map, too few arguments.");
        }
        options = _setDefaults(options, {
          base: _isString(input) ? input : "",
          contextResolver: new ContextResolver(
            { sharedCache: _resolvedContextCache }
          )
        });
        const expanded = await jsonld2.expand(input, options);
        return _createMergedNodeMap(expanded, options);
      };
      jsonld2.merge = async function(docs, ctx, options) {
        if (arguments.length < 1) {
          throw new TypeError("Could not merge, too few arguments.");
        }
        if (!_isArray(docs)) {
          throw new TypeError('Could not merge, "docs" must be an array.');
        }
        if (typeof ctx === "function") {
          ctx = null;
        } else {
          ctx = ctx || null;
        }
        options = _setDefaults(options, {
          contextResolver: new ContextResolver(
            { sharedCache: _resolvedContextCache }
          )
        });
        const expanded = await Promise.all(docs.map((doc) => {
          const opts = { ...options };
          return jsonld2.expand(doc, opts);
        }));
        let mergeNodes = true;
        if ("mergeNodes" in options) {
          mergeNodes = options.mergeNodes;
        }
        const issuer = options.issuer || new IdentifierIssuer("_:b");
        const graphs = { "@default": {} };
        for (let i = 0; i < expanded.length; ++i) {
          const doc = util2.relabelBlankNodes(expanded[i], {
            issuer: new IdentifierIssuer("_:b" + i + "-")
          });
          const _graphs = mergeNodes || i === 0 ? graphs : { "@default": {} };
          _createNodeMap(doc, _graphs, "@default", issuer);
          if (_graphs !== graphs) {
            for (const graphName in _graphs) {
              const _nodeMap = _graphs[graphName];
              if (!(graphName in graphs)) {
                graphs[graphName] = _nodeMap;
                continue;
              }
              const nodeMap = graphs[graphName];
              for (const key in _nodeMap) {
                if (!(key in nodeMap)) {
                  nodeMap[key] = _nodeMap[key];
                }
              }
            }
          }
        }
        const defaultGraph = _mergeNodeMaps(graphs);
        const flattened = [];
        const keys = Object.keys(defaultGraph).sort();
        for (let ki = 0; ki < keys.length; ++ki) {
          const node = defaultGraph[keys[ki]];
          if (!_isSubjectReference(node)) {
            flattened.push(node);
          }
        }
        if (ctx === null) {
          return flattened;
        }
        options.graph = true;
        options.skipExpansion = true;
        const compacted = await jsonld2.compact(flattened, ctx, options);
        return compacted;
      };
      Object.defineProperty(jsonld2, "documentLoader", {
        get: () => jsonld2._documentLoader,
        set: (v) => jsonld2._documentLoader = v
      });
      jsonld2.documentLoader = async (url) => {
        throw new JsonLdError(
          "Could not retrieve a JSON-LD document from the URL. URL dereferencing not implemented.",
          "jsonld.LoadDocumentError",
          { code: "loading document failed", url }
        );
      };
      jsonld2.get = async function(url, options) {
        let load;
        if (typeof options.documentLoader === "function") {
          load = options.documentLoader;
        } else {
          load = jsonld2.documentLoader;
        }
        const remoteDoc = await load(url);
        try {
          if (!remoteDoc.document) {
            throw new JsonLdError(
              "No remote document found at the given URL.",
              "jsonld.NullRemoteDocument"
            );
          }
          if (_isString(remoteDoc.document)) {
            remoteDoc.document = JSON.parse(remoteDoc.document);
          }
        } catch (e) {
          throw new JsonLdError(
            "Could not retrieve a JSON-LD document from the URL.",
            "jsonld.LoadDocumentError",
            {
              code: "loading document failed",
              cause: e,
              remoteDoc
            }
          );
        }
        return remoteDoc;
      };
      jsonld2.processContext = async function(activeCtx, localCtx, options) {
        options = _setDefaults(options, {
          base: "",
          contextResolver: new ContextResolver(
            { sharedCache: _resolvedContextCache }
          )
        });
        if (localCtx === null) {
          return _getInitialContext(options);
        }
        localCtx = util2.clone(localCtx);
        if (!(_isObject(localCtx) && "@context" in localCtx)) {
          localCtx = { "@context": localCtx };
        }
        return _processContext({ activeCtx, localCtx, options });
      };
      jsonld2.getContextValue = require_context3().getContextValue;
      jsonld2.documentLoaders = {};
      jsonld2.useDocumentLoader = function(type) {
        if (!(type in jsonld2.documentLoaders)) {
          throw new JsonLdError(
            'Unknown document loader type: "' + type + '"',
            "jsonld.UnknownDocumentLoader",
            { type }
          );
        }
        jsonld2.documentLoader = jsonld2.documentLoaders[type].apply(
          jsonld2,
          Array.prototype.slice.call(arguments, 1)
        );
      };
      jsonld2.registerRDFParser = function(contentType, parser) {
        _rdfParsers[contentType] = parser;
      };
      jsonld2.unregisterRDFParser = function(contentType) {
        delete _rdfParsers[contentType];
      };
      jsonld2.registerRDFParser("application/n-quads", NQuads.parse);
      jsonld2.registerRDFParser("application/nquads", NQuads.parse);
      jsonld2.url = require_url();
      jsonld2.util = util2;
      Object.assign(jsonld2, util2);
      jsonld2.promises = jsonld2;
      jsonld2.RequestQueue = require_RequestQueue();
      jsonld2.JsonLdProcessor = require_JsonLdProcessor()(jsonld2);
      platform.setupGlobals(jsonld2);
      platform.setupDocumentLoaders(jsonld2);
      function _setDefaults(options, {
        documentLoader = jsonld2.documentLoader,
        ...defaults
      }) {
        return Object.assign({}, { documentLoader }, defaults, options);
      }
      return jsonld2;
    };
    var factory = function() {
      return wrapper(function() {
        return factory();
      });
    };
    wrapper(factory);
    module.exports = factory;
  }
});

// node_modules/@digitalcredentials/jsonld-signatures/lib/contexts.js
var require_contexts = __commonJS({
  "node_modules/@digitalcredentials/jsonld-signatures/lib/contexts.js"(exports, module) {
    "use strict";
    var constants = require_constants5();
    var { contexts: securityContexts } = require_context2();
    module.exports = /* @__PURE__ */ new Map([
      [
        constants.SECURITY_CONTEXT_V1_URL,
        securityContexts.get(constants.SECURITY_CONTEXT_V1_URL)
      ],
      [
        constants.SECURITY_CONTEXT_V2_URL,
        securityContexts.get(constants.SECURITY_CONTEXT_V2_URL)
      ]
    ]);
  }
});

// node_modules/@digitalcredentials/jsonld-signatures/lib/documentLoader.js
var require_documentLoader = __commonJS({
  "node_modules/@digitalcredentials/jsonld-signatures/lib/documentLoader.js"(exports, module) {
    "use strict";
    var contexts = require_contexts();
    var api = {};
    module.exports = api;
    api.extendContextLoader = (documentLoader) => {
      return async (url) => {
        const context2 = contexts.get(url);
        if (context2 !== void 0) {
          return {
            contextUrl: null,
            documentUrl: url,
            document: context2,
            tag: "static"
          };
        }
        return documentLoader(url);
      };
    };
    api.strictDocumentLoader = api.extendContextLoader((url) => {
      throw new Error(`${url} not found.`);
    });
  }
});

// node_modules/serialize-error/index.js
var require_serialize_error = __commonJS({
  "node_modules/serialize-error/index.js"(exports, module) {
    "use strict";
    var NonError = class extends Error {
      constructor(message) {
        super(NonError._prepareSuperMessage(message));
        Object.defineProperty(this, "name", {
          value: "NonError",
          configurable: true,
          writable: true
        });
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, NonError);
        }
      }
      static _prepareSuperMessage(message) {
        try {
          return JSON.stringify(message);
        } catch {
          return String(message);
        }
      }
    };
    var commonProperties = [
      { property: "name", enumerable: false },
      { property: "message", enumerable: false },
      { property: "stack", enumerable: false },
      { property: "code", enumerable: true }
    ];
    var isCalled = Symbol(".toJSON called");
    var toJSON = (from) => {
      from[isCalled] = true;
      const json = from.toJSON();
      delete from[isCalled];
      return json;
    };
    var destroyCircular = ({
      from,
      seen,
      to_,
      forceEnumerable,
      maxDepth,
      depth
    }) => {
      const to = to_ || (Array.isArray(from) ? [] : {});
      seen.push(from);
      if (depth >= maxDepth) {
        return to;
      }
      if (typeof from.toJSON === "function" && from[isCalled] !== true) {
        return toJSON(from);
      }
      for (const [key, value] of Object.entries(from)) {
        if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
          to[key] = "[object Buffer]";
          continue;
        }
        if (typeof value === "function") {
          continue;
        }
        if (!value || typeof value !== "object") {
          to[key] = value;
          continue;
        }
        if (!seen.includes(from[key])) {
          depth++;
          to[key] = destroyCircular({
            from: from[key],
            seen: seen.slice(),
            forceEnumerable,
            maxDepth,
            depth
          });
          continue;
        }
        to[key] = "[Circular]";
      }
      for (const { property, enumerable } of commonProperties) {
        if (typeof from[property] === "string") {
          Object.defineProperty(to, property, {
            value: from[property],
            enumerable: forceEnumerable ? true : enumerable,
            configurable: true,
            writable: true
          });
        }
      }
      return to;
    };
    var serializeError = (value, options = {}) => {
      const { maxDepth = Number.POSITIVE_INFINITY } = options;
      if (typeof value === "object" && value !== null) {
        return destroyCircular({
          from: value,
          seen: [],
          forceEnumerable: true,
          maxDepth,
          depth: 0
        });
      }
      if (typeof value === "function") {
        return `[Function: ${value.name || "anonymous"}]`;
      }
      return value;
    };
    var deserializeError = (value, options = {}) => {
      const { maxDepth = Number.POSITIVE_INFINITY } = options;
      if (value instanceof Error) {
        return value;
      }
      if (typeof value === "object" && value !== null && !Array.isArray(value)) {
        const newError = new Error();
        destroyCircular({
          from: value,
          seen: [],
          to_: newError,
          maxDepth,
          depth: 0
        });
        return newError;
      }
      return new NonError(value);
    };
    module.exports = {
      serializeError,
      deserializeError
    };
  }
});

// node_modules/@digitalcredentials/jsonld-signatures/lib/expansionMap.js
var require_expansionMap = __commonJS({
  "node_modules/@digitalcredentials/jsonld-signatures/lib/expansionMap.js"(exports, module) {
    "use strict";
    module.exports = (info) => {
      if (info.unmappedProperty) {
        throw new Error('The property "' + info.unmappedProperty + '" in the input was not defined in the context.');
      }
    };
  }
});

// node_modules/@digitalcredentials/jsonld-signatures/lib/ProofSet.js
var require_ProofSet = __commonJS({
  "node_modules/@digitalcredentials/jsonld-signatures/lib/ProofSet.js"(exports, module) {
    "use strict";
    var constants = require_constants5();
    var jsonld2 = require_jsonld();
    var { extendContextLoader, strictDocumentLoader } = require_documentLoader();
    var { serializeError } = require_serialize_error();
    var strictExpansionMap = require_expansionMap();
    module.exports = class ProofSet {
      /**
       * Adds a Linked Data proof to a document. If the document contains other
       * proofs, the new proof will be appended to the existing set of proofs.
       *
       * Important note: This method assumes that the term `proof` in the given
       * document has the same definition as the `https://w3id.org/security/v2`
       * JSON-LD @context.
       *
       * @param document {object} - JSON-LD Document to be signed.
       * @param options {object} Options hashmap.
       *
       * A `suite` option is required:
       *
       * @param options.suite {LinkedDataSignature} a signature suite instance
       *   that will create the proof.
       *
       * A `purpose` option is required:
       *
       * @param options.purpose {ProofPurpose} a proof purpose instance that will
       *   augment the proof with information describing its intended purpose.
       *
       * Advanced optional parameters and overrides:
       *
       * @param [documentLoader] {function} a custom document loader,
       *   `Promise<RemoteDocument> documentLoader(url)`.
       * @param [expansionMap] {function} A custom expansion map that is
       *   passed to the JSON-LD processor; by default a function that will throw
       *   an error when unmapped properties are detected in the input, use `false`
       *   to turn this off and allow unmapped properties to be dropped or use a
       *   custom function.
       *
       * @return {Promise<object>} resolves with the signed document, with
       *   the signature in the top-level `proof` property.
       */
      async add(document, { suite, purpose, documentLoader, expansionMap } = {}) {
        if (!suite) {
          throw new TypeError('"options.suite" is required.');
        }
        if (!purpose) {
          throw new TypeError('"options.purpose" is required.');
        }
        if (documentLoader) {
          documentLoader = extendContextLoader(documentLoader);
        } else {
          documentLoader = strictDocumentLoader;
        }
        if (expansionMap !== false) {
          expansionMap = strictExpansionMap;
        }
        const input = { ...document };
        delete input.proof;
        const proof = await suite.createProof({
          document: input,
          purpose,
          documentLoader,
          expansionMap
        });
        jsonld2.addValue(document, "proof", proof);
        return document;
      }
      /**
       * Verifies Linked Data proof(s) on a document. The proofs to be verified
       * must match the given proof purpose.
       *
       * Important note: This method assumes that the term `proof` in the given
       * document has the same definition as the `https://w3id.org/security/v2`
       * JSON-LD @context.
       *
       * @param {object} document - The JSON-LD document with one or more proofs to
       *   be verified.
       *
       * @param {LinkedDataSignature|LinkedDataSignature[]} suite -
       *   Acceptable signature suite instances for verifying the proof(s).
       *
       * @param {ProofPurpose} purpose - A proof purpose instance that will
       *   match proofs to be verified and ensure they were created according to
       *   the appropriate purpose.
       *
       * Advanced optional parameters and overrides:
       *
       * @param {function} [documentLoader]  a custom document loader,
       *   `Promise<RemoteDocument> documentLoader(url)`.
       * @param {function} [expansionMap] - A custom expansion map that is
       *   passed to the JSON-LD processor; by default a function that will throw
       *   an error when unmapped properties are detected in the input, use `false`
       *   to turn this off and allow unmapped properties to be dropped or use a
       *   custom function.
       *
       * @return {Promise<{verified: boolean, results: Array, error: *}>} resolves
       *   with an object with a `verified`boolean property that is `true` if at
       *   least one proof matching the given purpose and suite verifies and `false`
       *   otherwise; a `results` property with an array of detailed results;
       *   if `false` an `error` property will be present.
       */
      async verify(document, { suite, purpose, documentLoader, expansionMap } = {}) {
        if (!suite) {
          throw new TypeError('"options.suite" is required.');
        }
        if (!purpose) {
          throw new TypeError('"options.purpose" is required.');
        }
        const suites = Array.isArray(suite) ? suite : [suite];
        if (suites.length === 0) {
          throw new TypeError("At least one suite is required.");
        }
        if (documentLoader) {
          documentLoader = extendContextLoader(documentLoader);
        } else {
          documentLoader = strictDocumentLoader;
        }
        if (expansionMap !== false) {
          expansionMap = strictExpansionMap;
        }
        try {
          document = { ...document };
          const { proofSet, document: doc } = await _getProofs({
            document,
            documentLoader,
            expansionMap
          });
          document = doc;
          const results = await _verify({
            document,
            suites,
            proofSet,
            purpose,
            documentLoader,
            expansionMap
          });
          if (results.length === 0) {
            const error = new Error(
              "Did not verify any proofs; insufficient proofs matched the acceptable suite(s) and required purpose(s)."
            );
            error.name = "NotFoundError";
            throw error;
          }
          const verified = results.some((r) => r.verified);
          if (!verified) {
            const errors = [].concat(
              ...results.filter((r) => r.error).map((r) => r.error)
            );
            const result2 = { verified, results };
            if (errors.length > 0) {
              result2.error = errors;
            }
            return result2;
          }
          return { verified, results };
        } catch (error) {
          _makeSerializable(error);
          return { verified: false, error };
        }
      }
    };
    async function _getProofs({ document }) {
      let proofSet;
      proofSet = jsonld2.getValues(document, "proof");
      delete document.proof;
      if (proofSet.length === 0) {
        throw new Error("No matching proofs found in the given document.");
      }
      const context2 = document["@context"] || constants.SECURITY_CONTEXT_URL;
      proofSet = proofSet.map((proof) => ({
        "@context": context2,
        ...proof
      }));
      return { proofSet, document };
    }
    async function _verify({
      document,
      suites,
      proofSet,
      purpose,
      documentLoader,
      expansionMap
    }) {
      const purposes = Array.isArray(purpose) ? purpose : [purpose];
      const purposeToProofs = /* @__PURE__ */ new Map();
      const proofToSuite = /* @__PURE__ */ new Map();
      const suiteMatchQueue = /* @__PURE__ */ new Map();
      await Promise.all(purposes.map((purpose2) => _matchProofSet({
        purposeToProofs,
        proofToSuite,
        purpose: purpose2,
        proofSet,
        suites,
        suiteMatchQueue,
        document,
        documentLoader,
        expansionMap
      })));
      if (purposeToProofs.size < purposes.length) {
        return [];
      }
      const verifyResults = /* @__PURE__ */ new Map();
      await Promise.all([...proofToSuite.entries()].map(async ([proof, suite]) => {
        let result2;
        try {
          let vm;
          const purpose2 = {
            async validate(proof2, { verificationMethod: verificationMethod2 }) {
              vm = verificationMethod2;
              return { valid: true };
            }
          };
          const { verified, verificationMethod, error } = await suite.verifyProof({
            proof,
            document,
            purpose: purpose2,
            documentLoader,
            expansionMap
          });
          if (!vm) {
            vm = verificationMethod;
          }
          result2 = { proof, verified, verificationMethod: vm, error };
        } catch (error) {
          result2 = { proof, verified: false, error };
        }
        if (result2.error) {
          _makeSerializable(result2.error);
        }
        verifyResults.set(proof, result2);
      }));
      await Promise.all([...purposeToProofs.entries()].map(
        async ([purpose2, proofs]) => {
          for (const proof of proofs) {
            const result2 = verifyResults.get(proof);
            if (!result2.verified) {
              continue;
            }
            const { verificationMethod } = result2;
            const suite = proofToSuite.get(proof);
            let purposeResult;
            try {
              purposeResult = await purpose2.validate(proof, {
                document,
                suite,
                verificationMethod,
                documentLoader,
                expansionMap
              });
            } catch (error) {
              purposeResult = { valid: false, error };
            }
            if (result2.purposeResult) {
              if (Array.isArray(result2.purposeResult)) {
                result2.purposeResult.push(purposeResult);
              } else {
                result2.purposeResult = [result2.purposeResult, purposeResult];
              }
            } else {
              result2.purposeResult = purposeResult;
            }
            if (!purposeResult.valid) {
              _makeSerializable(purposeResult.error);
              if (!result2.error) {
                result2.verified = false;
                result2.error = purposeResult.error;
              }
            }
          }
        }
      ));
      return [...verifyResults.values()];
    }
    function _makeSerializable(error) {
      Object.defineProperty(error, "toJSON", {
        value: function() {
          return serializeError(this);
        },
        configurable: true,
        writable: true
      });
    }
    async function _matchProofSet({
      purposeToProofs,
      proofToSuite,
      purpose,
      proofSet,
      suites,
      suiteMatchQueue,
      document,
      documentLoader,
      expansionMap
    }) {
      for (const proof of proofSet) {
        if (!await purpose.match(proof, { document, documentLoader, expansionMap })) {
          continue;
        }
        let matched = false;
        for (const s of suites) {
          let matchingProofs = suiteMatchQueue.get(s);
          if (!matchingProofs) {
            suiteMatchQueue.set(s, matchingProofs = /* @__PURE__ */ new Map());
          }
          let promise = matchingProofs.get(proof);
          if (!promise) {
            promise = s.matchProof({ proof, document, documentLoader, expansionMap });
            matchingProofs.set(proof, promise);
          }
          if (await promise) {
            matched = true;
            proofToSuite.set(proof, s);
            break;
          }
        }
        if (matched) {
          const matches2 = purposeToProofs.get(purpose);
          if (matches2) {
            matches2.push(proof);
          } else {
            purposeToProofs.set(purpose, [proof]);
          }
        }
      }
    }
  }
});

// node_modules/@digitalcredentials/jsonld-signatures/lib/VerificationError.js
var require_VerificationError = __commonJS({
  "node_modules/@digitalcredentials/jsonld-signatures/lib/VerificationError.js"(exports, module) {
    "use strict";
    var VerificationError = class extends Error {
      /**
       * @param {Error|Error[]} errors
       */
      constructor(errors) {
        super("Verification error(s).");
        this.name = "VerificationError";
        this.errors = [].concat(errors);
      }
    };
    module.exports = VerificationError;
  }
});

// node_modules/@digitalcredentials/jsonld-signatures/lib/suites/LinkedDataProof.js
var require_LinkedDataProof = __commonJS({
  "node_modules/@digitalcredentials/jsonld-signatures/lib/suites/LinkedDataProof.js"(exports, module) {
    "use strict";
    module.exports = class LinkedDataProof {
      constructor({ type } = {}) {
        if (typeof type !== "string") {
          throw new TypeError('A LinkedDataProof must have a "type".');
        }
        this.type = type;
      }
      /**
       * @param document {object} to be signed.
       * @param purpose {ProofPurpose}
       * @param documentLoader {function}
       * @param expansionMap {function}
       *
       * @returns {Promise<object>} Resolves with the created proof object.
       */
      async createProof({
        /* document, purpose, documentLoader, expansionMap */
      }) {
        throw new Error('"createProof" must be implemented in a derived class.');
      }
      /**
       * @param proof {object} the proof to be verified.
       * @param document {object} the document the proof applies to.
       * @param purpose {ProofPurpose}
       * @param documentLoader {function}
       * @param expansionMap {function}
       *
       * @returns {Promise<{object}>} Resolves with the verification result.
       */
      async verifyProof({
        /* proof, document, purpose, documentLoader, expansionMap */
      }) {
        throw new Error('"verifyProof" must be implemented in a derived class.');
      }
      /**
       * Checks whether a given proof exists in the document.
       *
       * @param {object} options - Options hashmap.
       * @param {object} options.proof
       *
       * @returns {Promise<boolean>} Whether a match for the proof was found.
       */
      async matchProof({
        proof
        /*, document, purpose, documentLoader, expansionMap */
      }) {
        return proof.type === this.type;
      }
    };
  }
});

// node_modules/@digitalcredentials/jsonld-signatures/lib/util.js
var require_util4 = __commonJS({
  "node_modules/@digitalcredentials/jsonld-signatures/lib/util.js"(exports, module) {
    "use strict";
    var api = {};
    module.exports = api;
    api.w3cDate = (date) => {
      if (date === void 0 || date === null) {
        date = /* @__PURE__ */ new Date();
      } else if (typeof date === "number" || typeof date === "string") {
        date = new Date(date);
      }
      const str = date.toISOString();
      return str.substr(0, str.length - 5) + "Z";
    };
    api.concat = (b1, b2) => {
      const rval = new Uint8Array(b1.length + b2.length);
      rval.set(b1, 0);
      rval.set(b2, b1.length);
      return rval;
    };
  }
});

// node_modules/@digitalcredentials/jsonld-signatures/lib/sha256digest-browser.js
var require_sha256digest_browser = __commonJS({
  "node_modules/@digitalcredentials/jsonld-signatures/lib/sha256digest-browser.js"(exports, module) {
    "use strict";
    var crypto2 = self && (self.crypto || self.msCrypto);
    module.exports = {
      /**
       * Hashes a string of data using SHA-256.
       *
       * @param {string} string - the string to hash.
       *
       * @return {Uint8Array} the hash digest.
       */
      async sha256digest({ string }) {
        const bytes = new TextEncoder().encode(string);
        return new Uint8Array(
          await crypto2.subtle.digest("SHA-256", bytes)
        );
      }
    };
  }
});

// node_modules/@digitalcredentials/jsonld-signatures/lib/suites/LinkedDataSignature.js
var require_LinkedDataSignature = __commonJS({
  "node_modules/@digitalcredentials/jsonld-signatures/lib/suites/LinkedDataSignature.js"(exports, module) {
    "use strict";
    var constants = require_constants5();
    var jsonld2 = require_jsonld();
    var util2 = require_util4();
    var { sha256digest } = require_sha256digest_browser();
    var LinkedDataProof = require_LinkedDataProof();
    module.exports = class LinkedDataSignature extends LinkedDataProof {
      /**
       * Parent class from which the various LinkDataSignature suites (such as
       * `Ed25519Signature2020`) inherit.
       * NOTE: Developers are never expected to use this class directly, but to
       * only work with individual suites.
       *
       * @param {object} options - Options hashmap.
       * @param {string} options.type - Suite name, provided by subclass.
       * @typedef LDKeyPair
       * @param {LDKeyPair} LDKeyClass - The crypto-ld key class that this suite
       *   will use to sign/verify signatures. Provided by subclass. Used
       *   during the `verifySignature` operation, to create an instance (containing
       *   a `verifier()` property) of a public key fetched via a `documentLoader`.
       *
       * @param {string} contextUrl - JSON-LD context URL that corresponds to this
       *   signature suite. Provided by subclass. Used for enforcing suite context
       *   during the `sign()` operation.
       *
       * For `sign()` operations, either a `key` OR a `signer` is required.
       * For `verify()` operations, you can pass in a verifier (from KMS), or
       * the public key will be fetched via documentLoader.
       *
       * @param {object} [options.key] - An optional key object (containing an
       *   `id` property, and either `signer` or `verifier`, depending on the
       *   intended operation. Useful for when the application is managing keys
       *   itself (when using a KMS, you never have access to the private key,
       *   and so should use the `signer` param instead).
       *
       * @param {{sign: Function, id: string}} [options.signer] - Signer object
       *   that has two properties: an async `sign()` method, and an `id`. This is
       *   useful when interfacing with a KMS (since you don't get access to the
       *   private key and its `signer`, the KMS client gives you only the signer
       *   object to use).
       *
       * @param {{verify: Function, id: string}} [options.verifier] - Verifier
       *   object that has two properties: an async `verify()` method, and an `id`.
       *   Useful when working with a KMS-provided verifier.
       *
       * Advanced optional parameters and overrides:
       *
       * @param {object} [options.proof] - A JSON-LD document with options to use
       *   for the `proof` node (e.g. any other custom fields can be provided here
       *   using a context different from security-v2). If not provided, this is
       *   constructed during signing.
       * @param {string|Date} [options.date] - Signing date to use (otherwise
       *   defaults to `now()`).
       * @param {boolean} [options.useNativeCanonize] - Whether to use a native
       *   canonize algorithm.
       */
      constructor({
        type,
        proof,
        LDKeyClass,
        date,
        key,
        signer,
        verifier,
        useNativeCanonize,
        contextUrl
      } = {}) {
        super({ type });
        this.LDKeyClass = LDKeyClass;
        this.contextUrl = contextUrl;
        this.proof = proof;
        const vm = _processSignatureParams({ key, signer, verifier });
        this.verificationMethod = vm.verificationMethod;
        this.key = vm.key;
        this.signer = vm.signer;
        this.verifier = vm.verifier;
        if (date) {
          this.date = new Date(date);
          if (isNaN(this.date)) {
            throw TypeError(`"date" "${date}" is not a valid date.`);
          }
        }
        this.useNativeCanonize = useNativeCanonize;
        this._hashCache = null;
      }
      /**
       * @param document {object} to be signed.
       * @param purpose {ProofPurpose}
       * @param documentLoader {function}
       * @param expansionMap {function}
       *
       * @returns {Promise<object>} Resolves with the created proof object.
       */
      async createProof({ document, purpose, documentLoader, expansionMap }) {
        let proof;
        if (this.proof) {
          proof = { ...this.proof };
        } else {
          proof = {};
        }
        proof.type = this.type;
        let date = this.date;
        if (proof.created === void 0 && date === void 0) {
          date = /* @__PURE__ */ new Date();
        }
        if (date && typeof date !== "string") {
          date = util2.w3cDate(date);
        }
        if (date) {
          proof.created = date;
        }
        proof.verificationMethod = this.verificationMethod;
        proof = await this.updateProof({
          document,
          proof,
          purpose,
          documentLoader,
          expansionMap
        });
        proof = await purpose.update(
          proof,
          { document, suite: this, documentLoader, expansionMap }
        );
        const verifyData = await this.createVerifyData({
          document,
          proof,
          documentLoader,
          expansionMap
        });
        proof = await this.sign(
          { verifyData, document, proof, documentLoader, expansionMap }
        );
        return proof;
      }
      /**
       * @param document {object} to be signed.
       * @param purpose {ProofPurpose}
       * @param documentLoader {function}
       * @param expansionMap {function}
       *
       * @returns {Promise<object>} Resolves with the created proof object.
       */
      async updateProof({ proof }) {
        return proof;
      }
      /**
       * @param proof {object} the proof to be verified.
       * @param document {object} the document the proof applies to.
       * @param documentLoader {function}
       * @param expansionMap {function}
       *
       * @returns {Promise<{object}>} Resolves with the verification result.
       */
      async verifyProof({ proof, document, documentLoader, expansionMap }) {
        try {
          const verifyData = await this.createVerifyData(
            { document, proof, documentLoader, expansionMap }
          );
          const verificationMethod = await this.getVerificationMethod(
            { proof, document, documentLoader, expansionMap }
          );
          const verified = await this.verifySignature({
            verifyData,
            verificationMethod,
            document,
            proof,
            documentLoader,
            expansionMap
          });
          if (!verified) {
            throw new Error("Invalid signature.");
          }
          return { verified: true, verificationMethod };
        } catch (error) {
          return { verified: false, error };
        }
      }
      async canonize(input, { documentLoader, expansionMap, skipExpansion }) {
        return jsonld2.canonize(input, {
          algorithm: "URDNA2015",
          format: "application/n-quads",
          documentLoader,
          expansionMap,
          skipExpansion,
          useNative: this.useNativeCanonize
        });
      }
      async canonizeProof(proof, { document, documentLoader, expansionMap }) {
        proof = {
          "@context": document["@context"] || constants.SECURITY_CONTEXT_URL,
          ...proof
        };
        delete proof.jws;
        delete proof.signatureValue;
        delete proof.proofValue;
        return this.canonize(proof, {
          documentLoader,
          expansionMap,
          skipExpansion: false
        });
      }
      /**
       * @param document {object} to be signed/verified.
       * @param proof {object}
       * @param documentLoader {function}
       * @param expansionMap {function}
       *
       * @returns {Promise<{Uint8Array}>}.
       */
      async createVerifyData({ document, proof, documentLoader, expansionMap }) {
        let cachedDocHash;
        const { _hashCache } = this;
        if (_hashCache && _hashCache.document === document) {
          cachedDocHash = _hashCache.hash;
        } else {
          this._hashCache = {
            document,
            // canonize and hash document
            hash: cachedDocHash = this.canonize(document, { documentLoader, expansionMap }).then((c14nDocument) => sha256digest({ string: c14nDocument }))
          };
        }
        const [proofHash, docHash] = await Promise.all([
          // canonize and hash proof
          this.canonizeProof(
            proof,
            { document, documentLoader, expansionMap }
          ).then((c14nProofOptions) => sha256digest({ string: c14nProofOptions })),
          cachedDocHash
        ]);
        return util2.concat(proofHash, docHash);
      }
      /**
       * @param document {object} to be signed.
       * @param proof {object}
       * @param documentLoader {function}
       */
      async getVerificationMethod({ proof, documentLoader }) {
        let { verificationMethod } = proof;
        if (typeof verificationMethod === "object") {
          verificationMethod = verificationMethod.id;
        }
        if (!verificationMethod) {
          throw new Error('No "verificationMethod" found in proof.');
        }
        const framed = await jsonld2.frame(verificationMethod, {
          "@context": constants.SECURITY_CONTEXT_URL,
          "@embed": "@always",
          id: verificationMethod
        }, { documentLoader, compactToRelative: false });
        if (!framed) {
          throw new Error(`Verification method ${verificationMethod} not found.`);
        }
        if (framed.revoked !== void 0) {
          throw new Error("The verification method has been revoked.");
        }
        return framed;
      }
      /**
       * @param verifyData {Uint8Array}.
       * @param document {object} to be signed.
       * @param proof {object}
       * @param documentLoader {function}
       * @param expansionMap {function}
       *
       * @returns {Promise<{object}>} the proof containing the signature value.
       */
      async sign() {
        throw new Error("Must be implemented by a derived class.");
      }
      /**
       * @param verifyData {Uint8Array}.
       * @param verificationMethod {object}.
       * @param document {object} to be signed.
       * @param proof {object}
       * @param documentLoader {function}
       * @param expansionMap {function}
       *
       * @returns {Promise<boolean>}
       */
      async verifySignature() {
        throw new Error("Must be implemented by a derived class.");
      }
      /**
       * Ensures the document to be signed contains the required signature suite
       * specific `@context`, by either adding it (if `addSuiteContext` is true),
       * or throwing an error if it's missing.
       *
       * @param {object} options - Options hashmap.
       * @param {object} options.document - JSON-LD document to be signed.
       * @param {boolean} options.addSuiteContext - Add suite context?
       */
      ensureSuiteContext({ document, addSuiteContext }) {
        const { contextUrl } = this;
        if (_includesContext({ document, contextUrl })) {
          return;
        }
        if (!addSuiteContext) {
          throw new TypeError(
            `The document to be signed must contain this suite's @context, "${contextUrl}".`
          );
        }
        const existingContext = document["@context"] || [];
        document["@context"] = Array.isArray(existingContext) ? [...existingContext, contextUrl] : [existingContext, contextUrl];
      }
    };
    function _includesContext({ document, contextUrl }) {
      const context2 = document["@context"];
      return context2 === contextUrl || Array.isArray(context2) && context2.includes(contextUrl);
    }
    function _processSignatureParams({ key, signer, verifier }) {
      const vm = {};
      if (key) {
        vm.key = key;
        vm.verificationMethod = key.id;
        if (typeof key.signer === "function") {
          vm.signer = key.signer();
        }
        if (typeof key.verifier === "function") {
          vm.verifier = key.verifier();
        }
        if (!(vm.signer || vm.verifier)) {
          throw new TypeError(
            'The "key" parameter must contain a "signer" or "verifier" method.'
          );
        }
      } else {
        vm.verificationMethod = signer && signer.id || verifier && verifier.id;
        vm.signer = signer;
        vm.verifier = verifier;
      }
      if (vm.signer) {
        if (typeof vm.signer.sign !== "function") {
          throw new TypeError("A signer API has not been specified.");
        }
      }
      if (vm.verifier) {
        if (typeof vm.verifier.verify !== "function") {
          throw new TypeError("A verifier API has not been specified.");
        }
      }
      return vm;
    }
  }
});

// node_modules/@digitalcredentials/jsonld-signatures/lib/suites.js
var require_suites = __commonJS({
  "node_modules/@digitalcredentials/jsonld-signatures/lib/suites.js"(exports, module) {
    "use strict";
    var api = {};
    module.exports = api;
    api.suites = {
      LinkedDataProof: require_LinkedDataProof(),
      LinkedDataSignature: require_LinkedDataSignature()
    };
  }
});

// node_modules/@digitalcredentials/jsonld-signatures/lib/purposes/ProofPurpose.js
var require_ProofPurpose = __commonJS({
  "node_modules/@digitalcredentials/jsonld-signatures/lib/purposes/ProofPurpose.js"(exports, module) {
    "use strict";
    module.exports = class ProofPurpose {
      /**
       * @param term {string} the `proofPurpose` term, as defined in the
       *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.
       * @param [date] {string or Date or integer} the expected date for
       *   the creation of the proof.
       * @param [maxTimestampDelta] {integer} a maximum number of seconds that
       *   the date on the signature can deviate from, defaults to `Infinity`.
       */
      constructor({ term, date, maxTimestampDelta = Infinity } = {}) {
        if (term === void 0) {
          throw new Error('"term" is required.');
        }
        if (maxTimestampDelta !== void 0 && typeof maxTimestampDelta !== "number") {
          throw new TypeError('"maxTimestampDelta" must be a number.');
        }
        this.term = term;
        if (date !== void 0) {
          this.date = new Date(date);
          if (isNaN(this.date)) {
            throw TypeError(`"date" "${date}" is not a valid date.`);
          }
        }
        this.maxTimestampDelta = maxTimestampDelta;
      }
      /**
       * Called to validate the purpose of a proof. This method is called during
       * proof verification, after the proof value has been checked against the
       * given verification method (e.g. in the case of a digital signature, the
       * signature has been cryptographically verified against the public key).
       *
       * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`,
       *   with the matching purpose to validate.
       *
       * @return {Promise<object>} resolves to an object with `valid` and `error`.
       */
      async validate(proof, {
        /*document, suite, verificationMethod,
        documentLoader, expansionMap*/
      }) {
        try {
          if (this.maxTimestampDelta !== Infinity) {
            const expected = (this.date || /* @__PURE__ */ new Date()).getTime();
            const delta = this.maxTimestampDelta * 1e3;
            const created = new Date(proof.created).getTime();
            if (!(created >= expected - delta && created <= expected + delta)) {
              throw new Error("The proof's created timestamp is out of range.");
            }
          }
          return { valid: true };
        } catch (error) {
          return { valid: false, error };
        }
      }
      /**
       * Called to update a proof when it is being created, adding any properties
       * specific to this purpose. This method is called prior to the proof
       * value being generated such that any properties added may be, for example,
       * included in a digital signature value.
       *
       * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`
       *   to update.
       *
       * @return {Promise<object>} resolves to the proof instance (in the
       *   `constants.SECURITY_CONTEXT_URL`.
       */
      async update(proof, {
        /*document, suite, documentLoader, expansionMap */
      }) {
        proof.proofPurpose = this.term;
        return proof;
      }
      /**
       * Determines if the given proof has a purpose that matches this instance,
       * i.e. this ProofPurpose instance should be used to validate the given
       * proof.
       *
       * @param proof {object} the proof to check.
       *
       * @return {Promise<boolean>} `true` if there's a match, `false` if not.
       */
      async match(proof, {
        /* document, documentLoader, expansionMap */
      }) {
        return proof.proofPurpose === this.term;
      }
    };
  }
});

// node_modules/@digitalcredentials/jsonld-signatures/lib/purposes/ControllerProofPurpose.js
var require_ControllerProofPurpose = __commonJS({
  "node_modules/@digitalcredentials/jsonld-signatures/lib/purposes/ControllerProofPurpose.js"(exports, module) {
    "use strict";
    var constants = require_constants5();
    var jsonld2 = require_jsonld();
    var ProofPurpose = require_ProofPurpose();
    var DID_CONTEXT_V1 = "https://www.w3.org/ns/did/v1";
    var DID_VR_TERMS = [
      "assertionMethod",
      "authentication",
      "capabilityInvocation",
      "capabilityDelegation",
      "keyAgreement",
      "verificationMethod"
    ];
    module.exports = class ControllerProofPurpose extends ProofPurpose {
      /**
       * Creates a proof purpose that will validate whether or not the verification
       * method in a proof was authorized by its declared controller for the
       * proof's purpose.
       *
       * @param term {string} the `proofPurpose` term, as defined in the
       *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.
       * @param [controller] {object} the description of the controller, if it
       *   is not to be dereferenced via a `documentLoader`.
       * @param [date] {string or Date or integer} the expected date for
       *   the creation of the proof.
       * @param [maxTimestampDelta] {integer} a maximum number of seconds that
       *   the date on the signature can deviate from, defaults to `Infinity`.
       */
      constructor({ term, controller, date, maxTimestampDelta = Infinity } = {}) {
        super({ term, date, maxTimestampDelta });
        if (controller !== void 0) {
          if (typeof controller !== "object") {
            throw new TypeError('"controller" must be an object.');
          }
          this.controller = controller;
        }
        this._termDefinedByDIDContext = DID_VR_TERMS.includes(term);
      }
      /**
       * Validates the purpose of a proof. This method is called during
       * proof verification, after the proof value has been checked against the
       * given verification method (e.g. in the case of a digital signature, the
       * signature has been cryptographically verified against the public key).
       *
       * @param proof
       * @param verificationMethod
       * @param documentLoader
       * @param expansionMap
       *
       * @throws {Error} If verification method not authorized by controller
       * @throws {Error} If proof's created timestamp is out of range
       *
       * @returns {Promise<{valid: boolean, error: Error}>}
       */
      async validate(proof, { verificationMethod, documentLoader, expansionMap }) {
        try {
          const result2 = await super.validate(
            proof,
            { verificationMethod, documentLoader, expansionMap }
          );
          if (!result2.valid) {
            throw result2.error;
          }
          const { id: verificationId } = verificationMethod;
          const { term, _termDefinedByDIDContext } = this;
          if (this.controller) {
            result2.controller = this.controller;
          } else {
            const { controller } = verificationMethod;
            let controllerId;
            if (controller) {
              if (typeof controller === "object") {
                controllerId = controller.id;
              } else if (typeof controller !== "string") {
                throw new TypeError(
                  '"controller" must be a string representing a URL.'
                );
              } else {
                controllerId = controller;
              }
            }
            let { document } = await documentLoader(controllerId);
            const mustFrame = !(_termDefinedByDIDContext && document["@context"] === DID_CONTEXT_V1 || Array.isArray(document["@context"]) && document["@context"][0] === DID_CONTEXT_V1);
            if (mustFrame) {
              document = await jsonld2.frame(document, {
                "@context": constants.SECURITY_CONTEXT_URL,
                id: controllerId,
                // this term must be in the JSON-LD controller document or
                // verification will fail
                [term]: {
                  "@embed": "@never",
                  id: verificationId
                }
              }, { documentLoader, compactToRelative: false });
            }
            result2.controller = document;
          }
          const verificationMethods = jsonld2.getValues(result2.controller, term);
          result2.valid = verificationMethods.some((vm) => vm === verificationId || typeof vm === "object" && vm.id === verificationId);
          if (!result2.valid) {
            throw new Error(
              `Verification method "${verificationMethod.id}" not authorized by controller for proof purpose "${this.term}".`
            );
          }
          return result2;
        } catch (error) {
          return { valid: false, error };
        }
      }
    };
  }
});

// node_modules/@digitalcredentials/jsonld-signatures/lib/purposes/AssertionProofPurpose.js
var require_AssertionProofPurpose = __commonJS({
  "node_modules/@digitalcredentials/jsonld-signatures/lib/purposes/AssertionProofPurpose.js"(exports, module) {
    "use strict";
    var ControllerProofPurpose = require_ControllerProofPurpose();
    module.exports = class AssertionProofPurpose extends ControllerProofPurpose {
      constructor({
        term = "assertionMethod",
        controller,
        date,
        maxTimestampDelta = Infinity
      } = {}) {
        super({ term, controller, date, maxTimestampDelta });
      }
    };
  }
});

// node_modules/@digitalcredentials/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js
var require_AuthenticationProofPurpose = __commonJS({
  "node_modules/@digitalcredentials/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js"(exports, module) {
    "use strict";
    var ControllerProofPurpose = require_ControllerProofPurpose();
    module.exports = class AuthenticationProofPurpose extends ControllerProofPurpose {
      constructor({
        term = "authentication",
        controller,
        challenge,
        date,
        domain,
        maxTimestampDelta = Infinity
      } = {}) {
        super({ term, controller, date, maxTimestampDelta });
        if (typeof challenge !== "string") {
          throw new TypeError('"challenge" must be a string.');
        }
        if (domain !== void 0 && typeof domain !== "string") {
          throw new TypeError('"domain" must be a string.');
        }
        this.challenge = challenge;
        this.domain = domain;
      }
      async validate(proof, { verificationMethod, documentLoader, expansionMap }) {
        try {
          if (proof.challenge !== this.challenge) {
            throw new Error(`The challenge is not as expected; challenge="${proof.challenge}", expected="${this.challenge}"`);
          }
          if (this.domain !== void 0 && proof.domain !== this.domain) {
            throw new Error(`The domain is not as expected; domain="${proof.domain}", expected="${this.domain}"`);
          }
          return super.validate(
            proof,
            { verificationMethod, documentLoader, expansionMap }
          );
        } catch (error) {
          return { valid: false, error };
        }
      }
      async update(proof, { document, suite, documentLoader, expansionMap }) {
        proof = await super.update(
          proof,
          { document, suite, documentLoader, expansionMap }
        );
        proof.challenge = this.challenge;
        if (this.domain !== void 0) {
          proof.domain = this.domain;
        }
        return proof;
      }
    };
  }
});

// node_modules/@digitalcredentials/jsonld-signatures/lib/purposes.js
var require_purposes = __commonJS({
  "node_modules/@digitalcredentials/jsonld-signatures/lib/purposes.js"(exports, module) {
    "use strict";
    var api = {};
    module.exports = api;
    api.purposes = {
      AssertionProofPurpose: require_AssertionProofPurpose(),
      AuthenticationProofPurpose: require_AuthenticationProofPurpose(),
      ControllerProofPurpose: require_ControllerProofPurpose(),
      ProofPurpose: require_ProofPurpose()
    };
  }
});

// node_modules/@digitalcredentials/jsonld-signatures/lib/jsonld-signatures.js
var require_jsonld_signatures = __commonJS({
  "node_modules/@digitalcredentials/jsonld-signatures/lib/jsonld-signatures.js"(exports, module) {
    "use strict";
    var api = {};
    module.exports = api;
    var constants = require_constants5();
    Object.assign(api, constants);
    var ProofSet = require_ProofSet();
    var VerificationError = require_VerificationError();
    api.sign = async function sign(document, {
      suite,
      purpose,
      documentLoader,
      expansionMap,
      addSuiteContext = true
    } = {}) {
      if (typeof document !== "object") {
        throw new TypeError('The "document" parameter must be an object.');
      }
      suite.ensureSuiteContext({ document, addSuiteContext });
      try {
        return await new ProofSet().add(
          document,
          { suite, purpose, documentLoader, expansionMap }
        );
      } catch (e) {
        if (!documentLoader && e.name === "jsonld.InvalidUrl") {
          const { details: { url } } = e;
          const err = new Error(
            `A URL "${url}" could not be fetched; you need to pass "documentLoader" or resolve the URL before calling "sign".`
          );
          err.cause = e;
          throw err;
        }
        throw e;
      }
    };
    api.verify = async function verify(document, {
      suite,
      purpose,
      documentLoader,
      expansionMap
    } = {}) {
      if (typeof document !== "object") {
        throw new TypeError('The "document" parameter must be an object.');
      }
      const result2 = await new ProofSet().verify(
        document,
        { suite, purpose, documentLoader, expansionMap }
      );
      const { error } = result2;
      if (error) {
        if (!documentLoader && error.name === "jsonld.InvalidUrl") {
          const { details: { url } } = error;
          const urlError = new Error(
            `A URL "${url}" could not be fetched; you need to pass "documentLoader" or resolve the URL before calling "verify".`
          );
          result2.error = new VerificationError(urlError);
        } else {
          result2.error = new VerificationError(error);
        }
      }
      return result2;
    };
    api.suites = require_suites().suites;
    api.purposes = require_purposes().purposes;
    Object.assign(api, require_documentLoader());
  }
});

// node_modules/@aries-framework/core/build/modules/vc/libraries/jsonld-signatures.js
var require_jsonld_signatures2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/libraries/jsonld-signatures.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.constants = exports.purposes = exports.suites = void 0;
    var jsonld_signatures_1 = require_jsonld_signatures();
    exports.suites = jsonld_signatures_1.suites;
    exports.purposes = jsonld_signatures_1.purposes;
    exports.constants = jsonld_signatures_1.constants;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/SignatureSuiteRegistry.js
var require_SignatureSuiteRegistry = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/SignatureSuiteRegistry.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignatureSuiteRegistry = exports.SignatureSuiteToken = void 0;
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var jsonld_signatures_1 = require_jsonld_signatures2();
    var LinkedDataSignature = jsonld_signatures_1.suites.LinkedDataSignature;
    exports.SignatureSuiteToken = Symbol("SignatureSuiteToken");
    var SignatureSuiteRegistry = class SignatureSuiteRegistry {
      constructor(suites) {
        this.suiteMapping = suites;
      }
      get supportedProofTypes() {
        return this.suiteMapping.map((x) => x.proofType);
      }
      getByVerificationMethodType(verificationMethodType) {
        return this.suiteMapping.find((x) => x.verificationMethodTypes.includes(verificationMethodType));
      }
      getByKeyType(keyType) {
        return this.suiteMapping.find((x) => x.keyTypes.includes(keyType));
      }
      getByProofType(proofType) {
        const suiteInfo = this.suiteMapping.find((x) => x.proofType === proofType);
        if (!suiteInfo) {
          throw new error_1.AriesFrameworkError(`No signature suite for proof type: ${proofType}`);
        }
        return suiteInfo;
      }
      getVerificationMethodTypesByProofType(proofType) {
        const suiteInfo = this.suiteMapping.find((suiteInfo2) => suiteInfo2.proofType === proofType);
        if (!suiteInfo) {
          throw new error_1.AriesFrameworkError(`No verification method type found for proof type: ${proofType}`);
        }
        return suiteInfo.verificationMethodTypes;
      }
    };
    SignatureSuiteRegistry = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.injectAll)(exports.SignatureSuiteToken)),
      __metadata("design:paramtypes", [Array])
    ], SignatureSuiteRegistry);
    exports.SignatureSuiteRegistry = SignatureSuiteRegistry;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/libraries/jsonld.js
var require_jsonld2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/libraries/jsonld.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsonld_1 = __importDefault(require_jsonld());
    exports.default = jsonld_1.default;
  }
});

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "https" has been externalized for browser compatibility. Cannot access "https.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/ky/index.js
var globals, getGlobal3, globalProperties, isObject4, supportsAbortController, supportsStreams, supportsFormData, mergeHeaders, deepMerge, requestMethods, responseTypes, retryMethods, retryStatusCodes, retryAfterStatusCodes, stop, HTTPError, TimeoutError, delay2, timeout, normalizeRequestMethod, defaultRetryOptions, normalizeRetryOptions, maxSafeTimeout, Ky, validateAndMerge, createInstance, ky_default;
var init_ky = __esm({
  "node_modules/ky/index.js"() {
    globals = {};
    getGlobal3 = (property) => {
      if (typeof self !== "undefined" && self && property in self) {
        return self;
      }
      if (typeof window !== "undefined" && window && property in window) {
        return window;
      }
      if (typeof global !== "undefined" && global && property in global) {
        return global;
      }
      if (typeof globalThis !== "undefined" && globalThis) {
        return globalThis;
      }
    };
    globalProperties = [
      "Headers",
      "Request",
      "Response",
      "ReadableStream",
      "fetch",
      "AbortController",
      "FormData"
    ];
    for (const property of globalProperties) {
      Object.defineProperty(globals, property, {
        get() {
          const globalObject = getGlobal3(property);
          const value = globalObject && globalObject[property];
          return typeof value === "function" ? value.bind(globalObject) : value;
        }
      });
    }
    isObject4 = (value) => value !== null && typeof value === "object";
    supportsAbortController = typeof globals.AbortController === "function";
    supportsStreams = typeof globals.ReadableStream === "function";
    supportsFormData = typeof globals.FormData === "function";
    mergeHeaders = (source1, source2) => {
      const result2 = new globals.Headers(source1 || {});
      const isHeadersInstance = source2 instanceof globals.Headers;
      const source = new globals.Headers(source2 || {});
      for (const [key, value] of source) {
        if (isHeadersInstance && value === "undefined" || value === void 0) {
          result2.delete(key);
        } else {
          result2.set(key, value);
        }
      }
      return result2;
    };
    deepMerge = (...sources) => {
      let returnValue = {};
      let headers = {};
      for (const source of sources) {
        if (Array.isArray(source)) {
          if (!Array.isArray(returnValue)) {
            returnValue = [];
          }
          returnValue = [...returnValue, ...source];
        } else if (isObject4(source)) {
          for (let [key, value] of Object.entries(source)) {
            if (isObject4(value) && key in returnValue) {
              value = deepMerge(returnValue[key], value);
            }
            returnValue = { ...returnValue, [key]: value };
          }
          if (isObject4(source.headers)) {
            headers = mergeHeaders(headers, source.headers);
          }
        }
        returnValue.headers = headers;
      }
      return returnValue;
    };
    requestMethods = [
      "get",
      "post",
      "put",
      "patch",
      "head",
      "delete"
    ];
    responseTypes = {
      json: "application/json",
      text: "text/*",
      formData: "multipart/form-data",
      arrayBuffer: "*/*",
      blob: "*/*"
    };
    retryMethods = [
      "get",
      "put",
      "head",
      "delete",
      "options",
      "trace"
    ];
    retryStatusCodes = [
      408,
      413,
      429,
      500,
      502,
      503,
      504
    ];
    retryAfterStatusCodes = [
      413,
      429,
      503
    ];
    stop = Symbol("stop");
    HTTPError = class extends Error {
      constructor(response) {
        super(
          response.statusText || String(
            response.status === 0 || response.status ? response.status : "Unknown response error"
          )
        );
        this.name = "HTTPError";
        this.response = response;
      }
    };
    TimeoutError = class extends Error {
      constructor(request) {
        super("Request timed out");
        this.name = "TimeoutError";
        this.request = request;
      }
    };
    delay2 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    timeout = (request, abortController, options) => new Promise((resolve, reject) => {
      const timeoutID = setTimeout(() => {
        if (abortController) {
          abortController.abort();
        }
        reject(new TimeoutError(request));
      }, options.timeout);
      options.fetch(request).then(resolve).catch(reject).then(() => {
        clearTimeout(timeoutID);
      });
    });
    normalizeRequestMethod = (input) => requestMethods.includes(input) ? input.toUpperCase() : input;
    defaultRetryOptions = {
      limit: 2,
      methods: retryMethods,
      statusCodes: retryStatusCodes,
      afterStatusCodes: retryAfterStatusCodes
    };
    normalizeRetryOptions = (retry = {}) => {
      if (typeof retry === "number") {
        return {
          ...defaultRetryOptions,
          limit: retry
        };
      }
      if (retry.methods && !Array.isArray(retry.methods)) {
        throw new Error("retry.methods must be an array");
      }
      if (retry.statusCodes && !Array.isArray(retry.statusCodes)) {
        throw new Error("retry.statusCodes must be an array");
      }
      return {
        ...defaultRetryOptions,
        ...retry,
        afterStatusCodes: retryAfterStatusCodes
      };
    };
    maxSafeTimeout = 2147483647;
    Ky = class {
      constructor(input, options = {}) {
        this._retryCount = 0;
        this._input = input;
        this._options = {
          // TODO: credentials can be removed when the spec change is implemented in all browsers. Context: https://www.chromestatus.com/feature/4539473312350208
          credentials: this._input.credentials || "same-origin",
          ...options,
          headers: mergeHeaders(this._input.headers, options.headers),
          hooks: deepMerge({
            beforeRequest: [],
            beforeRetry: [],
            afterResponse: []
          }, options.hooks),
          method: normalizeRequestMethod(options.method || this._input.method),
          prefixUrl: String(options.prefixUrl || ""),
          retry: normalizeRetryOptions(options.retry),
          throwHttpErrors: options.throwHttpErrors !== false,
          timeout: typeof options.timeout === "undefined" ? 1e4 : options.timeout,
          fetch: options.fetch || globals.fetch
        };
        if (typeof this._input !== "string" && !(this._input instanceof URL || this._input instanceof globals.Request)) {
          throw new TypeError("`input` must be a string, URL, or Request");
        }
        if (this._options.prefixUrl && typeof this._input === "string") {
          if (this._input.startsWith("/")) {
            throw new Error("`input` must not begin with a slash when using `prefixUrl`");
          }
          if (!this._options.prefixUrl.endsWith("/")) {
            this._options.prefixUrl += "/";
          }
          this._input = this._options.prefixUrl + this._input;
        }
        if (supportsAbortController) {
          this.abortController = new globals.AbortController();
          if (this._options.signal) {
            this._options.signal.addEventListener("abort", () => {
              this.abortController.abort();
            });
          }
          this._options.signal = this.abortController.signal;
        }
        this.request = new globals.Request(this._input, this._options);
        if (this._options.searchParams) {
          const searchParams = "?" + new URLSearchParams(this._options.searchParams).toString();
          const url = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, searchParams);
          if ((supportsFormData && this._options.body instanceof globals.FormData || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers["content-type"])) {
            this.request.headers.delete("content-type");
          }
          this.request = new globals.Request(new globals.Request(url, this.request), this._options);
        }
        if (this._options.json !== void 0) {
          this._options.body = JSON.stringify(this._options.json);
          this.request.headers.set("content-type", "application/json");
          this.request = new globals.Request(this.request, { body: this._options.body });
        }
        const fn = async () => {
          if (this._options.timeout > maxSafeTimeout) {
            throw new RangeError(`The \`timeout\` option cannot be greater than ${maxSafeTimeout}`);
          }
          await delay2(1);
          let response = await this._fetch();
          for (const hook of this._options.hooks.afterResponse) {
            const modifiedResponse = await hook(
              this.request,
              this._options,
              this._decorateResponse(response.clone())
            );
            if (modifiedResponse instanceof globals.Response) {
              response = modifiedResponse;
            }
          }
          this._decorateResponse(response);
          if (!response.ok && this._options.throwHttpErrors) {
            throw new HTTPError(response);
          }
          if (this._options.onDownloadProgress) {
            if (typeof this._options.onDownloadProgress !== "function") {
              throw new TypeError("The `onDownloadProgress` option must be a function");
            }
            if (!supportsStreams) {
              throw new Error("Streams are not supported in your environment. `ReadableStream` is missing.");
            }
            return this._stream(response.clone(), this._options.onDownloadProgress);
          }
          return response;
        };
        const isRetriableMethod = this._options.retry.methods.includes(this.request.method.toLowerCase());
        const result2 = isRetriableMethod ? this._retry(fn) : fn();
        for (const [type, mimeType] of Object.entries(responseTypes)) {
          result2[type] = async () => {
            this.request.headers.set("accept", this.request.headers.get("accept") || mimeType);
            const response = (await result2).clone();
            if (type === "json") {
              if (response.status === 204) {
                return "";
              }
              if (options.parseJson) {
                return options.parseJson(await response.text());
              }
            }
            return response[type]();
          };
        }
        return result2;
      }
      _calculateRetryDelay(error) {
        this._retryCount++;
        if (this._retryCount < this._options.retry.limit && !(error instanceof TimeoutError)) {
          if (error instanceof HTTPError) {
            if (!this._options.retry.statusCodes.includes(error.response.status)) {
              return 0;
            }
            const retryAfter = error.response.headers.get("Retry-After");
            if (retryAfter && this._options.retry.afterStatusCodes.includes(error.response.status)) {
              let after = Number(retryAfter);
              if (Number.isNaN(after)) {
                after = Date.parse(retryAfter) - Date.now();
              } else {
                after *= 1e3;
              }
              if (typeof this._options.retry.maxRetryAfter !== "undefined" && after > this._options.retry.maxRetryAfter) {
                return 0;
              }
              return after;
            }
            if (error.response.status === 413) {
              return 0;
            }
          }
          const BACKOFF_FACTOR = 0.3;
          return BACKOFF_FACTOR * 2 ** (this._retryCount - 1) * 1e3;
        }
        return 0;
      }
      _decorateResponse(response) {
        if (this._options.parseJson) {
          response.json = async () => {
            return this._options.parseJson(await response.text());
          };
        }
        return response;
      }
      async _retry(fn) {
        try {
          return await fn();
        } catch (error) {
          const ms = Math.min(this._calculateRetryDelay(error), maxSafeTimeout);
          if (ms !== 0 && this._retryCount > 0) {
            await delay2(ms);
            for (const hook of this._options.hooks.beforeRetry) {
              const hookResult = await hook({
                request: this.request,
                options: this._options,
                error,
                retryCount: this._retryCount
              });
              if (hookResult === stop) {
                return;
              }
            }
            return this._retry(fn);
          }
          if (this._options.throwHttpErrors) {
            throw error;
          }
        }
      }
      async _fetch() {
        for (const hook of this._options.hooks.beforeRequest) {
          const result2 = await hook(this.request, this._options);
          if (result2 instanceof Request) {
            this.request = result2;
            break;
          }
          if (result2 instanceof Response) {
            return result2;
          }
        }
        if (this._options.timeout === false) {
          return this._options.fetch(this.request.clone());
        }
        return timeout(this.request.clone(), this.abortController, this._options);
      }
      /* istanbul ignore next */
      _stream(response, onDownloadProgress) {
        const totalBytes = Number(response.headers.get("content-length")) || 0;
        let transferredBytes = 0;
        return new globals.Response(
          new globals.ReadableStream({
            start(controller) {
              const reader = response.body.getReader();
              if (onDownloadProgress) {
                onDownloadProgress({ percent: 0, transferredBytes: 0, totalBytes }, new Uint8Array());
              }
              async function read() {
                const { done, value } = await reader.read();
                if (done) {
                  controller.close();
                  return;
                }
                if (onDownloadProgress) {
                  transferredBytes += value.byteLength;
                  const percent = totalBytes === 0 ? 0 : transferredBytes / totalBytes;
                  onDownloadProgress({ percent, transferredBytes, totalBytes }, value);
                }
                controller.enqueue(value);
                read();
              }
              read();
            }
          })
        );
      }
    };
    validateAndMerge = (...sources) => {
      for (const source of sources) {
        if ((!isObject4(source) || Array.isArray(source)) && typeof source !== "undefined") {
          throw new TypeError("The `options` argument must be an object");
        }
      }
      return deepMerge({}, ...sources);
    };
    createInstance = (defaults) => {
      const ky = (input, options) => new Ky(input, validateAndMerge(defaults, options));
      for (const method of requestMethods) {
        ky[method] = (input, options) => new Ky(input, validateAndMerge(defaults, options, { method }));
      }
      ky.HTTPError = HTTPError;
      ky.TimeoutError = TimeoutError;
      ky.create = (newDefaults) => createInstance(validateAndMerge(newDefaults));
      ky.extend = (newDefaults) => createInstance(validateAndMerge(defaults, newDefaults));
      ky.stop = stop;
      return ky;
    };
    ky_default = createInstance();
  }
});

// node_modules/ky-universal/browser.js
var browser_exports = {};
__export(browser_exports, {
  default: () => ky_default
});
var init_browser = __esm({
  "node_modules/ky-universal/browser.js"() {
    init_ky();
  }
});

// node_modules/@digitalcredentials/http-client/dist/index.js
var require_dist = __commonJS({
  "node_modules/@digitalcredentials/http-client/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var kyOriginal = (init_browser(), __toCommonJS(browser_exports));
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var kyOriginal__default = _interopDefaultLegacy(kyOriginal);
    var DEFAULT_HEADERS = {
      Accept: "application/ld+json, application/json"
    };
    var ky = kyOriginal__default["default"].create({ headers: DEFAULT_HEADERS });
    var proxyMethods = /* @__PURE__ */ new Set([
      "get",
      "post",
      "push",
      "patch",
      "head",
      "delete"
    ]);
    var httpClient = new Proxy(ky, {
      apply: _handleResponse,
      get(target, propKey) {
        const propValue = target[propKey];
        if (!proxyMethods.has(propKey)) {
          return propValue;
        }
        return async function() {
          return _handleResponse(propValue, this, arguments);
        };
      }
    });
    async function _handleResponse(target, thisArg, args) {
      let response;
      try {
        response = await target.apply(thisArg, args);
      } catch (e) {
        return _handleError(e);
      }
      const { parseBody = true } = args[1] || {};
      if (parseBody) {
        const contentType = response.headers.get("content-type");
        if (contentType && contentType.includes("json")) {
          response.data = await response.json();
        }
      }
      return response;
    }
    async function _handleError(e) {
      if (!e.response) {
        if (e.message === "Failed to fetch") {
          e.message = `${e.message}. Possible CORS error.`;
        }
        throw e;
      }
      e.status = e.response.status;
      const contentType = e.response.headers.get("content-type");
      if (contentType && contentType.includes("json")) {
        const errorBody = await e.response.json();
        e.message = errorBody.message || e.message;
        e.data = errorBody;
      }
      throw e;
    }
    var index = {
      httpClient,
      ky: kyOriginal__default["default"],
      DEFAULT_HEADERS
    };
    exports.DEFAULT_HEADERS = DEFAULT_HEADERS;
    exports["default"] = index;
    exports.httpClient = httpClient;
  }
});

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "http" has been externalized for browser compatibility. Cannot access "http.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@digitalcredentials/jsonld/lib/documentLoaders/node.js
var require_node2 = __commonJS({
  "node_modules/@digitalcredentials/jsonld/lib/documentLoaders/node.js"(exports, module) {
    "use strict";
    var https = require_https();
    var { parseLinkHeader, buildHeaders } = require_util3();
    var { LINK_HEADER_CONTEXT } = require_constants6();
    var JsonLdError = require_JsonLdError();
    var RequestQueue = require_RequestQueue();
    var { prependBase } = require_url();
    var { httpClient } = require_dist();
    module.exports = ({
      secure,
      strictSSL = true,
      maxRedirects = -1,
      headers = {},
      httpAgent,
      httpsAgent
    } = { strictSSL: true, maxRedirects: -1, headers: {} }) => {
      headers = buildHeaders(headers);
      if (!("user-agent" in headers)) {
        headers = Object.assign({}, headers, {
          "user-agent": "jsonld.js"
        });
      }
      const http = require_http();
      const queue = new RequestQueue();
      return queue.wrapLoader(function(url) {
        return loadDocument(url, []);
      });
      async function loadDocument(url, redirects) {
        const isHttp = url.startsWith("http:");
        const isHttps = url.startsWith("https:");
        if (!isHttp && !isHttps) {
          throw new JsonLdError(
            'URL could not be dereferenced; only "http" and "https" URLs are supported.',
            "jsonld.InvalidUrl",
            { code: "loading document failed", url }
          );
        }
        if (secure && !isHttps) {
          throw new JsonLdError(
            `URL could not be dereferenced; secure mode is enabled and the URL's scheme is not "https".`,
            "jsonld.InvalidUrl",
            { code: "loading document failed", url }
          );
        }
        let doc = null;
        if (doc !== null) {
          return doc;
        }
        let alternate = null;
        const { res, body } = await _fetch({
          url,
          headers,
          strictSSL,
          httpAgent,
          httpsAgent
        });
        doc = { contextUrl: null, documentUrl: url, document: body || null };
        const statusText = http.STATUS_CODES[res.status];
        if (res.status >= 400) {
          throw new JsonLdError(
            `URL "${url}" could not be dereferenced: ${statusText}`,
            "jsonld.InvalidUrl",
            {
              code: "loading document failed",
              url,
              httpStatusCode: res.status
            }
          );
        }
        const link = res.headers.get("link");
        const contentType = res.headers.get("content-type");
        if (link && contentType !== "application/ld+json") {
          const linkHeaders = parseLinkHeader(link);
          const linkedContext = linkHeaders[LINK_HEADER_CONTEXT];
          if (Array.isArray(linkedContext)) {
            throw new JsonLdError(
              "URL could not be dereferenced, it has more than one associated HTTP Link Header.",
              "jsonld.InvalidUrl",
              { code: "multiple context link headers", url }
            );
          }
          if (linkedContext) {
            doc.contextUrl = linkedContext.target;
          }
          alternate = linkHeaders["alternate"];
          if (alternate && alternate.type == "application/ld+json" && !(contentType || "").match(/^application\/(\w*\+)?json$/)) {
            res.headers.set("location", prependBase(url, alternate.target));
          }
        }
        const location = res.headers.get("location");
        if ((alternate || res.status >= 300 && res.status < 400) && location) {
          if (redirects.length === maxRedirects) {
            throw new JsonLdError(
              "URL could not be dereferenced; there were too many redirects.",
              "jsonld.TooManyRedirects",
              {
                code: "loading document failed",
                url,
                httpStatusCode: res.status,
                redirects
              }
            );
          }
          if (redirects.indexOf(url) !== -1) {
            throw new JsonLdError(
              "URL could not be dereferenced; infinite redirection was detected.",
              "jsonld.InfiniteRedirectDetected",
              {
                code: "recursive context inclusion",
                url,
                httpStatusCode: res.status,
                redirects
              }
            );
          }
          redirects.push(url);
          return loadDocument(location, redirects);
        }
        redirects.push(url);
        return doc;
      }
    };
    async function _fetch({ url, headers, strictSSL, httpAgent, httpsAgent }) {
      try {
        const options = { headers, redirect: "manual" };
        const isHttps = url.startsWith("https:");
        if (isHttps) {
          options.agent = httpsAgent || new https.Agent({ rejectUnauthorized: strictSSL });
        } else {
          if (httpAgent) {
            options.agent = httpAgent;
          }
        }
        const res = await httpClient.get(url, options);
        return { res, body: res.data };
      } catch (e) {
        if (e.response) {
          return { res: e.response, body: null };
        }
        throw new JsonLdError(
          "URL could not be dereferenced, an error occurred.",
          "jsonld.LoadDocumentError",
          { code: "loading document failed", url, cause: e }
        );
      }
    }
  }
});

// node_modules/@aries-framework/core/build/modules/vc/libraries/nativeDocumentLoader.js
var require_nativeDocumentLoader = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/libraries/nativeDocumentLoader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNativeDocumentLoader = void 0;
    function getNativeDocumentLoader() {
      const loader = require_node2();
      return loader;
    }
    exports.getNativeDocumentLoader = getNativeDocumentLoader;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/libraries/documentLoader.js
var require_documentLoader2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/libraries/documentLoader.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultDocumentLoader = void 0;
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var dids_1 = require_dids();
    var jsonld_1 = __importDefault(require_jsonld2());
    var nativeDocumentLoader_1 = require_nativeDocumentLoader();
    function defaultDocumentLoader(agentContext) {
      const didResolver = agentContext.dependencyManager.resolve(dids_1.DidResolverService);
      async function loader(url) {
        if (url.startsWith("did:")) {
          const result2 = await didResolver.resolve(agentContext, url);
          if (result2.didResolutionMetadata.error || !result2.didDocument) {
            throw new AriesFrameworkError_1.AriesFrameworkError(`Unable to resolve DID: ${url}`);
          }
          const framed = await jsonld_1.default.frame(
            result2.didDocument.toJSON(),
            {
              "@context": result2.didDocument.context,
              "@embed": "@never",
              id: url
            },
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            { documentLoader: this }
          );
          return {
            contextUrl: null,
            documentUrl: url,
            document: framed
          };
        }
        const platformLoader = (0, nativeDocumentLoader_1.getNativeDocumentLoader)();
        const nativeLoader = platformLoader.apply(jsonld_1.default, []);
        return await nativeLoader(url);
      }
      return loader.bind(loader);
    }
    exports.defaultDocumentLoader = defaultDocumentLoader;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/W3cVcModuleConfig.js
var require_W3cVcModuleConfig = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/W3cVcModuleConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3cVcModuleConfig = void 0;
    var documentLoader_1 = require_documentLoader2();
    var W3cVcModuleConfig = class {
      constructor(options) {
        this.options = options !== null && options !== void 0 ? options : {};
      }
      /** See {@link W3cVcModuleConfigOptions.documentLoader} */
      get documentLoader() {
        var _a;
        return (_a = this.options.documentLoader) !== null && _a !== void 0 ? _a : documentLoader_1.defaultDocumentLoader;
      }
    };
    exports.W3cVcModuleConfig = W3cVcModuleConfig;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/jsonldUtil.js
var require_jsonldUtil = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/jsonldUtil.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTypeInfo = exports.w3cDate = exports.getProofs = exports._includesContext = exports.orArrayToArray = void 0;
    var constants_1 = require_constants2();
    var jsonld_1 = __importDefault(require_jsonld2());
    var orArrayToArray = (val) => {
      if (!val)
        return [];
      if (Array.isArray(val))
        return val;
      return [val];
    };
    exports.orArrayToArray = orArrayToArray;
    var _includesContext = (options) => {
      const context2 = options.document["@context"];
      return context2 === options.contextUrl || Array.isArray(context2) && context2.includes(options.contextUrl);
    };
    exports._includesContext = _includesContext;
    var PROOF_PROPERTY = "proof";
    var getProofs = async (options) => {
      const { proofType, skipProofCompaction, documentLoader, expansionMap } = options;
      let { document } = options;
      let proofs;
      if (!skipProofCompaction) {
        document = await jsonld_1.default.compact(document, constants_1.SECURITY_CONTEXT_URL, {
          documentLoader,
          expansionMap,
          compactToRelative: false
        });
      }
      proofs = jsonld_1.default.getValues(document, PROOF_PROPERTY);
      delete document[PROOF_PROPERTY];
      if (typeof proofType === "string") {
        proofs = proofs.filter((_) => _.type == proofType);
      }
      if (Array.isArray(proofType)) {
        proofs = proofs.filter((_) => proofType.includes(_.type));
      }
      proofs = proofs.map((matchedProof) => Object.assign({ "@context": constants_1.SECURITY_CONTEXT_URL }, matchedProof));
      return {
        proofs,
        document
      };
    };
    exports.getProofs = getProofs;
    var w3cDate = (date) => {
      let result2 = /* @__PURE__ */ new Date();
      if (typeof date === "number" || typeof date === "string") {
        result2 = new Date(date);
      }
      const str = result2.toISOString();
      return str.substr(0, str.length - 5) + "Z";
    };
    exports.w3cDate = w3cDate;
    var getTypeInfo = async (document, options) => {
      const { documentLoader, expansionMap } = options;
      const context2 = jsonld_1.default.getValues(document, "@context");
      const compacted = await jsonld_1.default.compact({ "@type": "_:b0" }, context2, {
        documentLoader,
        expansionMap
      });
      delete compacted["@context"];
      const alias = Object.keys(compacted)[0];
      let toExpand = { "@context": context2 };
      toExpand["@type"] = jsonld_1.default.getValues(document, "@type").concat(jsonld_1.default.getValues(document, alias));
      const expanded = (await jsonld_1.default.expand(toExpand, { documentLoader, expansionMap }))[0] || {};
      return { types: jsonld_1.default.getValues(expanded, "@type"), alias };
    };
    exports.getTypeInfo = getTypeInfo;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/validators.js
var require_validators2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/validators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsJsonLdContext = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var constants_1 = require_constants2();
    function IsJsonLdContext(validationOptions) {
      return (0, class_validator_1.ValidateBy)({
        name: "IsJsonLdContext",
        validator: {
          validate: (value) => {
            if (Array.isArray(value)) {
              return value.every((v) => (0, class_validator_1.isString)(v) && (0, class_validator_1.isURL)(v)) && value[0] === constants_1.CREDENTIALS_CONTEXT_V1_URL;
            }
            if (typeof value === "object") {
              return true;
            }
            return false;
          },
          defaultMessage: (0, class_validator_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be an array of strings or a JSON-LD context definition", validationOptions)
        }
      }, validationOptions);
    }
    exports.IsJsonLdContext = IsJsonLdContext;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/models/credential/CredentialSchema.js
var require_CredentialSchema = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/models/credential/CredentialSchema.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CredentialSchema = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var validators_1 = require_validators();
    var CredentialSchema = class {
      constructor(options) {
        if (options) {
          this.id = options.id;
          this.type = options.type;
        }
      }
    };
    __decorate([
      (0, validators_1.IsUri)(),
      __metadata("design:type", String)
    ], CredentialSchema.prototype, "id", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], CredentialSchema.prototype, "type", void 0);
    exports.CredentialSchema = CredentialSchema;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/models/credential/CredentialSubject.js
var require_CredentialSubject = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/models/credential/CredentialSubject.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CredentialSubjectTransformer = exports.CredentialSubject = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var validators_1 = require_validators();
    var CredentialSubject = class {
      constructor(options) {
        if (options) {
          this.id = options.id;
        }
      }
    };
    __decorate([
      (0, validators_1.IsUri)(),
      __metadata("design:type", String)
    ], CredentialSubject.prototype, "id", void 0);
    exports.CredentialSubject = CredentialSubject;
    function CredentialSubjectTransformer() {
      return (0, class_transformer_1.Transform)(({ value, type }) => {
        if (type === class_transformer_1.TransformationType.PLAIN_TO_CLASS) {
          if ((0, class_validator_1.isString)(value))
            return value;
          return (0, class_transformer_1.plainToInstance)(CredentialSubject, value);
        } else if (type === class_transformer_1.TransformationType.CLASS_TO_PLAIN) {
          if ((0, class_validator_1.isString)(value))
            return value;
          return (0, class_transformer_1.instanceToPlain)(value);
        }
        return value;
      });
    }
    exports.CredentialSubjectTransformer = CredentialSubjectTransformer;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/models/credential/Issuer.js
var require_Issuer = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/models/credential/Issuer.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsIssuer = exports.IssuerTransformer = exports.Issuer = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var validators_1 = require_validators();
    var Issuer = class {
      constructor(options) {
        if (options) {
          this.id = options.id;
        }
      }
    };
    __decorate([
      (0, validators_1.IsUri)(),
      __metadata("design:type", String)
    ], Issuer.prototype, "id", void 0);
    exports.Issuer = Issuer;
    function IssuerTransformer() {
      return (0, class_transformer_1.Transform)(({ value, type }) => {
        if (type === class_transformer_1.TransformationType.PLAIN_TO_CLASS) {
          if ((0, class_validator_1.isString)(value))
            return value;
          return (0, class_transformer_1.plainToInstance)(Issuer, value);
        } else if (type === class_transformer_1.TransformationType.CLASS_TO_PLAIN) {
          if ((0, class_validator_1.isString)(value))
            return value;
          return (0, class_transformer_1.instanceToPlain)(value);
        }
        return value;
      });
    }
    exports.IssuerTransformer = IssuerTransformer;
    function IsIssuer(validationOptions) {
      return (0, class_validator_1.ValidateBy)({
        name: "IsIssuer",
        validator: {
          validate: (value) => {
            if (typeof value === "string") {
              return validators_1.UriValidator.test(value);
            }
            if ((0, class_validator_1.isInstance)(value, Issuer)) {
              return validators_1.UriValidator.test(value.id);
            }
            return false;
          },
          defaultMessage: (0, class_validator_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a string or an object with an id property", validationOptions)
        }
      }, validationOptions);
    }
    exports.IsIssuer = IsIssuer;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/models/credential/W3cCredential.js
var require_W3cCredential = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/models/credential/W3cCredential.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsCredentialType = exports.W3cCredential = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var validators_1 = require_validators();
    var constants_1 = require_constants2();
    var validators_2 = require_validators2();
    var CredentialSchema_1 = require_CredentialSchema();
    var CredentialSubject_1 = require_CredentialSubject();
    var Issuer_1 = require_Issuer();
    var W3cCredential = class {
      constructor(options) {
        var _a;
        if (options) {
          this.context = (_a = options.context) !== null && _a !== void 0 ? _a : [constants_1.CREDENTIALS_CONTEXT_V1_URL];
          this.id = options.id;
          this.type = options.type || [];
          this.issuer = options.issuer;
          this.issuanceDate = options.issuanceDate;
          this.expirationDate = options.expirationDate;
          this.credentialSubject = options.credentialSubject;
        }
      }
      get issuerId() {
        return this.issuer instanceof Issuer_1.Issuer ? this.issuer.id : this.issuer;
      }
      get credentialSchemaIds() {
        if (!this.credentialSchema)
          return [];
        if (Array.isArray(this.credentialSchema)) {
          return this.credentialSchema.map((credentialSchema) => credentialSchema.id);
        }
        return [this.credentialSchema.id];
      }
      get credentialSubjectIds() {
        if (Array.isArray(this.credentialSubject)) {
          return this.credentialSubject.map((credentialSubject) => credentialSubject.id);
        }
        return [this.credentialSubject.id];
      }
      get contexts() {
        if (Array.isArray(this.context)) {
          return this.context.filter((x) => typeof x === "string");
        }
        if (typeof this.context === "string") {
          return [this.context];
        }
        return [this.context.id];
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "@context" }),
      (0, validators_2.IsJsonLdContext)(),
      __metadata("design:type", Object)
    ], W3cCredential.prototype, "context", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, validators_1.IsUri)(),
      __metadata("design:type", String)
    ], W3cCredential.prototype, "id", void 0);
    __decorate([
      IsCredentialType(),
      __metadata("design:type", Array)
    ], W3cCredential.prototype, "type", void 0);
    __decorate([
      (0, Issuer_1.IssuerTransformer)(),
      (0, Issuer_1.IsIssuer)(),
      __metadata("design:type", Object)
    ], W3cCredential.prototype, "issuer", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], W3cCredential.prototype, "issuanceDate", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], W3cCredential.prototype, "expirationDate", void 0);
    __decorate([
      (0, class_transformer_1.Type)(() => CredentialSubject_1.CredentialSubject),
      (0, validators_1.IsInstanceOrArrayOfInstances)({ classType: CredentialSubject_1.CredentialSubject }),
      __metadata("design:type", Object)
    ], W3cCredential.prototype, "credentialSubject", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_transformer_1.Type)(() => CredentialSchema_1.CredentialSchema),
      (0, validators_1.IsInstanceOrArrayOfInstances)({ classType: CredentialSchema_1.CredentialSchema }),
      __metadata("design:type", Object)
    ], W3cCredential.prototype, "credentialSchema", void 0);
    exports.W3cCredential = W3cCredential;
    function IsCredentialType(validationOptions) {
      return (0, class_validator_1.ValidateBy)({
        name: "IsVerifiableCredentialType",
        validator: {
          validate: (value) => {
            if (Array.isArray(value)) {
              return value.includes(constants_1.VERIFIABLE_CREDENTIAL_TYPE);
            }
            return false;
          },
          defaultMessage: (0, class_validator_1.buildMessage)((eachPrefix) => eachPrefix + '$property must be an array of strings which includes "VerifiableCredential"', validationOptions)
        }
      }, validationOptions);
    }
    exports.IsCredentialType = IsCredentialType;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/models/LinkedDataProof.js
var require_LinkedDataProof2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/models/LinkedDataProof.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkedDataProofTransformer = exports.LinkedDataProof = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var LinkedDataProof = class {
      constructor(options) {
        if (options) {
          this.type = options.type;
          this.proofPurpose = options.proofPurpose;
          this.verificationMethod = options.verificationMethod;
          this.created = options.created;
          this.domain = options.domain;
          this.challenge = options.challenge;
          this.jws = options.jws;
          this.proofValue = options.proofValue;
          this.nonce = options.nonce;
        }
      }
    };
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], LinkedDataProof.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], LinkedDataProof.prototype, "proofPurpose", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], LinkedDataProof.prototype, "verificationMethod", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], LinkedDataProof.prototype, "created", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], LinkedDataProof.prototype, "domain", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], LinkedDataProof.prototype, "challenge", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], LinkedDataProof.prototype, "jws", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], LinkedDataProof.prototype, "proofValue", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], LinkedDataProof.prototype, "nonce", void 0);
    exports.LinkedDataProof = LinkedDataProof;
    function LinkedDataProofTransformer() {
      return (0, class_transformer_1.Transform)(({ value, type }) => {
        if (type === class_transformer_1.TransformationType.PLAIN_TO_CLASS) {
          if (Array.isArray(value))
            return value.map((v) => (0, class_transformer_1.plainToInstance)(LinkedDataProof, v));
          return (0, class_transformer_1.plainToInstance)(LinkedDataProof, value);
        } else if (type === class_transformer_1.TransformationType.CLASS_TO_PLAIN) {
          if (Array.isArray(value))
            return value.map((v) => (0, class_transformer_1.instanceToPlain)(v));
          return (0, class_transformer_1.instanceToPlain)(value);
        }
        return value;
      });
    }
    exports.LinkedDataProofTransformer = LinkedDataProofTransformer;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/models/credential/W3cVerifiableCredential.js
var require_W3cVerifiableCredential = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/models/credential/W3cVerifiableCredential.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VerifiableCredentialTransformer = exports.W3cVerifiableCredential = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var utils_1 = require_utils();
    var jsonldUtil_1 = require_jsonldUtil();
    var LinkedDataProof_1 = require_LinkedDataProof2();
    var W3cCredential_1 = require_W3cCredential();
    var W3cVerifiableCredential = class extends W3cCredential_1.W3cCredential {
      constructor(options) {
        super(options);
        if (options) {
          this.proof = Array.isArray(options.proof) ? options.proof.map((proof) => new LinkedDataProof_1.LinkedDataProof(proof)) : new LinkedDataProof_1.LinkedDataProof(options.proof);
        }
      }
      get proofTypes() {
        var _a;
        const proofArray = (0, jsonldUtil_1.orArrayToArray)(this.proof);
        return (_a = proofArray === null || proofArray === void 0 ? void 0 : proofArray.map((x) => x.type)) !== null && _a !== void 0 ? _a : [];
      }
    };
    __decorate([
      (0, LinkedDataProof_1.LinkedDataProofTransformer)(),
      (0, utils_1.IsInstanceOrArrayOfInstances)({ classType: LinkedDataProof_1.LinkedDataProof }),
      __metadata("design:type", Object)
    ], W3cVerifiableCredential.prototype, "proof", void 0);
    exports.W3cVerifiableCredential = W3cVerifiableCredential;
    function VerifiableCredentialTransformer() {
      return (0, class_transformer_1.Transform)(({ value, type }) => {
        if (type === class_transformer_1.TransformationType.PLAIN_TO_CLASS) {
          if (Array.isArray(value))
            return value.map((v) => (0, class_transformer_1.plainToInstance)(W3cVerifiableCredential, v));
          return (0, class_transformer_1.plainToInstance)(W3cVerifiableCredential, value);
        } else if (type === class_transformer_1.TransformationType.CLASS_TO_PLAIN) {
          if (Array.isArray(value))
            return value.map((v) => (0, class_transformer_1.instanceToPlain)(v));
          return (0, class_transformer_1.instanceToPlain)(value);
        }
        return value;
      });
    }
    exports.VerifiableCredentialTransformer = VerifiableCredentialTransformer;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/models/credential/W3cVerifyCredentialResult.js
var require_W3cVerifyCredentialResult = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/models/credential/W3cVerifyCredentialResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/vc/models/presentation/VerifyPresentationResult.js
var require_VerifyPresentationResult = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/models/presentation/VerifyPresentationResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/vc/models/presentation/W3cPresentation.js
var require_W3cPresentation = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/models/presentation/W3cPresentation.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsVerifiablePresentationType = exports.W3cPresentation = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var validators_1 = require_validators();
    var constants_1 = require_constants2();
    var validators_2 = require_validators2();
    var W3cVerifiableCredential_1 = require_W3cVerifiableCredential();
    var W3cPresentation = class {
      constructor(options) {
        if (options) {
          this.id = options.id;
          this.context = options.context;
          this.type = options.type;
          this.verifiableCredential = Array.isArray(options.verifiableCredential) ? options.verifiableCredential.map((vc) => new W3cVerifiableCredential_1.W3cVerifiableCredential(vc)) : new W3cVerifiableCredential_1.W3cVerifiableCredential(options.verifiableCredential);
          this.holder = options.holder;
        }
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "@context" }),
      (0, validators_2.IsJsonLdContext)(),
      __metadata("design:type", Object)
    ], W3cPresentation.prototype, "context", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, validators_1.IsUri)(),
      __metadata("design:type", String)
    ], W3cPresentation.prototype, "id", void 0);
    __decorate([
      IsVerifiablePresentationType(),
      __metadata("design:type", Array)
    ], W3cPresentation.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      (0, validators_1.IsUri)(),
      __metadata("design:type", String)
    ], W3cPresentation.prototype, "holder", void 0);
    __decorate([
      (0, W3cVerifiableCredential_1.VerifiableCredentialTransformer)(),
      (0, validators_1.IsInstanceOrArrayOfInstances)({ classType: W3cVerifiableCredential_1.W3cVerifiableCredential }),
      __metadata("design:type", Object)
    ], W3cPresentation.prototype, "verifiableCredential", void 0);
    exports.W3cPresentation = W3cPresentation;
    function IsVerifiablePresentationType(validationOptions) {
      return (0, class_validator_1.ValidateBy)({
        name: "IsVerifiablePresentationType",
        validator: {
          validate: (value) => {
            if (Array.isArray(value)) {
              return value.includes(constants_1.VERIFIABLE_PRESENTATION_TYPE);
            }
            return false;
          },
          defaultMessage: (0, class_validator_1.buildMessage)((eachPrefix) => eachPrefix + '$property must be an array of strings which includes "VerifiablePresentation"', validationOptions)
        }
      }, validationOptions);
    }
    exports.IsVerifiablePresentationType = IsVerifiablePresentationType;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/models/presentation/W3cVerifiablePresentation.js
var require_W3cVerifiablePresentation = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/models/presentation/W3cVerifiablePresentation.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3cVerifiablePresentation = void 0;
    var validators_1 = require_validators();
    var LinkedDataProof_1 = require_LinkedDataProof2();
    var W3cPresentation_1 = require_W3cPresentation();
    var W3cVerifiablePresentation = class extends W3cPresentation_1.W3cPresentation {
      constructor(options) {
        super(options);
        if (options) {
          this.proof = new LinkedDataProof_1.LinkedDataProof(options.proof);
        }
      }
    };
    __decorate([
      (0, LinkedDataProof_1.LinkedDataProofTransformer)(),
      (0, validators_1.IsInstanceOrArrayOfInstances)({ classType: LinkedDataProof_1.LinkedDataProof }),
      __metadata("design:type", Object)
    ], W3cVerifiablePresentation.prototype, "proof", void 0);
    exports.W3cVerifiablePresentation = W3cVerifiablePresentation;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/models/GetProofsOptions.js
var require_GetProofsOptions = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/models/GetProofsOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/vc/models/GetProofsResult.js
var require_GetProofsResult = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/models/GetProofsResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/vc/models/GetTypeOptions.js
var require_GetTypeOptions = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/models/GetTypeOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/vc/models/index.js
var require_models8 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/models/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_W3cCredential(), exports);
    __exportStar(require_W3cVerifiableCredential(), exports);
    __exportStar(require_W3cVerifyCredentialResult(), exports);
    __exportStar(require_VerifyPresentationResult(), exports);
    __exportStar(require_W3cPresentation(), exports);
    __exportStar(require_W3cVerifiablePresentation(), exports);
    __exportStar(require_GetProofsOptions(), exports);
    __exportStar(require_GetProofsResult(), exports);
    __exportStar(require_GetTypeOptions(), exports);
    __exportStar(require_LdKeyPair(), exports);
    __exportStar(require_LinkedDataProof2(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/vc/deriveProof.js
var require_deriveProof = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/deriveProof.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deriveProof = void 0;
    var utils_1 = require_utils();
    var constants_1 = require_constants2();
    var jsonldUtil_1 = require_jsonldUtil();
    var jsonld_1 = __importDefault(require_jsonld2());
    var models_1 = require_models8();
    var deriveProof = async (proofDocument, revealDocument, { suite, skipProofCompaction, documentLoader, expansionMap, nonce }) => {
      var _a;
      if (!suite) {
        throw new TypeError('"options.suite" is required.');
      }
      if (Array.isArray(proofDocument)) {
        throw new TypeError("proofDocument should be an object not an array.");
      }
      const { proofs, document } = await (0, jsonldUtil_1.getProofs)({
        document: proofDocument,
        proofType: suite.supportedDeriveProofType,
        documentLoader,
        expansionMap
      });
      if (proofs.length === 0) {
        throw new Error(`There were not any proofs provided that can be used to derive a proof with this suite.`);
      }
      let derivedProof = await suite.deriveProof({
        document,
        proof: proofs[0],
        revealDocument,
        documentLoader,
        expansionMap,
        nonce
      });
      if (proofs.length > 1) {
        derivedProof = Object.assign(Object.assign({}, derivedProof), { proof: [derivedProof.proof] });
        proofs.splice(0, 1);
        for (const proof of proofs) {
          const additionalDerivedProofValue = await suite.deriveProof({
            document,
            proof,
            revealDocument,
            documentLoader,
            expansionMap
          });
          derivedProof.proof.push(additionalDerivedProofValue.proof);
        }
      }
      if (!skipProofCompaction) {
        let expandedProof = {
          [constants_1.SECURITY_PROOF_URL]: {
            "@graph": derivedProof.proof
          }
        };
        const { types, alias } = await (0, jsonldUtil_1.getTypeInfo)(derivedProof.document, {
          documentLoader,
          expansionMap
        });
        expandedProof["@type"] = types;
        const ctx = jsonld_1.default.getValues(derivedProof.document, "@context");
        const compactProof = await jsonld_1.default.compact(expandedProof, ctx, {
          documentLoader,
          expansionMap,
          compactToRelative: false
        });
        delete compactProof[alias];
        delete compactProof["@context"];
        if ((_a = compactProof.proof) === null || _a === void 0 ? void 0 : _a["@included"]) {
          compactProof.proof = compactProof.proof["@included"];
        }
        const key = Object.keys(compactProof)[0];
        jsonld_1.default.addValue(derivedProof.document, key, compactProof[key]);
      } else {
        delete derivedProof.proof["@context"];
        jsonld_1.default.addValue(derivedProof.document, "proof", derivedProof.proof);
      }
      return utils_1.JsonTransformer.fromJSON(derivedProof.document, models_1.W3cVerifiableCredential);
    };
    exports.deriveProof = deriveProof;
  }
});

// node_modules/@digitalcredentials/vc/lib/CredentialIssuancePurpose.js
var require_CredentialIssuancePurpose = __commonJS({
  "node_modules/@digitalcredentials/vc/lib/CredentialIssuancePurpose.js"(exports, module) {
    "use strict";
    var jsonld2 = require_jsonld();
    var { AssertionProofPurpose } = require_jsonld_signatures().purposes;
    var CredentialIssuancePurpose = class extends AssertionProofPurpose {
      /**
       * @param {object} options - The options to use.
       * @param {object} [options.controller] - The description of the controller,
       *   if it is not to be dereferenced via a `documentLoader`.
       * @param {string|Date|number} [options.date] - The expected date for
       *   the creation of the proof.
       * @param {number} [options.maxTimestampDelta=Infinity] - A maximum number
       *   of seconds that the date on the signature can deviate from.
       */
      constructor({ controller, date, maxTimestampDelta } = {}) {
        super({ controller, date, maxTimestampDelta });
      }
      /**
       * Validates the purpose of a proof. This method is called during
       * proof verification, after the proof value has been checked against the
       * given verification method (in the case of a digital signature, the
       * signature has been cryptographically verified against the public key).
       *
       * @param {object} proof - The proof to validate.
       * @param {object} options - The options to use.
       * @param {object} options.document - The document whose signature is
       *   being verified.
       * @param {object} options.suite - Signature suite used in
       *   the proof.
       * @param {string} options.verificationMethod - Key id URL to the paired
       *   public key.
       * @param {object} [options.documentLoader] - A document loader.
       * @param {object} [options.expansionMap] - An expansion map.
       *
       * @throws {Error} If verification method not authorized by controller.
       * @throws {Error} If proof's created timestamp is out of range.
       *
       * @returns {Promise<{valid: boolean, error: Error}>} Resolves on completion.
       */
      async validate(proof, {
        document,
        suite,
        verificationMethod,
        documentLoader,
        expansionMap
      }) {
        try {
          const result2 = await super.validate(proof, {
            document,
            suite,
            verificationMethod,
            documentLoader,
            expansionMap
          });
          if (!result2.valid) {
            throw result2.error;
          }
          const issuer = jsonld2.getValues(document, "issuer");
          if (!issuer || issuer.length === 0) {
            throw new Error("Credential issuer is required.");
          }
          const issuerId = typeof issuer[0] === "string" ? issuer[0] : issuer[0].id;
          if (result2.controller.id !== issuerId) {
            throw new Error(
              "Credential issuer must match the verification method controller."
            );
          }
          return { valid: true };
        } catch (error) {
          return { valid: false, error };
        }
      }
    };
    module.exports = CredentialIssuancePurpose;
  }
});

// node_modules/credentials-context/dist/context.esm.js
var context_esm_exports = {};
__export(context_esm_exports, {
  CONTEXT: () => context_3,
  CONTEXT_URL: () => context_4,
  CONTEXT_URL_V1: () => context_5,
  CREDENTIALS_CONTEXT_V1_URL: () => context_6,
  constants: () => context_2,
  contexts: () => context_1,
  default: () => context$1
});
function unwrapExports(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}
var context, context$1, context_1, context_2, context_3, context_4, context_5, context_6;
var init_context_esm = __esm({
  "node_modules/credentials-context/dist/context.esm.js"() {
    context = createCommonjsModule(function(module, exports) {
      (() => {
        var e = { 717: (e2) => {
          e2.exports = { CONTEXT_FILENAME: "credentials-v1.jsonld", CONTEXT_URL: "https://www.w3.org/2018/credentials/v1", CREDENTIALS_CONTEXT_V1_URL: "https://www.w3.org/2018/credentials/v1" };
        }, 869: (e2) => {
          e2.exports = { "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", VerifiableCredential: { "@id": "https://www.w3.org/2018/credentials#VerifiableCredential", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", cred: "https://www.w3.org/2018/credentials#", sec: "https://w3id.org/security#", xsd: "http://www.w3.org/2001/XMLSchema#", credentialSchema: { "@id": "cred:credentialSchema", "@type": "@id", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", cred: "https://www.w3.org/2018/credentials#", JsonSchemaValidator2018: "cred:JsonSchemaValidator2018" } }, credentialStatus: { "@id": "cred:credentialStatus", "@type": "@id" }, credentialSubject: { "@id": "cred:credentialSubject", "@type": "@id" }, evidence: { "@id": "cred:evidence", "@type": "@id" }, expirationDate: { "@id": "cred:expirationDate", "@type": "xsd:dateTime" }, holder: { "@id": "cred:holder", "@type": "@id" }, issued: { "@id": "cred:issued", "@type": "xsd:dateTime" }, issuer: { "@id": "cred:issuer", "@type": "@id" }, issuanceDate: { "@id": "cred:issuanceDate", "@type": "xsd:dateTime" }, proof: { "@id": "sec:proof", "@type": "@id", "@container": "@graph" }, refreshService: { "@id": "cred:refreshService", "@type": "@id", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", cred: "https://www.w3.org/2018/credentials#", ManualRefreshService2018: "cred:ManualRefreshService2018" } }, termsOfUse: { "@id": "cred:termsOfUse", "@type": "@id" }, validFrom: { "@id": "cred:validFrom", "@type": "xsd:dateTime" }, validUntil: { "@id": "cred:validUntil", "@type": "xsd:dateTime" } } }, VerifiablePresentation: { "@id": "https://www.w3.org/2018/credentials#VerifiablePresentation", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", cred: "https://www.w3.org/2018/credentials#", sec: "https://w3id.org/security#", holder: { "@id": "cred:holder", "@type": "@id" }, proof: { "@id": "sec:proof", "@type": "@id", "@container": "@graph" }, verifiableCredential: { "@id": "cred:verifiableCredential", "@type": "@id", "@container": "@graph" } } }, EcdsaSecp256k1Signature2019: { "@id": "https://w3id.org/security#EcdsaSecp256k1Signature2019", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", sec: "https://w3id.org/security#", xsd: "http://www.w3.org/2001/XMLSchema#", challenge: "sec:challenge", created: { "@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime" }, domain: "sec:domain", expires: { "@id": "sec:expiration", "@type": "xsd:dateTime" }, jws: "sec:jws", nonce: "sec:nonce", proofPurpose: { "@id": "sec:proofPurpose", "@type": "@vocab", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", sec: "https://w3id.org/security#", assertionMethod: { "@id": "sec:assertionMethod", "@type": "@id", "@container": "@set" }, authentication: { "@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set" } } }, proofValue: "sec:proofValue", verificationMethod: { "@id": "sec:verificationMethod", "@type": "@id" } } }, EcdsaSecp256r1Signature2019: { "@id": "https://w3id.org/security#EcdsaSecp256r1Signature2019", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", sec: "https://w3id.org/security#", xsd: "http://www.w3.org/2001/XMLSchema#", challenge: "sec:challenge", created: { "@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime" }, domain: "sec:domain", expires: { "@id": "sec:expiration", "@type": "xsd:dateTime" }, jws: "sec:jws", nonce: "sec:nonce", proofPurpose: { "@id": "sec:proofPurpose", "@type": "@vocab", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", sec: "https://w3id.org/security#", assertionMethod: { "@id": "sec:assertionMethod", "@type": "@id", "@container": "@set" }, authentication: { "@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set" } } }, proofValue: "sec:proofValue", verificationMethod: { "@id": "sec:verificationMethod", "@type": "@id" } } }, Ed25519Signature2018: { "@id": "https://w3id.org/security#Ed25519Signature2018", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", sec: "https://w3id.org/security#", xsd: "http://www.w3.org/2001/XMLSchema#", challenge: "sec:challenge", created: { "@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime" }, domain: "sec:domain", expires: { "@id": "sec:expiration", "@type": "xsd:dateTime" }, jws: "sec:jws", nonce: "sec:nonce", proofPurpose: { "@id": "sec:proofPurpose", "@type": "@vocab", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", sec: "https://w3id.org/security#", assertionMethod: { "@id": "sec:assertionMethod", "@type": "@id", "@container": "@set" }, authentication: { "@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set" } } }, proofValue: "sec:proofValue", verificationMethod: { "@id": "sec:verificationMethod", "@type": "@id" } } }, RsaSignature2018: { "@id": "https://w3id.org/security#RsaSignature2018", "@context": { "@version": 1.1, "@protected": true, challenge: "sec:challenge", created: { "@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime" }, domain: "sec:domain", expires: { "@id": "sec:expiration", "@type": "xsd:dateTime" }, jws: "sec:jws", nonce: "sec:nonce", proofPurpose: { "@id": "sec:proofPurpose", "@type": "@vocab", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", sec: "https://w3id.org/security#", assertionMethod: { "@id": "sec:assertionMethod", "@type": "@id", "@container": "@set" }, authentication: { "@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set" } } }, proofValue: "sec:proofValue", verificationMethod: { "@id": "sec:verificationMethod", "@type": "@id" } } }, proof: { "@id": "https://w3id.org/security#proof", "@type": "@id", "@container": "@graph" } } };
        }, 858: (e2, t2, i2) => {
          const { CONTEXT_URL: d2 } = i2(717), r2 = i2(869);
          e2.exports = { documentLoader(e3) {
            if (e3 !== d2)
              throw new Error(`Loading document "${e3}" is not allowed.`);
            return { contextUrl: null, document: r2, documentUrl: e3 };
          } };
        }, 243: (e2, t2, i2) => {
          const d2 = i2(869), r2 = i2(717), { documentLoader: o } = i2(858), { CONTEXT_URL: c } = r2, s = /* @__PURE__ */ new Map();
          s.set(r2.CONTEXT_URL, d2), e2.exports = { constants: r2, contexts: s, documentLoader: o, CONTEXT_URL: c, CREDENTIALS_CONTEXT_V1_URL: c, CONTEXT_URL_V1: c, CONTEXT: d2 };
        } }, t = {}, i = function i2(d2) {
          var r2 = t[d2];
          if (void 0 !== r2)
            return r2.exports;
          var o = t[d2] = { exports: {} };
          return e[d2](o, o.exports, i2), o.exports;
        }(243), d = exports;
        for (var r in i)
          d[r] = i[r];
        i.__esModule && Object.defineProperty(d, "__esModule", { value: true });
      })();
    });
    context$1 = unwrapExports(context);
    context_1 = context.contexts;
    context_2 = context.constants;
    context_3 = context.CONTEXT;
    context_4 = context.CONTEXT_URL;
    context_5 = context.CONTEXT_URL_V1;
    context_6 = context.CREDENTIALS_CONTEXT_V1_URL;
  }
});

// node_modules/@digitalcredentials/vc/lib/contexts/vc-examples-v1.js
var require_vc_examples_v1 = __commonJS({
  "node_modules/@digitalcredentials/vc/lib/contexts/vc-examples-v1.js"(exports, module) {
    module.exports = {
      "@context": [
        {
          "@version": 1.1
        },
        "https://www.w3.org/ns/odrl.jsonld",
        {
          "ex": "https://example.org/examples#",
          "schema": "http://schema.org/",
          "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
          "3rdPartyCorrelation": "ex:3rdPartyCorrelation",
          "AllVerifiers": "ex:AllVerifiers",
          "Archival": "ex:Archival",
          "BachelorDegree": "ex:BachelorDegree",
          "Child": "ex:Child",
          "CLCredentialDefinition2019": "ex:CLCredentialDefinition2019",
          "CLSignature2019": "ex:CLSignature2019",
          "IssuerPolicy": "ex:IssuerPolicy",
          "HolderPolicy": "ex:HolderPolicy",
          "Mother": "ex:Mother",
          "RelationshipCredential": "ex:RelationshipCredential",
          "UniversityDegreeCredential": "ex:UniversityDegreeCredential",
          "ZkpExampleSchema2018": "ex:ZkpExampleSchema2018",
          "alumniOf": { "@id": "schema:alumniOf", "@type": "rdf:HTML" },
          "child": { "@id": "ex:child", "@type": "@id" },
          "degree": "ex:degree",
          "name": { "@id": "schema:name", "@type": "rdf:HTML" },
          "parent": { "@id": "ex:parent", "@type": "@id" },
          "referenceId": "ex:referenceId",
          "documentPresence": "ex:documentPresence",
          "evidenceDocument": "ex:evidenceDocument",
          "subjectPresence": "ex:subjectPresence",
          "verifier": { "@id": "ex:verifier", "@type": "@id" }
        }
      ]
    };
  }
});

// node_modules/@digitalcredentials/vc/lib/contexts/odrl.js
var require_odrl = __commonJS({
  "node_modules/@digitalcredentials/vc/lib/contexts/odrl.js"(exports, module) {
    "use strict";
    module.exports = {
      "@context": {
        "odrl": "http://www.w3.org/ns/odrl/2/",
        "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
        "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
        "owl": "http://www.w3.org/2002/07/owl#",
        "skos": "http://www.w3.org/2004/02/skos/core#",
        "dct": "http://purl.org/dc/terms/",
        "xsd": "http://www.w3.org/2001/XMLSchema#",
        "vcard": "http://www.w3.org/2006/vcard/ns#",
        "foaf": "http://xmlns.com/foaf/0.1/",
        "schema": "http://schema.org/",
        "cc": "http://creativecommons.org/ns#",
        "uid": "@id",
        "type": "@type",
        "Policy": "odrl:Policy",
        "Rule": "odrl:Rule",
        "profile": { "@type": "@id", "@id": "odrl:profile" },
        "inheritFrom": { "@type": "@id", "@id": "odrl:inheritFrom" },
        "ConflictTerm": "odrl:ConflictTerm",
        "conflict": { "@type": "@vocab", "@id": "odrl:conflict" },
        "perm": "odrl:perm",
        "prohibit": "odrl:prohibit",
        "invalid": "odrl:invalid",
        "Agreement": "odrl:Agreement",
        "Assertion": "odrl:Assertion",
        "Offer": "odrl:Offer",
        "Privacy": "odrl:Privacy",
        "Request": "odrl:Request",
        "Set": "odrl:Set",
        "Ticket": "odrl:Ticket",
        "Asset": "odrl:Asset",
        "AssetCollection": "odrl:AssetCollection",
        "relation": { "@type": "@id", "@id": "odrl:relation" },
        "hasPolicy": { "@type": "@id", "@id": "odrl:hasPolicy" },
        "target": { "@type": "@id", "@id": "odrl:target" },
        "output": { "@type": "@id", "@id": "odrl:output" },
        "partOf": { "@type": "@id", "@id": "odrl:partOf" },
        "source": { "@type": "@id", "@id": "odrl:source" },
        "Party": "odrl:Party",
        "PartyCollection": "odrl:PartyCollection",
        "function": { "@type": "@vocab", "@id": "odrl:function" },
        "PartyScope": "odrl:PartyScope",
        "assignee": { "@type": "@id", "@id": "odrl:assignee" },
        "assigner": { "@type": "@id", "@id": "odrl:assigner" },
        "assigneeOf": { "@type": "@id", "@id": "odrl:assigneeOf" },
        "assignerOf": { "@type": "@id", "@id": "odrl:assignerOf" },
        "attributedParty": { "@type": "@id", "@id": "odrl:attributedParty" },
        "attributingParty": { "@type": "@id", "@id": "odrl:attributingParty" },
        "compensatedParty": { "@type": "@id", "@id": "odrl:compensatedParty" },
        "compensatingParty": { "@type": "@id", "@id": "odrl:compensatingParty" },
        "consentingParty": { "@type": "@id", "@id": "odrl:consentingParty" },
        "consentedParty": { "@type": "@id", "@id": "odrl:consentedParty" },
        "informedParty": { "@type": "@id", "@id": "odrl:informedParty" },
        "informingParty": { "@type": "@id", "@id": "odrl:informingParty" },
        "trackingParty": { "@type": "@id", "@id": "odrl:trackingParty" },
        "trackedParty": { "@type": "@id", "@id": "odrl:trackedParty" },
        "contractingParty": { "@type": "@id", "@id": "odrl:contractingParty" },
        "contractedParty": { "@type": "@id", "@id": "odrl:contractedParty" },
        "Action": "odrl:Action",
        "action": { "@type": "@vocab", "@id": "odrl:action" },
        "includedIn": { "@type": "@id", "@id": "odrl:includedIn" },
        "implies": { "@type": "@id", "@id": "odrl:implies" },
        "Permission": "odrl:Permission",
        "permission": { "@type": "@id", "@id": "odrl:permission" },
        "Prohibition": "odrl:Prohibition",
        "prohibition": { "@type": "@id", "@id": "odrl:prohibition" },
        "obligation": { "@type": "@id", "@id": "odrl:obligation" },
        "use": "odrl:use",
        "grantUse": "odrl:grantUse",
        "aggregate": "odrl:aggregate",
        "annotate": "odrl:annotate",
        "anonymize": "odrl:anonymize",
        "archive": "odrl:archive",
        "concurrentUse": "odrl:concurrentUse",
        "derive": "odrl:derive",
        "digitize": "odrl:digitize",
        "display": "odrl:display",
        "distribute": "odrl:distribute",
        "execute": "odrl:execute",
        "extract": "odrl:extract",
        "give": "odrl:give",
        "index": "odrl:index",
        "install": "odrl:install",
        "modify": "odrl:modify",
        "move": "odrl:move",
        "play": "odrl:play",
        "present": "odrl:present",
        "print": "odrl:print",
        "read": "odrl:read",
        "reproduce": "odrl:reproduce",
        "sell": "odrl:sell",
        "stream": "odrl:stream",
        "textToSpeech": "odrl:textToSpeech",
        "transfer": "odrl:transfer",
        "transform": "odrl:transform",
        "translate": "odrl:translate",
        "Duty": "odrl:Duty",
        "duty": { "@type": "@id", "@id": "odrl:duty" },
        "consequence": { "@type": "@id", "@id": "odrl:consequence" },
        "remedy": { "@type": "@id", "@id": "odrl:remedy" },
        "acceptTracking": "odrl:acceptTracking",
        "attribute": "odrl:attribute",
        "compensate": "odrl:compensate",
        "delete": "odrl:delete",
        "ensureExclusivity": "odrl:ensureExclusivity",
        "include": "odrl:include",
        "inform": "odrl:inform",
        "nextPolicy": "odrl:nextPolicy",
        "obtainConsent": "odrl:obtainConsent",
        "reviewPolicy": "odrl:reviewPolicy",
        "uninstall": "odrl:uninstall",
        "watermark": "odrl:watermark",
        "Constraint": "odrl:Constraint",
        "LogicalConstraint": "odrl:LogicalConstraint",
        "constraint": { "@type": "@id", "@id": "odrl:constraint" },
        "refinement": { "@type": "@id", "@id": "odrl:refinement" },
        "Operator": "odrl:Operator",
        "operator": { "@type": "@vocab", "@id": "odrl:operator" },
        "RightOperand": "odrl:RightOperand",
        "rightOperand": "odrl:rightOperand",
        "rightOperandReference": { "@type": "xsd:anyURI", "@id": "odrl:rightOperandReference" },
        "LeftOperand": "odrl:LeftOperand",
        "leftOperand": { "@type": "@vocab", "@id": "odrl:leftOperand" },
        "unit": "odrl:unit",
        "dataType": { "@type": "xsd:anyType", "@id": "odrl:datatype" },
        "status": "odrl:status",
        "absolutePosition": "odrl:absolutePosition",
        "absoluteSpatialPosition": "odrl:absoluteSpatialPosition",
        "absoluteTemporalPosition": "odrl:absoluteTemporalPosition",
        "absoluteSize": "odrl:absoluteSize",
        "count": "odrl:count",
        "dateTime": "odrl:dateTime",
        "delayPeriod": "odrl:delayPeriod",
        "deliveryChannel": "odrl:deliveryChannel",
        "elapsedTime": "odrl:elapsedTime",
        "event": "odrl:event",
        "fileFormat": "odrl:fileFormat",
        "industry": "odrl:industry:",
        "language": "odrl:language",
        "media": "odrl:media",
        "meteredTime": "odrl:meteredTime",
        "payAmount": "odrl:payAmount",
        "percentage": "odrl:percentage",
        "product": "odrl:product",
        "purpose": "odrl:purpose",
        "recipient": "odrl:recipient",
        "relativePosition": "odrl:relativePosition",
        "relativeSpatialPosition": "odrl:relativeSpatialPosition",
        "relativeTemporalPosition": "odrl:relativeTemporalPosition",
        "relativeSize": "odrl:relativeSize",
        "resolution": "odrl:resolution",
        "spatial": "odrl:spatial",
        "spatialCoordinates": "odrl:spatialCoordinates",
        "systemDevice": "odrl:systemDevice",
        "timeInterval": "odrl:timeInterval",
        "unitOfCount": "odrl:unitOfCount",
        "version": "odrl:version",
        "virtualLocation": "odrl:virtualLocation",
        "eq": "odrl:eq",
        "gt": "odrl:gt",
        "gteq": "odrl:gteq",
        "lt": "odrl:lt",
        "lteq": "odrl:lteq",
        "neq": "odrl:neg",
        "isA": "odrl:isA",
        "hasPart": "odrl:hasPart",
        "isPartOf": "odrl:isPartOf",
        "isAllOf": "odrl:isAllOf",
        "isAnyOf": "odrl:isAnyOf",
        "isNoneOf": "odrl:isNoneOf",
        "or": "odrl:or",
        "xone": "odrl:xone",
        "and": "odrl:and",
        "andSequence": "odrl:andSequence",
        "policyUsage": "odrl:policyUsage"
      }
    };
  }
});

// node_modules/@digitalcredentials/vc/lib/contexts/index.js
var require_contexts2 = __commonJS({
  "node_modules/@digitalcredentials/vc/lib/contexts/index.js"(exports, module) {
    "use strict";
    var { contexts, constants: contextConstants } = (init_context_esm(), __toCommonJS(context_esm_exports));
    var exportedContexts = module.exports = {
      "https://www.w3.org/2018/credentials/examples/v1": require_vc_examples_v1(),
      "https://www.w3.org/ns/odrl.jsonld": require_odrl()
    };
    for (const c in contextConstants) {
      const contextUrl = contextConstants[c];
      if (c.includes("URL")) {
        exportedContexts[contextUrl] = contexts.get(contextUrl);
      }
    }
  }
});

// node_modules/@digitalcredentials/vc/lib/documentLoader.js
var require_documentLoader3 = __commonJS({
  "node_modules/@digitalcredentials/vc/lib/documentLoader.js"(exports, module) {
    "use strict";
    var contexts = require_contexts2();
    module.exports = async function documentLoader(url) {
      const context2 = contexts[url];
      if (context2 !== void 0) {
        return {
          contextUrl: null,
          documentUrl: url,
          document: context2
        };
      }
      throw new Error(`Document loader unable to load URL "${url}".`);
    };
  }
});

// node_modules/@digitalcredentials/vc/lib/vc.js
var require_vc = __commonJS({
  "node_modules/@digitalcredentials/vc/lib/vc.js"(exports, module) {
    "use strict";
    var jsonld2 = require_jsonld();
    var jsigs = require_jsonld_signatures();
    var { AuthenticationProofPurpose } = jsigs.purposes;
    var CredentialIssuancePurpose = require_CredentialIssuancePurpose();
    var defaultDocumentLoader = jsigs.extendContextLoader(
      require_documentLoader3()
    );
    var { constants: { CREDENTIALS_CONTEXT_V1_URL } } = (init_context_esm(), __toCommonJS(context_esm_exports));
    var dateRegex = new RegExp("^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$", "i");
    module.exports = {
      issue,
      createPresentation,
      signPresentation,
      verify,
      verifyCredential,
      CredentialIssuancePurpose,
      defaultDocumentLoader,
      // export for testing:
      _checkCredential,
      _checkPresentation,
      dateRegex
    };
    async function issue({
      credential,
      suite,
      expansionMap,
      purpose = new CredentialIssuancePurpose(),
      documentLoader = defaultDocumentLoader
    } = {}) {
      if (!suite) {
        throw new TypeError('"suite" parameter is required for issuing.');
      }
      if (!suite.verificationMethod) {
        throw new TypeError('"suite.verificationMethod" property is required.');
      }
      if (!credential) {
        throw new TypeError('"credential" parameter is required for issuing.');
      }
      if (!credential.issuanceDate) {
        const now = (/* @__PURE__ */ new Date()).toJSON();
        credential.issuanceDate = `${now.substr(0, now.length - 5)}Z`;
      }
      _checkCredential(credential);
      return jsigs.sign(credential, { purpose, documentLoader, suite, expansionMap });
    }
    async function verify(options = {}) {
      const { presentation } = options;
      try {
        if (!presentation) {
          throw new TypeError(
            'A "presentation" property is required for verifying.'
          );
        }
        return _verifyPresentation(options);
      } catch (error) {
        return {
          verified: false,
          results: [{ presentation, verified: false, error }],
          error
        };
      }
    }
    async function verifyCredential(options = {}) {
      const { credential } = options;
      try {
        if (!credential) {
          throw new TypeError(
            'A "credential" property is required for verifying.'
          );
        }
        return _verifyCredential(options);
      } catch (error) {
        return {
          verified: false,
          results: [{ credential, verified: false, error }],
          error
        };
      }
    }
    async function _verifyCredential(options = {}) {
      const { credential, checkStatus } = options;
      _checkCredential(credential);
      if (credential.credentialStatus && typeof options.checkStatus !== "function") {
        throw new TypeError(
          'A "checkStatus" function must be given to verify credentials with "credentialStatus".'
        );
      }
      const documentLoader = options.documentLoader || defaultDocumentLoader;
      const { controller } = options;
      const purpose = options.purpose || new CredentialIssuancePurpose({
        controller
      });
      const result2 = await jsigs.verify(
        credential,
        { purpose, documentLoader, ...options }
      );
      if (!result2.verified) {
        return result2;
      }
      if (credential.credentialStatus) {
        result2.statusResult = await checkStatus(options);
        if (!result2.statusResult.verified) {
          result2.verified = false;
        }
      }
      return result2;
    }
    function createPresentation({ verifiableCredential, id, holder } = {}) {
      const presentation = {
        "@context": [CREDENTIALS_CONTEXT_V1_URL],
        type: ["VerifiablePresentation"]
      };
      if (verifiableCredential) {
        const credentials = [].concat(verifiableCredential);
        for (const credential of credentials) {
          _checkCredential(credential);
        }
        presentation.verifiableCredential = credentials;
      }
      if (id) {
        presentation.id = id;
      }
      if (holder) {
        presentation.holder = holder;
      }
      _checkPresentation(presentation);
      return presentation;
    }
    async function signPresentation(options = {}) {
      const { presentation, domain, challenge } = options;
      const purpose = options.purpose || new AuthenticationProofPurpose({
        domain,
        challenge
      });
      const documentLoader = options.documentLoader || defaultDocumentLoader;
      return jsigs.sign(presentation, { purpose, documentLoader, ...options });
    }
    async function _verifyPresentation(options = {}) {
      const { presentation, unsignedPresentation } = options;
      _checkPresentation(presentation);
      const documentLoader = options.documentLoader || defaultDocumentLoader;
      let credentialResults;
      let verified = true;
      const credentials = jsonld2.getValues(presentation, "verifiableCredential");
      if (credentials.length > 0) {
        credentialResults = await Promise.all(credentials.map((credential) => {
          return verifyCredential({ credential, documentLoader, ...options });
        }));
        for (const [i, credentialResult] of credentialResults.entries()) {
          credentialResult.credentialId = credentials[i].id;
        }
        const allCredentialsVerified = credentialResults.every((r) => r.verified);
        if (!allCredentialsVerified) {
          verified = false;
        }
      }
      if (unsignedPresentation) {
        return { verified, results: [presentation], credentialResults };
      }
      const { controller, domain, challenge } = options;
      if (!options.presentationPurpose && !challenge) {
        throw new Error(
          'A "challenge" param is required for AuthenticationProofPurpose.'
        );
      }
      const purpose = options.presentationPurpose || new AuthenticationProofPurpose({ controller, domain, challenge });
      const presentationResult = await jsigs.verify(
        presentation,
        { purpose, documentLoader, ...options }
      );
      return {
        presentationResult,
        verified: verified && presentationResult.verified,
        credentialResults,
        error: presentationResult.error
      };
    }
    function _getId(obj) {
      if (typeof obj === "string") {
        return obj;
      }
      if (!("id" in obj)) {
        return;
      }
      return obj.id;
    }
    function _checkPresentation(presentation) {
      const context2 = Array.isArray(presentation["@context"]) ? presentation["@context"] : [presentation["@context"]];
      if (context2[0] !== CREDENTIALS_CONTEXT_V1_URL) {
        throw new Error(
          `"${CREDENTIALS_CONTEXT_V1_URL}" needs to be first in the list of contexts.`
        );
      }
      const types = jsonld2.getValues(presentation, "type");
      if (!types.includes("VerifiablePresentation")) {
        throw new Error('"type" must include "VerifiablePresentation".');
      }
    }
    function _checkCredential(credential) {
      if (credential["@context"][0] !== CREDENTIALS_CONTEXT_V1_URL) {
        throw new Error(
          `"${CREDENTIALS_CONTEXT_V1_URL}" needs to be first in the list of contexts.`
        );
      }
      if (!credential.type) {
        throw new Error('"type" property is required.');
      }
      if (!jsonld2.getValues(credential, "type").includes("VerifiableCredential")) {
        throw new Error('"type" must include `VerifiableCredential`.');
      }
      if (!credential.credentialSubject) {
        throw new Error('"credentialSubject" property is required.');
      }
      if (credential.credentialSubject.id) {
        _validateUriId({
          id: credential.credentialSubject.id,
          propertyName: "credentialSubject.id"
        });
      }
      if (!credential.issuer) {
        throw new Error('"issuer" property is required.');
      }
      if (jsonld2.getValues(credential, "issuanceDate").length > 1) {
        throw new Error('"issuanceDate" property can only have one value.');
      }
      if (!credential.issuanceDate) {
        throw new Error('"issuanceDate" property is required.');
      }
      if ("issuanceDate" in credential) {
        if (!dateRegex.test(credential.issuanceDate)) {
          throw new Error(
            `"issuanceDate" must be a valid date: ${credential.issuanceDate}`
          );
        }
      }
      if (jsonld2.getValues(credential, "issuer").length > 1) {
        throw new Error('"issuer" property can only have one value.');
      }
      if ("issuer" in credential) {
        const issuer = _getId(credential.issuer);
        if (!issuer) {
          throw new Error(`"issuer" id is required.`);
        }
        _validateUriId({ id: issuer, propertyName: "issuer" });
      }
      if ("credentialStatus" in credential) {
        if (!credential.credentialStatus.id) {
          throw new Error('"credentialStatus" must include an id.');
        }
        if (!credential.credentialStatus.type) {
          throw new Error('"credentialStatus" must include a type.');
        }
      }
      jsonld2.getValues(credential, "evidence").forEach((evidence) => {
        const evidenceId = _getId(evidence);
        if (evidenceId) {
          _validateUriId({ id: evidenceId, propertyName: "evidence" });
        }
      });
      if ("expirationDate" in credential && !dateRegex.test(credential.expirationDate)) {
        throw new Error(
          `"expirationDate" must be a valid date: ${credential.expirationDate}`
        );
      }
    }
    function _validateUriId({ id, propertyName }) {
      try {
        new URL(id);
      } catch (e) {
        const error = new TypeError(`"${propertyName}" must be a URI: "${id}".`);
        error.cause = e;
        throw error;
      }
    }
  }
});

// node_modules/@digitalcredentials/vc/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@digitalcredentials/vc/lib/index.js"(exports, module) {
    module.exports = require_vc();
  }
});

// node_modules/@aries-framework/core/build/modules/vc/libraries/vc.js
var require_vc2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/libraries/vc.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var vc_1 = __importDefault(require_lib2());
    exports.default = vc_1.default;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/repository/W3cCredentialRecord.js
var require_W3cCredentialRecord = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/repository/W3cCredentialRecord.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3cCredentialRecord = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var BaseRecord_1 = require_BaseRecord();
    var uuid_1 = require_uuid();
    var W3cVerifiableCredential_1 = require_W3cVerifiableCredential();
    var W3cCredentialRecord = class extends BaseRecord_1.BaseRecord {
      constructor(props) {
        var _a, _b;
        super();
        this.type = W3cCredentialRecord.type;
        if (props) {
          this.id = (_a = props.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.createdAt = (_b = props.createdAt) !== null && _b !== void 0 ? _b : /* @__PURE__ */ new Date();
          this._tags = props.tags;
          this.credential = props.credential;
        }
      }
      getTags() {
        return Object.assign(Object.assign({}, this._tags), { issuerId: this.credential.issuerId, subjectIds: this.credential.credentialSubjectIds, schemaIds: this.credential.credentialSchemaIds, contexts: this.credential.contexts, proofTypes: this.credential.proofTypes, givenId: this.credential.id });
      }
    };
    W3cCredentialRecord.type = "W3cCredentialRecord";
    __decorate([
      (0, class_transformer_1.Type)(() => W3cVerifiableCredential_1.W3cVerifiableCredential),
      __metadata("design:type", W3cVerifiableCredential_1.W3cVerifiableCredential)
    ], W3cCredentialRecord.prototype, "credential", void 0);
    exports.W3cCredentialRecord = W3cCredentialRecord;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/repository/W3cCredentialRepository.js
var require_W3cCredentialRepository = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/repository/W3cCredentialRepository.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3cCredentialRepository = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var Repository_1 = require_Repository();
    var W3cCredentialRecord_1 = require_W3cCredentialRecord();
    var W3cCredentialRepository = class W3cCredentialRepository extends Repository_1.Repository {
      constructor(storageService, eventEmitter) {
        super(W3cCredentialRecord_1.W3cCredentialRecord, storageService, eventEmitter);
      }
    };
    W3cCredentialRepository = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.StorageService)),
      __metadata("design:paramtypes", [Object, EventEmitter_1.EventEmitter])
    ], W3cCredentialRepository);
    exports.W3cCredentialRepository = W3cCredentialRepository;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/repository/index.js
var require_repository7 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/repository/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_W3cCredentialRecord(), exports);
    __exportStar(require_W3cCredentialRepository(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/vc/W3cCredentialService.js
var require_W3cCredentialService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/W3cCredentialService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3cCredentialService = void 0;
    var WalletKeyPair_1 = require_WalletKeyPair();
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var utils_1 = require_utils();
    var dids_1 = require_dids();
    var key_type_1 = require_key_type();
    var SignatureSuiteRegistry_1 = require_SignatureSuiteRegistry();
    var W3cVcModuleConfig_1 = require_W3cVcModuleConfig();
    var deriveProof_1 = require_deriveProof();
    var jsonldUtil_1 = require_jsonldUtil();
    var jsonld_1 = __importDefault(require_jsonld2());
    var vc_1 = __importDefault(require_vc2());
    var models_1 = require_models8();
    var W3cPresentation_1 = require_W3cPresentation();
    var W3cVerifiablePresentation_1 = require_W3cVerifiablePresentation();
    var repository_1 = require_repository7();
    var W3cCredentialService = class W3cCredentialService {
      constructor(w3cCredentialRepository, signatureSuiteRegistry, w3cVcModuleConfig) {
        this.w3cCredentialRepository = w3cCredentialRepository;
        this.signatureSuiteRegistry = signatureSuiteRegistry;
        this.w3cVcModuleConfig = w3cVcModuleConfig;
      }
      /**
       * Signs a credential
       *
       * @param credential the credential to be signed
       * @returns the signed credential
       */
      async signCredential(agentContext, options) {
        var _a;
        const WalletKeyPair = (0, WalletKeyPair_1.createWalletKeyPairClass)(agentContext.wallet);
        const signingKey = await this.getPublicKeyFromVerificationMethod(agentContext, options.verificationMethod);
        const suiteInfo = this.signatureSuiteRegistry.getByProofType(options.proofType);
        if (!suiteInfo.keyTypes.includes(signingKey.keyType)) {
          throw new error_1.AriesFrameworkError("The key type of the verification method does not match the suite");
        }
        const keyPair = new WalletKeyPair({
          controller: options.credential.issuerId,
          id: options.verificationMethod,
          key: signingKey,
          wallet: agentContext.wallet
        });
        const SuiteClass = suiteInfo.suiteClass;
        const suite = new SuiteClass({
          key: keyPair,
          LDKeyClass: WalletKeyPair,
          proof: {
            verificationMethod: options.verificationMethod
          },
          useNativeCanonize: false,
          date: (_a = options.created) !== null && _a !== void 0 ? _a : (0, jsonldUtil_1.w3cDate)()
        });
        const result2 = await vc_1.default.issue({
          credential: utils_1.JsonTransformer.toJSON(options.credential),
          suite,
          purpose: options.proofPurpose,
          documentLoader: this.w3cVcModuleConfig.documentLoader(agentContext)
        });
        return utils_1.JsonTransformer.fromJSON(result2, models_1.W3cVerifiableCredential);
      }
      /**
       * Verifies the signature(s) of a credential
       *
       * @param credential the credential to be verified
       * @returns the verification result
       */
      async verifyCredential(agentContext, options) {
        const suites = this.getSignatureSuitesForCredential(agentContext, options.credential);
        const verifyOptions = {
          credential: utils_1.JsonTransformer.toJSON(options.credential),
          suite: suites,
          documentLoader: this.w3cVcModuleConfig.documentLoader(agentContext)
        };
        if (options.proofPurpose) {
          verifyOptions["purpose"] = options.proofPurpose;
        }
        const result2 = await vc_1.default.verifyCredential(verifyOptions);
        return result2;
      }
      /**
       * Utility method that creates a {@link W3cPresentation} from one or more {@link W3cVerifiableCredential}s.
       *
       * **NOTE: the presentation that is returned is unsigned.**
       *
       * @param credentials One or more instances of {@link W3cVerifiableCredential}
       * @param [id] an optional unique identifier for the presentation
       * @param [holderUrl] an optional identifier identifying the entity that is generating the presentation
       * @returns An instance of {@link W3cPresentation}
       */
      async createPresentation(options) {
        if (!Array.isArray(options.credentials)) {
          options.credentials = [options.credentials];
        }
        const presentationJson = vc_1.default.createPresentation({
          verifiableCredential: options.credentials.map((credential) => utils_1.JsonTransformer.toJSON(credential)),
          id: options.id,
          holder: options.holderUrl
        });
        return utils_1.JsonTransformer.fromJSON(presentationJson, W3cPresentation_1.W3cPresentation);
      }
      /**
       * Signs a presentation including the credentials it includes
       *
       * @param presentation the presentation to be signed
       * @returns the signed presentation
       */
      async signPresentation(agentContext, options) {
        const WalletKeyPair = (0, WalletKeyPair_1.createWalletKeyPairClass)(agentContext.wallet);
        const suiteInfo = this.signatureSuiteRegistry.getByProofType(options.signatureType);
        if (!suiteInfo) {
          throw new error_1.AriesFrameworkError(`The requested proofType ${options.signatureType} is not supported`);
        }
        const signingKey = await this.getPublicKeyFromVerificationMethod(agentContext, options.verificationMethod);
        if (!suiteInfo.keyTypes.includes(signingKey.keyType)) {
          throw new error_1.AriesFrameworkError("The key type of the verification method does not match the suite");
        }
        const documentLoader = this.w3cVcModuleConfig.documentLoader(agentContext);
        const verificationMethodObject = (await documentLoader(options.verificationMethod)).document;
        const keyPair = new WalletKeyPair({
          controller: verificationMethodObject["controller"],
          id: options.verificationMethod,
          key: signingKey,
          wallet: agentContext.wallet
        });
        const suite = new suiteInfo.suiteClass({
          LDKeyClass: WalletKeyPair,
          proof: {
            verificationMethod: options.verificationMethod
          },
          date: (/* @__PURE__ */ new Date()).toISOString(),
          key: keyPair,
          useNativeCanonize: false
        });
        const result2 = await vc_1.default.signPresentation({
          presentation: utils_1.JsonTransformer.toJSON(options.presentation),
          suite,
          challenge: options.challenge,
          documentLoader: this.w3cVcModuleConfig.documentLoader(agentContext)
        });
        return utils_1.JsonTransformer.fromJSON(result2, W3cVerifiablePresentation_1.W3cVerifiablePresentation);
      }
      /**
       * Verifies a presentation including the credentials it includes
       *
       * @param presentation the presentation to be verified
       * @returns the verification result
       */
      async verifyPresentation(agentContext, options) {
        const WalletKeyPair = (0, WalletKeyPair_1.createWalletKeyPairClass)(agentContext.wallet);
        let proofs = options.presentation.proof;
        if (!Array.isArray(proofs)) {
          proofs = [proofs];
        }
        if (options.purpose) {
          proofs = proofs.filter((proof) => proof.proofPurpose === options.purpose.term);
        }
        const presentationSuites = proofs.map((proof) => {
          const SuiteClass = this.signatureSuiteRegistry.getByProofType(proof.type).suiteClass;
          return new SuiteClass({
            LDKeyClass: WalletKeyPair,
            proof: {
              verificationMethod: proof.verificationMethod
            },
            date: proof.created,
            useNativeCanonize: false
          });
        });
        const credentials = Array.isArray(options.presentation.verifiableCredential) ? options.presentation.verifiableCredential : [options.presentation.verifiableCredential];
        const credentialSuites = credentials.map((credential) => this.getSignatureSuitesForCredential(agentContext, credential));
        const allSuites = presentationSuites.concat(...credentialSuites);
        const verifyOptions = {
          presentation: utils_1.JsonTransformer.toJSON(options.presentation),
          suite: allSuites,
          challenge: options.challenge,
          documentLoader: this.w3cVcModuleConfig.documentLoader(agentContext)
        };
        if (options.purpose) {
          verifyOptions["presentationPurpose"] = options.purpose;
        }
        const result2 = await vc_1.default.verify(verifyOptions);
        return result2;
      }
      async deriveProof(agentContext, options) {
        const suiteInfo = this.signatureSuiteRegistry.getByProofType("BbsBlsSignatureProof2020");
        const SuiteClass = suiteInfo.suiteClass;
        const suite = new SuiteClass();
        const proof = await (0, deriveProof_1.deriveProof)(utils_1.JsonTransformer.toJSON(options.credential), options.revealDocument, {
          suite,
          documentLoader: this.w3cVcModuleConfig.documentLoader(agentContext)
        });
        return proof;
      }
      async getPublicKeyFromVerificationMethod(agentContext, verificationMethod) {
        const documentLoader = this.w3cVcModuleConfig.documentLoader(agentContext);
        const verificationMethodObject = await documentLoader(verificationMethod);
        const verificationMethodClass = utils_1.JsonTransformer.fromJSON(verificationMethodObject.document, dids_1.VerificationMethod);
        const key = (0, key_type_1.getKeyDidMappingByVerificationMethod)(verificationMethodClass);
        return key.getKeyFromVerificationMethod(verificationMethodClass);
      }
      /**
       * Writes a credential to storage
       *
       * @param record the credential to be stored
       * @returns the credential record that was written to storage
       */
      async storeCredential(agentContext, options) {
        const expandedTypes = (await jsonld_1.default.expand(utils_1.JsonTransformer.toJSON(options.credential), {
          documentLoader: this.w3cVcModuleConfig.documentLoader(agentContext)
        }))[0]["@type"];
        const w3cCredentialRecord = new repository_1.W3cCredentialRecord({
          tags: { expandedTypes: (0, jsonldUtil_1.orArrayToArray)(expandedTypes) },
          credential: options.credential
        });
        await this.w3cCredentialRepository.save(agentContext, w3cCredentialRecord);
        return w3cCredentialRecord;
      }
      async removeCredentialRecord(agentContext, id) {
        const credential = await this.w3cCredentialRepository.getById(agentContext, id);
        await this.w3cCredentialRepository.delete(agentContext, credential);
      }
      async getAllCredentialRecords(agentContext) {
        return await this.w3cCredentialRepository.getAll(agentContext);
      }
      async getCredentialRecordById(agentContext, id) {
        return await this.w3cCredentialRepository.getById(agentContext, id);
      }
      async findCredentialRecordsByQuery(agentContext, query) {
        const result2 = await this.w3cCredentialRepository.findByQuery(agentContext, query);
        return result2.map((record) => record.credential);
      }
      getVerificationMethodTypesByProofType(proofType) {
        return this.signatureSuiteRegistry.getByProofType(proofType).verificationMethodTypes;
      }
      getKeyTypesByProofType(proofType) {
        return this.signatureSuiteRegistry.getByProofType(proofType).keyTypes;
      }
      async findCredentialRecordByQuery(agentContext, query) {
        const result2 = await this.w3cCredentialRepository.findSingleByQuery(agentContext, query);
        return result2 === null || result2 === void 0 ? void 0 : result2.credential;
      }
      getSignatureSuitesForCredential(agentContext, credential) {
        const WalletKeyPair = (0, WalletKeyPair_1.createWalletKeyPairClass)(agentContext.wallet);
        let proofs = credential.proof;
        if (!Array.isArray(proofs)) {
          proofs = [proofs];
        }
        return proofs.map((proof) => {
          var _a;
          const SuiteClass = (_a = this.signatureSuiteRegistry.getByProofType(proof.type)) === null || _a === void 0 ? void 0 : _a.suiteClass;
          if (SuiteClass) {
            return new SuiteClass({
              LDKeyClass: WalletKeyPair,
              proof: {
                verificationMethod: proof.verificationMethod
              },
              date: proof.created,
              useNativeCanonize: false
            });
          }
        });
      }
    };
    W3cCredentialService = __decorate([
      (0, plugins_1.injectable)(),
      __metadata("design:paramtypes", [
        repository_1.W3cCredentialRepository,
        SignatureSuiteRegistry_1.SignatureSuiteRegistry,
        W3cVcModuleConfig_1.W3cVcModuleConfig
      ])
    ], W3cCredentialService);
    exports.W3cCredentialService = W3cCredentialService;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/signature-suites/JwsLinkedDataSignature.js
var require_JwsLinkedDataSignature = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/signature-suites/JwsLinkedDataSignature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JwsLinkedDataSignature = void 0;
    var error_1 = require_error();
    var utils_1 = require_utils();
    var jsonld_signatures_1 = require_jsonld_signatures2();
    var LinkedDataSignature = jsonld_signatures_1.suites.LinkedDataSignature;
    var JwsLinkedDataSignature = class extends LinkedDataSignature {
      /**
       * @param options - Options hashmap.
       * @param options.type - Provided by subclass.
       * @param options.alg - JWS alg provided by subclass.
       * @param [options.LDKeyClass] - Provided by subclass or subclass
       *   overrides `getVerificationMethod`.
       *
       * Either a `key` OR at least one of `signer`/`verifier` is required.
       *
       * @param [options.key] - An optional key object (containing an
       *   `id` property, and either `signer` or `verifier`, depending on the
       *   intended operation. Useful for when the application is managing keys
       *   itself (when using a KMS, you never have access to the private key,
       *   and so should use the `signer` param instead).
       *
       * Advanced optional parameters and overrides.
       *
       * @param [options.proof] - A JSON-LD document with options to use
       *   for the `proof` node. Any other custom fields can be provided here
       *   using a context different from `security-v2`.
       * @param [options.date] - Signing date to use if not passed.
       * @param options.contextUrl - JSON-LD context url that corresponds
       *   to this signature suite. Used for enforcing suite context during the
       *   `sign()` operation.
       * @param [options.useNativeCanonize] - Whether to use a native
       *   canonize algorithm.
       */
      constructor(options) {
        super({
          type: options.type,
          LDKeyClass: options.LDKeyClass,
          contextUrl: options.contextUrl,
          key: options.key,
          signer: void 0,
          verifier: void 0,
          proof: options.proof,
          date: options.date,
          useNativeCanonize: options.useNativeCanonize
        });
        this.alg = options.algorithm;
      }
      /**
       * @param options - Options hashmap.
       * @param options.verifyData - The data to sign.
       * @param options.proof - A JSON-LD document with options to use
       *   for the `proof` node. Any other custom fields can be provided here
       *   using a context different from `security-v2`.
       *
       * @returns The proof containing the signature value.
       */
      async sign(options) {
        if (!(this.signer && typeof this.signer.sign === "function")) {
          throw new Error("A signer API has not been specified.");
        }
        const header = {
          alg: this.alg,
          b64: false,
          crit: ["b64"]
        };
        const encodedHeader = utils_1.JsonEncoder.toBase64URL(header);
        const data = _createJws({ encodedHeader, verifyData: options.verifyData });
        const signature = await this.signer.sign({ data });
        const encodedSignature = utils_1.TypedArrayEncoder.toBase64URL(signature);
        options.proof.jws = encodedHeader + ".." + encodedSignature;
        return options.proof;
      }
      /**
       * @param options - Options hashmap.
       * @param options.verifyData - The data to verify.
       * @param options.verificationMethod - A verification method.
       * @param options.proof - The proof to be verified.
       *
       * @returns Resolves with the verification result.
       */
      async verifySignature(options) {
        if (!(options.proof.jws && typeof options.proof.jws === "string" && options.proof.jws.includes("."))) {
          throw new TypeError('The proof does not include a valid "jws" property.');
        }
        const [encodedHeader, , encodedSignature] = options.proof.jws.split(".");
        let header;
        try {
          header = utils_1.JsonEncoder.fromBase64(encodedHeader);
        } catch (e) {
          throw new Error("Could not parse JWS header; " + e);
        }
        if (!(header && typeof header === "object")) {
          throw new Error("Invalid JWS header.");
        }
        if (!(header.alg === this.alg && header.b64 === false && Array.isArray(header.crit) && header.crit.length === 1 && header.crit[0] === "b64") && Object.keys(header).length === 3) {
          throw new Error(`Invalid JWS header parameters for ${this.type}.`);
        }
        const signature = utils_1.TypedArrayEncoder.fromBase64(encodedSignature);
        const data = _createJws({ encodedHeader, verifyData: options.verifyData });
        let { verifier } = this;
        if (!verifier) {
          const key = await this.LDKeyClass.from(options.verificationMethod);
          verifier = key.verifier();
        }
        return verifier.verify({ data, signature });
      }
      async getVerificationMethod(options) {
        if (this.key) {
          return this.key.export({ publicKey: true });
        }
        let { verificationMethod } = options.proof;
        if (typeof verificationMethod === "object" && verificationMethod !== null) {
          verificationMethod = verificationMethod.id;
        }
        if (!verificationMethod) {
          throw new Error('No "verificationMethod" found in proof.');
        }
        if (!options.documentLoader) {
          throw new error_1.AriesFrameworkError("Missing custom document loader. This is required for resolving verification methods.");
        }
        const { document } = await options.documentLoader(verificationMethod);
        verificationMethod = typeof document === "string" ? JSON.parse(document) : document;
        await this.assertVerificationMethod(verificationMethod);
        return verificationMethod;
      }
      /**
       * Checks whether a given proof exists in the document.
       *
       * @param options - Options hashmap.
       * @param options.proof - A proof.
       * @param options.document - A JSON-LD document.
       * @param options.purpose - A jsonld-signatures ProofPurpose
       *  instance (e.g. AssertionProofPurpose, AuthenticationProofPurpose, etc).
       * @param options.documentLoader  - A secure document loader (it is
       *   recommended to use one that provides static known documents, instead of
       *   fetching from the web) for returning contexts, controller documents,
       *   keys, and other relevant URLs needed for the proof.
       * @param [options.expansionMap] - A custom expansion map that is
       *   passed to the JSON-LD processor; by default a function that will throw
       *   an error when unmapped properties are detected in the input, use `false`
       *   to turn this off and allow unmapped properties to be dropped or use a
       *   custom function.
       *
       * @returns Whether a match for the proof was found.
       */
      async matchProof(options) {
        const proofMatches = await super.matchProof({
          proof: options.proof,
          document: options.document,
          purpose: options.purpose,
          documentLoader: options.documentLoader,
          expansionMap: options.expansionMap
        });
        if (!proofMatches) {
          return false;
        }
        if (!this.key) {
          return true;
        }
        const { verificationMethod } = options.proof;
        if (typeof verificationMethod === "object") {
          return verificationMethod.id === this.key.id;
        }
        return verificationMethod === this.key.id;
      }
    };
    exports.JwsLinkedDataSignature = JwsLinkedDataSignature;
    function _createJws(options) {
      const encodedHeaderBytes = utils_1.TypedArrayEncoder.fromString(options.encodedHeader + ".");
      const data = new Uint8Array(encodedHeaderBytes.length + options.verifyData.length);
      data.set(encodedHeaderBytes, 0);
      data.set(options.verifyData, encodedHeaderBytes.length);
      return data;
    }
  }
});

// node_modules/@aries-framework/core/build/modules/vc/signature-suites/ed25519/context.js
var require_context4 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/signature-suites/ed25519/context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ed25519Signature2018Context = exports.context = void 0;
    var constants_1 = require_constants3();
    exports.context = {
      "@context": {
        id: "@id",
        type: "@type",
        "@protected": true,
        proof: {
          "@id": "https://w3id.org/security#proof",
          "@type": "@id",
          "@container": "@graph"
        },
        Ed25519VerificationKey2018: {
          "@id": "https://w3id.org/security#Ed25519VerificationKey2018",
          "@context": {
            "@protected": true,
            id: "@id",
            type: "@type",
            controller: {
              "@id": "https://w3id.org/security#controller",
              "@type": "@id"
            },
            revoked: {
              "@id": "https://w3id.org/security#revoked",
              "@type": "http://www.w3.org/2001/XMLSchema#dateTime"
            },
            publicKeyBase58: {
              "@id": "https://w3id.org/security#publicKeyBase58"
            }
          }
        },
        Ed25519Signature2018: {
          "@id": "https://w3id.org/security#Ed25519Signature2018",
          "@context": {
            "@protected": true,
            id: "@id",
            type: "@type",
            challenge: "https://w3id.org/security#challenge",
            created: {
              "@id": "http://purl.org/dc/terms/created",
              "@type": "http://www.w3.org/2001/XMLSchema#dateTime"
            },
            domain: "https://w3id.org/security#domain",
            expires: {
              "@id": "https://w3id.org/security#expiration",
              "@type": "http://www.w3.org/2001/XMLSchema#dateTime"
            },
            nonce: "https://w3id.org/security#nonce",
            proofPurpose: {
              "@id": "https://w3id.org/security#proofPurpose",
              "@type": "@vocab",
              "@context": {
                "@protected": true,
                id: "@id",
                type: "@type",
                assertionMethod: {
                  "@id": "https://w3id.org/security#assertionMethod",
                  "@type": "@id",
                  "@container": "@set"
                },
                authentication: {
                  "@id": "https://w3id.org/security#authenticationMethod",
                  "@type": "@id",
                  "@container": "@set"
                },
                capabilityInvocation: {
                  "@id": "https://w3id.org/security#capabilityInvocationMethod",
                  "@type": "@id",
                  "@container": "@set"
                },
                capabilityDelegation: {
                  "@id": "https://w3id.org/security#capabilityDelegationMethod",
                  "@type": "@id",
                  "@container": "@set"
                },
                keyAgreement: {
                  "@id": "https://w3id.org/security#keyAgreementMethod",
                  "@type": "@id",
                  "@container": "@set"
                }
              }
            },
            jws: {
              "@id": "https://w3id.org/security#jws"
            },
            verificationMethod: {
              "@id": "https://w3id.org/security#verificationMethod",
              "@type": "@id"
            }
          }
        }
      }
    };
    var ed25519Signature2018Context = /* @__PURE__ */ new Map();
    exports.ed25519Signature2018Context = ed25519Signature2018Context;
    ed25519Signature2018Context.set(constants_1.ED25519_SUITE_CONTEXT_URL_2018, exports.context);
  }
});

// node_modules/@aries-framework/core/build/modules/vc/signature-suites/ed25519/Ed25519Signature2018.js
var require_Ed25519Signature2018 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/signature-suites/ed25519/Ed25519Signature2018.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Ed25519Signature2018 = void 0;
    var utils_1 = require_utils();
    var constants_1 = require_constants2();
    var jsonldUtil_1 = require_jsonldUtil();
    var jsonld_1 = __importDefault(require_jsonld2());
    var JwsLinkedDataSignature_1 = require_JwsLinkedDataSignature();
    var constants_2 = require_constants3();
    var context_12 = require_context4();
    var Ed25519Signature2018 = class extends JwsLinkedDataSignature_1.JwsLinkedDataSignature {
      /**
       * @param {object} options - Options hashmap.
       *
       * Either a `key` OR at least one of `signer`/`verifier` is required.
       *
       * @param {object} [options.key] - An optional key object (containing an
       *   `id` property, and either `signer` or `verifier`, depending on the
       *   intended operation. Useful for when the application is managing keys
       *   itself (when using a KMS, you never have access to the private key,
       *   and so should use the `signer` param instead).
       * @param {Function} [options.signer] - Signer function that returns an
       *   object with an async sign() method. This is useful when interfacing
       *   with a KMS (since you don't get access to the private key and its
       *   `signer()`, the KMS client gives you only the signer function to use).
       * @param {Function} [options.verifier] - Verifier function that returns
       *   an object with an async `verify()` method. Useful when working with a
       *   KMS-provided verifier function.
       *
       * Advanced optional parameters and overrides.
       *
       * @param {object} [options.proof] - A JSON-LD document with options to use
       *   for the `proof` node. Any other custom fields can be provided here
       *   using a context different from security-v2).
       * @param {string|Date} [options.date] - Signing date to use if not passed.
       * @param {boolean} [options.useNativeCanonize] - Whether to use a native
       *   canonize algorithm.
       */
      constructor(options) {
        super({
          type: "Ed25519Signature2018",
          algorithm: "EdDSA",
          LDKeyClass: options.LDKeyClass,
          contextUrl: constants_2.ED25519_SUITE_CONTEXT_URL_2018,
          key: options.key,
          proof: options.proof,
          date: options.date,
          useNativeCanonize: options.useNativeCanonize
        });
        this.requiredKeyType = "Ed25519VerificationKey2018";
      }
      async assertVerificationMethod(document) {
        if (!_includesCompatibleContext({ document })) {
          throw new TypeError(`The verification method (key) must contain "${this.contextUrl}".`);
        }
        if (!(_isEd2018Key(document) || _isEd2020Key(document))) {
          throw new Error(`Invalid key type. Key type must be "${this.requiredKeyType}".`);
        }
        if (document.revoked !== void 0) {
          throw new Error("The verification method has been revoked.");
        }
      }
      async getVerificationMethod(options) {
        let verificationMethod = await super.getVerificationMethod({
          proof: options.proof,
          documentLoader: options.documentLoader
        });
        if (_isEd2020Key(verificationMethod)) {
          const publicKeyBuffer = utils_1.MultiBaseEncoder.decode(verificationMethod.publicKeyMultibase);
          const context2020Index = verificationMethod["@context"].indexOf(constants_2.ED25519_SUITE_CONTEXT_URL_2020);
          verificationMethod["@context"].splice(context2020Index, 1);
          verificationMethod["@context"].push(constants_2.ED25519_SUITE_CONTEXT_URL_2018);
          verificationMethod.type = "Ed25519VerificationKey2018";
          verificationMethod = Object.assign(Object.assign({}, verificationMethod), { publicKeyMultibase: void 0, publicKeyBase58: utils_1.TypedArrayEncoder.toBase58(publicKeyBuffer.data) });
        }
        return verificationMethod;
      }
      /**
       * Ensures the document to be signed contains the required signature suite
       * specific `@context`, by either adding it (if `addSuiteContext` is true),
       * or throwing an error if it's missing.
       *
       * @override
       *
       * @param {object} options - Options hashmap.
       * @param {object} options.document - JSON-LD document to be signed.
       * @param {boolean} options.addSuiteContext - Add suite context?
       */
      ensureSuiteContext(options) {
        if (_includesCompatibleContext({ document: options.document })) {
          return;
        }
        super.ensureSuiteContext({ document: options.document, addSuiteContext: options.addSuiteContext });
      }
      /**
       * Checks whether a given proof exists in the document.
       *
       * @override
       *
       * @param {object} options - Options hashmap.
       * @param {object} options.proof - A proof.
       * @param {object} options.document - A JSON-LD document.
       * @param {object} options.purpose - A jsonld-signatures ProofPurpose
       *  instance (e.g. AssertionProofPurpose, AuthenticationProofPurpose, etc).
       * @param {Function} options.documentLoader  - A secure document loader (it is
       *   recommended to use one that provides static known documents, instead of
       *   fetching from the web) for returning contexts, controller documents,
       *   keys, and other relevant URLs needed for the proof.
       * @param {Function} [options.expansionMap] - A custom expansion map that is
       *   passed to the JSON-LD processor; by default a function that will throw
       *   an error when unmapped properties are detected in the input, use `false`
       *   to turn this off and allow unmapped properties to be dropped or use a
       *   custom function.
       *
       * @returns {Promise<boolean>} Whether a match for the proof was found.
       */
      async matchProof(options) {
        if (!_includesCompatibleContext({ document: options.document })) {
          return false;
        }
        return super.matchProof({
          proof: options.proof,
          document: options.document,
          purpose: options.purpose,
          documentLoader: options.documentLoader,
          expansionMap: options.expansionMap
        });
      }
    };
    exports.Ed25519Signature2018 = Ed25519Signature2018;
    Ed25519Signature2018.CONTEXT_URL = constants_2.ED25519_SUITE_CONTEXT_URL_2018;
    Ed25519Signature2018.CONTEXT = context_12.ed25519Signature2018Context.get(constants_2.ED25519_SUITE_CONTEXT_URL_2018);
    function _includesCompatibleContext(options) {
      const hasEd2018 = (0, jsonldUtil_1._includesContext)({
        document: options.document,
        contextUrl: constants_2.ED25519_SUITE_CONTEXT_URL_2018
      });
      const hasEd2020 = (0, jsonldUtil_1._includesContext)({
        document: options.document,
        contextUrl: constants_2.ED25519_SUITE_CONTEXT_URL_2020
      });
      const hasCred = (0, jsonldUtil_1._includesContext)({ document: options.document, contextUrl: constants_1.CREDENTIALS_CONTEXT_V1_URL });
      const hasSecV2 = (0, jsonldUtil_1._includesContext)({ document: options.document, contextUrl: constants_1.SECURITY_CONTEXT_URL });
      if (hasEd2018 && hasCred) {
        return false;
      }
      if (hasEd2018 && hasSecV2) {
        return false;
      }
      return hasEd2018 || hasEd2020 || hasCred || hasSecV2;
    }
    function _isEd2018Key(verificationMethod) {
      const hasEd2018 = (0, jsonldUtil_1._includesContext)({
        document: verificationMethod,
        contextUrl: constants_2.ED25519_SUITE_CONTEXT_URL_2018
      });
      return hasEd2018 && jsonld_1.default.hasValue(verificationMethod, "type", "Ed25519VerificationKey2018");
    }
    function _isEd2020Key(verificationMethod) {
      const hasEd2020 = (0, jsonldUtil_1._includesContext)({
        document: verificationMethod,
        contextUrl: constants_2.ED25519_SUITE_CONTEXT_URL_2020
      });
      return hasEd2020 && jsonld_1.default.hasValue(verificationMethod, "type", "Ed25519VerificationKey2020");
    }
  }
});

// node_modules/@aries-framework/core/build/modules/vc/signature-suites/index.js
var require_signature_suites = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/signature-suites/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_Ed25519Signature2018(), exports);
    __exportStar(require_JwsLinkedDataSignature(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/vc/W3cVcModule.js
var require_W3cVcModule = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/W3cVcModule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3cVcModule = void 0;
    var crypto_1 = require_crypto();
    var ed25519_1 = require_ed255192();
    var SignatureSuiteRegistry_1 = require_SignatureSuiteRegistry();
    var W3cCredentialService_1 = require_W3cCredentialService();
    var W3cVcModuleConfig_1 = require_W3cVcModuleConfig();
    var W3cCredentialRepository_1 = require_W3cCredentialRepository();
    var signature_suites_1 = require_signature_suites();
    var W3cVcModule = class {
      constructor(config) {
        this.config = new W3cVcModuleConfig_1.W3cVcModuleConfig(config);
      }
      register(dependencyManager) {
        dependencyManager.registerSingleton(W3cCredentialService_1.W3cCredentialService);
        dependencyManager.registerSingleton(W3cCredentialRepository_1.W3cCredentialRepository);
        dependencyManager.registerSingleton(SignatureSuiteRegistry_1.SignatureSuiteRegistry);
        dependencyManager.registerInstance(W3cVcModuleConfig_1.W3cVcModuleConfig, this.config);
        dependencyManager.registerInstance(SignatureSuiteRegistry_1.SignatureSuiteToken, {
          suiteClass: signature_suites_1.Ed25519Signature2018,
          proofType: "Ed25519Signature2018",
          verificationMethodTypes: [
            ed25519_1.VERIFICATION_METHOD_TYPE_ED25519_VERIFICATION_KEY_2018,
            ed25519_1.VERIFICATION_METHOD_TYPE_ED25519_VERIFICATION_KEY_2020
          ],
          keyTypes: [crypto_1.KeyType.Ed25519]
        });
      }
    };
    exports.W3cVcModule = W3cVcModule;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/proof-purposes/CredentialIssuancePurpose.js
var require_CredentialIssuancePurpose2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/proof-purposes/CredentialIssuancePurpose.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CredentialIssuancePurpose = void 0;
    var jsonld_signatures_1 = require_jsonld_signatures2();
    var AssertionProofPurpose = jsonld_signatures_1.purposes.AssertionProofPurpose;
    var LinkedDataProof = jsonld_signatures_1.suites.LinkedDataProof;
    var CredentialIssuancePurpose = class extends AssertionProofPurpose {
      /**
       * @param {object} options - The options to use.
       * @param {object} [options.controller] - The description of the controller,
       *   if it is not to be dereferenced via a `documentLoader`.
       * @param {string|Date|number} [options.date] - The expected date for
       *   the creation of the proof.
       * @param {number} [options.maxTimestampDelta=Infinity] - A maximum number
       *   of seconds that the date on the signature can deviate from.
       */
      constructor(options) {
        options.maxTimestampDelta = options.maxTimestampDelta || Infinity;
        super(options);
      }
      /**
       * Validates the purpose of a proof. This method is called during
       * proof verification, after the proof value has been checked against the
       * given verification method (in the case of a digital signature, the
       * signature has been cryptographically verified against the public key).
       *
       * @param {object} proof - The proof to validate.
       * @param {object} options - The options to use.
       * @param {object} options.document - The document whose signature is
       *   being verified.
       * @param {object} options.suite - Signature suite used in
       *   the proof.
       * @param {string} options.verificationMethod - Key id URL to the paired
       *   public key.
       * @param {object} [options.documentLoader] - A document loader.
       * @param {object} [options.expansionMap] - An expansion map.
       *
       * @throws {Error} If verification method not authorized by controller.
       * @throws {Error} If proof's created timestamp is out of range.
       *
       * @returns {Promise<{valid: boolean, error: Error}>} Resolves on completion.
       */
      async validate(proof, options) {
        try {
          const result2 = await super.validate(proof, options);
          if (!result2.valid) {
            throw result2.error;
          }
          const issuer = jsonld.util.getValues(options.document, "issuer");
          if (!issuer || issuer.length === 0) {
            throw new Error("Credential issuer is required.");
          }
          const issuerId = typeof issuer[0] === "string" ? issuer[0] : issuer[0].id;
          if (result2.controller.id !== issuerId) {
            throw new Error("Credential issuer must match the verification method controller.");
          }
          return { valid: true };
        } catch (error) {
          return { valid: false, error };
        }
      }
    };
    exports.CredentialIssuancePurpose = CredentialIssuancePurpose;
  }
});

// node_modules/@aries-framework/core/build/modules/vc/proof-purposes/ProofPurpose.js
var require_ProofPurpose2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/proof-purposes/ProofPurpose.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/vc/proof-purposes/index.js
var require_proof_purposes = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/proof-purposes/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_CredentialIssuancePurpose2(), exports);
    __exportStar(require_ProofPurpose2(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/vc/libraries/index.js
var require_libraries = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/libraries/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.vcLibraries = void 0;
    var jsonld2 = __importStar(require_jsonld2());
    var jsonldSignatures = __importStar(require_jsonld_signatures2());
    var vc = __importStar(require_vc2());
    exports.vcLibraries = {
      jsonldSignatures,
      jsonld: Object.assign(Object.assign({}, jsonld2), jsonld2.default),
      vc: Object.assign(Object.assign({}, vc), vc.default)
    };
  }
});

// node_modules/@aries-framework/core/build/modules/vc/index.js
var require_vc3 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/vc/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignatureSuiteToken = exports.orArrayToArray = exports.w3cDate = void 0;
    __exportStar(require_W3cCredentialService(), exports);
    __exportStar(require_W3cCredentialRecord(), exports);
    __exportStar(require_W3cVcModule(), exports);
    __exportStar(require_models8(), exports);
    var jsonldUtil_1 = require_jsonldUtil();
    Object.defineProperty(exports, "w3cDate", { enumerable: true, get: function() {
      return jsonldUtil_1.w3cDate;
    } });
    Object.defineProperty(exports, "orArrayToArray", { enumerable: true, get: function() {
      return jsonldUtil_1.orArrayToArray;
    } });
    __exportStar(require_proof_purposes(), exports);
    __exportStar(require_constants2(), exports);
    __exportStar(require_libraries(), exports);
    var SignatureSuiteRegistry_1 = require_SignatureSuiteRegistry();
    Object.defineProperty(exports, "SignatureSuiteToken", { enumerable: true, get: function() {
      return SignatureSuiteRegistry_1.SignatureSuiteToken;
    } });
    __exportStar(require_signature_suites(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/formats/jsonld/JsonLdCredentialDetailOptions.js
var require_JsonLdCredentialDetailOptions = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/formats/jsonld/JsonLdCredentialDetailOptions.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonLdCredentialDetailOptions = exports.JsonLdCredentialDetailCredentialStatus = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var JsonLdCredentialDetailCredentialStatus = class {
      constructor(options) {
        if (options) {
          this.type = options.type;
        }
      }
    };
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], JsonLdCredentialDetailCredentialStatus.prototype, "type", void 0);
    exports.JsonLdCredentialDetailCredentialStatus = JsonLdCredentialDetailCredentialStatus;
    var JsonLdCredentialDetailOptions = class {
      constructor(options) {
        if (options) {
          this.proofPurpose = options.proofPurpose;
          this.created = options.created;
          this.domain = options.domain;
          this.challenge = options.challenge;
          this.credentialStatus = options.credentialStatus;
          this.proofType = options.proofType;
        }
      }
    };
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], JsonLdCredentialDetailOptions.prototype, "proofPurpose", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], JsonLdCredentialDetailOptions.prototype, "created", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], JsonLdCredentialDetailOptions.prototype, "domain", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], JsonLdCredentialDetailOptions.prototype, "challenge", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], JsonLdCredentialDetailOptions.prototype, "proofType", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsObject)(),
      __metadata("design:type", JsonLdCredentialDetailCredentialStatus)
    ], JsonLdCredentialDetailOptions.prototype, "credentialStatus", void 0);
    exports.JsonLdCredentialDetailOptions = JsonLdCredentialDetailOptions;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/formats/jsonld/JsonLdCredentialDetail.js
var require_JsonLdCredentialDetail = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/formats/jsonld/JsonLdCredentialDetail.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonLdCredentialDetail = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var W3cCredential_1 = require_W3cCredential();
    var JsonLdCredentialDetailOptions_1 = require_JsonLdCredentialDetailOptions();
    var JsonLdCredentialDetail = class {
      constructor(options) {
        if (options) {
          this.credential = options.credential;
          this.options = options.options;
        }
      }
    };
    __decorate([
      (0, class_transformer_1.Type)(() => W3cCredential_1.W3cCredential),
      __metadata("design:type", W3cCredential_1.W3cCredential)
    ], JsonLdCredentialDetail.prototype, "credential", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "options" }),
      (0, class_transformer_1.Type)(() => JsonLdCredentialDetailOptions_1.JsonLdCredentialDetailOptions),
      __metadata("design:type", JsonLdCredentialDetailOptions_1.JsonLdCredentialDetailOptions)
    ], JsonLdCredentialDetail.prototype, "options", void 0);
    exports.JsonLdCredentialDetail = JsonLdCredentialDetail;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/formats/jsonld/JsonLdCredentialFormatService.js
var require_JsonLdCredentialFormatService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/formats/jsonld/JsonLdCredentialFormatService.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonLdCredentialFormatService = void 0;
    var Attachment_1 = require_Attachment();
    var error_1 = require_error();
    var utils_1 = require_utils();
    var JsonTransformer_1 = require_JsonTransformer();
    var DidDocument_1 = require_DidDocument();
    var DidResolverService_1 = require_DidResolverService();
    var vc_1 = require_vc3();
    var models_1 = require_models8();
    var CredentialFormatSpec_1 = require_CredentialFormatSpec();
    var JsonLdCredentialDetail_1 = require_JsonLdCredentialDetail();
    var JSONLD_VC_DETAIL = "aries/ld-proof-vc-detail@v1.0";
    var JSONLD_VC = "aries/ld-proof-vc@1.0";
    var JsonLdCredentialFormatService = class {
      constructor() {
        this.formatKey = "jsonld";
        this.credentialRecordType = "w3c";
        this.areCredentialsEqual = (message1, message2) => {
          const obj1 = message1.getDataAsJson();
          const obj2 = message2.getDataAsJson();
          return (0, utils_1.areObjectsEqual)(obj1, obj2);
        };
      }
      /**
       * Create a {@link AttachmentFormats} object dependent on the message type.
       *
       * @param options The object containing all the options for the proposed credential
       * @returns object containing associated attachment, formats and filtersAttach elements
       *
       */
      async createProposal(agentContext, { credentialFormats }) {
        const format2 = new CredentialFormatSpec_1.CredentialFormatSpec({
          format: JSONLD_VC_DETAIL
        });
        const jsonLdFormat = credentialFormats.jsonld;
        if (!jsonLdFormat) {
          throw new error_1.AriesFrameworkError("Missing jsonld payload in createProposal");
        }
        JsonTransformer_1.JsonTransformer.fromJSON(jsonLdFormat.credential, JsonLdCredentialDetail_1.JsonLdCredentialDetail);
        const attachment = this.getFormatData(jsonLdFormat, format2.attachId);
        return { format: format2, attachment };
      }
      /**
       * Method called on reception of a propose credential message
       * @param options the options needed to accept the proposal
       */
      async processProposal(agentContext, { attachment }) {
        const credProposalJson = attachment.getDataAsJson();
        if (!credProposalJson) {
          throw new error_1.AriesFrameworkError("Missing jsonld credential proposal data payload");
        }
        JsonTransformer_1.JsonTransformer.fromJSON(credProposalJson, JsonLdCredentialDetail_1.JsonLdCredentialDetail);
      }
      async acceptProposal(agentContext, { attachId, proposalAttachment }) {
        const format2 = new CredentialFormatSpec_1.CredentialFormatSpec({
          attachId,
          format: JSONLD_VC_DETAIL
        });
        const credentialProposal = proposalAttachment.getDataAsJson();
        JsonTransformer_1.JsonTransformer.fromJSON(credentialProposal, JsonLdCredentialDetail_1.JsonLdCredentialDetail);
        const offerData = credentialProposal;
        const attachment = this.getFormatData(offerData, format2.attachId);
        return { format: format2, attachment };
      }
      /**
       * Create a {@link AttachmentFormats} object dependent on the message type.
       *
       * @param options The object containing all the options for the credential offer
       * @returns object containing associated attachment, formats and offersAttach elements
       *
       */
      async createOffer(agentContext, { credentialFormats, attachId }) {
        const format2 = new CredentialFormatSpec_1.CredentialFormatSpec({
          attachId,
          format: JSONLD_VC_DETAIL
        });
        const jsonLdFormat = credentialFormats === null || credentialFormats === void 0 ? void 0 : credentialFormats.jsonld;
        if (!jsonLdFormat) {
          throw new error_1.AriesFrameworkError("Missing jsonld payload in createOffer");
        }
        JsonTransformer_1.JsonTransformer.fromJSON(jsonLdFormat.credential, JsonLdCredentialDetail_1.JsonLdCredentialDetail);
        const attachment = this.getFormatData(jsonLdFormat, format2.attachId);
        return { format: format2, attachment };
      }
      async processOffer(agentContext, { attachment }) {
        const credentialOfferJson = attachment.getDataAsJson();
        if (!credentialOfferJson) {
          throw new error_1.AriesFrameworkError("Missing jsonld credential offer data payload");
        }
        JsonTransformer_1.JsonTransformer.fromJSON(credentialOfferJson, JsonLdCredentialDetail_1.JsonLdCredentialDetail);
      }
      async acceptOffer(agentContext, { attachId, offerAttachment }) {
        const credentialOffer = offerAttachment.getDataAsJson();
        JsonTransformer_1.JsonTransformer.fromJSON(credentialOffer, JsonLdCredentialDetail_1.JsonLdCredentialDetail);
        const format2 = new CredentialFormatSpec_1.CredentialFormatSpec({
          attachId,
          format: JSONLD_VC_DETAIL
        });
        const attachment = this.getFormatData(credentialOffer, format2.attachId);
        return { format: format2, attachment };
      }
      /**
       * Create a credential attachment format for a credential request.
       *
       * @param options The object containing all the options for the credential request is derived
       * @returns object containing associated attachment, formats and requestAttach elements
       *
       */
      async createRequest(agentContext, { credentialFormats }) {
        const jsonLdFormat = credentialFormats === null || credentialFormats === void 0 ? void 0 : credentialFormats.jsonld;
        const format2 = new CredentialFormatSpec_1.CredentialFormatSpec({
          format: JSONLD_VC_DETAIL
        });
        if (!jsonLdFormat) {
          throw new error_1.AriesFrameworkError("Missing jsonld payload in createRequest");
        }
        JsonTransformer_1.JsonTransformer.fromJSON(jsonLdFormat.credential, JsonLdCredentialDetail_1.JsonLdCredentialDetail);
        const attachment = this.getFormatData(jsonLdFormat, format2.attachId);
        return { format: format2, attachment };
      }
      async processRequest(agentContext, { attachment }) {
        const requestJson = attachment.getDataAsJson();
        if (!requestJson) {
          throw new error_1.AriesFrameworkError("Missing jsonld credential request data payload");
        }
        JsonTransformer_1.JsonTransformer.fromJSON(requestJson, JsonLdCredentialDetail_1.JsonLdCredentialDetail);
      }
      async acceptRequest(agentContext, { credentialFormats, attachId, requestAttachment }) {
        var _a, _b;
        const w3cCredentialService = agentContext.dependencyManager.resolve(vc_1.W3cCredentialService);
        const credentialRequest = requestAttachment.getDataAsJson();
        const verificationMethod = (_b = (_a = credentialFormats === null || credentialFormats === void 0 ? void 0 : credentialFormats.jsonld) === null || _a === void 0 ? void 0 : _a.verificationMethod) !== null && _b !== void 0 ? _b : await this.deriveVerificationMethod(agentContext, credentialRequest.credential, credentialRequest);
        if (!verificationMethod) {
          throw new error_1.AriesFrameworkError("Missing verification method in credential data");
        }
        const format2 = new CredentialFormatSpec_1.CredentialFormatSpec({
          attachId,
          format: JSONLD_VC
        });
        const options = credentialRequest.options;
        const unsupportedFields = ["challenge", "domain", "credentialStatus", "created"];
        const foundFields = unsupportedFields.filter((field) => options[field] !== void 0);
        if (foundFields.length > 0) {
          throw new error_1.AriesFrameworkError(`Some fields are not currently supported in credential options: ${foundFields.join(", ")}`);
        }
        const credential = JsonTransformer_1.JsonTransformer.fromJSON(credentialRequest.credential, models_1.W3cCredential);
        const verifiableCredential = await w3cCredentialService.signCredential(agentContext, {
          credential,
          proofType: credentialRequest.options.proofType,
          verificationMethod
        });
        const attachment = this.getFormatData(verifiableCredential, format2.attachId);
        return { format: format2, attachment };
      }
      /**
       * Derive a verification method using the issuer from the given verifiable credential
       * @param credentialAsJson the verifiable credential we want to sign
       * @return the verification method derived from this credential and its associated issuer did, keys etc.
       */
      async deriveVerificationMethod(agentContext, credentialAsJson, credentialRequest) {
        const didResolver = agentContext.dependencyManager.resolve(DidResolverService_1.DidResolverService);
        const w3cCredentialService = agentContext.dependencyManager.resolve(vc_1.W3cCredentialService);
        const credential = JsonTransformer_1.JsonTransformer.fromJSON(credentialAsJson, models_1.W3cCredential);
        let issuerDid = credential.issuer;
        if (typeof issuerDid !== "string") {
          issuerDid = issuerDid.id;
        }
        const issuerDidDocument = await didResolver.resolveDidDocument(agentContext, issuerDid);
        const proofType = credentialRequest.options.proofType;
        const keyType = w3cCredentialService.getVerificationMethodTypesByProofType(proofType);
        if (!keyType || keyType.length === 0) {
          throw new error_1.AriesFrameworkError(`No Key Type found for proofType ${proofType}`);
        }
        const verificationMethod = await (0, DidDocument_1.findVerificationMethodByKeyType)(keyType[0], issuerDidDocument);
        if (!verificationMethod) {
          throw new error_1.AriesFrameworkError(`Missing verification method for key type ${keyType}`);
        }
        return verificationMethod.id;
      }
      /**
       * Processes an incoming credential - retrieve metadata, retrieve payload and store it in the Indy wallet
       * @param options the issue credential message wrapped inside this object
       * @param credentialRecord the credential exchange record for this credential
       */
      async processCredential(agentContext, { credentialRecord, attachment, requestAttachment }) {
        const w3cCredentialService = agentContext.dependencyManager.resolve(vc_1.W3cCredentialService);
        const credentialAsJson = attachment.getDataAsJson();
        const credential = JsonTransformer_1.JsonTransformer.fromJSON(credentialAsJson, models_1.W3cVerifiableCredential);
        const requestAsJson = requestAttachment.getDataAsJson();
        this.verifyReceivedCredentialMatchesRequest(credential, requestAsJson);
        const result2 = await w3cCredentialService.verifyCredential(agentContext, { credential });
        if (result2 && !result2.verified) {
          throw new error_1.AriesFrameworkError(`Failed to validate credential, error = ${result2.error}`);
        }
        const verifiableCredential = await w3cCredentialService.storeCredential(agentContext, {
          credential
        });
        credentialRecord.credentials.push({
          credentialRecordType: this.credentialRecordType,
          credentialRecordId: verifiableCredential.id
        });
      }
      verifyReceivedCredentialMatchesRequest(credential, request) {
        const jsonCredential = JsonTransformer_1.JsonTransformer.toJSON(credential);
        delete jsonCredential.proof;
        if (Array.isArray(credential.proof)) {
          throw new error_1.AriesFrameworkError("Credential proof arrays are not supported");
        }
        if (request.options.created && credential.proof.created !== request.options.created) {
          throw new error_1.AriesFrameworkError("Received credential proof created does not match created from credential request");
        }
        if (credential.proof.domain !== request.options.domain) {
          throw new error_1.AriesFrameworkError("Received credential proof domain does not match domain from credential request");
        }
        if (credential.proof.challenge !== request.options.challenge) {
          throw new error_1.AriesFrameworkError("Received credential proof challenge does not match challenge from credential request");
        }
        if (credential.proof.type !== request.options.proofType) {
          throw new error_1.AriesFrameworkError("Received credential proof type does not match proof type from credential request");
        }
        if (credential.proof.proofPurpose !== request.options.proofPurpose) {
          throw new error_1.AriesFrameworkError("Received credential proof purpose does not match proof purpose from credential request");
        }
        if (!(0, utils_1.areObjectsEqual)(jsonCredential, request.credential)) {
          throw new error_1.AriesFrameworkError("Received credential does not match credential request");
        }
      }
      supportsFormat(format2) {
        const supportedFormats = [JSONLD_VC_DETAIL, JSONLD_VC];
        return supportedFormats.includes(format2);
      }
      async deleteCredentialById() {
        throw new Error("Not implemented.");
      }
      shouldAutoRespondToProposal(agentContext, { offerAttachment, proposalAttachment }) {
        return this.areCredentialsEqual(proposalAttachment, offerAttachment);
      }
      shouldAutoRespondToOffer(agentContext, { offerAttachment, proposalAttachment }) {
        return this.areCredentialsEqual(proposalAttachment, offerAttachment);
      }
      shouldAutoRespondToRequest(agentContext, { offerAttachment, requestAttachment }) {
        return this.areCredentialsEqual(offerAttachment, requestAttachment);
      }
      shouldAutoRespondToCredential(agentContext, { requestAttachment, credentialAttachment }) {
        const credentialJson = credentialAttachment.getDataAsJson();
        const w3cCredential = JsonTransformer_1.JsonTransformer.fromJSON(credentialJson, models_1.W3cVerifiableCredential);
        const request = requestAttachment.getDataAsJson();
        try {
          this.verifyReceivedCredentialMatchesRequest(w3cCredential, request);
          return true;
        } catch (error) {
          return false;
        }
      }
      /**
       * Returns an object of type {@link Attachment} for use in credential exchange messages.
       * It looks up the correct format identifier and encodes the data as a base64 attachment.
       *
       * @param data The data to include in the attach object
       * @param id the attach id from the formats component of the message
       */
      getFormatData(data, id) {
        const attachment = new Attachment_1.Attachment({
          id,
          mimeType: "application/json",
          data: new Attachment_1.AttachmentData({
            base64: utils_1.JsonEncoder.toBase64(data)
          })
        });
        return attachment;
      }
    };
    exports.JsonLdCredentialFormatService = JsonLdCredentialFormatService;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/formats/jsonld/JsonLdCredentialFormat.js
var require_JsonLdCredentialFormat = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/formats/jsonld/JsonLdCredentialFormat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/formats/jsonld/index.js
var require_jsonld3 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/formats/jsonld/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_JsonLdCredentialFormatService(), exports);
    __exportStar(require_JsonLdCredentialFormat(), exports);
    __exportStar(require_JsonLdCredentialDetail(), exports);
    __exportStar(require_JsonLdCredentialDetailOptions(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/formats/index.js
var require_formats = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/formats/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_CredentialFormatService(), exports);
    __exportStar(require_CredentialFormatServiceOptions(), exports);
    __exportStar(require_CredentialFormat(), exports);
    __exportStar(require_indy(), exports);
    __exportStar(require_jsonld3(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/util/composeAutoAccept.js
var require_composeAutoAccept = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/util/composeAutoAccept.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.composeAutoAccept = void 0;
    var CredentialAutoAcceptType_1 = require_CredentialAutoAcceptType();
    function composeAutoAccept(recordConfig, agentConfig) {
      var _a;
      return (_a = recordConfig !== null && recordConfig !== void 0 ? recordConfig : agentConfig) !== null && _a !== void 0 ? _a : CredentialAutoAcceptType_1.AutoAcceptCredential.Never;
    }
    exports.composeAutoAccept = composeAutoAccept;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/util/previewAttributes.js
var require_previewAttributes = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/util/previewAttributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arePreviewAttributesEqual = void 0;
    function arePreviewAttributesEqual(firstAttributes, secondAttributes) {
      if (firstAttributes.length !== secondAttributes.length)
        return false;
      const secondAttributeMap = secondAttributes.reduce((attributeMap, attribute) => Object.assign(Object.assign({}, attributeMap), { [attribute.name]: attribute }), {});
      if (new Set(firstAttributes.map((attribute) => attribute.name)).size !== firstAttributes.length)
        return false;
      if (new Set(secondAttributes.map((attribute) => attribute.name)).size !== secondAttributes.length)
        return false;
      for (const firstAttribute of firstAttributes) {
        const secondAttribute = secondAttributeMap[firstAttribute.name];
        if (!secondAttribute)
          return false;
        if (firstAttribute.value !== secondAttribute.value)
          return false;
        if (firstAttribute.mimeType !== secondAttribute.mimeType)
          return false;
      }
      return true;
    }
    exports.arePreviewAttributesEqual = arePreviewAttributesEqual;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/BaseCredentialProtocol.js
var require_BaseCredentialProtocol = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/BaseCredentialProtocol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseCredentialProtocol = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var storage_1 = require_storage();
    var utils_1 = require_utils();
    var CredentialEvents_1 = require_CredentialEvents();
    var CredentialState_1 = require_CredentialState();
    var repository_1 = require_repository6();
    var BaseCredentialProtocol = class {
      /**
       * Decline a credential offer
       * @param credentialRecord The credential to be declined
       */
      async declineOffer(agentContext, credentialRecord) {
        credentialRecord.assertState(CredentialState_1.CredentialState.OfferReceived);
        await this.updateState(agentContext, credentialRecord, CredentialState_1.CredentialState.Declined);
        return credentialRecord;
      }
      /**
       * Process a received credential {@link ProblemReportMessage}.
       *
       * @param messageContext The message context containing a credential problem report message
       * @returns credential record associated with the credential problem report message
       */
      async processProblemReport(messageContext) {
        const { message: credentialProblemReportMessage, agentContext } = messageContext;
        const connection = messageContext.assertReadyConnection();
        agentContext.config.logger.debug(`Processing problem report with id ${credentialProblemReportMessage.id}`);
        const credentialRecord = await this.getByThreadAndConnectionId(messageContext.agentContext, credentialProblemReportMessage.threadId, connection.id);
        credentialRecord.errorMessage = `${credentialProblemReportMessage.description.code}: ${credentialProblemReportMessage.description.en}`;
        await this.update(messageContext.agentContext, credentialRecord);
        return credentialRecord;
      }
      /**
       * Update the record to a new state and emit an state changed event. Also updates the record
       * in storage.
       *
       * @param credentialRecord The credential record to update the state for
       * @param newState The state to update to
       *
       */
      async updateState(agentContext, credentialRecord, newState) {
        const credentialRepository = agentContext.dependencyManager.resolve(repository_1.CredentialRepository);
        agentContext.config.logger.debug(`Updating credential record ${credentialRecord.id} to state ${newState} (previous=${credentialRecord.state})`);
        const previousState = credentialRecord.state;
        credentialRecord.state = newState;
        await credentialRepository.update(agentContext, credentialRecord);
        this.emitStateChangedEvent(agentContext, credentialRecord, previousState);
      }
      emitStateChangedEvent(agentContext, credentialRecord, previousState) {
        const eventEmitter = agentContext.dependencyManager.resolve(EventEmitter_1.EventEmitter);
        const clonedCredential = utils_1.JsonTransformer.clone(credentialRecord);
        eventEmitter.emit(agentContext, {
          type: CredentialEvents_1.CredentialEventTypes.CredentialStateChanged,
          payload: {
            credentialRecord: clonedCredential,
            previousState
          }
        });
      }
      /**
       * Retrieve a credential record by id
       *
       * @param credentialRecordId The credential record id
       * @throws {RecordNotFoundError} If no record is found
       * @return The credential record
       *
       */
      getById(agentContext, credentialRecordId) {
        const credentialRepository = agentContext.dependencyManager.resolve(repository_1.CredentialRepository);
        return credentialRepository.getById(agentContext, credentialRecordId);
      }
      /**
       * Retrieve all credential records
       *
       * @returns List containing all credential records
       */
      getAll(agentContext) {
        const credentialRepository = agentContext.dependencyManager.resolve(repository_1.CredentialRepository);
        return credentialRepository.getAll(agentContext);
      }
      async findAllByQuery(agentContext, query) {
        const credentialRepository = agentContext.dependencyManager.resolve(repository_1.CredentialRepository);
        return credentialRepository.findByQuery(agentContext, query);
      }
      /**
       * Find a credential record by id
       *
       * @param credentialRecordId the credential record id
       * @returns The credential record or null if not found
       */
      findById(agentContext, connectionId) {
        const credentialRepository = agentContext.dependencyManager.resolve(repository_1.CredentialRepository);
        return credentialRepository.findById(agentContext, connectionId);
      }
      async delete(agentContext, credentialRecord, options) {
        var _a, _b;
        const credentialRepository = agentContext.dependencyManager.resolve(repository_1.CredentialRepository);
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        await credentialRepository.delete(agentContext, credentialRecord);
        const deleteAssociatedCredentials = (_a = options === null || options === void 0 ? void 0 : options.deleteAssociatedCredentials) !== null && _a !== void 0 ? _a : true;
        const deleteAssociatedDidCommMessages = (_b = options === null || options === void 0 ? void 0 : options.deleteAssociatedDidCommMessages) !== null && _b !== void 0 ? _b : true;
        if (deleteAssociatedCredentials) {
          for (const credential of credentialRecord.credentials) {
            const formatService = this.getFormatServiceForRecordType(credential.credentialRecordType);
            await formatService.deleteCredentialById(agentContext, credential.credentialRecordId);
          }
        }
        if (deleteAssociatedDidCommMessages) {
          const didCommMessages = await didCommMessageRepository.findByQuery(agentContext, {
            associatedRecordId: credentialRecord.id
          });
          for (const didCommMessage of didCommMessages) {
            await didCommMessageRepository.delete(agentContext, didCommMessage);
          }
        }
      }
      /**
       * Retrieve a credential record by connection id and thread id
       *
       * @param connectionId The connection id
       * @param threadId The thread id
       * @throws {RecordNotFoundError} If no record is found
       * @throws {RecordDuplicateError} If multiple records are found
       * @returns The credential record
       */
      getByThreadAndConnectionId(agentContext, threadId, connectionId) {
        const credentialRepository = agentContext.dependencyManager.resolve(repository_1.CredentialRepository);
        return credentialRepository.getSingleByQuery(agentContext, {
          connectionId,
          threadId
        });
      }
      /**
       * Find a credential record by connection id and thread id, returns null if not found
       *
       * @param connectionId The connection id
       * @param threadId The thread id
       * @returns The credential record
       */
      findByThreadAndConnectionId(agentContext, threadId, connectionId) {
        const credentialRepository = agentContext.dependencyManager.resolve(repository_1.CredentialRepository);
        return credentialRepository.findSingleByQuery(agentContext, {
          connectionId,
          threadId
        });
      }
      async update(agentContext, credentialRecord) {
        const credentialRepository = agentContext.dependencyManager.resolve(repository_1.CredentialRepository);
        return await credentialRepository.update(agentContext, credentialRecord);
      }
    };
    exports.BaseCredentialProtocol = BaseCredentialProtocol;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/handlers/V1CredentialAckHandler.js
var require_V1CredentialAckHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/handlers/V1CredentialAckHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1CredentialAckHandler = void 0;
    var messages_1 = require_messages10();
    var V1CredentialAckHandler = class {
      constructor(credentialProtocol) {
        this.supportedMessages = [messages_1.V1CredentialAckMessage];
        this.credentialProtocol = credentialProtocol;
      }
      async handle(messageContext) {
        await this.credentialProtocol.processAck(messageContext);
      }
    };
    exports.V1CredentialAckHandler = V1CredentialAckHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/handlers/V1IssueCredentialHandler.js
var require_V1IssueCredentialHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/handlers/V1IssueCredentialHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1IssueCredentialHandler = void 0;
    var models_1 = require_models3();
    var storage_1 = require_storage();
    var messages_1 = require_messages10();
    var V1IssueCredentialHandler = class {
      constructor(credentialProtocol) {
        this.supportedMessages = [messages_1.V1IssueCredentialMessage];
        this.credentialProtocol = credentialProtocol;
      }
      async handle(messageContext) {
        const credentialRecord = await this.credentialProtocol.processCredential(messageContext);
        const shouldAutoRespond = await this.credentialProtocol.shouldAutoRespondToCredential(messageContext.agentContext, {
          credentialRecord,
          credentialMessage: messageContext.message
        });
        if (shouldAutoRespond) {
          return await this.acceptCredential(credentialRecord, messageContext);
        }
      }
      async acceptCredential(credentialRecord, messageContext) {
        messageContext.agentContext.config.logger.info(`Automatically sending acknowledgement with autoAccept`);
        const { message } = await this.credentialProtocol.acceptCredential(messageContext.agentContext, {
          credentialRecord
        });
        const didCommMessageRepository = messageContext.agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const requestMessage = await didCommMessageRepository.getAgentMessage(messageContext.agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: messages_1.V1RequestCredentialMessage
        });
        if (messageContext.connection) {
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            connection: messageContext.connection,
            associatedRecord: credentialRecord
          });
        } else if (messageContext.message.service && requestMessage.service) {
          const recipientService = messageContext.message.service;
          const ourService = requestMessage.service;
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            serviceParams: {
              service: recipientService.resolvedDidCommService,
              senderKey: ourService.resolvedDidCommService.recipientKeys[0]
            }
          });
        }
        messageContext.agentContext.config.logger.error(`Could not automatically create credential ack`);
      }
    };
    exports.V1IssueCredentialHandler = V1IssueCredentialHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/handlers/V1OfferCredentialHandler.js
var require_V1OfferCredentialHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/handlers/V1OfferCredentialHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1OfferCredentialHandler = void 0;
    var models_1 = require_models3();
    var ServiceDecorator_1 = require_ServiceDecorator();
    var storage_1 = require_storage();
    var RoutingService_1 = require_RoutingService();
    var messages_1 = require_messages10();
    var V1OfferCredentialHandler = class {
      constructor(credentialProtocol) {
        this.supportedMessages = [messages_1.V1OfferCredentialMessage];
        this.credentialProtocol = credentialProtocol;
      }
      async handle(messageContext) {
        const credentialRecord = await this.credentialProtocol.processOffer(messageContext);
        const shouldAutoRespond = await this.credentialProtocol.shouldAutoRespondToOffer(messageContext.agentContext, {
          credentialRecord,
          offerMessage: messageContext.message
        });
        if (shouldAutoRespond) {
          return await this.acceptOffer(credentialRecord, messageContext);
        }
      }
      async acceptOffer(credentialRecord, messageContext) {
        messageContext.agentContext.config.logger.info(`Automatically sending request with autoAccept`);
        if (messageContext.connection) {
          const { message } = await this.credentialProtocol.acceptOffer(messageContext.agentContext, { credentialRecord });
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            connection: messageContext.connection,
            associatedRecord: credentialRecord
          });
        } else if (messageContext.message.service) {
          const routingService = messageContext.agentContext.dependencyManager.resolve(RoutingService_1.RoutingService);
          const routing = await routingService.getRouting(messageContext.agentContext);
          const ourService = new ServiceDecorator_1.ServiceDecorator({
            serviceEndpoint: routing.endpoints[0],
            recipientKeys: [routing.recipientKey.publicKeyBase58],
            routingKeys: routing.routingKeys.map((key) => key.publicKeyBase58)
          });
          const recipientService = messageContext.message.service;
          const { message } = await this.credentialProtocol.acceptOffer(messageContext.agentContext, {
            credentialRecord,
            credentialFormats: {
              indy: {
                holderDid: ourService.recipientKeys[0]
              }
            }
          });
          message.service = ourService;
          const didCommMessageRepository = messageContext.agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
          await didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
            agentMessage: message,
            role: storage_1.DidCommMessageRole.Sender,
            associatedRecordId: credentialRecord.id
          });
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            serviceParams: {
              service: recipientService.resolvedDidCommService,
              senderKey: ourService.resolvedDidCommService.recipientKeys[0]
            }
          });
        }
        messageContext.agentContext.config.logger.error(`Could not automatically create credential request`);
      }
    };
    exports.V1OfferCredentialHandler = V1OfferCredentialHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/handlers/V1ProposeCredentialHandler.js
var require_V1ProposeCredentialHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/handlers/V1ProposeCredentialHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1ProposeCredentialHandler = void 0;
    var models_1 = require_models3();
    var messages_1 = require_messages10();
    var V1ProposeCredentialHandler = class {
      constructor(credentialProtocol) {
        this.supportedMessages = [messages_1.V1ProposeCredentialMessage];
        this.credentialProtocol = credentialProtocol;
      }
      async handle(messageContext) {
        const credentialRecord = await this.credentialProtocol.processProposal(messageContext);
        const shouldAutoAcceptProposal = await this.credentialProtocol.shouldAutoRespondToProposal(messageContext.agentContext, {
          credentialRecord,
          proposalMessage: messageContext.message
        });
        if (shouldAutoAcceptProposal) {
          return await this.acceptProposal(credentialRecord, messageContext);
        }
      }
      async acceptProposal(credentialRecord, messageContext) {
        messageContext.agentContext.config.logger.info(`Automatically sending offer with autoAccept`);
        if (!messageContext.connection) {
          messageContext.agentContext.config.logger.error("No connection on the messageContext, aborting auto accept");
          return;
        }
        const { message } = await this.credentialProtocol.acceptProposal(messageContext.agentContext, {
          credentialRecord
        });
        return new models_1.OutboundMessageContext(message, {
          agentContext: messageContext.agentContext,
          connection: messageContext.connection,
          associatedRecord: credentialRecord
        });
      }
    };
    exports.V1ProposeCredentialHandler = V1ProposeCredentialHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/handlers/V1RequestCredentialHandler.js
var require_V1RequestCredentialHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/handlers/V1RequestCredentialHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1RequestCredentialHandler = void 0;
    var models_1 = require_models3();
    var storage_1 = require_storage();
    var messages_1 = require_messages10();
    var V1RequestCredentialHandler = class {
      constructor(credentialProtocol) {
        this.supportedMessages = [messages_1.V1RequestCredentialMessage];
        this.credentialProtocol = credentialProtocol;
      }
      async handle(messageContext) {
        const credentialRecord = await this.credentialProtocol.processRequest(messageContext);
        const shouldAutoRespond = await this.credentialProtocol.shouldAutoRespondToRequest(messageContext.agentContext, {
          credentialRecord,
          requestMessage: messageContext.message
        });
        if (shouldAutoRespond) {
          return await this.acceptRequest(credentialRecord, messageContext);
        }
      }
      async acceptRequest(credentialRecord, messageContext) {
        messageContext.agentContext.config.logger.info(`Automatically sending credential with autoAccept`);
        const offerMessage = await this.credentialProtocol.findOfferMessage(messageContext.agentContext, credentialRecord.id);
        const { message } = await this.credentialProtocol.acceptRequest(messageContext.agentContext, {
          credentialRecord
        });
        if (messageContext.connection) {
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            connection: messageContext.connection,
            associatedRecord: credentialRecord
          });
        } else if (messageContext.message.service && (offerMessage === null || offerMessage === void 0 ? void 0 : offerMessage.service)) {
          const recipientService = messageContext.message.service;
          const ourService = offerMessage.service;
          message.setService(ourService);
          const didCommMessageRepository = messageContext.agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
          await didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
            agentMessage: message,
            role: storage_1.DidCommMessageRole.Sender,
            associatedRecordId: credentialRecord.id
          });
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            serviceParams: {
              service: recipientService.resolvedDidCommService,
              senderKey: ourService.resolvedDidCommService.recipientKeys[0]
            }
          });
        }
        messageContext.agentContext.config.logger.error(`Could not automatically create credential request`);
      }
    };
    exports.V1RequestCredentialHandler = V1RequestCredentialHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/handlers/V1CredentialProblemReportHandler.js
var require_V1CredentialProblemReportHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/handlers/V1CredentialProblemReportHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1CredentialProblemReportHandler = void 0;
    var messages_1 = require_messages10();
    var V1CredentialProblemReportHandler = class {
      constructor(credentialProtocol) {
        this.supportedMessages = [messages_1.V1CredentialProblemReportMessage];
        this.credentialProtocol = credentialProtocol;
      }
      async handle(messageContext) {
        await this.credentialProtocol.processProblemReport(messageContext);
      }
    };
    exports.V1CredentialProblemReportHandler = V1CredentialProblemReportHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/handlers/index.js
var require_handlers9 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/handlers/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_V1CredentialAckHandler(), exports);
    __exportStar(require_V1IssueCredentialHandler(), exports);
    __exportStar(require_V1OfferCredentialHandler(), exports);
    __exportStar(require_V1ProposeCredentialHandler(), exports);
    __exportStar(require_V1RequestCredentialHandler(), exports);
    __exportStar(require_V1CredentialProblemReportHandler(), exports);
    __exportStar(require_V1RevocationNotificationHandler(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/V1CredentialProtocol.js
var require_V1CredentialProtocol = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/V1CredentialProtocol.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1CredentialProtocol = void 0;
    var features_1 = require_features();
    var Attachment_1 = require_Attachment();
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var storage_1 = require_storage();
    var utils_1 = require_utils();
    var attachment_1 = require_attachment();
    var uuid_1 = require_uuid();
    var common_1 = require_common();
    var services_1 = require_services3();
    var CredentialsModuleConfig_1 = require_CredentialsModuleConfig();
    var errors_1 = require_errors3();
    var models_1 = require_models7();
    var CredentialAutoAcceptType_1 = require_CredentialAutoAcceptType();
    var CredentialState_1 = require_CredentialState();
    var repository_1 = require_repository6();
    var composeAutoAccept_1 = require_composeAutoAccept();
    var previewAttributes_1 = require_previewAttributes();
    var BaseCredentialProtocol_1 = require_BaseCredentialProtocol();
    var handlers_1 = require_handlers9();
    var messages_1 = require_messages10();
    var V1CredentialPreview_1 = require_V1CredentialPreview();
    var V1CredentialProtocol = class V1CredentialProtocol extends BaseCredentialProtocol_1.BaseCredentialProtocol {
      constructor({ indyCredentialFormat }) {
        super();
        this.version = "v1";
        this.indyCredentialFormat = indyCredentialFormat;
      }
      /**
       * Registers the protocol implementation (handlers, feature registry) on the agent.
       */
      register(dependencyManager, featureRegistry) {
        dependencyManager.registerMessageHandlers([
          new handlers_1.V1ProposeCredentialHandler(this),
          new handlers_1.V1OfferCredentialHandler(this),
          new handlers_1.V1RequestCredentialHandler(this),
          new handlers_1.V1IssueCredentialHandler(this),
          new handlers_1.V1CredentialAckHandler(this),
          new handlers_1.V1CredentialProblemReportHandler(this)
        ]);
        featureRegistry.register(new features_1.Protocol({
          id: "https://didcomm.org/issue-credential/1.0",
          roles: ["holder", "issuer"]
        }));
      }
      /**
       * Create a {@link ProposeCredentialMessage} not bound to an existing credential exchange.
       * To create a proposal as response to an existing credential exchange, use {@link createProposalAsResponse}.
       *
       * @param options The object containing config options
       * @returns Object containing proposal message and associated credential record
       *
       */
      async createProposal(agentContext, { connection, credentialFormats, comment, autoAcceptCredential }) {
        this.assertOnlyIndyFormat(credentialFormats);
        const credentialRepository = agentContext.dependencyManager.resolve(repository_1.CredentialRepository);
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        if (!credentialFormats.indy) {
          throw new error_1.AriesFrameworkError("Missing indy credential format in v1 create proposal call.");
        }
        const { linkedAttachments } = credentialFormats.indy;
        const credentialRecord = new repository_1.CredentialExchangeRecord({
          connectionId: connection.id,
          threadId: (0, uuid_1.uuid)(),
          state: CredentialState_1.CredentialState.ProposalSent,
          linkedAttachments: linkedAttachments === null || linkedAttachments === void 0 ? void 0 : linkedAttachments.map((linkedAttachment) => linkedAttachment.attachment),
          autoAcceptCredential,
          protocolVersion: "v1"
        });
        const { previewAttributes, attachment } = await this.indyCredentialFormat.createProposal(agentContext, {
          credentialFormats,
          credentialRecord
        });
        const indyCredentialProposal = utils_1.JsonTransformer.fromJSON(attachment.getDataAsJson(), models_1.IndyCredPropose);
        const credentialProposal = previewAttributes ? new V1CredentialPreview_1.V1CredentialPreview({
          attributes: previewAttributes
        }) : void 0;
        const message = new messages_1.V1ProposeCredentialMessage(Object.assign(Object.assign({}, indyCredentialProposal), { id: credentialRecord.threadId, credentialPreview: credentialProposal, comment }));
        await didCommMessageRepository.saveAgentMessage(agentContext, {
          agentMessage: message,
          role: storage_1.DidCommMessageRole.Sender,
          associatedRecordId: credentialRecord.id
        });
        credentialRecord.credentialAttributes = previewAttributes;
        await credentialRepository.save(agentContext, credentialRecord);
        this.emitStateChangedEvent(agentContext, credentialRecord, null);
        return { credentialRecord, message };
      }
      /**
       * Process a received {@link ProposeCredentialMessage}. This will not accept the credential proposal
       * or send a credential offer. It will only create a new, or update the existing credential record with
       * the information from the credential proposal message. Use {@link createOfferAsResponse}
       * after calling this method to create a credential offer.
       *
       * @param messageContext The message context containing a credential proposal message
       * @returns credential record associated with the credential proposal message
       *
       */
      async processProposal(messageContext) {
        const { message: proposalMessage, connection, agentContext } = messageContext;
        const credentialRepository = agentContext.dependencyManager.resolve(repository_1.CredentialRepository);
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const connectionService = agentContext.dependencyManager.resolve(services_1.ConnectionService);
        agentContext.config.logger.debug(`Processing credential proposal with message id ${proposalMessage.id}`);
        let credentialRecord = await this.findByThreadAndConnectionId(messageContext.agentContext, proposalMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        if (credentialRecord) {
          agentContext.config.logger.debug("Credential record already exists for incoming proposal");
          credentialRecord.assertProtocolVersion("v1");
          credentialRecord.assertState(CredentialState_1.CredentialState.OfferSent);
          const proposalCredentialMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: credentialRecord.id,
            messageClass: messages_1.V1ProposeCredentialMessage
          });
          const offerCredentialMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: credentialRecord.id,
            messageClass: messages_1.V1OfferCredentialMessage
          });
          connectionService.assertConnectionOrServiceDecorator(messageContext, {
            previousReceivedMessage: proposalCredentialMessage !== null && proposalCredentialMessage !== void 0 ? proposalCredentialMessage : void 0,
            previousSentMessage: offerCredentialMessage !== null && offerCredentialMessage !== void 0 ? offerCredentialMessage : void 0
          });
          await this.indyCredentialFormat.processProposal(messageContext.agentContext, {
            credentialRecord,
            attachment: new Attachment_1.Attachment({
              data: new Attachment_1.AttachmentData({
                json: utils_1.JsonTransformer.toJSON(this.rfc0592ProposalFromV1ProposeMessage(proposalMessage))
              })
            })
          });
          await this.updateState(messageContext.agentContext, credentialRecord, CredentialState_1.CredentialState.ProposalReceived);
          await didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
            agentMessage: proposalMessage,
            role: storage_1.DidCommMessageRole.Receiver,
            associatedRecordId: credentialRecord.id
          });
        } else {
          agentContext.config.logger.debug("Credential record does not exists yet for incoming proposal");
          credentialRecord = new repository_1.CredentialExchangeRecord({
            connectionId: connection === null || connection === void 0 ? void 0 : connection.id,
            threadId: proposalMessage.threadId,
            state: CredentialState_1.CredentialState.ProposalReceived,
            protocolVersion: "v1"
          });
          connectionService.assertConnectionOrServiceDecorator(messageContext);
          await credentialRepository.save(messageContext.agentContext, credentialRecord);
          this.emitStateChangedEvent(messageContext.agentContext, credentialRecord, null);
          await didCommMessageRepository.saveAgentMessage(messageContext.agentContext, {
            agentMessage: proposalMessage,
            role: storage_1.DidCommMessageRole.Receiver,
            associatedRecordId: credentialRecord.id
          });
        }
        return credentialRecord;
      }
      /**
       * Processing an incoming credential message and create a credential offer as a response
       * @param options The object containing config options
       * @returns Object containing proposal message and associated credential record
       */
      async acceptProposal(agentContext, { credentialRecord, credentialFormats, comment, autoAcceptCredential }) {
        var _a;
        credentialRecord.assertProtocolVersion("v1");
        credentialRecord.assertState(CredentialState_1.CredentialState.ProposalReceived);
        if (credentialFormats)
          this.assertOnlyIndyFormat(credentialFormats);
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const proposalMessage = await didCommMessageRepository.getAgentMessage(agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: messages_1.V1ProposeCredentialMessage
        });
        credentialRecord.credentialAttributes = (_a = proposalMessage.credentialPreview) === null || _a === void 0 ? void 0 : _a.attributes;
        const { attachment, previewAttributes } = await this.indyCredentialFormat.acceptProposal(agentContext, {
          attachId: messages_1.INDY_CREDENTIAL_OFFER_ATTACHMENT_ID,
          credentialFormats,
          credentialRecord,
          proposalAttachment: new Attachment_1.Attachment({
            data: new Attachment_1.AttachmentData({
              json: utils_1.JsonTransformer.toJSON(this.rfc0592ProposalFromV1ProposeMessage(proposalMessage))
            })
          })
        });
        if (!previewAttributes) {
          throw new error_1.AriesFrameworkError("Missing required credential preview attributes from indy format service");
        }
        const message = new messages_1.V1OfferCredentialMessage({
          comment,
          offerAttachments: [attachment],
          credentialPreview: new V1CredentialPreview_1.V1CredentialPreview({
            attributes: previewAttributes
          }),
          attachments: credentialRecord.linkedAttachments
        });
        message.setThread({ threadId: credentialRecord.threadId });
        credentialRecord.credentialAttributes = previewAttributes;
        credentialRecord.autoAcceptCredential = autoAcceptCredential !== null && autoAcceptCredential !== void 0 ? autoAcceptCredential : credentialRecord.autoAcceptCredential;
        await this.updateState(agentContext, credentialRecord, CredentialState_1.CredentialState.OfferSent);
        await didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: message,
          role: storage_1.DidCommMessageRole.Sender,
          associatedRecordId: credentialRecord.id
        });
        return { credentialRecord, message };
      }
      /**
       * Negotiate a credential proposal as issuer (by sending a credential offer message) to the connection
       * associated with the credential record.
       *
       * @param options configuration for the offer see {@link NegotiateProposalOptions}
       * @returns Credential record associated with the credential offer and the corresponding new offer message
       *
       */
      async negotiateProposal(agentContext, { credentialFormats, credentialRecord, comment, autoAcceptCredential }) {
        credentialRecord.assertProtocolVersion("v1");
        credentialRecord.assertState(CredentialState_1.CredentialState.ProposalReceived);
        if (credentialFormats)
          this.assertOnlyIndyFormat(credentialFormats);
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const { attachment, previewAttributes } = await this.indyCredentialFormat.createOffer(agentContext, {
          attachId: messages_1.INDY_CREDENTIAL_OFFER_ATTACHMENT_ID,
          credentialFormats,
          credentialRecord
        });
        if (!previewAttributes) {
          throw new error_1.AriesFrameworkError("Missing required credential preview attributes from indy format service");
        }
        const message = new messages_1.V1OfferCredentialMessage({
          comment,
          offerAttachments: [attachment],
          credentialPreview: new V1CredentialPreview_1.V1CredentialPreview({
            attributes: previewAttributes
          }),
          attachments: credentialRecord.linkedAttachments
        });
        message.setThread({ threadId: credentialRecord.threadId });
        credentialRecord.credentialAttributes = previewAttributes;
        credentialRecord.autoAcceptCredential = autoAcceptCredential !== null && autoAcceptCredential !== void 0 ? autoAcceptCredential : credentialRecord.autoAcceptCredential;
        await this.updateState(agentContext, credentialRecord, CredentialState_1.CredentialState.OfferSent);
        await didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: message,
          role: storage_1.DidCommMessageRole.Sender,
          associatedRecordId: credentialRecord.id
        });
        return { credentialRecord, message };
      }
      /**
       * Create a {@link OfferCredentialMessage} not bound to an existing credential exchange.
       * To create an offer as response to an existing credential exchange, use {@link V1CredentialProtocol#createOfferAsResponse}.
       *
       * @param options The options containing config params for creating the credential offer
       * @returns Object containing offer message and associated credential record
       *
       */
      async createOffer(agentContext, { credentialFormats, autoAcceptCredential, comment, connection }) {
        var _a, _b;
        if (credentialFormats)
          this.assertOnlyIndyFormat(credentialFormats);
        const credentialRepository = agentContext.dependencyManager.resolve(repository_1.CredentialRepository);
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        if (!credentialFormats.indy) {
          throw new error_1.AriesFrameworkError("Missing indy credential format data for v1 create offer");
        }
        const credentialRecord = new repository_1.CredentialExchangeRecord({
          connectionId: connection === null || connection === void 0 ? void 0 : connection.id,
          threadId: (0, uuid_1.uuid)(),
          linkedAttachments: (_a = credentialFormats.indy.linkedAttachments) === null || _a === void 0 ? void 0 : _a.map((linkedAttachments) => linkedAttachments.attachment),
          state: CredentialState_1.CredentialState.OfferSent,
          autoAcceptCredential,
          protocolVersion: "v1"
        });
        const { attachment, previewAttributes } = await this.indyCredentialFormat.createOffer(agentContext, {
          attachId: messages_1.INDY_CREDENTIAL_OFFER_ATTACHMENT_ID,
          credentialFormats,
          credentialRecord
        });
        if (!previewAttributes) {
          throw new error_1.AriesFrameworkError("Missing required credential preview from indy format service");
        }
        const message = new messages_1.V1OfferCredentialMessage({
          id: credentialRecord.threadId,
          credentialPreview: new V1CredentialPreview_1.V1CredentialPreview({
            attributes: previewAttributes
          }),
          comment,
          offerAttachments: [attachment],
          attachments: (_b = credentialFormats.indy.linkedAttachments) === null || _b === void 0 ? void 0 : _b.map((linkedAttachments) => linkedAttachments.attachment)
        });
        await didCommMessageRepository.saveAgentMessage(agentContext, {
          associatedRecordId: credentialRecord.id,
          agentMessage: message,
          role: storage_1.DidCommMessageRole.Sender
        });
        credentialRecord.credentialAttributes = previewAttributes;
        await credentialRepository.save(agentContext, credentialRecord);
        this.emitStateChangedEvent(agentContext, credentialRecord, null);
        return { message, credentialRecord };
      }
      /**
       * Process a received {@link OfferCredentialMessage}. This will not accept the credential offer
       * or send a credential request. It will only create a new credential record with
       * the information from the credential offer message. Use {@link createRequest}
       * after calling this method to create a credential request.
       *
       * @param messageContext The message context containing a credential request message
       * @returns credential record associated with the credential offer message
       *
       */
      async processOffer(messageContext) {
        const { message: offerMessage, connection, agentContext } = messageContext;
        const credentialRepository = agentContext.dependencyManager.resolve(repository_1.CredentialRepository);
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const connectionService = agentContext.dependencyManager.resolve(services_1.ConnectionService);
        agentContext.config.logger.debug(`Processing credential offer with id ${offerMessage.id}`);
        let credentialRecord = await this.findByThreadAndConnectionId(messageContext.agentContext, offerMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        const offerAttachment = offerMessage.getOfferAttachmentById(messages_1.INDY_CREDENTIAL_OFFER_ATTACHMENT_ID);
        if (!offerAttachment) {
          throw new error_1.AriesFrameworkError(`Indy attachment with id ${messages_1.INDY_CREDENTIAL_OFFER_ATTACHMENT_ID} not found in offer message`);
        }
        if (credentialRecord) {
          const proposalCredentialMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: credentialRecord.id,
            messageClass: messages_1.V1ProposeCredentialMessage
          });
          const offerCredentialMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: credentialRecord.id,
            messageClass: messages_1.V1OfferCredentialMessage
          });
          credentialRecord.assertProtocolVersion("v1");
          credentialRecord.assertState(CredentialState_1.CredentialState.ProposalSent);
          connectionService.assertConnectionOrServiceDecorator(messageContext, {
            previousReceivedMessage: offerCredentialMessage !== null && offerCredentialMessage !== void 0 ? offerCredentialMessage : void 0,
            previousSentMessage: proposalCredentialMessage !== null && proposalCredentialMessage !== void 0 ? proposalCredentialMessage : void 0
          });
          await this.indyCredentialFormat.processOffer(messageContext.agentContext, {
            credentialRecord,
            attachment: offerAttachment
          });
          await didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
            agentMessage: offerMessage,
            role: storage_1.DidCommMessageRole.Receiver,
            associatedRecordId: credentialRecord.id
          });
          await this.updateState(messageContext.agentContext, credentialRecord, CredentialState_1.CredentialState.OfferReceived);
          return credentialRecord;
        } else {
          credentialRecord = new repository_1.CredentialExchangeRecord({
            connectionId: connection === null || connection === void 0 ? void 0 : connection.id,
            threadId: offerMessage.id,
            state: CredentialState_1.CredentialState.OfferReceived,
            protocolVersion: "v1"
          });
          connectionService.assertConnectionOrServiceDecorator(messageContext);
          await this.indyCredentialFormat.processOffer(messageContext.agentContext, {
            credentialRecord,
            attachment: offerAttachment
          });
          await didCommMessageRepository.saveAgentMessage(messageContext.agentContext, {
            agentMessage: offerMessage,
            role: storage_1.DidCommMessageRole.Receiver,
            associatedRecordId: credentialRecord.id
          });
          await credentialRepository.save(messageContext.agentContext, credentialRecord);
          this.emitStateChangedEvent(messageContext.agentContext, credentialRecord, null);
          return credentialRecord;
        }
      }
      /**
       * Create a {@link RequestCredentialMessage} as response to a received credential offer.
       *
       * @param options configuration to use for the credential request
       * @returns Object containing request message and associated credential record
       *
       */
      async acceptOffer(agentContext, { credentialRecord, credentialFormats, comment, autoAcceptCredential }) {
        var _a, _b;
        credentialRecord.assertProtocolVersion("v1");
        credentialRecord.assertState(CredentialState_1.CredentialState.OfferReceived);
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const offerMessage = await didCommMessageRepository.getAgentMessage(agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: messages_1.V1OfferCredentialMessage
        });
        const offerAttachment = offerMessage.getOfferAttachmentById(messages_1.INDY_CREDENTIAL_OFFER_ATTACHMENT_ID);
        if (!offerAttachment) {
          throw new error_1.AriesFrameworkError(`Indy attachment with id ${messages_1.INDY_CREDENTIAL_OFFER_ATTACHMENT_ID} not found in offer message`);
        }
        const { attachment } = await this.indyCredentialFormat.acceptOffer(agentContext, {
          credentialRecord,
          credentialFormats,
          attachId: messages_1.INDY_CREDENTIAL_REQUEST_ATTACHMENT_ID,
          offerAttachment
        });
        const requestMessage = new messages_1.V1RequestCredentialMessage({
          comment,
          requestAttachments: [attachment],
          attachments: (_a = offerMessage.appendedAttachments) === null || _a === void 0 ? void 0 : _a.filter((attachment2) => (0, attachment_1.isLinkedAttachment)(attachment2))
        });
        requestMessage.setThread({ threadId: credentialRecord.threadId });
        credentialRecord.credentialAttributes = offerMessage.credentialPreview.attributes;
        credentialRecord.autoAcceptCredential = autoAcceptCredential !== null && autoAcceptCredential !== void 0 ? autoAcceptCredential : credentialRecord.autoAcceptCredential;
        credentialRecord.linkedAttachments = (_b = offerMessage.appendedAttachments) === null || _b === void 0 ? void 0 : _b.filter((attachment2) => (0, attachment_1.isLinkedAttachment)(attachment2));
        await didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: requestMessage,
          associatedRecordId: credentialRecord.id,
          role: storage_1.DidCommMessageRole.Sender
        });
        await this.updateState(agentContext, credentialRecord, CredentialState_1.CredentialState.RequestSent);
        return { message: requestMessage, credentialRecord };
      }
      /**
       * Process a received {@link RequestCredentialMessage}. This will not accept the credential request
       * or send a credential. It will only update the existing credential record with
       * the information from the credential request message. Use {@link createCredential}
       * after calling this method to create a credential.
       *
       * @param messageContext The message context containing a credential request message
       * @returns credential record associated with the credential request message
       *
       */
      async negotiateOffer(agentContext, { credentialFormats, credentialRecord, autoAcceptCredential, comment }) {
        credentialRecord.assertProtocolVersion("v1");
        credentialRecord.assertState(CredentialState_1.CredentialState.OfferReceived);
        this.assertOnlyIndyFormat(credentialFormats);
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        if (!credentialRecord.connectionId) {
          throw new error_1.AriesFrameworkError(`No connectionId found for credential record '${credentialRecord.id}'. Connection-less issuance does not support negotiation.`);
        }
        if (!credentialFormats.indy) {
          throw new error_1.AriesFrameworkError("Missing indy credential format in v1 create proposal call.");
        }
        const { linkedAttachments } = credentialFormats.indy;
        const { previewAttributes, attachment } = await this.indyCredentialFormat.createProposal(agentContext, {
          credentialFormats,
          credentialRecord
        });
        const indyCredentialProposal = utils_1.JsonTransformer.fromJSON(attachment.getDataAsJson(), models_1.IndyCredPropose);
        const credentialProposal = previewAttributes ? new V1CredentialPreview_1.V1CredentialPreview({
          attributes: previewAttributes
        }) : void 0;
        const message = new messages_1.V1ProposeCredentialMessage(Object.assign(Object.assign({}, indyCredentialProposal), { credentialPreview: credentialProposal, comment }));
        message.setThread({ threadId: credentialRecord.threadId });
        await didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: message,
          role: storage_1.DidCommMessageRole.Sender,
          associatedRecordId: credentialRecord.id
        });
        credentialRecord.credentialAttributes = previewAttributes;
        credentialRecord.linkedAttachments = linkedAttachments === null || linkedAttachments === void 0 ? void 0 : linkedAttachments.map((attachment2) => attachment2.attachment);
        credentialRecord.autoAcceptCredential = autoAcceptCredential !== null && autoAcceptCredential !== void 0 ? autoAcceptCredential : credentialRecord.autoAcceptCredential;
        await this.updateState(agentContext, credentialRecord, CredentialState_1.CredentialState.ProposalSent);
        return { credentialRecord, message };
      }
      /**
       * Starting from a request is not supported in v1 of the issue credential protocol
       * because indy doesn't allow to start from a request
       */
      async createRequest() {
        throw new error_1.AriesFrameworkError("Starting from a request is not supported for v1 issue credential protocol");
      }
      /**
       * Process a received {@link IssueCredentialMessage}. This will not accept the credential
       * or send a credential acknowledgement. It will only update the existing credential record with
       * the information from the issue credential message. Use {@link createAck}
       * after calling this method to create a credential acknowledgement.
       *
       * @param messageContext The message context containing an issue credential message
       *
       * @returns credential record associated with the issue credential message
       *
       */
      async processRequest(messageContext) {
        const { message: requestMessage, connection, agentContext } = messageContext;
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const connectionService = agentContext.dependencyManager.resolve(services_1.ConnectionService);
        agentContext.config.logger.debug(`Processing credential request with id ${requestMessage.id}`);
        const credentialRecord = await this.getByThreadAndConnectionId(messageContext.agentContext, requestMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        agentContext.config.logger.trace("Credential record found when processing credential request", credentialRecord);
        const proposalMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: messages_1.V1ProposeCredentialMessage
        });
        const offerMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: messages_1.V1OfferCredentialMessage
        });
        credentialRecord.assertProtocolVersion("v1");
        credentialRecord.assertState(CredentialState_1.CredentialState.OfferSent);
        connectionService.assertConnectionOrServiceDecorator(messageContext, {
          previousReceivedMessage: proposalMessage !== null && proposalMessage !== void 0 ? proposalMessage : void 0,
          previousSentMessage: offerMessage !== null && offerMessage !== void 0 ? offerMessage : void 0
        });
        const requestAttachment = requestMessage.getRequestAttachmentById(messages_1.INDY_CREDENTIAL_REQUEST_ATTACHMENT_ID);
        if (!requestAttachment) {
          throw new error_1.AriesFrameworkError(`Indy attachment with id ${messages_1.INDY_CREDENTIAL_REQUEST_ATTACHMENT_ID} not found in request message`);
        }
        await this.indyCredentialFormat.processRequest(messageContext.agentContext, {
          credentialRecord,
          attachment: requestAttachment
        });
        await didCommMessageRepository.saveAgentMessage(messageContext.agentContext, {
          agentMessage: requestMessage,
          role: storage_1.DidCommMessageRole.Receiver,
          associatedRecordId: credentialRecord.id
        });
        await this.updateState(messageContext.agentContext, credentialRecord, CredentialState_1.CredentialState.RequestReceived);
        return credentialRecord;
      }
      /**
       * Create a {@link IssueCredentialMessage} as response to a received credential request.
       *
       * @returns Object containing issue credential message and associated credential record
       *
       */
      async acceptRequest(agentContext, { credentialRecord, credentialFormats, comment, autoAcceptCredential }) {
        credentialRecord.assertProtocolVersion("v1");
        credentialRecord.assertState(CredentialState_1.CredentialState.RequestReceived);
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const offerMessage = await didCommMessageRepository.getAgentMessage(agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: messages_1.V1OfferCredentialMessage
        });
        const requestMessage = await didCommMessageRepository.getAgentMessage(agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: messages_1.V1RequestCredentialMessage
        });
        const offerAttachment = offerMessage.getOfferAttachmentById(messages_1.INDY_CREDENTIAL_OFFER_ATTACHMENT_ID);
        const requestAttachment = requestMessage.getRequestAttachmentById(messages_1.INDY_CREDENTIAL_REQUEST_ATTACHMENT_ID);
        if (!offerAttachment || !requestAttachment) {
          throw new error_1.AriesFrameworkError(`Missing data payload in offer or request attachment in credential Record ${credentialRecord.id}`);
        }
        const { attachment: credentialsAttach } = await this.indyCredentialFormat.acceptRequest(agentContext, {
          credentialRecord,
          requestAttachment,
          offerAttachment,
          attachId: messages_1.INDY_CREDENTIAL_ATTACHMENT_ID,
          credentialFormats
        });
        const issueMessage = new messages_1.V1IssueCredentialMessage({
          comment,
          credentialAttachments: [credentialsAttach],
          attachments: credentialRecord.linkedAttachments
        });
        issueMessage.setThread({ threadId: credentialRecord.threadId });
        issueMessage.setPleaseAck();
        await didCommMessageRepository.saveAgentMessage(agentContext, {
          agentMessage: issueMessage,
          associatedRecordId: credentialRecord.id,
          role: storage_1.DidCommMessageRole.Sender
        });
        credentialRecord.autoAcceptCredential = autoAcceptCredential !== null && autoAcceptCredential !== void 0 ? autoAcceptCredential : credentialRecord.autoAcceptCredential;
        await this.updateState(agentContext, credentialRecord, CredentialState_1.CredentialState.CredentialIssued);
        return { message: issueMessage, credentialRecord };
      }
      /**
       * Process an incoming {@link IssueCredentialMessage}
       *
       * @param messageContext The message context containing a credential acknowledgement message
       * @returns credential record associated with the credential acknowledgement message
       *
       */
      async processCredential(messageContext) {
        const { message: issueMessage, connection, agentContext } = messageContext;
        agentContext.config.logger.debug(`Processing credential with id ${issueMessage.id}`);
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const connectionService = agentContext.dependencyManager.resolve(services_1.ConnectionService);
        const credentialRecord = await this.getByThreadAndConnectionId(messageContext.agentContext, issueMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        const requestCredentialMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: messages_1.V1RequestCredentialMessage
        });
        const offerCredentialMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: messages_1.V1OfferCredentialMessage
        });
        credentialRecord.assertProtocolVersion("v1");
        credentialRecord.assertState(CredentialState_1.CredentialState.RequestSent);
        connectionService.assertConnectionOrServiceDecorator(messageContext, {
          previousReceivedMessage: offerCredentialMessage !== null && offerCredentialMessage !== void 0 ? offerCredentialMessage : void 0,
          previousSentMessage: requestCredentialMessage !== null && requestCredentialMessage !== void 0 ? requestCredentialMessage : void 0
        });
        const issueAttachment = issueMessage.getCredentialAttachmentById(messages_1.INDY_CREDENTIAL_ATTACHMENT_ID);
        if (!issueAttachment) {
          throw new error_1.AriesFrameworkError("Missing indy credential attachment in processCredential");
        }
        const requestAttachment = requestCredentialMessage === null || requestCredentialMessage === void 0 ? void 0 : requestCredentialMessage.getRequestAttachmentById(messages_1.INDY_CREDENTIAL_REQUEST_ATTACHMENT_ID);
        if (!requestAttachment) {
          throw new error_1.AriesFrameworkError("Missing indy credential request attachment in processCredential");
        }
        await this.indyCredentialFormat.processCredential(messageContext.agentContext, {
          attachment: issueAttachment,
          credentialRecord,
          requestAttachment
        });
        await didCommMessageRepository.saveAgentMessage(messageContext.agentContext, {
          agentMessage: issueMessage,
          role: storage_1.DidCommMessageRole.Receiver,
          associatedRecordId: credentialRecord.id
        });
        await this.updateState(messageContext.agentContext, credentialRecord, CredentialState_1.CredentialState.CredentialReceived);
        return credentialRecord;
      }
      /**
       * Create a {@link CredentialAckMessage} as response to a received credential.
       *
       * @param credentialRecord The credential record for which to create the credential acknowledgement
       * @returns Object containing credential acknowledgement message and associated credential record
       *
       */
      async acceptCredential(agentContext, { credentialRecord }) {
        credentialRecord.assertProtocolVersion("v1");
        credentialRecord.assertState(CredentialState_1.CredentialState.CredentialReceived);
        const ackMessage = new messages_1.V1CredentialAckMessage({
          status: common_1.AckStatus.OK,
          threadId: credentialRecord.threadId
        });
        await this.updateState(agentContext, credentialRecord, CredentialState_1.CredentialState.Done);
        return { message: ackMessage, credentialRecord };
      }
      /**
       * Process a received {@link CredentialAckMessage}.
       *
       * @param messageContext The message context containing a credential acknowledgement message
       * @returns credential record associated with the credential acknowledgement message
       *
       */
      async processAck(messageContext) {
        const { message: ackMessage, connection, agentContext } = messageContext;
        agentContext.config.logger.debug(`Processing credential ack with id ${ackMessage.id}`);
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const connectionService = agentContext.dependencyManager.resolve(services_1.ConnectionService);
        const credentialRecord = await this.getByThreadAndConnectionId(messageContext.agentContext, ackMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        const requestCredentialMessage = await didCommMessageRepository.getAgentMessage(messageContext.agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: messages_1.V1RequestCredentialMessage
        });
        const issueCredentialMessage = await didCommMessageRepository.getAgentMessage(messageContext.agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: messages_1.V1IssueCredentialMessage
        });
        credentialRecord.assertProtocolVersion("v1");
        credentialRecord.assertState(CredentialState_1.CredentialState.CredentialIssued);
        connectionService.assertConnectionOrServiceDecorator(messageContext, {
          previousReceivedMessage: requestCredentialMessage,
          previousSentMessage: issueCredentialMessage
        });
        await this.updateState(messageContext.agentContext, credentialRecord, CredentialState_1.CredentialState.Done);
        return credentialRecord;
      }
      /**
       * Create a {@link V1CredentialProblemReportMessage} to be sent.
       *
       * @param message message to send
       * @returns a {@link V1CredentialProblemReportMessage}
       *
       */
      createProblemReport(agentContext, options) {
        return new messages_1.V1CredentialProblemReportMessage({
          description: {
            en: options.message,
            code: errors_1.CredentialProblemReportReason.IssuanceAbandoned
          }
        });
      }
      // AUTO RESPOND METHODS
      async shouldAutoRespondToProposal(agentContext, options) {
        const { credentialRecord, proposalMessage } = options;
        const credentialsModuleConfig = agentContext.dependencyManager.resolve(CredentialsModuleConfig_1.CredentialsModuleConfig);
        const autoAccept = (0, composeAutoAccept_1.composeAutoAccept)(credentialRecord.autoAcceptCredential, credentialsModuleConfig.autoAcceptCredentials);
        if (autoAccept === CredentialAutoAcceptType_1.AutoAcceptCredential.Always)
          return true;
        if (autoAccept === CredentialAutoAcceptType_1.AutoAcceptCredential.Never)
          return false;
        const offerMessage = await this.findOfferMessage(agentContext, credentialRecord.id);
        if (!offerMessage || !offerMessage.credentialPreview)
          return false;
        if (!proposalMessage.credentialPreview || !proposalMessage.credentialDefinitionId)
          return false;
        const credentialOfferJson = offerMessage.indyCredentialOffer;
        if (!credentialOfferJson)
          return false;
        if (credentialOfferJson.cred_def_id !== proposalMessage.credentialDefinitionId)
          return false;
        return (0, previewAttributes_1.arePreviewAttributesEqual)(proposalMessage.credentialPreview.attributes, offerMessage.credentialPreview.attributes);
      }
      async shouldAutoRespondToOffer(agentContext, options) {
        const { credentialRecord, offerMessage } = options;
        const credentialsModuleConfig = agentContext.dependencyManager.resolve(CredentialsModuleConfig_1.CredentialsModuleConfig);
        const autoAccept = (0, composeAutoAccept_1.composeAutoAccept)(credentialRecord.autoAcceptCredential, credentialsModuleConfig.autoAcceptCredentials);
        if (autoAccept === CredentialAutoAcceptType_1.AutoAcceptCredential.Always)
          return true;
        if (autoAccept === CredentialAutoAcceptType_1.AutoAcceptCredential.Never)
          return false;
        const proposalMessage = await this.findProposalMessage(agentContext, credentialRecord.id);
        if (!offerMessage.credentialPreview)
          return false;
        if (!proposalMessage || !proposalMessage.credentialPreview || !proposalMessage.credentialDefinitionId)
          return false;
        const credentialOfferJson = offerMessage.indyCredentialOffer;
        if (!credentialOfferJson)
          return false;
        if (credentialOfferJson.cred_def_id !== proposalMessage.credentialDefinitionId)
          return false;
        return (0, previewAttributes_1.arePreviewAttributesEqual)(proposalMessage.credentialPreview.attributes, offerMessage.credentialPreview.attributes);
      }
      async shouldAutoRespondToRequest(agentContext, options) {
        const { credentialRecord, requestMessage } = options;
        const credentialsModuleConfig = agentContext.dependencyManager.resolve(CredentialsModuleConfig_1.CredentialsModuleConfig);
        const autoAccept = (0, composeAutoAccept_1.composeAutoAccept)(credentialRecord.autoAcceptCredential, credentialsModuleConfig.autoAcceptCredentials);
        if (autoAccept === CredentialAutoAcceptType_1.AutoAcceptCredential.Always)
          return true;
        if (autoAccept === CredentialAutoAcceptType_1.AutoAcceptCredential.Never)
          return false;
        const offerMessage = await this.findOfferMessage(agentContext, credentialRecord.id);
        if (!offerMessage)
          return false;
        const offerAttachment = offerMessage.getOfferAttachmentById(messages_1.INDY_CREDENTIAL_OFFER_ATTACHMENT_ID);
        const requestAttachment = requestMessage.getRequestAttachmentById(messages_1.INDY_CREDENTIAL_REQUEST_ATTACHMENT_ID);
        if (!offerAttachment || !requestAttachment)
          return false;
        return this.indyCredentialFormat.shouldAutoRespondToRequest(agentContext, {
          credentialRecord,
          offerAttachment,
          requestAttachment
        });
      }
      async shouldAutoRespondToCredential(agentContext, options) {
        const { credentialRecord, credentialMessage } = options;
        const credentialsModuleConfig = agentContext.dependencyManager.resolve(CredentialsModuleConfig_1.CredentialsModuleConfig);
        const autoAccept = (0, composeAutoAccept_1.composeAutoAccept)(credentialRecord.autoAcceptCredential, credentialsModuleConfig.autoAcceptCredentials);
        if (autoAccept === CredentialAutoAcceptType_1.AutoAcceptCredential.Always)
          return true;
        if (autoAccept === CredentialAutoAcceptType_1.AutoAcceptCredential.Never)
          return false;
        const requestMessage = await this.findRequestMessage(agentContext, credentialRecord.id);
        const offerMessage = await this.findOfferMessage(agentContext, credentialRecord.id);
        const credentialAttachment = credentialMessage.getCredentialAttachmentById(messages_1.INDY_CREDENTIAL_ATTACHMENT_ID);
        if (!credentialAttachment)
          return false;
        const requestAttachment = requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.getRequestAttachmentById(messages_1.INDY_CREDENTIAL_REQUEST_ATTACHMENT_ID);
        if (!requestAttachment)
          return false;
        const offerAttachment = offerMessage === null || offerMessage === void 0 ? void 0 : offerMessage.getOfferAttachmentById(messages_1.INDY_CREDENTIAL_OFFER_ATTACHMENT_ID);
        return this.indyCredentialFormat.shouldAutoRespondToCredential(agentContext, {
          credentialRecord,
          credentialAttachment,
          requestAttachment,
          offerAttachment
        });
      }
      async findProposalMessage(agentContext, credentialExchangeId) {
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        return await didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: credentialExchangeId,
          messageClass: messages_1.V1ProposeCredentialMessage
        });
      }
      async findOfferMessage(agentContext, credentialExchangeId) {
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        return await didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: credentialExchangeId,
          messageClass: messages_1.V1OfferCredentialMessage
        });
      }
      async findRequestMessage(agentContext, credentialExchangeId) {
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        return await didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: credentialExchangeId,
          messageClass: messages_1.V1RequestCredentialMessage
        });
      }
      async findCredentialMessage(agentContext, credentialExchangeId) {
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        return await didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: credentialExchangeId,
          messageClass: messages_1.V1IssueCredentialMessage
        });
      }
      async getFormatData(agentContext, credentialExchangeId) {
        var _a, _b, _c, _d, _e;
        const [proposalMessage, offerMessage, requestMessage, credentialMessage] = await Promise.all([
          this.findProposalMessage(agentContext, credentialExchangeId),
          this.findOfferMessage(agentContext, credentialExchangeId),
          this.findRequestMessage(agentContext, credentialExchangeId),
          this.findCredentialMessage(agentContext, credentialExchangeId)
        ]);
        const indyProposal = proposalMessage ? utils_1.JsonTransformer.toJSON(this.rfc0592ProposalFromV1ProposeMessage(proposalMessage)) : void 0;
        const indyOffer = (_a = offerMessage === null || offerMessage === void 0 ? void 0 : offerMessage.indyCredentialOffer) !== null && _a !== void 0 ? _a : void 0;
        const indyRequest = (_b = requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.indyCredentialRequest) !== null && _b !== void 0 ? _b : void 0;
        const indyCredential = (_c = credentialMessage === null || credentialMessage === void 0 ? void 0 : credentialMessage.indyCredential) !== null && _c !== void 0 ? _c : void 0;
        return {
          proposalAttributes: (_d = proposalMessage === null || proposalMessage === void 0 ? void 0 : proposalMessage.credentialPreview) === null || _d === void 0 ? void 0 : _d.attributes,
          proposal: proposalMessage ? {
            indy: indyProposal
          } : void 0,
          offerAttributes: (_e = offerMessage === null || offerMessage === void 0 ? void 0 : offerMessage.credentialPreview) === null || _e === void 0 ? void 0 : _e.attributes,
          offer: offerMessage ? {
            indy: indyOffer
          } : void 0,
          request: requestMessage ? {
            indy: indyRequest
          } : void 0,
          credential: credentialMessage ? {
            indy: indyCredential
          } : void 0
        };
      }
      rfc0592ProposalFromV1ProposeMessage(proposalMessage) {
        const indyCredentialProposal = new models_1.IndyCredPropose({
          credentialDefinitionId: proposalMessage.credentialDefinitionId,
          schemaId: proposalMessage.schemaId,
          issuerDid: proposalMessage.issuerDid,
          schemaIssuerDid: proposalMessage.schemaIssuerDid,
          schemaName: proposalMessage.schemaName,
          schemaVersion: proposalMessage.schemaVersion
        });
        return indyCredentialProposal;
      }
      assertOnlyIndyFormat(credentialFormats) {
        const formatKeys = Object.keys(credentialFormats);
        if (formatKeys.length === 0)
          return;
        if (formatKeys.length !== 1 || !formatKeys.includes("indy")) {
          throw new error_1.AriesFrameworkError("Only indy credential format is supported for issue credential v1 protocol");
        }
      }
      getFormatServiceForRecordType(credentialRecordType) {
        if (credentialRecordType !== this.indyCredentialFormat.credentialRecordType) {
          throw new error_1.AriesFrameworkError(`Unsupported credential record type ${credentialRecordType} for v1 issue credential protocol (need ${this.indyCredentialFormat.credentialRecordType})`);
        }
        return this.indyCredentialFormat;
      }
    };
    V1CredentialProtocol = __decorate([
      (0, plugins_1.injectable)(),
      __metadata("design:paramtypes", [Object])
    ], V1CredentialProtocol);
    exports.V1CredentialProtocol = V1CredentialProtocol;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/index.js
var require_v13 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v1/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_V1CredentialProtocol(), exports);
    __exportStar(require_messages10(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/messages/V2CredentialAckMessage.js
var require_V2CredentialAckMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/messages/V2CredentialAckMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2CredentialAckMessage = void 0;
    var messageType_1 = require_messageType();
    var common_1 = require_common();
    var V2CredentialAckMessage = class extends common_1.AckMessage {
      /**
       * Create new CredentialAckMessage instance.
       * @param options
       */
      constructor(options) {
        super(options);
        this.type = V2CredentialAckMessage.type.messageTypeUri;
      }
    };
    V2CredentialAckMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/issue-credential/2.0/ack");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V2CredentialAckMessage.type),
      __metadata("design:type", Object)
    ], V2CredentialAckMessage.prototype, "type", void 0);
    exports.V2CredentialAckMessage = V2CredentialAckMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/messages/V2CredentialProblemReportMessage.js
var require_V2CredentialProblemReportMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/messages/V2CredentialProblemReportMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2CredentialProblemReportMessage = void 0;
    var messageType_1 = require_messageType();
    var ProblemReportMessage_1 = require_ProblemReportMessage();
    var V2CredentialProblemReportMessage = class extends ProblemReportMessage_1.ProblemReportMessage {
      /**
       * Create new CredentialProblemReportMessage instance.
       * @param options
       */
      constructor(options) {
        super(options);
        this.type = V2CredentialProblemReportMessage.type.messageTypeUri;
      }
    };
    V2CredentialProblemReportMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/issue-credential/2.0/problem-report");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V2CredentialProblemReportMessage.type),
      __metadata("design:type", Object)
    ], V2CredentialProblemReportMessage.prototype, "type", void 0);
    exports.V2CredentialProblemReportMessage = V2CredentialProblemReportMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/messages/V2IssueCredentialMessage.js
var require_V2IssueCredentialMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/messages/V2IssueCredentialMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2IssueCredentialMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var Attachment_1 = require_Attachment();
    var messageType_1 = require_messageType();
    var models_1 = require_models6();
    var V2IssueCredentialMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a;
        super();
        this.type = V2IssueCredentialMessage.type.messageTypeUri;
        if (options) {
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.comment = options.comment;
          this.formats = options.formats;
          this.credentialAttachments = options.credentialAttachments;
        }
      }
      getCredentialAttachmentById(id) {
        return this.credentialAttachments.find((attachment) => attachment.id == id);
      }
    };
    V2IssueCredentialMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/issue-credential/2.0/issue-credential");
    __decorate([
      (0, class_transformer_1.Type)(() => models_1.CredentialFormatSpec),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.IsInstance)(models_1.CredentialFormatSpec, { each: true }),
      __metadata("design:type", Array)
    ], V2IssueCredentialMessage.prototype, "formats", void 0);
    __decorate([
      (0, messageType_1.IsValidMessageType)(V2IssueCredentialMessage.type),
      __metadata("design:type", Object)
    ], V2IssueCredentialMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], V2IssueCredentialMessage.prototype, "comment", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "credentials~attach" }),
      (0, class_transformer_1.Type)(() => Attachment_1.Attachment),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)({
        each: true
      }),
      (0, class_validator_1.IsInstance)(Attachment_1.Attachment, { each: true }),
      __metadata("design:type", Array)
    ], V2IssueCredentialMessage.prototype, "credentialAttachments", void 0);
    exports.V2IssueCredentialMessage = V2IssueCredentialMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/messages/V2CredentialPreview.js
var require_V2CredentialPreview = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/messages/V2CredentialPreview.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2CredentialPreview = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var JsonTransformer_1 = require_JsonTransformer();
    var messageType_1 = require_messageType();
    var CredentialPreviewAttribute_1 = require_CredentialPreviewAttribute();
    var V2CredentialPreview = class {
      constructor(options) {
        this.type = V2CredentialPreview.type.messageTypeUri;
        if (options) {
          this.attributes = options.attributes;
        }
      }
      toJSON() {
        return JsonTransformer_1.JsonTransformer.toJSON(this);
      }
      /**
       * Create a credential preview from a record with name and value entries.
       *
       * @example
       * const preview = CredentialPreview.fromRecord({
       *   name: "Bob",
       *   age: "20"
       * })
       */
      static fromRecord(record) {
        const attributes = Object.entries(record).map(([name, value]) => new CredentialPreviewAttribute_1.CredentialPreviewAttribute({
          name,
          mimeType: "text/plain",
          value
        }));
        return new V2CredentialPreview({
          attributes
        });
      }
    };
    V2CredentialPreview.type = (0, messageType_1.parseMessageType)("https://didcomm.org/issue-credential/2.0/credential-preview");
    __decorate([
      (0, class_transformer_1.Expose)({ name: "@type" }),
      (0, messageType_1.IsValidMessageType)(V2CredentialPreview.type),
      (0, class_transformer_1.Transform)(({ value }) => (0, messageType_1.replaceLegacyDidSovPrefix)(value), {
        toClassOnly: true
      }),
      __metadata("design:type", Object)
    ], V2CredentialPreview.prototype, "type", void 0);
    __decorate([
      (0, class_transformer_1.Type)(() => CredentialPreviewAttribute_1.CredentialPreviewAttribute),
      (0, class_validator_1.ValidateNested)({ each: true }),
      (0, class_validator_1.IsInstance)(CredentialPreviewAttribute_1.CredentialPreviewAttribute, { each: true }),
      __metadata("design:type", Array)
    ], V2CredentialPreview.prototype, "attributes", void 0);
    exports.V2CredentialPreview = V2CredentialPreview;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/messages/V2OfferCredentialMessage.js
var require_V2OfferCredentialMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/messages/V2OfferCredentialMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2OfferCredentialMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var Attachment_1 = require_Attachment();
    var messageType_1 = require_messageType();
    var models_1 = require_models6();
    var V2CredentialPreview_1 = require_V2CredentialPreview();
    var V2OfferCredentialMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a;
        super();
        this.type = V2OfferCredentialMessage.type.messageTypeUri;
        if (options) {
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.comment = options.comment;
          this.formats = options.formats;
          this.credentialPreview = options.credentialPreview;
          this.offerAttachments = options.offerAttachments;
        }
      }
      getOfferAttachmentById(id) {
        return this.offerAttachments.find((attachment) => attachment.id == id);
      }
    };
    V2OfferCredentialMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/issue-credential/2.0/offer-credential");
    __decorate([
      (0, class_transformer_1.Type)(() => models_1.CredentialFormatSpec),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.IsInstance)(models_1.CredentialFormatSpec, { each: true }),
      __metadata("design:type", Array)
    ], V2OfferCredentialMessage.prototype, "formats", void 0);
    __decorate([
      (0, messageType_1.IsValidMessageType)(V2OfferCredentialMessage.type),
      __metadata("design:type", Object)
    ], V2OfferCredentialMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], V2OfferCredentialMessage.prototype, "comment", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "credential_preview" }),
      (0, class_transformer_1.Type)(() => V2CredentialPreview_1.V2CredentialPreview),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsInstance)(V2CredentialPreview_1.V2CredentialPreview),
      __metadata("design:type", V2CredentialPreview_1.V2CredentialPreview)
    ], V2OfferCredentialMessage.prototype, "credentialPreview", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "offers~attach" }),
      (0, class_transformer_1.Type)(() => Attachment_1.Attachment),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)({
        each: true
      }),
      (0, class_validator_1.IsInstance)(Attachment_1.Attachment, { each: true }),
      __metadata("design:type", Array)
    ], V2OfferCredentialMessage.prototype, "offerAttachments", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "replacement_id" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], V2OfferCredentialMessage.prototype, "replacementId", void 0);
    exports.V2OfferCredentialMessage = V2OfferCredentialMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/messages/V2ProposeCredentialMessage.js
var require_V2ProposeCredentialMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/messages/V2ProposeCredentialMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2ProposeCredentialMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var Attachment_1 = require_Attachment();
    var messageType_1 = require_messageType();
    var models_1 = require_models6();
    var V2CredentialPreview_1 = require_V2CredentialPreview();
    var V2ProposeCredentialMessage = class extends AgentMessage_1.AgentMessage {
      constructor(props) {
        var _a;
        super();
        this.type = V2ProposeCredentialMessage.type.messageTypeUri;
        if (props) {
          this.id = (_a = props.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.comment = props.comment;
          this.credentialPreview = props.credentialPreview;
          this.formats = props.formats;
          this.proposalAttachments = props.proposalAttachments;
          this.appendedAttachments = props.attachments;
        }
      }
      getProposalAttachmentById(id) {
        return this.proposalAttachments.find((attachment) => attachment.id == id);
      }
    };
    V2ProposeCredentialMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/issue-credential/2.0/propose-credential");
    __decorate([
      (0, class_transformer_1.Type)(() => models_1.CredentialFormatSpec),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsArray)(),
      __metadata("design:type", Array)
    ], V2ProposeCredentialMessage.prototype, "formats", void 0);
    __decorate([
      (0, messageType_1.IsValidMessageType)(V2ProposeCredentialMessage.type),
      __metadata("design:type", Object)
    ], V2ProposeCredentialMessage.prototype, "type", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "credential_preview" }),
      (0, class_transformer_1.Type)(() => V2CredentialPreview_1.V2CredentialPreview),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsInstance)(V2CredentialPreview_1.V2CredentialPreview),
      __metadata("design:type", V2CredentialPreview_1.V2CredentialPreview)
    ], V2ProposeCredentialMessage.prototype, "credentialPreview", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "filters~attach" }),
      (0, class_transformer_1.Type)(() => Attachment_1.Attachment),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)({
        each: true
      }),
      (0, class_validator_1.IsInstance)(Attachment_1.Attachment, { each: true }),
      __metadata("design:type", Array)
    ], V2ProposeCredentialMessage.prototype, "proposalAttachments", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], V2ProposeCredentialMessage.prototype, "comment", void 0);
    exports.V2ProposeCredentialMessage = V2ProposeCredentialMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/messages/V2RequestCredentialMessage.js
var require_V2RequestCredentialMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/messages/V2RequestCredentialMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2RequestCredentialMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var Attachment_1 = require_Attachment();
    var messageType_1 = require_messageType();
    var models_1 = require_models6();
    var V2RequestCredentialMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a;
        super();
        this.type = V2RequestCredentialMessage.type.messageTypeUri;
        if (options) {
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.comment = options.comment;
          this.formats = options.formats;
          this.requestAttachments = options.requestAttachments;
        }
      }
      getRequestAttachmentById(id) {
        return this.requestAttachments.find((attachment) => attachment.id == id);
      }
    };
    V2RequestCredentialMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/issue-credential/2.0/request-credential");
    __decorate([
      (0, class_transformer_1.Type)(() => models_1.CredentialFormatSpec),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.IsInstance)(models_1.CredentialFormatSpec, { each: true }),
      __metadata("design:type", Array)
    ], V2RequestCredentialMessage.prototype, "formats", void 0);
    __decorate([
      (0, messageType_1.IsValidMessageType)(V2RequestCredentialMessage.type),
      __metadata("design:type", Object)
    ], V2RequestCredentialMessage.prototype, "type", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "requests~attach" }),
      (0, class_transformer_1.Type)(() => Attachment_1.Attachment),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)({
        each: true
      }),
      (0, class_validator_1.IsInstance)(Attachment_1.Attachment, { each: true }),
      __metadata("design:type", Array)
    ], V2RequestCredentialMessage.prototype, "requestAttachments", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], V2RequestCredentialMessage.prototype, "comment", void 0);
    exports.V2RequestCredentialMessage = V2RequestCredentialMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/messages/index.js
var require_messages11 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/messages/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_V2CredentialAckMessage(), exports);
    __exportStar(require_V2CredentialProblemReportMessage(), exports);
    __exportStar(require_V2IssueCredentialMessage(), exports);
    __exportStar(require_V2OfferCredentialMessage(), exports);
    __exportStar(require_V2ProposeCredentialMessage(), exports);
    __exportStar(require_V2RequestCredentialMessage(), exports);
    __exportStar(require_V2CredentialPreview(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/CredentialFormatCoordinator.js
var require_CredentialFormatCoordinator = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/CredentialFormatCoordinator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CredentialFormatCoordinator = void 0;
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var storage_1 = require_storage();
    var messages_1 = require_messages11();
    var CredentialFormatCoordinator = class {
      /**
       * Create a {@link V2ProposeCredentialMessage}.
       *
       * @param options
       * @returns The created {@link V2ProposeCredentialMessage}
       *
       */
      async createProposal(agentContext, { credentialFormats, formatServices, credentialRecord, comment }) {
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const formats = [];
        const proposalAttachments = [];
        let credentialPreview;
        for (const formatService of formatServices) {
          const { format: format2, attachment, previewAttributes } = await formatService.createProposal(agentContext, {
            credentialFormats,
            credentialRecord
          });
          if (previewAttributes) {
            credentialPreview = new messages_1.V2CredentialPreview({
              attributes: previewAttributes
            });
          }
          proposalAttachments.push(attachment);
          formats.push(format2);
        }
        credentialRecord.credentialAttributes = credentialPreview === null || credentialPreview === void 0 ? void 0 : credentialPreview.attributes;
        const message = new messages_1.V2ProposeCredentialMessage({
          id: credentialRecord.threadId,
          formats,
          proposalAttachments,
          comment,
          credentialPreview
        });
        message.setThread({ threadId: credentialRecord.threadId });
        await didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: message,
          role: storage_1.DidCommMessageRole.Sender,
          associatedRecordId: credentialRecord.id
        });
        return message;
      }
      async processProposal(agentContext, { credentialRecord, message, formatServices }) {
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        for (const formatService of formatServices) {
          const attachment = this.getAttachmentForService(formatService, message.formats, message.proposalAttachments);
          await formatService.processProposal(agentContext, {
            attachment,
            credentialRecord
          });
        }
        await didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: message,
          role: storage_1.DidCommMessageRole.Receiver,
          associatedRecordId: credentialRecord.id
        });
      }
      async acceptProposal(agentContext, { credentialRecord, credentialFormats, formatServices, comment }) {
        var _a;
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const formats = [];
        const offerAttachments = [];
        let credentialPreview;
        const proposalMessage = await didCommMessageRepository.getAgentMessage(agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: messages_1.V2ProposeCredentialMessage
        });
        credentialRecord.credentialAttributes = (_a = proposalMessage.credentialPreview) === null || _a === void 0 ? void 0 : _a.attributes;
        for (const formatService of formatServices) {
          const proposalAttachment = this.getAttachmentForService(formatService, proposalMessage.formats, proposalMessage.proposalAttachments);
          const { attachment, format: format2, previewAttributes } = await formatService.acceptProposal(agentContext, {
            credentialRecord,
            credentialFormats,
            proposalAttachment
          });
          if (previewAttributes) {
            credentialPreview = new messages_1.V2CredentialPreview({
              attributes: previewAttributes
            });
          }
          offerAttachments.push(attachment);
          formats.push(format2);
        }
        credentialRecord.credentialAttributes = credentialPreview === null || credentialPreview === void 0 ? void 0 : credentialPreview.attributes;
        if (!credentialPreview) {
          credentialPreview = new messages_1.V2CredentialPreview({
            attributes: []
          });
        }
        const message = new messages_1.V2OfferCredentialMessage({
          formats,
          credentialPreview,
          offerAttachments,
          comment
        });
        message.setThread({ threadId: credentialRecord.threadId });
        await didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: message,
          associatedRecordId: credentialRecord.id,
          role: storage_1.DidCommMessageRole.Sender
        });
        return message;
      }
      /**
       * Create a {@link V2OfferCredentialMessage}.
       *
       * @param options
       * @returns The created {@link V2OfferCredentialMessage}
       *
       */
      async createOffer(agentContext, { credentialFormats, formatServices, credentialRecord, comment }) {
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const formats = [];
        const offerAttachments = [];
        let credentialPreview;
        for (const formatService of formatServices) {
          const { format: format2, attachment, previewAttributes } = await formatService.createOffer(agentContext, {
            credentialFormats,
            credentialRecord
          });
          if (previewAttributes) {
            credentialPreview = new messages_1.V2CredentialPreview({
              attributes: previewAttributes
            });
          }
          offerAttachments.push(attachment);
          formats.push(format2);
        }
        credentialRecord.credentialAttributes = credentialPreview === null || credentialPreview === void 0 ? void 0 : credentialPreview.attributes;
        if (!credentialPreview) {
          credentialPreview = new messages_1.V2CredentialPreview({
            attributes: []
          });
        }
        const message = new messages_1.V2OfferCredentialMessage({
          formats,
          comment,
          offerAttachments,
          credentialPreview
        });
        message.setThread({ threadId: credentialRecord.threadId });
        await didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: message,
          role: storage_1.DidCommMessageRole.Sender,
          associatedRecordId: credentialRecord.id
        });
        return message;
      }
      async processOffer(agentContext, { credentialRecord, message, formatServices }) {
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        for (const formatService of formatServices) {
          const attachment = this.getAttachmentForService(formatService, message.formats, message.offerAttachments);
          await formatService.processOffer(agentContext, {
            attachment,
            credentialRecord
          });
        }
        await didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: message,
          role: storage_1.DidCommMessageRole.Receiver,
          associatedRecordId: credentialRecord.id
        });
      }
      async acceptOffer(agentContext, { credentialRecord, credentialFormats, formatServices, comment }) {
        var _a;
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const offerMessage = await didCommMessageRepository.getAgentMessage(agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: messages_1.V2OfferCredentialMessage
        });
        const formats = [];
        const requestAttachments = [];
        for (const formatService of formatServices) {
          const offerAttachment = this.getAttachmentForService(formatService, offerMessage.formats, offerMessage.offerAttachments);
          const { attachment, format: format2 } = await formatService.acceptOffer(agentContext, {
            offerAttachment,
            credentialRecord,
            credentialFormats
          });
          requestAttachments.push(attachment);
          formats.push(format2);
        }
        credentialRecord.credentialAttributes = (_a = offerMessage.credentialPreview) === null || _a === void 0 ? void 0 : _a.attributes;
        const message = new messages_1.V2RequestCredentialMessage({
          formats,
          requestAttachments,
          comment
        });
        message.setThread({ threadId: credentialRecord.threadId });
        await didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: message,
          associatedRecordId: credentialRecord.id,
          role: storage_1.DidCommMessageRole.Sender
        });
        return message;
      }
      /**
       * Create a {@link V2RequestCredentialMessage}.
       *
       * @param options
       * @returns The created {@link V2RequestCredentialMessage}
       *
       */
      async createRequest(agentContext, { credentialFormats, formatServices, credentialRecord, comment }) {
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const formats = [];
        const requestAttachments = [];
        for (const formatService of formatServices) {
          const { format: format2, attachment } = await formatService.createRequest(agentContext, {
            credentialFormats,
            credentialRecord
          });
          requestAttachments.push(attachment);
          formats.push(format2);
        }
        const message = new messages_1.V2RequestCredentialMessage({
          formats,
          comment,
          requestAttachments
        });
        message.setThread({ threadId: credentialRecord.threadId });
        await didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: message,
          role: storage_1.DidCommMessageRole.Sender,
          associatedRecordId: credentialRecord.id
        });
        return message;
      }
      async processRequest(agentContext, { credentialRecord, message, formatServices }) {
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        for (const formatService of formatServices) {
          const attachment = this.getAttachmentForService(formatService, message.formats, message.requestAttachments);
          await formatService.processRequest(agentContext, {
            attachment,
            credentialRecord
          });
        }
        await didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: message,
          role: storage_1.DidCommMessageRole.Receiver,
          associatedRecordId: credentialRecord.id
        });
      }
      async acceptRequest(agentContext, { credentialRecord, credentialFormats, formatServices, comment }) {
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const requestMessage = await didCommMessageRepository.getAgentMessage(agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: messages_1.V2RequestCredentialMessage
        });
        const offerMessage = await didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: messages_1.V2OfferCredentialMessage
        });
        const formats = [];
        const credentialAttachments = [];
        for (const formatService of formatServices) {
          const requestAttachment = this.getAttachmentForService(formatService, requestMessage.formats, requestMessage.requestAttachments);
          const offerAttachment = offerMessage ? this.getAttachmentForService(formatService, offerMessage.formats, offerMessage.offerAttachments) : void 0;
          const { attachment, format: format2 } = await formatService.acceptRequest(agentContext, {
            requestAttachment,
            offerAttachment,
            credentialRecord,
            credentialFormats
          });
          credentialAttachments.push(attachment);
          formats.push(format2);
        }
        const message = new messages_1.V2IssueCredentialMessage({
          formats,
          credentialAttachments,
          comment
        });
        message.setThread({ threadId: credentialRecord.threadId });
        message.setPleaseAck();
        await didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: message,
          associatedRecordId: credentialRecord.id,
          role: storage_1.DidCommMessageRole.Sender
        });
        return message;
      }
      async processCredential(agentContext, { credentialRecord, message, requestMessage, formatServices }) {
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        for (const formatService of formatServices) {
          const attachment = this.getAttachmentForService(formatService, message.formats, message.credentialAttachments);
          const requestAttachment = this.getAttachmentForService(formatService, requestMessage.formats, requestMessage.requestAttachments);
          await formatService.processCredential(agentContext, {
            attachment,
            requestAttachment,
            credentialRecord
          });
        }
        await didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: message,
          role: storage_1.DidCommMessageRole.Receiver,
          associatedRecordId: credentialRecord.id
        });
      }
      getAttachmentForService(credentialFormatService, formats, attachments) {
        const attachmentId = this.getAttachmentIdForService(credentialFormatService, formats);
        const attachment = attachments.find((attachment2) => attachment2.id === attachmentId);
        if (!attachment) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`Attachment with id ${attachmentId} not found in attachments.`);
        }
        return attachment;
      }
      getAttachmentIdForService(credentialFormatService, formats) {
        const format2 = formats.find((format3) => credentialFormatService.supportsFormat(format3.format));
        if (!format2)
          throw new AriesFrameworkError_1.AriesFrameworkError(`No attachment found for service ${credentialFormatService.formatKey}`);
        return format2.attachId;
      }
    };
    exports.CredentialFormatCoordinator = CredentialFormatCoordinator;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/handlers/V2CredentialAckHandler.js
var require_V2CredentialAckHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/handlers/V2CredentialAckHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2CredentialAckHandler = void 0;
    var V2CredentialAckMessage_1 = require_V2CredentialAckMessage();
    var V2CredentialAckHandler = class {
      constructor(credentialProtocol) {
        this.supportedMessages = [V2CredentialAckMessage_1.V2CredentialAckMessage];
        this.credentialProtocol = credentialProtocol;
      }
      async handle(messageContext) {
        await this.credentialProtocol.processAck(messageContext);
      }
    };
    exports.V2CredentialAckHandler = V2CredentialAckHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/handlers/V2IssueCredentialHandler.js
var require_V2IssueCredentialHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/handlers/V2IssueCredentialHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2IssueCredentialHandler = void 0;
    var models_1 = require_models3();
    var storage_1 = require_storage();
    var V2IssueCredentialMessage_1 = require_V2IssueCredentialMessage();
    var V2RequestCredentialMessage_1 = require_V2RequestCredentialMessage();
    var V2IssueCredentialHandler = class {
      constructor(credentialProtocol) {
        this.supportedMessages = [V2IssueCredentialMessage_1.V2IssueCredentialMessage];
        this.credentialProtocol = credentialProtocol;
      }
      async handle(messageContext) {
        const credentialRecord = await this.credentialProtocol.processCredential(messageContext);
        const shouldAutoRespond = await this.credentialProtocol.shouldAutoRespondToCredential(messageContext.agentContext, {
          credentialRecord,
          credentialMessage: messageContext.message
        });
        if (shouldAutoRespond) {
          return await this.acceptCredential(credentialRecord, messageContext);
        }
      }
      async acceptCredential(credentialRecord, messageContext) {
        messageContext.agentContext.config.logger.info(`Automatically sending acknowledgement with autoAccept`);
        const didCommMessageRepository = messageContext.agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const requestMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: V2RequestCredentialMessage_1.V2RequestCredentialMessage
        });
        const { message } = await this.credentialProtocol.acceptCredential(messageContext.agentContext, {
          credentialRecord
        });
        if (messageContext.connection) {
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            connection: messageContext.connection,
            associatedRecord: credentialRecord
          });
        } else if ((requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.service) && messageContext.message.service) {
          const recipientService = messageContext.message.service;
          const ourService = requestMessage.service;
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            serviceParams: {
              service: recipientService.resolvedDidCommService,
              senderKey: ourService.resolvedDidCommService.recipientKeys[0]
            }
          });
        }
        messageContext.agentContext.config.logger.error(`Could not automatically create credential ack`);
      }
    };
    exports.V2IssueCredentialHandler = V2IssueCredentialHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/handlers/V2OfferCredentialHandler.js
var require_V2OfferCredentialHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/handlers/V2OfferCredentialHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2OfferCredentialHandler = void 0;
    var models_1 = require_models3();
    var ServiceDecorator_1 = require_ServiceDecorator();
    var storage_1 = require_storage();
    var RoutingService_1 = require_RoutingService();
    var V2OfferCredentialMessage_1 = require_V2OfferCredentialMessage();
    var V2OfferCredentialHandler = class {
      constructor(credentialProtocol) {
        this.supportedMessages = [V2OfferCredentialMessage_1.V2OfferCredentialMessage];
        this.credentialProtocol = credentialProtocol;
      }
      async handle(messageContext) {
        const credentialRecord = await this.credentialProtocol.processOffer(messageContext);
        const shouldAutoRespond = await this.credentialProtocol.shouldAutoRespondToOffer(messageContext.agentContext, {
          credentialRecord,
          offerMessage: messageContext.message
        });
        if (shouldAutoRespond) {
          return await this.acceptOffer(credentialRecord, messageContext);
        }
      }
      async acceptOffer(credentialRecord, messageContext, offerMessage) {
        messageContext.agentContext.config.logger.info(`Automatically sending request with autoAccept`);
        if (messageContext.connection) {
          const { message } = await this.credentialProtocol.acceptOffer(messageContext.agentContext, {
            credentialRecord
          });
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            connection: messageContext.connection,
            associatedRecord: credentialRecord
          });
        } else if (offerMessage === null || offerMessage === void 0 ? void 0 : offerMessage.service) {
          const routingService = messageContext.agentContext.dependencyManager.resolve(RoutingService_1.RoutingService);
          const routing = await routingService.getRouting(messageContext.agentContext);
          const ourService = new ServiceDecorator_1.ServiceDecorator({
            serviceEndpoint: routing.endpoints[0],
            recipientKeys: [routing.recipientKey.publicKeyBase58],
            routingKeys: routing.routingKeys.map((key) => key.publicKeyBase58)
          });
          const recipientService = offerMessage.service;
          const { message } = await this.credentialProtocol.acceptOffer(messageContext.agentContext, {
            credentialRecord
          });
          message.service = ourService;
          const didCommMessageRepository = messageContext.agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
          await didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
            agentMessage: message,
            role: storage_1.DidCommMessageRole.Sender,
            associatedRecordId: credentialRecord.id
          });
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            serviceParams: {
              service: recipientService.resolvedDidCommService,
              senderKey: ourService.resolvedDidCommService.recipientKeys[0]
            }
          });
        }
        messageContext.agentContext.config.logger.error(`Could not automatically create credential request`);
      }
    };
    exports.V2OfferCredentialHandler = V2OfferCredentialHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/handlers/V2ProposeCredentialHandler.js
var require_V2ProposeCredentialHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/handlers/V2ProposeCredentialHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2ProposeCredentialHandler = void 0;
    var models_1 = require_models3();
    var V2ProposeCredentialMessage_1 = require_V2ProposeCredentialMessage();
    var V2ProposeCredentialHandler = class {
      constructor(credentialProtocol) {
        this.supportedMessages = [V2ProposeCredentialMessage_1.V2ProposeCredentialMessage];
        this.credentialProtocol = credentialProtocol;
      }
      async handle(messageContext) {
        const credentialRecord = await this.credentialProtocol.processProposal(messageContext);
        const shouldAutoRespond = await this.credentialProtocol.shouldAutoRespondToProposal(messageContext.agentContext, {
          credentialRecord,
          proposalMessage: messageContext.message
        });
        if (shouldAutoRespond) {
          return await this.acceptProposal(credentialRecord, messageContext);
        }
      }
      async acceptProposal(credentialRecord, messageContext) {
        messageContext.agentContext.config.logger.info(`Automatically sending offer with autoAccept`);
        if (!messageContext.connection) {
          messageContext.agentContext.config.logger.error("No connection on the messageContext, aborting auto accept");
          return;
        }
        const { message } = await this.credentialProtocol.acceptProposal(messageContext.agentContext, { credentialRecord });
        return new models_1.OutboundMessageContext(message, {
          agentContext: messageContext.agentContext,
          connection: messageContext.connection,
          associatedRecord: credentialRecord
        });
      }
    };
    exports.V2ProposeCredentialHandler = V2ProposeCredentialHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/handlers/V2RequestCredentialHandler.js
var require_V2RequestCredentialHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/handlers/V2RequestCredentialHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2RequestCredentialHandler = void 0;
    var models_1 = require_models3();
    var storage_1 = require_storage();
    var V2OfferCredentialMessage_1 = require_V2OfferCredentialMessage();
    var V2RequestCredentialMessage_1 = require_V2RequestCredentialMessage();
    var V2RequestCredentialHandler = class {
      constructor(credentialProtocol) {
        this.supportedMessages = [V2RequestCredentialMessage_1.V2RequestCredentialMessage];
        this.credentialProtocol = credentialProtocol;
      }
      async handle(messageContext) {
        const credentialRecord = await this.credentialProtocol.processRequest(messageContext);
        const shouldAutoRespond = await this.credentialProtocol.shouldAutoRespondToRequest(messageContext.agentContext, {
          credentialRecord,
          requestMessage: messageContext.message
        });
        if (shouldAutoRespond) {
          return await this.acceptRequest(credentialRecord, messageContext);
        }
      }
      async acceptRequest(credentialRecord, messageContext) {
        messageContext.agentContext.config.logger.info(`Automatically sending credential with autoAccept`);
        const didCommMessageRepository = messageContext.agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const offerMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: V2OfferCredentialMessage_1.V2OfferCredentialMessage
        });
        const { message } = await this.credentialProtocol.acceptRequest(messageContext.agentContext, {
          credentialRecord
        });
        if (messageContext.connection) {
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            connection: messageContext.connection,
            associatedRecord: credentialRecord
          });
        } else if (messageContext.message.service && (offerMessage === null || offerMessage === void 0 ? void 0 : offerMessage.service)) {
          const recipientService = messageContext.message.service;
          const ourService = offerMessage.service;
          message.setService(ourService);
          await didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
            agentMessage: message,
            associatedRecordId: credentialRecord.id,
            role: storage_1.DidCommMessageRole.Sender
          });
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            serviceParams: {
              service: recipientService.resolvedDidCommService,
              senderKey: ourService.resolvedDidCommService.recipientKeys[0]
            }
          });
        }
        messageContext.agentContext.config.logger.error(`Could not automatically issue credential`);
      }
    };
    exports.V2RequestCredentialHandler = V2RequestCredentialHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/handlers/V2CredentialProblemReportHandler.js
var require_V2CredentialProblemReportHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/handlers/V2CredentialProblemReportHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2CredentialProblemReportHandler = void 0;
    var V2CredentialProblemReportMessage_1 = require_V2CredentialProblemReportMessage();
    var V2CredentialProblemReportHandler = class {
      constructor(credentialProtocol) {
        this.supportedMessages = [V2CredentialProblemReportMessage_1.V2CredentialProblemReportMessage];
        this.credentialProtocol = credentialProtocol;
      }
      async handle(messageContext) {
        await this.credentialProtocol.processProblemReport(messageContext);
      }
    };
    exports.V2CredentialProblemReportHandler = V2CredentialProblemReportHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/handlers/index.js
var require_handlers10 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/handlers/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_V2CredentialAckHandler(), exports);
    __exportStar(require_V2IssueCredentialHandler(), exports);
    __exportStar(require_V2OfferCredentialHandler(), exports);
    __exportStar(require_V2ProposeCredentialHandler(), exports);
    __exportStar(require_V2RequestCredentialHandler(), exports);
    __exportStar(require_V2CredentialProblemReportHandler(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/V2CredentialProtocol.js
var require_V2CredentialProtocol = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/V2CredentialProtocol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2CredentialProtocol = void 0;
    var Protocol_1 = require_Protocol();
    var error_1 = require_error();
    var storage_1 = require_storage();
    var uuid_1 = require_uuid();
    var common_1 = require_common();
    var connections_1 = require_connections();
    var CredentialsModuleConfig_1 = require_CredentialsModuleConfig();
    var errors_1 = require_errors3();
    var models_1 = require_models6();
    var repository_1 = require_repository6();
    var composeAutoAccept_1 = require_composeAutoAccept();
    var previewAttributes_1 = require_previewAttributes();
    var BaseCredentialProtocol_1 = require_BaseCredentialProtocol();
    var CredentialFormatCoordinator_1 = require_CredentialFormatCoordinator();
    var handlers_1 = require_handlers10();
    var V2CredentialProblemReportHandler_1 = require_V2CredentialProblemReportHandler();
    var messages_1 = require_messages11();
    var V2CredentialProtocol = class extends BaseCredentialProtocol_1.BaseCredentialProtocol {
      constructor({ credentialFormats }) {
        super();
        this.credentialFormatCoordinator = new CredentialFormatCoordinator_1.CredentialFormatCoordinator();
        this.version = "v2";
        this.credentialFormats = credentialFormats;
      }
      /**
       * Registers the protocol implementation (handlers, feature registry) on the agent.
       */
      register(dependencyManager, featureRegistry) {
        dependencyManager.registerMessageHandlers([
          new handlers_1.V2ProposeCredentialHandler(this),
          new handlers_1.V2OfferCredentialHandler(this),
          new handlers_1.V2RequestCredentialHandler(this),
          new handlers_1.V2IssueCredentialHandler(this),
          new handlers_1.V2CredentialAckHandler(this),
          new V2CredentialProblemReportHandler_1.V2CredentialProblemReportHandler(this)
        ]);
        featureRegistry.register(new Protocol_1.Protocol({
          id: "https://didcomm.org/issue-credential/2.0",
          roles: ["holder", "issuer"]
        }));
      }
      /**
       * Create a {@link V2ProposeCredentialMessage} not bound to an existing credential exchange.
       *
       * @param proposal The ProposeCredentialOptions object containing the important fields for the credential message
       * @returns Object containing proposal message and associated credential record
       *
       */
      async createProposal(agentContext, { connection, credentialFormats, comment, autoAcceptCredential }) {
        agentContext.config.logger.debug("Get the Format Service and Create Proposal Message");
        const credentialRepository = agentContext.dependencyManager.resolve(repository_1.CredentialRepository);
        const formatServices = this.getFormatServices(credentialFormats);
        if (formatServices.length === 0) {
          throw new error_1.AriesFrameworkError(`Unable to create proposal. No supported formats`);
        }
        const credentialRecord = new repository_1.CredentialExchangeRecord({
          connectionId: connection.id,
          threadId: (0, uuid_1.uuid)(),
          state: models_1.CredentialState.ProposalSent,
          autoAcceptCredential,
          protocolVersion: "v2"
        });
        const proposalMessage = await this.credentialFormatCoordinator.createProposal(agentContext, {
          credentialFormats,
          credentialRecord,
          formatServices,
          comment
        });
        agentContext.config.logger.debug("Save record and emit state change event");
        await credentialRepository.save(agentContext, credentialRecord);
        this.emitStateChangedEvent(agentContext, credentialRecord, null);
        return { credentialRecord, message: proposalMessage };
      }
      /**
       * Method called by {@link V2ProposeCredentialHandler} on reception of a propose credential message
       * We do the necessary processing here to accept the proposal and do the state change, emit event etc.
       * @param messageContext the inbound propose credential message
       * @returns credential record appropriate for this incoming message (once accepted)
       */
      async processProposal(messageContext) {
        const { message: proposalMessage, connection, agentContext } = messageContext;
        agentContext.config.logger.debug(`Processing credential proposal with id ${proposalMessage.id}`);
        const credentialRepository = agentContext.dependencyManager.resolve(repository_1.CredentialRepository);
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const connectionService = agentContext.dependencyManager.resolve(connections_1.ConnectionService);
        let credentialRecord = await this.findByThreadAndConnectionId(messageContext.agentContext, proposalMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        const formatServices = this.getFormatServicesFromMessage(agentContext, proposalMessage.formats);
        if (formatServices.length === 0) {
          throw new error_1.AriesFrameworkError(`Unable to process proposal. No supported formats`);
        }
        if (credentialRecord) {
          const proposalCredentialMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: credentialRecord.id,
            messageClass: messages_1.V2ProposeCredentialMessage
          });
          const offerCredentialMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: credentialRecord.id,
            messageClass: messages_1.V2OfferCredentialMessage
          });
          credentialRecord.assertProtocolVersion("v2");
          credentialRecord.assertState(models_1.CredentialState.OfferSent);
          connectionService.assertConnectionOrServiceDecorator(messageContext, {
            previousReceivedMessage: proposalCredentialMessage !== null && proposalCredentialMessage !== void 0 ? proposalCredentialMessage : void 0,
            previousSentMessage: offerCredentialMessage !== null && offerCredentialMessage !== void 0 ? offerCredentialMessage : void 0
          });
          await this.credentialFormatCoordinator.processProposal(messageContext.agentContext, {
            credentialRecord,
            formatServices,
            message: proposalMessage
          });
          await this.updateState(messageContext.agentContext, credentialRecord, models_1.CredentialState.ProposalReceived);
          return credentialRecord;
        } else {
          connectionService.assertConnectionOrServiceDecorator(messageContext);
          credentialRecord = new repository_1.CredentialExchangeRecord({
            connectionId: connection === null || connection === void 0 ? void 0 : connection.id,
            threadId: proposalMessage.threadId,
            state: models_1.CredentialState.ProposalReceived,
            protocolVersion: "v2"
          });
          await this.credentialFormatCoordinator.processProposal(messageContext.agentContext, {
            credentialRecord,
            formatServices,
            message: proposalMessage
          });
          await credentialRepository.save(messageContext.agentContext, credentialRecord);
          this.emitStateChangedEvent(messageContext.agentContext, credentialRecord, null);
          return credentialRecord;
        }
      }
      async acceptProposal(agentContext, { credentialRecord, credentialFormats, autoAcceptCredential, comment }) {
        credentialRecord.assertProtocolVersion("v2");
        credentialRecord.assertState(models_1.CredentialState.ProposalReceived);
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        let formatServices = this.getFormatServices(credentialFormats !== null && credentialFormats !== void 0 ? credentialFormats : {});
        if (formatServices.length === 0) {
          const proposalMessage = await didCommMessageRepository.getAgentMessage(agentContext, {
            associatedRecordId: credentialRecord.id,
            messageClass: messages_1.V2ProposeCredentialMessage
          });
          formatServices = this.getFormatServicesFromMessage(agentContext, proposalMessage.formats);
        }
        if (formatServices.length === 0) {
          throw new error_1.AriesFrameworkError(`Unable to accept proposal. No supported formats provided as input or in proposal message`);
        }
        const offerMessage = await this.credentialFormatCoordinator.acceptProposal(agentContext, {
          credentialRecord,
          formatServices,
          comment,
          credentialFormats
        });
        credentialRecord.autoAcceptCredential = autoAcceptCredential !== null && autoAcceptCredential !== void 0 ? autoAcceptCredential : credentialRecord.autoAcceptCredential;
        await this.updateState(agentContext, credentialRecord, models_1.CredentialState.OfferSent);
        return { credentialRecord, message: offerMessage };
      }
      /**
       * Negotiate a credential proposal as issuer (by sending a credential offer message) to the connection
       * associated with the credential record.
       *
       * @param options configuration for the offer see {@link NegotiateProposalOptions}
       * @returns Credential exchange record associated with the credential offer
       *
       */
      async negotiateProposal(agentContext, { credentialRecord, credentialFormats, autoAcceptCredential, comment }) {
        credentialRecord.assertProtocolVersion("v2");
        credentialRecord.assertState(models_1.CredentialState.ProposalReceived);
        if (!credentialRecord.connectionId) {
          throw new error_1.AriesFrameworkError(`No connectionId found for credential record '${credentialRecord.id}'. Connection-less issuance does not support negotiation.`);
        }
        const formatServices = this.getFormatServices(credentialFormats);
        if (formatServices.length === 0) {
          throw new error_1.AriesFrameworkError(`Unable to create offer. No supported formats`);
        }
        const offerMessage = await this.credentialFormatCoordinator.createOffer(agentContext, {
          formatServices,
          credentialFormats,
          credentialRecord,
          comment
        });
        credentialRecord.autoAcceptCredential = autoAcceptCredential !== null && autoAcceptCredential !== void 0 ? autoAcceptCredential : credentialRecord.autoAcceptCredential;
        await this.updateState(agentContext, credentialRecord, models_1.CredentialState.OfferSent);
        return { credentialRecord, message: offerMessage };
      }
      /**
       * Create a {@link V2OfferCredentialMessage} as beginning of protocol process. If no connectionId is provided, the
       * exchange will be created without a connection for usage in oob and connection-less issuance.
       *
       * @param formatService {@link CredentialFormatService} the format service object containing format-specific logic
       * @param options attributes of the original offer
       * @returns Object containing offer message and associated credential record
       *
       */
      async createOffer(agentContext, { credentialFormats, autoAcceptCredential, comment, connection }) {
        const credentialRepository = agentContext.dependencyManager.resolve(repository_1.CredentialRepository);
        const formatServices = this.getFormatServices(credentialFormats);
        if (formatServices.length === 0) {
          throw new error_1.AriesFrameworkError(`Unable to create offer. No supported formats`);
        }
        const credentialRecord = new repository_1.CredentialExchangeRecord({
          connectionId: connection === null || connection === void 0 ? void 0 : connection.id,
          threadId: (0, uuid_1.uuid)(),
          state: models_1.CredentialState.OfferSent,
          autoAcceptCredential,
          protocolVersion: "v2"
        });
        const offerMessage = await this.credentialFormatCoordinator.createOffer(agentContext, {
          formatServices,
          credentialFormats,
          credentialRecord,
          comment
        });
        agentContext.config.logger.debug(`Saving record and emitting state changed for credential exchange record ${credentialRecord.id}`);
        await credentialRepository.save(agentContext, credentialRecord);
        this.emitStateChangedEvent(agentContext, credentialRecord, null);
        return { credentialRecord, message: offerMessage };
      }
      /**
       * Method called by {@link V2OfferCredentialHandler} on reception of a offer credential message
       * We do the necessary processing here to accept the offer and do the state change, emit event etc.
       * @param messageContext the inbound offer credential message
       * @returns credential record appropriate for this incoming message (once accepted)
       */
      async processOffer(messageContext) {
        const { message: offerMessage, connection, agentContext } = messageContext;
        agentContext.config.logger.debug(`Processing credential offer with id ${offerMessage.id}`);
        const credentialRepository = agentContext.dependencyManager.resolve(repository_1.CredentialRepository);
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const connectionService = agentContext.dependencyManager.resolve(connections_1.ConnectionService);
        let credentialRecord = await this.findByThreadAndConnectionId(messageContext.agentContext, offerMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        const formatServices = this.getFormatServicesFromMessage(agentContext, offerMessage.formats);
        if (formatServices.length === 0) {
          throw new error_1.AriesFrameworkError(`Unable to process offer. No supported formats`);
        }
        if (credentialRecord) {
          const proposeCredentialMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: credentialRecord.id,
            messageClass: messages_1.V2ProposeCredentialMessage
          });
          const offerCredentialMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: credentialRecord.id,
            messageClass: messages_1.V2OfferCredentialMessage
          });
          credentialRecord.assertProtocolVersion("v2");
          credentialRecord.assertState(models_1.CredentialState.ProposalSent);
          connectionService.assertConnectionOrServiceDecorator(messageContext, {
            previousReceivedMessage: offerCredentialMessage !== null && offerCredentialMessage !== void 0 ? offerCredentialMessage : void 0,
            previousSentMessage: proposeCredentialMessage !== null && proposeCredentialMessage !== void 0 ? proposeCredentialMessage : void 0
          });
          await this.credentialFormatCoordinator.processOffer(messageContext.agentContext, {
            credentialRecord,
            formatServices,
            message: offerMessage
          });
          await this.updateState(messageContext.agentContext, credentialRecord, models_1.CredentialState.OfferReceived);
          return credentialRecord;
        } else {
          connectionService.assertConnectionOrServiceDecorator(messageContext);
          agentContext.config.logger.debug("No credential record found for offer, creating a new one");
          credentialRecord = new repository_1.CredentialExchangeRecord({
            connectionId: connection === null || connection === void 0 ? void 0 : connection.id,
            threadId: offerMessage.threadId,
            state: models_1.CredentialState.OfferReceived,
            protocolVersion: "v2"
          });
          await this.credentialFormatCoordinator.processOffer(messageContext.agentContext, {
            credentialRecord,
            formatServices,
            message: offerMessage
          });
          agentContext.config.logger.debug("Saving credential record and emit offer-received event");
          await credentialRepository.save(messageContext.agentContext, credentialRecord);
          this.emitStateChangedEvent(messageContext.agentContext, credentialRecord, null);
          return credentialRecord;
        }
      }
      async acceptOffer(agentContext, { credentialRecord, autoAcceptCredential, comment, credentialFormats }) {
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        credentialRecord.assertProtocolVersion("v2");
        credentialRecord.assertState(models_1.CredentialState.OfferReceived);
        let formatServices = this.getFormatServices(credentialFormats !== null && credentialFormats !== void 0 ? credentialFormats : {});
        if (formatServices.length === 0) {
          const offerMessage = await didCommMessageRepository.getAgentMessage(agentContext, {
            associatedRecordId: credentialRecord.id,
            messageClass: messages_1.V2OfferCredentialMessage
          });
          formatServices = this.getFormatServicesFromMessage(agentContext, offerMessage.formats);
        }
        if (formatServices.length === 0) {
          throw new error_1.AriesFrameworkError(`Unable to accept offer. No supported formats provided as input or in offer message`);
        }
        const message = await this.credentialFormatCoordinator.acceptOffer(agentContext, {
          credentialRecord,
          formatServices,
          comment,
          credentialFormats
        });
        credentialRecord.autoAcceptCredential = autoAcceptCredential !== null && autoAcceptCredential !== void 0 ? autoAcceptCredential : credentialRecord.autoAcceptCredential;
        await this.updateState(agentContext, credentialRecord, models_1.CredentialState.RequestSent);
        return { credentialRecord, message };
      }
      /**
       * Create a {@link ProposePresentationMessage} as response to a received credential offer.
       * To create a proposal not bound to an existing credential exchange, use {@link createProposal}.
       *
       * @param options configuration to use for the proposal
       * @returns Object containing proposal message and associated credential record
       *
       */
      async negotiateOffer(agentContext, { credentialRecord, credentialFormats, autoAcceptCredential, comment }) {
        credentialRecord.assertProtocolVersion("v2");
        credentialRecord.assertState(models_1.CredentialState.OfferReceived);
        if (!credentialRecord.connectionId) {
          throw new error_1.AriesFrameworkError(`No connectionId found for credential record '${credentialRecord.id}'. Connection-less issuance does not support negotiation.`);
        }
        const formatServices = this.getFormatServices(credentialFormats);
        if (formatServices.length === 0) {
          throw new error_1.AriesFrameworkError(`Unable to create proposal. No supported formats`);
        }
        const proposalMessage = await this.credentialFormatCoordinator.createProposal(agentContext, {
          formatServices,
          credentialFormats,
          credentialRecord,
          comment
        });
        credentialRecord.autoAcceptCredential = autoAcceptCredential !== null && autoAcceptCredential !== void 0 ? autoAcceptCredential : credentialRecord.autoAcceptCredential;
        await this.updateState(agentContext, credentialRecord, models_1.CredentialState.ProposalSent);
        return { credentialRecord, message: proposalMessage };
      }
      /**
       * Create a {@link V2RequestCredentialMessage} as beginning of protocol process.
       * @returns Object containing offer message and associated credential record
       *
       */
      async createRequest(agentContext, { credentialFormats, autoAcceptCredential, comment, connection }) {
        const credentialRepository = agentContext.dependencyManager.resolve(repository_1.CredentialRepository);
        const formatServices = this.getFormatServices(credentialFormats);
        if (formatServices.length === 0) {
          throw new error_1.AriesFrameworkError(`Unable to create request. No supported formats`);
        }
        const credentialRecord = new repository_1.CredentialExchangeRecord({
          connectionId: connection.id,
          threadId: (0, uuid_1.uuid)(),
          state: models_1.CredentialState.RequestSent,
          autoAcceptCredential,
          protocolVersion: "v2"
        });
        const requestMessage = await this.credentialFormatCoordinator.createRequest(agentContext, {
          formatServices,
          credentialFormats,
          credentialRecord,
          comment
        });
        agentContext.config.logger.debug(`Saving record and emitting state changed for credential exchange record ${credentialRecord.id}`);
        await credentialRepository.save(agentContext, credentialRecord);
        this.emitStateChangedEvent(agentContext, credentialRecord, null);
        return { credentialRecord, message: requestMessage };
      }
      /**
       * Process a received {@link RequestCredentialMessage}. This will not accept the credential request
       * or send a credential. It will only update the existing credential record with
       * the information from the credential request message. Use {@link createCredential}
       * after calling this method to create a credential.
       *z
       * @param messageContext The message context containing a v2 credential request message
       * @returns credential record associated with the credential request message
       *
       */
      async processRequest(messageContext) {
        const { message: requestMessage, connection, agentContext } = messageContext;
        const credentialRepository = agentContext.dependencyManager.resolve(repository_1.CredentialRepository);
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const connectionService = agentContext.dependencyManager.resolve(connections_1.ConnectionService);
        agentContext.config.logger.debug(`Processing credential request with id ${requestMessage.id}`);
        let credentialRecord = await this.findByThreadAndConnectionId(messageContext.agentContext, requestMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        const formatServices = this.getFormatServicesFromMessage(agentContext, requestMessage.formats);
        if (formatServices.length === 0) {
          throw new error_1.AriesFrameworkError(`Unable to process request. No supported formats`);
        }
        if (credentialRecord) {
          const proposalMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: credentialRecord.id,
            messageClass: messages_1.V2ProposeCredentialMessage
          });
          const offerMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: credentialRecord.id,
            messageClass: messages_1.V2OfferCredentialMessage
          });
          credentialRecord.assertProtocolVersion("v2");
          credentialRecord.assertState(models_1.CredentialState.OfferSent);
          connectionService.assertConnectionOrServiceDecorator(messageContext, {
            previousReceivedMessage: proposalMessage !== null && proposalMessage !== void 0 ? proposalMessage : void 0,
            previousSentMessage: offerMessage !== null && offerMessage !== void 0 ? offerMessage : void 0
          });
          await this.credentialFormatCoordinator.processRequest(messageContext.agentContext, {
            credentialRecord,
            formatServices,
            message: requestMessage
          });
          await this.updateState(messageContext.agentContext, credentialRecord, models_1.CredentialState.RequestReceived);
          return credentialRecord;
        } else {
          connectionService.assertConnectionOrServiceDecorator(messageContext);
          agentContext.config.logger.debug("No credential record found for request, creating a new one");
          credentialRecord = new repository_1.CredentialExchangeRecord({
            connectionId: connection === null || connection === void 0 ? void 0 : connection.id,
            threadId: requestMessage.threadId,
            state: models_1.CredentialState.RequestReceived,
            protocolVersion: "v2"
          });
          await this.credentialFormatCoordinator.processRequest(messageContext.agentContext, {
            credentialRecord,
            formatServices,
            message: requestMessage
          });
          agentContext.config.logger.debug("Saving credential record and emit request-received event");
          await credentialRepository.save(messageContext.agentContext, credentialRecord);
          this.emitStateChangedEvent(messageContext.agentContext, credentialRecord, null);
          return credentialRecord;
        }
      }
      async acceptRequest(agentContext, { credentialRecord, autoAcceptCredential, comment, credentialFormats }) {
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        credentialRecord.assertProtocolVersion("v2");
        credentialRecord.assertState(models_1.CredentialState.RequestReceived);
        let formatServices = this.getFormatServices(credentialFormats !== null && credentialFormats !== void 0 ? credentialFormats : {});
        if (formatServices.length === 0) {
          const requestMessage = await didCommMessageRepository.getAgentMessage(agentContext, {
            associatedRecordId: credentialRecord.id,
            messageClass: messages_1.V2RequestCredentialMessage
          });
          formatServices = this.getFormatServicesFromMessage(agentContext, requestMessage.formats);
        }
        if (formatServices.length === 0) {
          throw new error_1.AriesFrameworkError(`Unable to accept request. No supported formats provided as input or in request message`);
        }
        const message = await this.credentialFormatCoordinator.acceptRequest(agentContext, {
          credentialRecord,
          formatServices,
          comment,
          credentialFormats
        });
        credentialRecord.autoAcceptCredential = autoAcceptCredential !== null && autoAcceptCredential !== void 0 ? autoAcceptCredential : credentialRecord.autoAcceptCredential;
        await this.updateState(agentContext, credentialRecord, models_1.CredentialState.CredentialIssued);
        return { credentialRecord, message };
      }
      /**
       * Process a received {@link IssueCredentialMessage}. This will not accept the credential
       * or send a credential acknowledgement. It will only update the existing credential record with
       * the information from the issue credential message. Use {@link createAck}
       * after calling this method to create a credential acknowledgement.
       *
       * @param messageContext The message context containing an issue credential message
       *
       * @returns credential record associated with the issue credential message
       *
       */
      async processCredential(messageContext) {
        const { message: credentialMessage, connection, agentContext } = messageContext;
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const connectionService = agentContext.dependencyManager.resolve(connections_1.ConnectionService);
        agentContext.config.logger.debug(`Processing credential with id ${credentialMessage.id}`);
        const credentialRecord = await this.getByThreadAndConnectionId(messageContext.agentContext, credentialMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        const requestMessage = await didCommMessageRepository.getAgentMessage(messageContext.agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: messages_1.V2RequestCredentialMessage
        });
        const offerMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: messages_1.V2OfferCredentialMessage
        });
        credentialRecord.assertProtocolVersion("v2");
        credentialRecord.assertState(models_1.CredentialState.RequestSent);
        connectionService.assertConnectionOrServiceDecorator(messageContext, {
          previousReceivedMessage: offerMessage !== null && offerMessage !== void 0 ? offerMessage : void 0,
          previousSentMessage: requestMessage
        });
        const formatServices = this.getFormatServicesFromMessage(agentContext, requestMessage.formats);
        if (formatServices.length === 0) {
          throw new error_1.AriesFrameworkError(`Unable to process credential. No supported formats`);
        }
        await this.credentialFormatCoordinator.processCredential(messageContext.agentContext, {
          credentialRecord,
          formatServices,
          requestMessage,
          message: credentialMessage
        });
        await this.updateState(messageContext.agentContext, credentialRecord, models_1.CredentialState.CredentialReceived);
        return credentialRecord;
      }
      /**
       * Create a {@link V2CredentialAckMessage} as response to a received credential.
       *
       * @param credentialRecord The credential record for which to create the credential acknowledgement
       * @returns Object containing credential acknowledgement message and associated credential record
       *
       */
      async acceptCredential(agentContext, { credentialRecord }) {
        credentialRecord.assertProtocolVersion("v2");
        credentialRecord.assertState(models_1.CredentialState.CredentialReceived);
        const ackMessage = new messages_1.V2CredentialAckMessage({
          status: common_1.AckStatus.OK,
          threadId: credentialRecord.threadId
        });
        await this.updateState(agentContext, credentialRecord, models_1.CredentialState.Done);
        return { message: ackMessage, credentialRecord };
      }
      /**
       * Process a received {@link CredentialAckMessage}.
       *
       * @param messageContext The message context containing a credential acknowledgement message
       * @returns credential record associated with the credential acknowledgement message
       *
       */
      async processAck(messageContext) {
        const { message: ackMessage, connection, agentContext } = messageContext;
        agentContext.config.logger.debug(`Processing credential ack with id ${ackMessage.id}`);
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        const connectionService = agentContext.dependencyManager.resolve(connections_1.ConnectionService);
        const credentialRecord = await this.getByThreadAndConnectionId(messageContext.agentContext, ackMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        credentialRecord.connectionId = connection === null || connection === void 0 ? void 0 : connection.id;
        const requestMessage = await didCommMessageRepository.getAgentMessage(messageContext.agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: messages_1.V2RequestCredentialMessage
        });
        const credentialMessage = await didCommMessageRepository.getAgentMessage(messageContext.agentContext, {
          associatedRecordId: credentialRecord.id,
          messageClass: messages_1.V2IssueCredentialMessage
        });
        credentialRecord.assertProtocolVersion("v2");
        credentialRecord.assertState(models_1.CredentialState.CredentialIssued);
        connectionService.assertConnectionOrServiceDecorator(messageContext, {
          previousReceivedMessage: requestMessage,
          previousSentMessage: credentialMessage
        });
        await this.updateState(messageContext.agentContext, credentialRecord, models_1.CredentialState.Done);
        return credentialRecord;
      }
      /**
       * Create a {@link V2CredentialProblemReportMessage} to be sent.
       *
       * @param message message to send
       * @returns a {@link V2CredentialProblemReportMessage}
       *
       */
      createProblemReport(agentContext, options) {
        return new messages_1.V2CredentialProblemReportMessage({
          description: {
            en: options.message,
            code: errors_1.CredentialProblemReportReason.IssuanceAbandoned
          }
        });
      }
      // AUTO ACCEPT METHODS
      async shouldAutoRespondToProposal(agentContext, options) {
        const { credentialRecord, proposalMessage } = options;
        const credentialsModuleConfig = agentContext.dependencyManager.resolve(CredentialsModuleConfig_1.CredentialsModuleConfig);
        const autoAccept = (0, composeAutoAccept_1.composeAutoAccept)(credentialRecord.autoAcceptCredential, credentialsModuleConfig.autoAcceptCredentials);
        if (autoAccept === models_1.AutoAcceptCredential.Always)
          return true;
        if (autoAccept === models_1.AutoAcceptCredential.Never)
          return false;
        const offerMessage = await this.findOfferMessage(agentContext, credentialRecord.id);
        if (!offerMessage)
          return false;
        const formatServices = this.getFormatServicesFromMessage(agentContext, offerMessage.formats);
        for (const formatService of formatServices) {
          const offerAttachment = this.credentialFormatCoordinator.getAttachmentForService(formatService, offerMessage.formats, offerMessage.offerAttachments);
          const proposalAttachment = this.credentialFormatCoordinator.getAttachmentForService(formatService, proposalMessage.formats, proposalMessage.proposalAttachments);
          const shouldAutoRespondToFormat = formatService.shouldAutoRespondToProposal(agentContext, {
            credentialRecord,
            offerAttachment,
            proposalAttachment
          });
          if (!shouldAutoRespondToFormat)
            return false;
        }
        if (proposalMessage.credentialPreview || offerMessage.credentialPreview) {
          if (!proposalMessage.credentialPreview || !offerMessage.credentialPreview)
            return false;
          return (0, previewAttributes_1.arePreviewAttributesEqual)(proposalMessage.credentialPreview.attributes, offerMessage.credentialPreview.attributes);
        }
        return true;
      }
      async shouldAutoRespondToOffer(agentContext, options) {
        var _a, _b, _c, _d;
        const { credentialRecord, offerMessage } = options;
        const credentialsModuleConfig = agentContext.dependencyManager.resolve(CredentialsModuleConfig_1.CredentialsModuleConfig);
        const autoAccept = (0, composeAutoAccept_1.composeAutoAccept)(credentialRecord.autoAcceptCredential, credentialsModuleConfig.autoAcceptCredentials);
        if (autoAccept === models_1.AutoAcceptCredential.Always)
          return true;
        if (autoAccept === models_1.AutoAcceptCredential.Never)
          return false;
        const proposalMessage = await this.findProposalMessage(agentContext, credentialRecord.id);
        if (!proposalMessage)
          return false;
        const formatServices = this.getFormatServicesFromMessage(agentContext, proposalMessage.formats);
        for (const formatService of formatServices) {
          const offerAttachment = this.credentialFormatCoordinator.getAttachmentForService(formatService, offerMessage.formats, offerMessage.offerAttachments);
          const proposalAttachment = this.credentialFormatCoordinator.getAttachmentForService(formatService, proposalMessage.formats, proposalMessage.proposalAttachments);
          const shouldAutoRespondToFormat = formatService.shouldAutoRespondToOffer(agentContext, {
            credentialRecord,
            offerAttachment,
            proposalAttachment
          });
          if (!shouldAutoRespondToFormat)
            return false;
        }
        if (proposalMessage.credentialPreview || offerMessage.credentialPreview) {
          return (0, previewAttributes_1.arePreviewAttributesEqual)((_b = (_a = proposalMessage.credentialPreview) === null || _a === void 0 ? void 0 : _a.attributes) !== null && _b !== void 0 ? _b : [], (_d = (_c = offerMessage.credentialPreview) === null || _c === void 0 ? void 0 : _c.attributes) !== null && _d !== void 0 ? _d : []);
        }
        return true;
      }
      async shouldAutoRespondToRequest(agentContext, options) {
        const { credentialRecord, requestMessage } = options;
        const credentialsModuleConfig = agentContext.dependencyManager.resolve(CredentialsModuleConfig_1.CredentialsModuleConfig);
        const autoAccept = (0, composeAutoAccept_1.composeAutoAccept)(credentialRecord.autoAcceptCredential, credentialsModuleConfig.autoAcceptCredentials);
        if (autoAccept === models_1.AutoAcceptCredential.Always)
          return true;
        if (autoAccept === models_1.AutoAcceptCredential.Never)
          return false;
        const proposalMessage = await this.findProposalMessage(agentContext, credentialRecord.id);
        const offerMessage = await this.findOfferMessage(agentContext, credentialRecord.id);
        if (!offerMessage)
          return false;
        const formatServices = this.getFormatServicesFromMessage(agentContext, offerMessage.formats);
        for (const formatService of formatServices) {
          const offerAttachment = this.credentialFormatCoordinator.getAttachmentForService(formatService, offerMessage.formats, offerMessage.offerAttachments);
          const proposalAttachment = proposalMessage ? this.credentialFormatCoordinator.getAttachmentForService(formatService, proposalMessage.formats, proposalMessage.proposalAttachments) : void 0;
          const requestAttachment = this.credentialFormatCoordinator.getAttachmentForService(formatService, requestMessage.formats, requestMessage.requestAttachments);
          const shouldAutoRespondToFormat = formatService.shouldAutoRespondToRequest(agentContext, {
            credentialRecord,
            offerAttachment,
            requestAttachment,
            proposalAttachment
          });
          if (!shouldAutoRespondToFormat)
            return false;
        }
        return true;
      }
      async shouldAutoRespondToCredential(agentContext, options) {
        const { credentialRecord, credentialMessage } = options;
        const credentialsModuleConfig = agentContext.dependencyManager.resolve(CredentialsModuleConfig_1.CredentialsModuleConfig);
        const autoAccept = (0, composeAutoAccept_1.composeAutoAccept)(credentialRecord.autoAcceptCredential, credentialsModuleConfig.autoAcceptCredentials);
        if (autoAccept === models_1.AutoAcceptCredential.Always)
          return true;
        if (autoAccept === models_1.AutoAcceptCredential.Never)
          return false;
        const proposalMessage = await this.findProposalMessage(agentContext, credentialRecord.id);
        const offerMessage = await this.findOfferMessage(agentContext, credentialRecord.id);
        const requestMessage = await this.findRequestMessage(agentContext, credentialRecord.id);
        if (!requestMessage)
          return false;
        const formatServices = this.getFormatServicesFromMessage(agentContext, requestMessage.formats);
        for (const formatService of formatServices) {
          const offerAttachment = offerMessage ? this.credentialFormatCoordinator.getAttachmentForService(formatService, offerMessage.formats, offerMessage.offerAttachments) : void 0;
          const proposalAttachment = proposalMessage ? this.credentialFormatCoordinator.getAttachmentForService(formatService, proposalMessage.formats, proposalMessage.proposalAttachments) : void 0;
          const requestAttachment = this.credentialFormatCoordinator.getAttachmentForService(formatService, requestMessage.formats, requestMessage.requestAttachments);
          const credentialAttachment = this.credentialFormatCoordinator.getAttachmentForService(formatService, credentialMessage.formats, credentialMessage.credentialAttachments);
          const shouldAutoRespondToFormat = formatService.shouldAutoRespondToCredential(agentContext, {
            credentialRecord,
            offerAttachment,
            credentialAttachment,
            requestAttachment,
            proposalAttachment
          });
          if (!shouldAutoRespondToFormat)
            return false;
        }
        return true;
      }
      async findProposalMessage(agentContext, credentialExchangeId) {
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        return didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: credentialExchangeId,
          messageClass: messages_1.V2ProposeCredentialMessage
        });
      }
      async findOfferMessage(agentContext, credentialExchangeId) {
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        return await didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: credentialExchangeId,
          messageClass: messages_1.V2OfferCredentialMessage
        });
      }
      async findRequestMessage(agentContext, credentialExchangeId) {
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        return await didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: credentialExchangeId,
          messageClass: messages_1.V2RequestCredentialMessage
        });
      }
      async findCredentialMessage(agentContext, credentialExchangeId) {
        const didCommMessageRepository = agentContext.dependencyManager.resolve(storage_1.DidCommMessageRepository);
        return await didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: credentialExchangeId,
          messageClass: messages_1.V2IssueCredentialMessage
        });
      }
      async getFormatData(agentContext, credentialExchangeId) {
        var _a, _b;
        const [proposalMessage, offerMessage, requestMessage, credentialMessage] = await Promise.all([
          this.findProposalMessage(agentContext, credentialExchangeId),
          this.findOfferMessage(agentContext, credentialExchangeId),
          this.findRequestMessage(agentContext, credentialExchangeId),
          this.findCredentialMessage(agentContext, credentialExchangeId)
        ]);
        const messages = {
          proposal: [proposalMessage === null || proposalMessage === void 0 ? void 0 : proposalMessage.formats, proposalMessage === null || proposalMessage === void 0 ? void 0 : proposalMessage.proposalAttachments],
          offer: [offerMessage === null || offerMessage === void 0 ? void 0 : offerMessage.formats, offerMessage === null || offerMessage === void 0 ? void 0 : offerMessage.offerAttachments],
          request: [requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.formats, requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.requestAttachments],
          credential: [credentialMessage === null || credentialMessage === void 0 ? void 0 : credentialMessage.formats, credentialMessage === null || credentialMessage === void 0 ? void 0 : credentialMessage.credentialAttachments]
        };
        const formatData = {
          proposalAttributes: (_a = proposalMessage === null || proposalMessage === void 0 ? void 0 : proposalMessage.credentialPreview) === null || _a === void 0 ? void 0 : _a.attributes,
          offerAttributes: (_b = offerMessage === null || offerMessage === void 0 ? void 0 : offerMessage.credentialPreview) === null || _b === void 0 ? void 0 : _b.attributes
        };
        for (const [messageKey, [formats, attachments]] of Object.entries(messages)) {
          if (!formats || !attachments)
            continue;
          const formatServices = this.getFormatServicesFromMessage(agentContext, formats);
          const messageFormatData = {};
          for (const formatService of formatServices) {
            const attachment = this.credentialFormatCoordinator.getAttachmentForService(formatService, formats, attachments);
            messageFormatData[formatService.formatKey] = attachment.getDataAsJson();
          }
          formatData[messageKey] = messageFormatData;
        }
        return formatData;
      }
      /**
       * Get all the format service objects for a given credential format from an incoming message
       * @param messageFormats the format objects containing the format name (eg indy)
       * @return the credential format service objects in an array - derived from format object keys
       */
      getFormatServicesFromMessage(agentContext, messageFormats) {
        const formatServices = /* @__PURE__ */ new Set();
        for (const msg of messageFormats) {
          const service = this.getFormatServiceForFormat(msg.format);
          if (service)
            formatServices.add(service);
        }
        return Array.from(formatServices);
      }
      /**
       * Get all the format service objects for a given credential format
       * @param credentialFormats the format object containing various optional parameters
       * @return the credential format service objects in an array - derived from format object keys
       */
      getFormatServices(credentialFormats) {
        const formats = /* @__PURE__ */ new Set();
        for (const formatKey of Object.keys(credentialFormats)) {
          const formatService = this.getFormatServiceForFormatKey(formatKey);
          if (formatService)
            formats.add(formatService);
        }
        return Array.from(formats);
      }
      getFormatServiceForFormatKey(formatKey) {
        const formatService = this.credentialFormats.find((credentialFormat) => credentialFormat.formatKey === formatKey);
        return formatService !== null && formatService !== void 0 ? formatService : null;
      }
      getFormatServiceForFormat(format2) {
        const formatService = this.credentialFormats.find((credentialFormat) => credentialFormat.supportsFormat(format2));
        return formatService !== null && formatService !== void 0 ? formatService : null;
      }
      getFormatServiceForRecordType(credentialRecordType) {
        const formatService = this.credentialFormats.find((credentialFormat) => credentialFormat.credentialRecordType === credentialRecordType);
        if (!formatService) {
          throw new error_1.AriesFrameworkError(`No format service found for credential record type ${credentialRecordType} in v2 credential protocol`);
        }
        return formatService;
      }
    };
    exports.V2CredentialProtocol = V2CredentialProtocol;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/index.js
var require_v23 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/v2/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_V2CredentialProtocol(), exports);
    __exportStar(require_messages11(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/messages/index.js
var require_messages12 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/messages/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_V1RevocationNotificationMessage(), exports);
    __exportStar(require_V2RevocationNotificationMessage(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/index.js
var require_revocation_notification = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/revocation-notification/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_messages12(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/protocol/index.js
var require_protocol3 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/protocol/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_v13(), exports);
    __exportStar(require_v23(), exports);
    __exportStar(require_revocation_notification(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/CredentialsModule.js
var require_CredentialsModule = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/CredentialsModule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CredentialsModule = void 0;
    var models_1 = require_models3();
    var CredentialsApi_1 = require_CredentialsApi();
    var CredentialsModuleConfig_1 = require_CredentialsModuleConfig();
    var indy_1 = require_indy();
    var services_1 = require_services8();
    var v1_1 = require_v13();
    var v2_1 = require_v23();
    var repository_1 = require_repository6();
    var CredentialsModule = class {
      constructor(config) {
        var _a;
        this.api = CredentialsApi_1.CredentialsApi;
        this.config = new CredentialsModuleConfig_1.CredentialsModuleConfig(Object.assign(Object.assign({}, config), {
          // NOTE: the credentialProtocols defaults are set in the CredentialsModule rather than the CredentialsModuleConfig to
          // void dependency cycles.
          credentialProtocols: (_a = config === null || config === void 0 ? void 0 : config.credentialProtocols) !== null && _a !== void 0 ? _a : this.getDefaultCredentialProtocols()
        }));
      }
      /**
       * Get the default credential protocols that will be registered if the `credentialProtocols` property is not configured.
       */
      getDefaultCredentialProtocols() {
        const indyCredentialFormat = new indy_1.IndyCredentialFormatService();
        const v1CredentialProtocol = new v1_1.V1CredentialProtocol({ indyCredentialFormat });
        const v2CredentialProtocol = new v2_1.V2CredentialProtocol({
          credentialFormats: [indyCredentialFormat]
        });
        return [v1CredentialProtocol, v2CredentialProtocol];
      }
      /**
       * Registers the dependencies of the credentials module on the dependency manager.
       */
      register(dependencyManager, featureRegistry) {
        dependencyManager.registerContextScoped(CredentialsApi_1.CredentialsApi);
        dependencyManager.registerInstance(CredentialsModuleConfig_1.CredentialsModuleConfig, this.config);
        dependencyManager.registerSingleton(services_1.RevocationNotificationService);
        dependencyManager.registerSingleton(repository_1.CredentialRepository);
        featureRegistry.register(new models_1.Protocol({
          id: "https://didcomm.org/revocation_notification/1.0",
          roles: ["holder"]
        }), new models_1.Protocol({
          id: "https://didcomm.org/revocation_notification/2.0",
          roles: ["holder"]
        }));
        for (const credentialProtocol of this.config.credentialProtocols) {
          credentialProtocol.register(dependencyManager, featureRegistry);
        }
      }
    };
    exports.CredentialsModule = CredentialsModule;
  }
});

// node_modules/@aries-framework/core/build/modules/credentials/index.js
var require_credentials = __commonJS({
  "node_modules/@aries-framework/core/build/modules/credentials/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_CredentialsApi(), exports);
    __exportStar(require_CredentialsApiOptions(), exports);
    __exportStar(require_repository6(), exports);
    __exportStar(require_CredentialEvents(), exports);
    __exportStar(require_models6(), exports);
    __exportStar(require_formats(), exports);
    __exportStar(require_protocol3(), exports);
    __exportStar(require_CredentialsModule(), exports);
    __exportStar(require_CredentialsModuleConfig(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/generic-records/repository/GenericRecord.js
var require_GenericRecord = __commonJS({
  "node_modules/@aries-framework/core/build/modules/generic-records/repository/GenericRecord.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GenericRecord = void 0;
    var BaseRecord_1 = require_BaseRecord();
    var uuid_1 = require_uuid();
    var GenericRecord = class extends BaseRecord_1.BaseRecord {
      constructor(props) {
        var _a, _b, _c;
        super();
        this.type = GenericRecord.type;
        if (props) {
          this.id = (_a = props.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.createdAt = (_b = props.createdAt) !== null && _b !== void 0 ? _b : /* @__PURE__ */ new Date();
          this.content = props.content;
          this._tags = (_c = props.tags) !== null && _c !== void 0 ? _c : {};
        }
      }
      getTags() {
        return Object.assign({}, this._tags);
      }
    };
    exports.GenericRecord = GenericRecord;
    GenericRecord.type = "GenericRecord";
  }
});

// node_modules/@aries-framework/core/build/modules/generic-records/repository/GenericRecordsRepository.js
var require_GenericRecordsRepository = __commonJS({
  "node_modules/@aries-framework/core/build/modules/generic-records/repository/GenericRecordsRepository.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GenericRecordsRepository = void 0;
    var EventEmitter_1 = require_EventEmitter();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var Repository_1 = require_Repository();
    var GenericRecord_1 = require_GenericRecord();
    var GenericRecordsRepository = class GenericRecordsRepository extends Repository_1.Repository {
      constructor(storageService, eventEmitter) {
        super(GenericRecord_1.GenericRecord, storageService, eventEmitter);
      }
    };
    GenericRecordsRepository = __decorate([
      (0, plugins_1.injectable)(),
      __param(0, (0, plugins_1.inject)(constants_1.InjectionSymbols.StorageService)),
      __metadata("design:paramtypes", [Object, EventEmitter_1.EventEmitter])
    ], GenericRecordsRepository);
    exports.GenericRecordsRepository = GenericRecordsRepository;
  }
});

// node_modules/@aries-framework/core/build/modules/generic-records/services/GenericRecordService.js
var require_GenericRecordService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/generic-records/services/GenericRecordService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GenericRecordService = void 0;
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var GenericRecord_1 = require_GenericRecord();
    var GenericRecordsRepository_1 = require_GenericRecordsRepository();
    var GenericRecordService = class GenericRecordService {
      constructor(genericRecordsRepository) {
        this.genericRecordsRepository = genericRecordsRepository;
      }
      async save(agentContext, { content, tags, id }) {
        const genericRecord = new GenericRecord_1.GenericRecord({
          id,
          content,
          tags
        });
        try {
          await this.genericRecordsRepository.save(agentContext, genericRecord);
          return genericRecord;
        } catch (error) {
          throw new error_1.AriesFrameworkError(`Unable to store the genericRecord record with id ${genericRecord.id}. Message: ${error}`);
        }
      }
      async delete(agentContext, record) {
        try {
          await this.genericRecordsRepository.delete(agentContext, record);
        } catch (error) {
          throw new error_1.AriesFrameworkError(`Unable to delete the genericRecord record with id ${record.id}. Message: ${error}`);
        }
      }
      async deleteById(agentContext, id) {
        await this.genericRecordsRepository.deleteById(agentContext, id);
      }
      async update(agentContext, record) {
        try {
          await this.genericRecordsRepository.update(agentContext, record);
        } catch (error) {
          throw new error_1.AriesFrameworkError(`Unable to update the genericRecord record with id ${record.id}. Message: ${error}`);
        }
      }
      async findAllByQuery(agentContext, query) {
        return this.genericRecordsRepository.findByQuery(agentContext, query);
      }
      async findById(agentContext, id) {
        return this.genericRecordsRepository.findById(agentContext, id);
      }
      async getAll(agentContext) {
        return this.genericRecordsRepository.getAll(agentContext);
      }
    };
    GenericRecordService = __decorate([
      (0, plugins_1.injectable)(),
      __metadata("design:paramtypes", [GenericRecordsRepository_1.GenericRecordsRepository])
    ], GenericRecordService);
    exports.GenericRecordService = GenericRecordService;
  }
});

// node_modules/@aries-framework/core/build/modules/generic-records/GenericRecordsApi.js
var require_GenericRecordsApi = __commonJS({
  "node_modules/@aries-framework/core/build/modules/generic-records/GenericRecordsApi.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GenericRecordsApi = void 0;
    var agent_1 = require_agent();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var GenericRecordService_1 = require_GenericRecordService();
    var GenericRecordsApi = class GenericRecordsApi {
      constructor(genericRecordsService, logger, agentContext) {
        this.genericRecordsService = genericRecordsService;
        this.logger = logger;
        this.agentContext = agentContext;
      }
      async save({ content, tags, id }) {
        try {
          const record = await this.genericRecordsService.save(this.agentContext, {
            id,
            content,
            tags
          });
          return record;
        } catch (error) {
          this.logger.error("Error while saving generic-record", {
            error,
            content,
            errorMessage: error instanceof Error ? error.message : error
          });
          throw error;
        }
      }
      async delete(record) {
        try {
          await this.genericRecordsService.delete(this.agentContext, record);
        } catch (error) {
          this.logger.error("Error while saving generic-record", {
            error,
            content: record.content,
            errorMessage: error instanceof Error ? error.message : error
          });
          throw error;
        }
      }
      async deleteById(id) {
        await this.genericRecordsService.deleteById(this.agentContext, id);
      }
      async update(record) {
        try {
          await this.genericRecordsService.update(this.agentContext, record);
        } catch (error) {
          this.logger.error("Error while update generic-record", {
            error,
            content: record.content,
            errorMessage: error instanceof Error ? error.message : error
          });
          throw error;
        }
      }
      async findById(id) {
        return this.genericRecordsService.findById(this.agentContext, id);
      }
      async findAllByQuery(query) {
        return this.genericRecordsService.findAllByQuery(this.agentContext, query);
      }
      async getAll() {
        return this.genericRecordsService.getAll(this.agentContext);
      }
    };
    GenericRecordsApi = __decorate([
      (0, plugins_1.injectable)(),
      __param(1, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [GenericRecordService_1.GenericRecordService, Object, agent_1.AgentContext])
    ], GenericRecordsApi);
    exports.GenericRecordsApi = GenericRecordsApi;
  }
});

// node_modules/@aries-framework/core/build/modules/generic-records/GenericRecordsModule.js
var require_GenericRecordsModule = __commonJS({
  "node_modules/@aries-framework/core/build/modules/generic-records/GenericRecordsModule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GenericRecordsModule = void 0;
    var GenericRecordsApi_1 = require_GenericRecordsApi();
    var GenericRecordsRepository_1 = require_GenericRecordsRepository();
    var GenericRecordService_1 = require_GenericRecordService();
    var GenericRecordsModule = class {
      constructor() {
        this.api = GenericRecordsApi_1.GenericRecordsApi;
      }
      /**
       * Registers the dependencies of the generic records module on the dependency manager.
       */
      register(dependencyManager) {
        dependencyManager.registerContextScoped(GenericRecordsApi_1.GenericRecordsApi);
        dependencyManager.registerSingleton(GenericRecordService_1.GenericRecordService);
        dependencyManager.registerSingleton(GenericRecordsRepository_1.GenericRecordsRepository);
      }
    };
    exports.GenericRecordsModule = GenericRecordsModule;
  }
});

// node_modules/@aries-framework/core/build/modules/generic-records/index.js
var require_generic_records = __commonJS({
  "node_modules/@aries-framework/core/build/modules/generic-records/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_GenericRecordsApi(), exports);
    __exportStar(require_GenericRecordsModule(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/indy/services/IndyVerifierService.js
var require_IndyVerifierService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/indy/services/IndyVerifierService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyVerifierService = void 0;
    var constants_1 = require_constants();
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var indyError_1 = require_indyError();
    var IndyLedgerService_1 = require_IndyLedgerService();
    var IndyVerifierService = class IndyVerifierService {
      constructor(ledgerService, agentDependencies) {
        this.indy = agentDependencies.indy;
        this.ledgerService = ledgerService;
      }
      async verifyProof(agentContext, { proofRequest, proof, schemas, credentialDefinitions }) {
        try {
          const { revocationRegistryDefinitions, revocationRegistries } = await this.getRevocationRegistries(agentContext, proof);
          return await this.indy.verifierVerifyProof(proofRequest, proof, schemas, credentialDefinitions, revocationRegistryDefinitions, revocationRegistries);
        } catch (error) {
          throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
      }
      async getRevocationRegistries(agentContext, proof) {
        var _a;
        const revocationRegistryDefinitions = {};
        const revocationRegistries = /* @__PURE__ */ Object.create(null);
        for (const identifier of proof.identifiers) {
          const revocationRegistryId = identifier.rev_reg_id;
          const timestamp = identifier.timestamp;
          if (revocationRegistryId && !revocationRegistryDefinitions[revocationRegistryId]) {
            const { revocationRegistryDefinition } = await this.ledgerService.getRevocationRegistryDefinition(agentContext, revocationRegistryId);
            revocationRegistryDefinitions[revocationRegistryId] = revocationRegistryDefinition;
          }
          if (revocationRegistryId && timestamp && !((_a = revocationRegistries[revocationRegistryId]) === null || _a === void 0 ? void 0 : _a[timestamp])) {
            if (!revocationRegistries[revocationRegistryId]) {
              revocationRegistries[revocationRegistryId] = /* @__PURE__ */ Object.create(null);
            }
            const { revocationRegistry } = await this.ledgerService.getRevocationRegistry(agentContext, revocationRegistryId, timestamp);
            revocationRegistries[revocationRegistryId][timestamp] = revocationRegistry;
          }
        }
        return { revocationRegistryDefinitions, revocationRegistries };
      }
    };
    IndyVerifierService = __decorate([
      (0, plugins_1.injectable)(),
      __param(1, (0, plugins_1.inject)(constants_1.InjectionSymbols.AgentDependencies)),
      __metadata("design:paramtypes", [IndyLedgerService_1.IndyLedgerService, Object])
    ], IndyVerifierService);
    exports.IndyVerifierService = IndyVerifierService;
  }
});

// node_modules/@aries-framework/core/build/modules/indy/services/index.js
var require_services9 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/indy/services/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_IndyHolderService(), exports);
    __exportStar(require_IndyIssuerService(), exports);
    __exportStar(require_IndyVerifierService(), exports);
    __exportStar(require_IndyUtilitiesService(), exports);
    __exportStar(require_IndyRevocationService(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/indy/IndyModule.js
var require_IndyModule = __commonJS({
  "node_modules/@aries-framework/core/build/modules/indy/IndyModule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyModule = void 0;
    var services_1 = require_services9();
    var IndyHolderService_1 = require_IndyHolderService();
    var IndyIssuerService_1 = require_IndyIssuerService();
    var IndyVerifierService_1 = require_IndyVerifierService();
    var IndyModule = class {
      register(dependencyManager) {
        dependencyManager.registerSingleton(IndyIssuerService_1.IndyIssuerService);
        dependencyManager.registerSingleton(IndyHolderService_1.IndyHolderService);
        dependencyManager.registerSingleton(IndyVerifierService_1.IndyVerifierService);
        dependencyManager.registerSingleton(services_1.IndyRevocationService);
        dependencyManager.registerSingleton(services_1.IndyUtilitiesService);
      }
    };
    exports.IndyModule = IndyModule;
  }
});

// node_modules/@aries-framework/core/build/modules/indy/index.js
var require_indy2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/indy/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_services9(), exports);
    __exportStar(require_IndyModule(), exports);
  }
});

// node_modules/@aries-framework/core/build/utils/parseInvitation.js
var require_parseInvitation = __commonJS({
  "node_modules/@aries-framework/core/build/utils/parseInvitation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseInvitationShortUrl = exports.oobInvitationFromShortUrl = exports.parseInvitationUrl = void 0;
    var abort_controller_1 = require_browser2();
    var query_string_1 = require_query_string();
    var error_1 = require_error();
    var connections_1 = require_connections();
    var helpers_1 = require_helpers3();
    var messages_1 = require_messages4();
    var JsonTransformer_1 = require_JsonTransformer();
    var MessageValidator_1 = require_MessageValidator();
    var messageType_1 = require_messageType();
    var fetchShortUrl = async (invitationUrl, dependencies) => {
      const abortController = new abort_controller_1.AbortController();
      const id = setTimeout(() => abortController.abort(), 15e3);
      let response;
      try {
        response = await dependencies.fetch(invitationUrl, {
          method: "GET",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json"
          }
        });
      } catch (error) {
        throw new error_1.AriesFrameworkError(`Get request failed on provided url: ${error.message}`, { cause: error });
      }
      clearTimeout(id);
      return response;
    };
    var parseInvitationUrl = (invitationUrl) => {
      const parsedUrl = (0, query_string_1.parseUrl)(invitationUrl).query;
      if (parsedUrl["oob"]) {
        const outOfBandInvitation = messages_1.OutOfBandInvitation.fromUrl(invitationUrl);
        return outOfBandInvitation;
      } else if (parsedUrl["c_i"] || parsedUrl["d_m"]) {
        const invitation = connections_1.ConnectionInvitationMessage.fromUrl(invitationUrl);
        return (0, helpers_1.convertToNewInvitation)(invitation);
      }
      throw new error_1.AriesFrameworkError("InvitationUrl is invalid. It needs to contain one, and only one, of the following parameters: `oob`, `c_i` or `d_m`.");
    };
    exports.parseInvitationUrl = parseInvitationUrl;
    var oobInvitationFromShortUrl = async (response) => {
      var _a;
      if (response) {
        if (((_a = response.headers.get("Content-Type")) === null || _a === void 0 ? void 0 : _a.startsWith("application/json")) && response.ok) {
          const invitationJson = await response.json();
          const parsedMessageType = (0, messageType_1.parseMessageType)(invitationJson["@type"]);
          if ((0, messageType_1.supportsIncomingMessageType)(parsedMessageType, messages_1.OutOfBandInvitation.type)) {
            const invitation = JsonTransformer_1.JsonTransformer.fromJSON(invitationJson, messages_1.OutOfBandInvitation);
            MessageValidator_1.MessageValidator.validateSync(invitation);
            return invitation;
          } else if ((0, messageType_1.supportsIncomingMessageType)(parsedMessageType, connections_1.ConnectionInvitationMessage.type)) {
            const invitation = JsonTransformer_1.JsonTransformer.fromJSON(invitationJson, connections_1.ConnectionInvitationMessage);
            MessageValidator_1.MessageValidator.validateSync(invitation);
            return (0, helpers_1.convertToNewInvitation)(invitation);
          } else {
            throw new error_1.AriesFrameworkError(`Invitation with '@type' ${parsedMessageType.messageTypeUri} not supported.`);
          }
        } else if (response["url"]) {
          let responseUrl;
          const location = response.headers.get("Location");
          if ((response.status === 302 || response.status === 301) && location)
            responseUrl = location;
          else
            responseUrl = response["url"];
          return (0, exports.parseInvitationUrl)(responseUrl);
        }
      }
      throw new error_1.AriesFrameworkError("HTTP request time out or did not receive valid response");
    };
    exports.oobInvitationFromShortUrl = oobInvitationFromShortUrl;
    var parseInvitationShortUrl = async (invitationUrl, dependencies) => {
      const parsedUrl = (0, query_string_1.parseUrl)(invitationUrl).query;
      if (parsedUrl["oob"]) {
        const outOfBandInvitation = messages_1.OutOfBandInvitation.fromUrl(invitationUrl);
        return outOfBandInvitation;
      } else if (parsedUrl["c_i"] || parsedUrl["d_m"]) {
        const invitation = connections_1.ConnectionInvitationMessage.fromUrl(invitationUrl);
        return (0, helpers_1.convertToNewInvitation)(invitation);
      } else {
        try {
          return (0, exports.oobInvitationFromShortUrl)(await fetchShortUrl(invitationUrl, dependencies));
        } catch (error) {
          throw new error_1.AriesFrameworkError("InvitationUrl is invalid. It needs to contain one, and only one, of the following parameters: `oob`, `c_i` or `d_m`, or be valid shortened URL");
        }
      }
    };
    exports.parseInvitationShortUrl = parseInvitationShortUrl;
  }
});

// node_modules/@aries-framework/core/build/modules/oob/handlers/HandshakeReuseHandler.js
var require_HandshakeReuseHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/handlers/HandshakeReuseHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HandshakeReuseHandler = void 0;
    var models_1 = require_models3();
    var HandshakeReuseMessage_1 = require_HandshakeReuseMessage();
    var HandshakeReuseHandler = class {
      constructor(outOfBandService) {
        this.supportedMessages = [HandshakeReuseMessage_1.HandshakeReuseMessage];
        this.outOfBandService = outOfBandService;
      }
      async handle(messageContext) {
        const connectionRecord = messageContext.assertReadyConnection();
        const handshakeReuseAcceptedMessage = await this.outOfBandService.processHandshakeReuse(messageContext);
        return new models_1.OutboundMessageContext(handshakeReuseAcceptedMessage, {
          agentContext: messageContext.agentContext,
          connection: connectionRecord
        });
      }
    };
    exports.HandshakeReuseHandler = HandshakeReuseHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/oob/handlers/index.js
var require_handlers11 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/handlers/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_HandshakeReuseHandler(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/oob/handlers/HandshakeReuseAcceptedHandler.js
var require_HandshakeReuseAcceptedHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/handlers/HandshakeReuseAcceptedHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HandshakeReuseAcceptedHandler = void 0;
    var HandshakeReuseAcceptedMessage_1 = require_HandshakeReuseAcceptedMessage();
    var HandshakeReuseAcceptedHandler = class {
      constructor(outOfBandService) {
        this.supportedMessages = [HandshakeReuseAcceptedMessage_1.HandshakeReuseAcceptedMessage];
        this.outOfBandService = outOfBandService;
      }
      async handle(messageContext) {
        messageContext.assertReadyConnection();
        await this.outOfBandService.processHandshakeReuseAccepted(messageContext);
      }
    };
    exports.HandshakeReuseAcceptedHandler = HandshakeReuseAcceptedHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/oob/OutOfBandApi.js
var require_OutOfBandApi = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/OutOfBandApi.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutOfBandApi = void 0;
    var rxjs_1 = require_cjs();
    var agent_1 = require_agent();
    var EventEmitter_1 = require_EventEmitter();
    var Events_1 = require_Events();
    var MessageHandlerRegistry_1 = require_MessageHandlerRegistry();
    var MessageSender_1 = require_MessageSender();
    var models_1 = require_models3();
    var constants_1 = require_constants();
    var crypto_1 = require_crypto();
    var ServiceDecorator_1 = require_ServiceDecorator();
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var storage_1 = require_storage();
    var utils_1 = require_utils();
    var messageType_1 = require_messageType();
    var parseInvitation_1 = require_parseInvitation();
    var connections_1 = require_connections();
    var didcomm_1 = require_didcomm();
    var dids_1 = require_dids();
    var helpers_1 = require_helpers();
    var RoutingService_1 = require_RoutingService();
    var OutOfBandService_1 = require_OutOfBandService();
    var OutOfBandDidCommService_1 = require_OutOfBandDidCommService();
    var OutOfBandEvents_1 = require_OutOfBandEvents();
    var OutOfBandRole_1 = require_OutOfBandRole();
    var OutOfBandState_1 = require_OutOfBandState();
    var handlers_1 = require_handlers11();
    var HandshakeReuseAcceptedHandler_1 = require_HandshakeReuseAcceptedHandler();
    var helpers_2 = require_helpers3();
    var messages_1 = require_messages4();
    var OutOfBandRecord_1 = require_OutOfBandRecord();
    var didCommProfiles = ["didcomm/aip1", "didcomm/aip2;env=rfc19"];
    var OutOfBandApi = class OutOfBandApi {
      constructor(messageHandlerRegistry, didCommDocumentService, outOfBandService, routingService, connectionsApi, didCommMessageRepository, messageSender, eventEmitter, logger, agentContext) {
        this.messageHandlerRegistry = messageHandlerRegistry;
        this.didCommDocumentService = didCommDocumentService;
        this.agentContext = agentContext;
        this.logger = logger;
        this.outOfBandService = outOfBandService;
        this.routingService = routingService;
        this.connectionsApi = connectionsApi;
        this.didCommMessageRepository = didCommMessageRepository;
        this.messageSender = messageSender;
        this.eventEmitter = eventEmitter;
        this.registerMessageHandlers(messageHandlerRegistry);
      }
      /**
       * Creates an outbound out-of-band record containing out-of-band invitation message defined in
       * Aries RFC 0434: Out-of-Band Protocol 1.1.
       *
       * It automatically adds all supported handshake protocols by agent to `handshake_protocols`. You
       * can modify this by setting `handshakeProtocols` in `config` parameter. If you want to create
       * invitation without handshake, you can set `handshake` to `false`.
       *
       * If `config` parameter contains `messages` it adds them to `requests~attach` attribute.
       *
       * Agent role: sender (inviter)
       *
       * @param config configuration of how out-of-band invitation should be created
       * @returns out-of-band record
       */
      async createInvitation(config = {}) {
        var _a, _b, _c, _d, _e, _f;
        const multiUseInvitation = (_a = config.multiUseInvitation) !== null && _a !== void 0 ? _a : false;
        const handshake = (_b = config.handshake) !== null && _b !== void 0 ? _b : true;
        const customHandshakeProtocols = config.handshakeProtocols;
        const autoAcceptConnection = (_c = config.autoAcceptConnection) !== null && _c !== void 0 ? _c : this.connectionsApi.config.autoAcceptConnections;
        const messages = config.messages && config.messages.length > 0 ? config.messages : void 0;
        const label = (_d = config.label) !== null && _d !== void 0 ? _d : this.agentContext.config.label;
        const imageUrl = (_e = config.imageUrl) !== null && _e !== void 0 ? _e : this.agentContext.config.connectionImageUrl;
        const appendedAttachments = config.appendedAttachments && config.appendedAttachments.length > 0 ? config.appendedAttachments : void 0;
        if (!handshake && !messages) {
          throw new error_1.AriesFrameworkError("One or both of handshake_protocols and requests~attach MUST be included in the message.");
        }
        if (!handshake && customHandshakeProtocols) {
          throw new error_1.AriesFrameworkError(`Attribute 'handshake' can not be 'false' when 'handshakeProtocols' is defined.`);
        }
        if (messages && multiUseInvitation) {
          throw new error_1.AriesFrameworkError("Attribute 'multiUseInvitation' can not be 'true' when 'messages' is defined.");
        }
        let handshakeProtocols;
        if (handshake) {
          if (customHandshakeProtocols) {
            this.assertHandshakeProtocols(customHandshakeProtocols);
            handshakeProtocols = customHandshakeProtocols;
          } else {
            handshakeProtocols = this.getSupportedHandshakeProtocols();
          }
        }
        const routing = (_f = config.routing) !== null && _f !== void 0 ? _f : await this.routingService.getRouting(this.agentContext, {});
        const services = routing.endpoints.map((endpoint, index) => {
          return new OutOfBandDidCommService_1.OutOfBandDidCommService({
            id: `#inline-${index}`,
            serviceEndpoint: endpoint,
            recipientKeys: [routing.recipientKey].map((key) => new dids_1.DidKey(key).did),
            routingKeys: routing.routingKeys.map((key) => new dids_1.DidKey(key).did)
          });
        });
        const options = {
          label,
          goal: config.goal,
          goalCode: config.goalCode,
          imageUrl,
          accept: didCommProfiles,
          services,
          handshakeProtocols,
          appendedAttachments
        };
        const outOfBandInvitation = new messages_1.OutOfBandInvitation(options);
        if (messages) {
          messages.forEach((message) => {
            if (message.service) {
              message.service = void 0;
            }
            outOfBandInvitation.addRequest(message);
          });
        }
        const outOfBandRecord = new OutOfBandRecord_1.OutOfBandRecord({
          mediatorId: routing.mediatorId,
          role: OutOfBandRole_1.OutOfBandRole.Sender,
          state: OutOfBandState_1.OutOfBandState.AwaitResponse,
          alias: config.alias,
          outOfBandInvitation,
          reusable: multiUseInvitation,
          autoAcceptConnection,
          tags: {
            recipientKeyFingerprints: services.reduce((aggr, { recipientKeys }) => [...aggr, ...recipientKeys], []).map((didKey) => dids_1.DidKey.fromDid(didKey).key.fingerprint)
          }
        });
        await this.outOfBandService.save(this.agentContext, outOfBandRecord);
        this.outOfBandService.emitStateChangedEvent(this.agentContext, outOfBandRecord, null);
        return outOfBandRecord;
      }
      /**
       * Creates an outbound out-of-band record in the same way how `createInvitation` method does it,
       * but it also converts out-of-band invitation message to an "legacy" invitation message defined
       * in RFC 0160: Connection Protocol and returns it together with out-of-band record.
       *
       * Agent role: sender (inviter)
       *
       * @param config configuration of how a connection invitation should be created
       * @returns out-of-band record and connection invitation
       */
      async createLegacyInvitation(config = {}) {
        const outOfBandRecord = await this.createInvitation(Object.assign(Object.assign({}, config), { handshakeProtocols: [connections_1.HandshakeProtocol.Connections] }));
        return { outOfBandRecord, invitation: (0, helpers_2.convertToOldInvitation)(outOfBandRecord.outOfBandInvitation) };
      }
      async createLegacyConnectionlessInvitation(config) {
        const routing = await this.routingService.getRouting(this.agentContext);
        config.message.service = new ServiceDecorator_1.ServiceDecorator({
          serviceEndpoint: routing.endpoints[0],
          recipientKeys: [routing.recipientKey].map((key) => key.publicKeyBase58),
          routingKeys: routing.routingKeys.map((key) => key.publicKeyBase58)
        });
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(this.agentContext, {
          agentMessage: config.message,
          associatedRecordId: config.recordId,
          role: storage_1.DidCommMessageRole.Sender
        });
        return {
          message: config.message,
          invitationUrl: `${config.domain}?d_m=${utils_1.JsonEncoder.toBase64URL(utils_1.JsonTransformer.toJSON(config.message))}`
        };
      }
      /**
       * Parses URL, decodes invitation and calls `receiveMessage` with parsed invitation message.
       *
       * Agent role: receiver (invitee)
       *
       * @param invitationUrl url containing a base64 encoded invitation to receive
       * @param config configuration of how out-of-band invitation should be processed
       * @returns out-of-band record and connection record if one has been created
       */
      async receiveInvitationFromUrl(invitationUrl, config = {}) {
        const message = await this.parseInvitation(invitationUrl);
        return this.receiveInvitation(message, config);
      }
      /**
       * Parses URL containing encoded invitation and returns invitation message.
       *
       * Will fetch the url if the url does not contain a base64 encoded invitation.
       *
       * @param invitationUrl URL containing encoded invitation
       *
       * @returns OutOfBandInvitation
       */
      async parseInvitation(invitationUrl) {
        return (0, parseInvitation_1.parseInvitationShortUrl)(invitationUrl, this.agentContext.config.agentDependencies);
      }
      /**
       * Creates inbound out-of-band record and assigns out-of-band invitation message to it if the
       * message is valid. It automatically passes out-of-band invitation for further processing to
       * `acceptInvitation` method. If you don't want to do that you can set `autoAcceptInvitation`
       * attribute in `config` parameter to `false` and accept the message later by calling
       * `acceptInvitation`.
       *
       * It supports both OOB (Aries RFC 0434: Out-of-Band Protocol 1.1) and Connection Invitation
       * (0160: Connection Protocol).
       *
       * Agent role: receiver (invitee)
       *
       * @param invitation either OutOfBandInvitation or ConnectionInvitationMessage
       * @param config config for handling of invitation
       *
       * @returns out-of-band record and connection record if one has been created.
       */
      async receiveInvitation(invitation, config = {}) {
        var _a, _b, _c, _d, _e;
        const outOfBandInvitation = invitation instanceof messages_1.OutOfBandInvitation ? invitation : (0, helpers_2.convertToNewInvitation)(invitation);
        const { handshakeProtocols } = outOfBandInvitation;
        const { routing } = config;
        const autoAcceptInvitation = (_a = config.autoAcceptInvitation) !== null && _a !== void 0 ? _a : true;
        const autoAcceptConnection = (_b = config.autoAcceptConnection) !== null && _b !== void 0 ? _b : true;
        const reuseConnection = (_c = config.reuseConnection) !== null && _c !== void 0 ? _c : false;
        const label = (_d = config.label) !== null && _d !== void 0 ? _d : this.agentContext.config.label;
        const alias = config.alias;
        const imageUrl = (_e = config.imageUrl) !== null && _e !== void 0 ? _e : this.agentContext.config.connectionImageUrl;
        const messages = outOfBandInvitation.getRequests();
        if ((!handshakeProtocols || handshakeProtocols.length === 0) && (!messages || (messages === null || messages === void 0 ? void 0 : messages.length) === 0)) {
          throw new error_1.AriesFrameworkError("One or both of handshake_protocols and requests~attach MUST be included in the message.");
        }
        let [outOfBandRecord] = await this.outOfBandService.findAllByQuery(this.agentContext, {
          invitationId: outOfBandInvitation.id,
          role: OutOfBandRole_1.OutOfBandRole.Receiver
        });
        if (outOfBandRecord) {
          throw new error_1.AriesFrameworkError(`An out of band record with invitation ${outOfBandInvitation.id} has already been received. Invitations should have a unique id.`);
        }
        const recipientKeyFingerprints = [];
        for (const service of outOfBandInvitation.getServices()) {
          if (typeof service === "string") {
            this.logger.debug(`Resolving services for did ${service}.`);
            const resolvedDidCommServices = await this.didCommDocumentService.resolveServicesFromDid(this.agentContext, service);
            recipientKeyFingerprints.push(...resolvedDidCommServices.reduce((aggr, { recipientKeys }) => [...aggr, ...recipientKeys], []).map((key) => key.fingerprint));
          } else {
            recipientKeyFingerprints.push(...service.recipientKeys.map((didKey) => dids_1.DidKey.fromDid(didKey).key.fingerprint));
          }
        }
        outOfBandRecord = new OutOfBandRecord_1.OutOfBandRecord({
          role: OutOfBandRole_1.OutOfBandRole.Receiver,
          state: OutOfBandState_1.OutOfBandState.Initial,
          outOfBandInvitation,
          autoAcceptConnection,
          tags: { recipientKeyFingerprints }
        });
        await this.outOfBandService.save(this.agentContext, outOfBandRecord);
        this.outOfBandService.emitStateChangedEvent(this.agentContext, outOfBandRecord, null);
        if (autoAcceptInvitation) {
          return await this.acceptInvitation(outOfBandRecord.id, {
            label,
            alias,
            imageUrl,
            autoAcceptConnection,
            reuseConnection,
            routing,
            timeoutMs: config.acceptInvitationTimeoutMs
          });
        }
        return { outOfBandRecord };
      }
      /**
       * Creates a connection if the out-of-band invitation message contains `handshake_protocols`
       * attribute, except for the case when connection already exists and `reuseConnection` is enabled.
       *
       * It passes first supported message from `requests~attach` attribute to the agent, except for the
       * case reuse of connection is applied when it just sends `handshake-reuse` message to existing
       * connection.
       *
       * Agent role: receiver (invitee)
       *
       * @param outOfBandId
       * @param config
       * @returns out-of-band record and connection record if one has been created.
       */
      async acceptInvitation(outOfBandId, config) {
        var _a;
        const outOfBandRecord = await this.outOfBandService.getById(this.agentContext, outOfBandId);
        const { outOfBandInvitation } = outOfBandRecord;
        const { label, alias, imageUrl, autoAcceptConnection, reuseConnection, routing } = config;
        const { handshakeProtocols } = outOfBandInvitation;
        const services = outOfBandInvitation.getServices();
        const messages = outOfBandInvitation.getRequests();
        const timeoutMs = (_a = config.timeoutMs) !== null && _a !== void 0 ? _a : 2e4;
        const existingConnection = await this.findExistingConnection(outOfBandInvitation);
        await this.outOfBandService.updateState(this.agentContext, outOfBandRecord, OutOfBandState_1.OutOfBandState.PrepareResponse);
        if (handshakeProtocols) {
          this.logger.debug("Out of band message contains handshake protocols.");
          let connectionRecord;
          if (existingConnection && reuseConnection) {
            this.logger.debug(`Connection already exists and reuse is enabled. Reusing an existing connection with ID ${existingConnection.id}.`);
            if (!messages) {
              this.logger.debug("Out of band message does not contain any request messages.");
              const isHandshakeReuseSuccessful = await this.handleHandshakeReuse(outOfBandRecord, existingConnection);
              if (isHandshakeReuseSuccessful) {
                this.logger.debug(`Handshake reuse successful. Reusing existing connection ${existingConnection.id}.`);
                connectionRecord = existingConnection;
              } else {
                this.logger.debug(`Handshake reuse failed. Not using existing connection ${existingConnection.id}.`);
              }
            } else {
              this.logger.debug(`Reusing existing connection ${existingConnection.id}.`);
              connectionRecord = existingConnection;
            }
          }
          if (!connectionRecord) {
            this.logger.debug("Connection does not exist or reuse is disabled. Creating a new connection.");
            const handshakeProtocol = this.getFirstSupportedProtocol(handshakeProtocols);
            connectionRecord = await this.connectionsApi.acceptOutOfBandInvitation(outOfBandRecord, {
              label,
              alias,
              imageUrl,
              autoAcceptConnection,
              protocol: handshakeProtocol,
              routing
            });
          }
          if (messages) {
            this.logger.debug("Out of band message contains request messages.");
            if (connectionRecord.isReady) {
              await this.emitWithConnection(connectionRecord, messages);
            } else {
              this.connectionsApi.returnWhenIsConnected(connectionRecord.id, { timeoutMs }).then((connectionRecord2) => this.emitWithConnection(connectionRecord2, messages)).catch((error) => {
                if (error instanceof rxjs_1.EmptyError) {
                  this.logger.warn(`Agent unsubscribed before connection got into ${connections_1.DidExchangeState.Completed} state`, error);
                } else {
                  this.logger.error("Promise waiting for the connection to be complete failed.", error);
                }
              });
            }
          }
          return { outOfBandRecord, connectionRecord };
        } else if (messages) {
          this.logger.debug("Out of band message contains only request messages.");
          if (existingConnection) {
            this.logger.debug("Connection already exists.", { connectionId: existingConnection.id });
            await this.emitWithConnection(existingConnection, messages);
          } else {
            await this.emitWithServices(services, messages);
          }
        }
        return { outOfBandRecord };
      }
      async findByReceivedInvitationId(receivedInvitationId) {
        return this.outOfBandService.findByReceivedInvitationId(this.agentContext, receivedInvitationId);
      }
      async findByCreatedInvitationId(createdInvitationId) {
        return this.outOfBandService.findByCreatedInvitationId(this.agentContext, createdInvitationId);
      }
      /**
       * Retrieve all out of bands records
       *
       * @returns List containing all  out of band records
       */
      getAll() {
        return this.outOfBandService.getAll(this.agentContext);
      }
      /**
       * Retrieve all out of bands records by specified query param
       *
       * @returns List containing all out of band records matching specified query params
       */
      findAllByQuery(query) {
        return this.outOfBandService.findAllByQuery(this.agentContext, query);
      }
      /**
       * Retrieve a out of band record by id
       *
       * @param outOfBandId The  out of band record id
       * @throws {RecordNotFoundError} If no record is found
       * @return The out of band record
       *
       */
      getById(outOfBandId) {
        return this.outOfBandService.getById(this.agentContext, outOfBandId);
      }
      /**
       * Find an out of band record by id
       *
       * @param outOfBandId the  out of band record id
       * @returns The out of band record or null if not found
       */
      findById(outOfBandId) {
        return this.outOfBandService.findById(this.agentContext, outOfBandId);
      }
      /**
       * Delete an out of band record by id
       *
       * @param outOfBandId the out of band record id
       */
      async deleteById(outOfBandId) {
        const outOfBandRecord = await this.getById(outOfBandId);
        const relatedConnections = await this.connectionsApi.findAllByOutOfBandId(outOfBandId);
        if (outOfBandRecord.mediatorId && (relatedConnections.length === 0 || outOfBandRecord.reusable)) {
          const recipientKeys = outOfBandRecord.getTags().recipientKeyFingerprints.map((item) => crypto_1.Key.fromFingerprint(item));
          await this.routingService.removeRouting(this.agentContext, {
            recipientKeys,
            mediatorId: outOfBandRecord.mediatorId
          });
        }
        return this.outOfBandService.deleteById(this.agentContext, outOfBandId);
      }
      assertHandshakeProtocols(handshakeProtocols) {
        if (!this.areHandshakeProtocolsSupported(handshakeProtocols)) {
          const supportedProtocols = this.getSupportedHandshakeProtocols();
          throw new error_1.AriesFrameworkError(`Handshake protocols [${handshakeProtocols}] are not supported. Supported protocols are [${supportedProtocols}]`);
        }
      }
      areHandshakeProtocolsSupported(handshakeProtocols) {
        const supportedProtocols = this.getSupportedHandshakeProtocols();
        return handshakeProtocols.every((p) => supportedProtocols.includes(p));
      }
      getSupportedHandshakeProtocols() {
        const handshakeMessageFamilies = ["https://didcomm.org/didexchange", "https://didcomm.org/connections"];
        const handshakeProtocols = this.messageHandlerRegistry.filterSupportedProtocolsByMessageFamilies(handshakeMessageFamilies);
        if (handshakeProtocols.length === 0) {
          throw new error_1.AriesFrameworkError("There is no handshake protocol supported. Agent can not create a connection.");
        }
        const orderedProtocols = handshakeMessageFamilies.map((messageFamily) => handshakeProtocols.find((p) => p.startsWith(messageFamily))).filter((item) => !!item);
        return orderedProtocols;
      }
      getFirstSupportedProtocol(handshakeProtocols) {
        const supportedProtocols = this.getSupportedHandshakeProtocols();
        const handshakeProtocol = handshakeProtocols.find((p) => supportedProtocols.includes(p));
        if (!handshakeProtocol) {
          throw new error_1.AriesFrameworkError(`Handshake protocols [${handshakeProtocols}] are not supported. Supported protocols are [${supportedProtocols}]`);
        }
        return handshakeProtocol;
      }
      async findExistingConnection(outOfBandInvitation) {
        this.logger.debug("Searching for an existing connection for out-of-band invitation.", { outOfBandInvitation });
        for (const invitationDid of outOfBandInvitation.invitationDids) {
          const connections = await this.connectionsApi.findByInvitationDid(invitationDid);
          this.logger.debug(`Retrieved ${connections.length} connections for invitation did ${invitationDid}`);
          if (connections.length === 1) {
            const [firstConnection] = connections;
            return firstConnection;
          } else if (connections.length > 1) {
            this.logger.warn(`There is more than one connection created from invitationDid ${invitationDid}. Taking the first one.`);
            const [firstConnection] = connections;
            return firstConnection;
          }
          return null;
        }
      }
      async emitWithConnection(connectionRecord, messages) {
        const supportedMessageTypes = this.messageHandlerRegistry.supportedMessageTypes;
        const plaintextMessage = messages.find((message) => {
          const parsedMessageType = (0, messageType_1.parseMessageType)(message["@type"]);
          return supportedMessageTypes.find((type) => (0, messageType_1.supportsIncomingMessageType)(parsedMessageType, type));
        });
        if (!plaintextMessage) {
          throw new error_1.AriesFrameworkError("There is no message in requests~attach supported by agent.");
        }
        this.logger.debug(`Message with type ${plaintextMessage["@type"]} can be processed.`);
        this.eventEmitter.emit(this.agentContext, {
          type: Events_1.AgentEventTypes.AgentMessageReceived,
          payload: {
            message: plaintextMessage,
            connection: connectionRecord,
            contextCorrelationId: this.agentContext.contextCorrelationId
          }
        });
      }
      async emitWithServices(services, messages) {
        var _a;
        if (!services || services.length === 0) {
          throw new error_1.AriesFrameworkError(`There are no services. We can not emit messages`);
        }
        const supportedMessageTypes = this.messageHandlerRegistry.supportedMessageTypes;
        const plaintextMessage = messages.find((message) => {
          const parsedMessageType = (0, messageType_1.parseMessageType)(message["@type"]);
          return supportedMessageTypes.find((type) => (0, messageType_1.supportsIncomingMessageType)(parsedMessageType, type));
        });
        if (!plaintextMessage) {
          throw new error_1.AriesFrameworkError("There is no message in requests~attach supported by agent.");
        }
        this.logger.debug(`Message with type ${plaintextMessage["@type"]} can be processed.`);
        let serviceEndpoint;
        let recipientKeys;
        let routingKeys = [];
        const [service] = services;
        if (typeof service === "string") {
          const [didService] = await this.didCommDocumentService.resolveServicesFromDid(this.agentContext, service);
          if (didService) {
            serviceEndpoint = didService.serviceEndpoint;
            recipientKeys = didService.recipientKeys.map((key) => key.publicKeyBase58);
            routingKeys = didService.routingKeys.map((key) => key.publicKeyBase58) || [];
          }
        } else {
          serviceEndpoint = service.serviceEndpoint;
          recipientKeys = service.recipientKeys.map(helpers_1.didKeyToVerkey);
          routingKeys = ((_a = service.routingKeys) === null || _a === void 0 ? void 0 : _a.map(helpers_1.didKeyToVerkey)) || [];
        }
        if (!serviceEndpoint || !recipientKeys) {
          throw new error_1.AriesFrameworkError("Service not found");
        }
        const serviceDecorator = new ServiceDecorator_1.ServiceDecorator({
          recipientKeys,
          routingKeys,
          serviceEndpoint
        });
        plaintextMessage["~service"] = utils_1.JsonTransformer.toJSON(serviceDecorator);
        this.eventEmitter.emit(this.agentContext, {
          type: Events_1.AgentEventTypes.AgentMessageReceived,
          payload: {
            message: plaintextMessage,
            contextCorrelationId: this.agentContext.contextCorrelationId
          }
        });
      }
      async handleHandshakeReuse(outOfBandRecord, connectionRecord) {
        const reuseMessage = await this.outOfBandService.createHandShakeReuse(this.agentContext, outOfBandRecord, connectionRecord);
        const reuseAcceptedEventPromise = (0, rxjs_1.firstValueFrom)(this.eventEmitter.observable(OutOfBandEvents_1.OutOfBandEventTypes.HandshakeReused).pipe(
          (0, Events_1.filterContextCorrelationId)(this.agentContext.contextCorrelationId),
          // Find the first reuse event where the handshake reuse accepted matches the reuse message thread
          // TODO: Should we store the reuse state? Maybe we can keep it in memory for now
          (0, rxjs_1.first)((event) => event.payload.reuseThreadId === reuseMessage.threadId && event.payload.outOfBandRecord.id === outOfBandRecord.id && event.payload.connectionRecord.id === connectionRecord.id),
          // If the event is found, we return the value true
          (0, rxjs_1.map)(() => true),
          (0, rxjs_1.timeout)(15e3),
          // If timeout is reached, we return false
          (0, rxjs_1.catchError)(() => (0, rxjs_1.of)(false))
        ));
        const outboundMessageContext = new models_1.OutboundMessageContext(reuseMessage, {
          agentContext: this.agentContext,
          connection: connectionRecord
        });
        await this.messageSender.sendMessage(outboundMessageContext);
        return reuseAcceptedEventPromise;
      }
      // TODO: we should probably move these to the out of band module and register the handler there
      registerMessageHandlers(messageHandlerRegistry) {
        messageHandlerRegistry.registerMessageHandler(new handlers_1.HandshakeReuseHandler(this.outOfBandService));
        messageHandlerRegistry.registerMessageHandler(new HandshakeReuseAcceptedHandler_1.HandshakeReuseAcceptedHandler(this.outOfBandService));
      }
    };
    OutOfBandApi = __decorate([
      (0, plugins_1.injectable)(),
      __param(8, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [
        MessageHandlerRegistry_1.MessageHandlerRegistry,
        didcomm_1.DidCommDocumentService,
        OutOfBandService_1.OutOfBandService,
        RoutingService_1.RoutingService,
        connections_1.ConnectionsApi,
        storage_1.DidCommMessageRepository,
        MessageSender_1.MessageSender,
        EventEmitter_1.EventEmitter,
        Object,
        agent_1.AgentContext
      ])
    ], OutOfBandApi);
    exports.OutOfBandApi = OutOfBandApi;
  }
});

// node_modules/@aries-framework/core/build/modules/oob/OutOfBandModule.js
var require_OutOfBandModule = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/OutOfBandModule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutOfBandModule = void 0;
    var models_1 = require_models3();
    var OutOfBandApi_1 = require_OutOfBandApi();
    var OutOfBandService_1 = require_OutOfBandService();
    var repository_1 = require_repository3();
    var OutOfBandModule = class {
      constructor() {
        this.api = OutOfBandApi_1.OutOfBandApi;
      }
      /**
       * Registers the dependencies of the ot of band module on the dependency manager.
       */
      register(dependencyManager, featureRegistry) {
        dependencyManager.registerContextScoped(OutOfBandApi_1.OutOfBandApi);
        dependencyManager.registerSingleton(OutOfBandService_1.OutOfBandService);
        dependencyManager.registerSingleton(repository_1.OutOfBandRepository);
        featureRegistry.register(new models_1.Protocol({
          id: "https://didcomm.org/out-of-band/1.1",
          roles: ["sender", "receiver"]
        }));
      }
    };
    exports.OutOfBandModule = OutOfBandModule;
  }
});

// node_modules/@aries-framework/core/build/modules/oob/domain/index.js
var require_domain2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/domain/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_OutOfBandRole(), exports);
    __exportStar(require_OutOfBandState(), exports);
    __exportStar(require_OutOfBandDidCommService(), exports);
    __exportStar(require_OutOfBandEvents(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/oob/index.js
var require_oob = __commonJS({
  "node_modules/@aries-framework/core/build/modules/oob/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_messages4(), exports);
    __exportStar(require_repository3(), exports);
    __exportStar(require_OutOfBandApi(), exports);
    __exportStar(require_OutOfBandService(), exports);
    __exportStar(require_OutOfBandModule(), exports);
    __exportStar(require_domain2(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/errors/PresentationProblemReportReason.js
var require_PresentationProblemReportReason = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/errors/PresentationProblemReportReason.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PresentationProblemReportReason = void 0;
    var PresentationProblemReportReason;
    (function(PresentationProblemReportReason2) {
      PresentationProblemReportReason2["Abandoned"] = "abandoned";
    })(PresentationProblemReportReason = exports.PresentationProblemReportReason || (exports.PresentationProblemReportReason = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/errors/index.js
var require_errors4 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/errors/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_PresentationProblemReportReason(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/indy/errors/InvalidEncodedValueError.js
var require_InvalidEncodedValueError = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/indy/errors/InvalidEncodedValueError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidEncodedValueError = void 0;
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var InvalidEncodedValueError = class extends AriesFrameworkError_1.AriesFrameworkError {
    };
    exports.InvalidEncodedValueError = InvalidEncodedValueError;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/indy/errors/MissingIndyProofMessageError.js
var require_MissingIndyProofMessageError = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/indy/errors/MissingIndyProofMessageError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingIndyProofMessageError = void 0;
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var MissingIndyProofMessageError = class extends AriesFrameworkError_1.AriesFrameworkError {
    };
    exports.MissingIndyProofMessageError = MissingIndyProofMessageError;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/indy/errors/index.js
var require_errors5 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/indy/errors/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_InvalidEncodedValueError(), exports);
    __exportStar(require_MissingIndyProofMessageError(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/AttributeFilter.js
var require_AttributeFilter = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/AttributeFilter.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AttributeFilterTransformer = exports.AttributeFilter = exports.AttributeValue = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var regex_1 = require_regex();
    var AttributeValue = class {
      constructor(options) {
        if (options) {
          this.name = options.name;
          this.value = options.value;
        }
      }
    };
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], AttributeValue.prototype, "name", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], AttributeValue.prototype, "value", void 0);
    exports.AttributeValue = AttributeValue;
    var AttributeFilter = class {
      constructor(options) {
        if (options) {
          this.schemaId = options.schemaId;
          this.schemaIssuerDid = options.schemaIssuerDid;
          this.schemaName = options.schemaName;
          this.schemaVersion = options.schemaVersion;
          this.issuerDid = options.issuerDid;
          this.credentialDefinitionId = options.credentialDefinitionId;
          this.attributeValue = options.attributeValue;
        }
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "schema_id" }),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.Matches)(regex_1.schemaIdRegex),
      __metadata("design:type", String)
    ], AttributeFilter.prototype, "schemaId", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "schema_issuer_did" }),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.Matches)(regex_1.indyDidRegex),
      __metadata("design:type", String)
    ], AttributeFilter.prototype, "schemaIssuerDid", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "schema_name" }),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], AttributeFilter.prototype, "schemaName", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "schema_version" }),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.Matches)(regex_1.schemaVersionRegex, {
        message: "Version must be X.X or X.X.X"
      }),
      __metadata("design:type", String)
    ], AttributeFilter.prototype, "schemaVersion", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "issuer_did" }),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.Matches)(regex_1.indyDidRegex),
      __metadata("design:type", String)
    ], AttributeFilter.prototype, "issuerDid", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "cred_def_id" }),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.Matches)(regex_1.credDefIdRegex),
      __metadata("design:type", String)
    ], AttributeFilter.prototype, "credentialDefinitionId", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_transformer_1.Type)(() => AttributeValue),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsInstance)(AttributeValue),
      __metadata("design:type", AttributeValue)
    ], AttributeFilter.prototype, "attributeValue", void 0);
    exports.AttributeFilter = AttributeFilter;
    function AttributeFilterTransformer() {
      return (0, class_transformer_1.Transform)(({ value: attributeFilter, type: transformationType }) => {
        switch (transformationType) {
          case class_transformer_1.TransformationType.CLASS_TO_PLAIN:
            if (attributeFilter.attributeValue) {
              attributeFilter[`attr::${attributeFilter.attributeValue.name}::value`] = attributeFilter.attributeValue.value;
              delete attributeFilter.attributeValue;
            }
            return attributeFilter;
          case class_transformer_1.TransformationType.PLAIN_TO_CLASS:
            for (const [key, value] of Object.entries(attributeFilter)) {
              const match = new RegExp("^attr::([^:]+)::(value)$").exec(key);
              if (match) {
                const attributeValue = new AttributeValue({
                  name: match[1],
                  value
                });
                delete attributeFilter[key];
                attributeFilter.attributeValue = attributeValue;
                return attributeFilter;
              }
            }
            return attributeFilter;
          default:
            return attributeFilter;
        }
      });
    }
    exports.AttributeFilterTransformer = AttributeFilterTransformer;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/PredicateType.js
var require_PredicateType = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/PredicateType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PredicateType = void 0;
    var PredicateType;
    (function(PredicateType2) {
      PredicateType2["LessThan"] = "<";
      PredicateType2["LessThanOrEqualTo"] = "<=";
      PredicateType2["GreaterThan"] = ">";
      PredicateType2["GreaterThanOrEqualTo"] = ">=";
    })(PredicateType = exports.PredicateType || (exports.PredicateType = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/ProofAttributeInfo.js
var require_ProofAttributeInfo = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/ProofAttributeInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofAttributeInfo = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var credentials_1 = require_credentials();
    var AttributeFilter_1 = require_AttributeFilter();
    var ProofAttributeInfo = class {
      constructor(options) {
        if (options) {
          this.name = options.name;
          this.names = options.names;
          this.nonRevoked = options.nonRevoked;
          this.restrictions = options.restrictions;
        }
      }
    };
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.ValidateIf)((o) => o.names === void 0),
      __metadata("design:type", String)
    ], ProofAttributeInfo.prototype, "name", void 0);
    __decorate([
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.IsString)({ each: true }),
      (0, class_validator_1.ValidateIf)((o) => o.name === void 0),
      (0, class_validator_1.ArrayNotEmpty)(),
      __metadata("design:type", Array)
    ], ProofAttributeInfo.prototype, "names", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "non_revoked" }),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsInstance)(credentials_1.IndyRevocationInterval),
      (0, class_transformer_1.Type)(() => credentials_1.IndyRevocationInterval),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", credentials_1.IndyRevocationInterval)
    ], ProofAttributeInfo.prototype, "nonRevoked", void 0);
    __decorate([
      (0, class_validator_1.ValidateNested)({ each: true }),
      (0, class_transformer_1.Type)(() => AttributeFilter_1.AttributeFilter),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsInstance)(AttributeFilter_1.AttributeFilter, { each: true }),
      __metadata("design:type", Array)
    ], ProofAttributeInfo.prototype, "restrictions", void 0);
    exports.ProofAttributeInfo = ProofAttributeInfo;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/ProofPredicateInfo.js
var require_ProofPredicateInfo = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/ProofPredicateInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofPredicateInfo = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var credentials_1 = require_credentials();
    var AttributeFilter_1 = require_AttributeFilter();
    var PredicateType_1 = require_PredicateType();
    var ProofPredicateInfo = class {
      constructor(options) {
        if (options) {
          this.name = options.name;
          this.nonRevoked = options.nonRevoked;
          this.restrictions = options.restrictions;
          this.predicateType = options.predicateType;
          this.predicateValue = options.predicateValue;
        }
      }
    };
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], ProofPredicateInfo.prototype, "name", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "p_type" }),
      (0, class_validator_1.IsEnum)(PredicateType_1.PredicateType),
      __metadata("design:type", String)
    ], ProofPredicateInfo.prototype, "predicateType", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "p_value" }),
      (0, class_validator_1.IsInt)(),
      __metadata("design:type", Number)
    ], ProofPredicateInfo.prototype, "predicateValue", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "non_revoked" }),
      (0, class_validator_1.ValidateNested)(),
      (0, class_transformer_1.Type)(() => credentials_1.IndyRevocationInterval),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsInstance)(credentials_1.IndyRevocationInterval),
      __metadata("design:type", credentials_1.IndyRevocationInterval)
    ], ProofPredicateInfo.prototype, "nonRevoked", void 0);
    __decorate([
      (0, class_validator_1.ValidateNested)({ each: true }),
      (0, class_transformer_1.Type)(() => AttributeFilter_1.AttributeFilter),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsInstance)(AttributeFilter_1.AttributeFilter, { each: true }),
      (0, class_validator_1.IsArray)(),
      __metadata("design:type", Array)
    ], ProofPredicateInfo.prototype, "restrictions", void 0);
    exports.ProofPredicateInfo = ProofPredicateInfo;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/ProofRequest.js
var require_ProofRequest = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/ProofRequest.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofRequest = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var JsonTransformer_1 = require_JsonTransformer();
    var transformers_1 = require_transformers();
    var credentials_1 = require_credentials();
    var ProofAttributeInfo_1 = require_ProofAttributeInfo();
    var ProofPredicateInfo_1 = require_ProofPredicateInfo();
    var ProofRequest = class {
      constructor(options) {
        if (options) {
          this.name = options.name;
          this.version = options.version;
          this.nonce = options.nonce;
          this.requestedAttributes = options.requestedAttributes ? options.requestedAttributes instanceof Map ? options.requestedAttributes : new Map(Object.entries(options.requestedAttributes)) : /* @__PURE__ */ new Map();
          this.requestedPredicates = options.requestedPredicates ? options.requestedPredicates instanceof Map ? options.requestedPredicates : new Map(Object.entries(options.requestedPredicates)) : /* @__PURE__ */ new Map();
          this.nonRevoked = options.nonRevoked;
          this.ver = options.ver;
        }
      }
      toJSON() {
        return JsonTransformer_1.JsonTransformer.toJSON(this);
      }
    };
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], ProofRequest.prototype, "name", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], ProofRequest.prototype, "version", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], ProofRequest.prototype, "nonce", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "requested_attributes" }),
      (0, transformers_1.IsMap)(),
      (0, class_validator_1.ValidateNested)({ each: true }),
      (0, class_transformer_1.Type)(() => ProofAttributeInfo_1.ProofAttributeInfo),
      (0, class_validator_1.IsInstance)(ProofAttributeInfo_1.ProofAttributeInfo, { each: true }),
      __metadata("design:type", Map)
    ], ProofRequest.prototype, "requestedAttributes", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "requested_predicates" }),
      (0, transformers_1.IsMap)(),
      (0, class_validator_1.ValidateNested)({ each: true }),
      (0, class_transformer_1.Type)(() => ProofPredicateInfo_1.ProofPredicateInfo),
      (0, class_validator_1.IsInstance)(ProofPredicateInfo_1.ProofPredicateInfo, { each: true }),
      __metadata("design:type", Map)
    ], ProofRequest.prototype, "requestedPredicates", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "non_revoked" }),
      (0, class_validator_1.ValidateNested)(),
      (0, class_transformer_1.Type)(() => credentials_1.IndyRevocationInterval),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsInstance)(credentials_1.IndyRevocationInterval),
      __metadata("design:type", credentials_1.IndyRevocationInterval)
    ], ProofRequest.prototype, "nonRevoked", void 0);
    __decorate([
      (0, class_validator_1.IsIn)(["1.0", "2.0"]),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], ProofRequest.prototype, "ver", void 0);
    exports.ProofRequest = ProofRequest;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/RequestedAttribute.js
var require_RequestedAttribute = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/RequestedAttribute.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RequestedAttribute = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var IndyCredentialInfo_1 = require_IndyCredentialInfo();
    var RequestedAttribute = class {
      constructor(options) {
        if (options) {
          this.credentialId = options.credentialId;
          this.timestamp = options.timestamp;
          this.revealed = options.revealed;
          this.credentialInfo = options.credentialInfo;
          this.revoked = options.revoked;
        }
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "cred_id" }),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], RequestedAttribute.prototype, "credentialId", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "timestamp" }),
      (0, class_validator_1.IsInt)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Number)
    ], RequestedAttribute.prototype, "timestamp", void 0);
    __decorate([
      (0, class_validator_1.IsBoolean)(),
      __metadata("design:type", Boolean)
    ], RequestedAttribute.prototype, "revealed", void 0);
    __decorate([
      (0, class_transformer_1.Exclude)({ toPlainOnly: true }),
      __metadata("design:type", IndyCredentialInfo_1.IndyCredentialInfo)
    ], RequestedAttribute.prototype, "credentialInfo", void 0);
    __decorate([
      (0, class_transformer_1.Exclude)({ toPlainOnly: true }),
      __metadata("design:type", Boolean)
    ], RequestedAttribute.prototype, "revoked", void 0);
    exports.RequestedAttribute = RequestedAttribute;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/RequestedPredicate.js
var require_RequestedPredicate = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/RequestedPredicate.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RequestedPredicate = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var credentials_1 = require_credentials();
    var RequestedPredicate = class {
      constructor(options) {
        if (options) {
          this.credentialId = options.credentialId;
          this.timestamp = options.timestamp;
          this.credentialInfo = options.credentialInfo;
          this.revoked = options.revoked;
        }
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "cred_id" }),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], RequestedPredicate.prototype, "credentialId", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "timestamp" }),
      (0, class_validator_1.IsInt)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Number)
    ], RequestedPredicate.prototype, "timestamp", void 0);
    __decorate([
      (0, class_transformer_1.Exclude)({ toPlainOnly: true }),
      __metadata("design:type", credentials_1.IndyCredentialInfo)
    ], RequestedPredicate.prototype, "credentialInfo", void 0);
    __decorate([
      (0, class_transformer_1.Exclude)({ toPlainOnly: true }),
      __metadata("design:type", Boolean)
    ], RequestedPredicate.prototype, "revoked", void 0);
    exports.RequestedPredicate = RequestedPredicate;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/RequestedCredentials.js
var require_RequestedCredentials = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/RequestedCredentials.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RequestedCredentials = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var JsonTransformer_1 = require_JsonTransformer();
    var transformers_1 = require_transformers();
    var RequestedAttribute_1 = require_RequestedAttribute();
    var RequestedPredicate_1 = require_RequestedPredicate();
    var RequestedCredentials = class {
      constructor(options = {}) {
        var _a, _b, _c;
        if (options) {
          this.requestedAttributes = (_a = options.requestedAttributes) !== null && _a !== void 0 ? _a : {};
          this.requestedPredicates = (_b = options.requestedPredicates) !== null && _b !== void 0 ? _b : {};
          this.selfAttestedAttributes = (_c = options.selfAttestedAttributes) !== null && _c !== void 0 ? _c : {};
        }
      }
      toJSON() {
        return JsonTransformer_1.JsonTransformer.toJSON(this);
      }
      getCredentialIdentifiers() {
        const credIds = /* @__PURE__ */ new Set();
        Object.values(this.requestedAttributes).forEach((attr) => {
          credIds.add(attr.credentialId);
        });
        Object.values(this.requestedPredicates).forEach((pred) => {
          credIds.add(pred.credentialId);
        });
        return Array.from(credIds);
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "requested_attributes" }),
      (0, class_validator_1.ValidateNested)({ each: true }),
      (0, transformers_1.RecordTransformer)(RequestedAttribute_1.RequestedAttribute),
      __metadata("design:type", Object)
    ], RequestedCredentials.prototype, "requestedAttributes", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "requested_predicates" }),
      (0, class_validator_1.ValidateNested)({ each: true }),
      (0, transformers_1.RecordTransformer)(RequestedPredicate_1.RequestedPredicate),
      __metadata("design:type", Object)
    ], RequestedCredentials.prototype, "requestedPredicates", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "self_attested_attributes" }),
      __metadata("design:type", Object)
    ], RequestedCredentials.prototype, "selfAttestedAttributes", void 0);
    exports.RequestedCredentials = RequestedCredentials;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/RetrievedCredentials.js
var require_RetrievedCredentials = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/RetrievedCredentials.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RetrievedCredentials = void 0;
    var RetrievedCredentials = class {
      constructor(options = {}) {
        var _a, _b;
        this.requestedAttributes = (_a = options.requestedAttributes) !== null && _a !== void 0 ? _a : {};
        this.requestedPredicates = (_b = options.requestedPredicates) !== null && _b !== void 0 ? _b : {};
      }
    };
    exports.RetrievedCredentials = RetrievedCredentials;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/index.js
var require_models9 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/indy/models/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_AttributeFilter(), exports);
    __exportStar(require_PredicateType(), exports);
    __exportStar(require_ProofAttributeInfo(), exports);
    __exportStar(require_ProofPredicateInfo(), exports);
    __exportStar(require_ProofRequest(), exports);
    __exportStar(require_RequestedAttribute(), exports);
    __exportStar(require_RequestedCredentials(), exports);
    __exportStar(require_RequestedPredicate(), exports);
    __exportStar(require_RetrievedCredentials(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/indy/IndyProofFormat.js
var require_IndyProofFormat = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/indy/IndyProofFormat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/indy/IndyProofFormatsServiceOptions.js
var require_IndyProofFormatsServiceOptions = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/indy/IndyProofFormatsServiceOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/indy/index.js
var require_indy3 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/indy/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_errors5(), exports);
    __exportStar(require_models9(), exports);
    __exportStar(require_IndyProofFormat(), exports);
    __exportStar(require_IndyProofFormatsServiceOptions(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/models/ProofAttachmentFormat.js
var require_ProofAttachmentFormat = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/models/ProofAttachmentFormat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/models/ProofFormatServiceOptions.js
var require_ProofFormatServiceOptions = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/models/ProofFormatServiceOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/models/index.js
var require_models10 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/models/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ProofAttachmentFormat(), exports);
    __exportStar(require_ProofFormatServiceOptions(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/ProofFormat.js
var require_ProofFormat = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/ProofFormat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/ProofFormatConstants.js
var require_ProofFormatConstants = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/ProofFormatConstants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2_INDY_PRESENTATION = exports.V2_INDY_PRESENTATION_REQUEST = exports.V2_INDY_PRESENTATION_PROPOSAL = exports.INDY_ATTACH_ID = void 0;
    exports.INDY_ATTACH_ID = "indy";
    exports.V2_INDY_PRESENTATION_PROPOSAL = "hlindy/proof-req@v2.0";
    exports.V2_INDY_PRESENTATION_REQUEST = "hlindy/proof-req@v2.0";
    exports.V2_INDY_PRESENTATION = "hlindy/proof@v2.0";
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/ProofFormatService.js
var require_ProofFormatService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/ProofFormatService.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofFormatService = void 0;
    var ProofFormatService = class {
      constructor(didCommMessageRepository, agentConfig) {
        this.didCommMessageRepository = didCommMessageRepository;
        this.agentConfig = agentConfig;
      }
    };
    exports.ProofFormatService = ProofFormatService;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/ProofFormatServiceOptions.js
var require_ProofFormatServiceOptions2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/ProofFormatServiceOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/index.js
var require_formats2 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_indy3(), exports);
    __exportStar(require_models10(), exports);
    __exportStar(require_ProofFormat(), exports);
    __exportStar(require_ProofFormatConstants(), exports);
    __exportStar(require_ProofFormatService(), exports);
    __exportStar(require_ProofFormatServiceOptions2(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/messages/PresentationAckMessage.js
var require_PresentationAckMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/messages/PresentationAckMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/messages/index.js
var require_messages13 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/messages/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_PresentationAckMessage(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/messages/V1PresentationProblemReportMessage.js
var require_V1PresentationProblemReportMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/messages/V1PresentationProblemReportMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1PresentationProblemReportMessage = void 0;
    var messageType_1 = require_messageType();
    var ProblemReportMessage_1 = require_ProblemReportMessage();
    var V1PresentationProblemReportMessage = class extends ProblemReportMessage_1.ProblemReportMessage {
      /**
       * Create new PresentationProblemReportMessage instance.
       * @param options description of error and multiple optional fields for reporting problem
       */
      constructor(options) {
        super(options);
        this.type = V1PresentationProblemReportMessage.type.messageTypeUri;
      }
    };
    V1PresentationProblemReportMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/present-proof/1.0/problem-report");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V1PresentationProblemReportMessage.type),
      __metadata("design:type", Object)
    ], V1PresentationProblemReportMessage.prototype, "type", void 0);
    exports.V1PresentationProblemReportMessage = V1PresentationProblemReportMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/errors/V1PresentationProblemReportError.js
var require_V1PresentationProblemReportError = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/errors/V1PresentationProblemReportError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1PresentationProblemReportError = void 0;
    var problem_reports_1 = require_problem_reports();
    var V1PresentationProblemReportMessage_1 = require_V1PresentationProblemReportMessage();
    var V1PresentationProblemReportError = class extends problem_reports_1.ProblemReportError {
      constructor(message, { problemCode }) {
        super(message, { problemCode });
        this.message = message;
        this.problemReport = new V1PresentationProblemReportMessage_1.V1PresentationProblemReportMessage({
          description: {
            en: message,
            code: problemCode
          }
        });
      }
    };
    exports.V1PresentationProblemReportError = V1PresentationProblemReportError;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/errors/index.js
var require_errors6 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/errors/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_V1PresentationProblemReportError(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/models/V1PresentationPreview.js
var require_V1PresentationPreview = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/models/V1PresentationPreview.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PresentationPreview = exports.PresentationPreviewPredicate = exports.PresentationPreviewAttribute = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var utils_1 = require_utils();
    var JsonTransformer_1 = require_JsonTransformer();
    var messageType_1 = require_messageType();
    var PredicateType_1 = require_PredicateType();
    var PresentationPreviewAttribute = class {
      constructor(options) {
        if (options) {
          this.name = options.name;
          this.credentialDefinitionId = options.credentialDefinitionId;
          this.mimeType = options.mimeType;
          this.value = options.value;
          this.referent = options.referent;
        }
      }
      toJSON() {
        return JsonTransformer_1.JsonTransformer.toJSON(this);
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "cred_def_id" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.ValidateIf)((o) => o.referent !== void 0),
      (0, class_validator_1.Matches)(utils_1.credDefIdRegex),
      __metadata("design:type", String)
    ], PresentationPreviewAttribute.prototype, "credentialDefinitionId", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "mime-type" }),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsMimeType)(),
      __metadata("design:type", String)
    ], PresentationPreviewAttribute.prototype, "mimeType", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], PresentationPreviewAttribute.prototype, "value", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], PresentationPreviewAttribute.prototype, "referent", void 0);
    exports.PresentationPreviewAttribute = PresentationPreviewAttribute;
    var PresentationPreviewPredicate = class {
      constructor(options) {
        if (options) {
          this.name = options.name;
          this.credentialDefinitionId = options.credentialDefinitionId;
          this.predicate = options.predicate;
          this.threshold = options.threshold;
        }
      }
      toJSON() {
        return JsonTransformer_1.JsonTransformer.toJSON(this);
      }
    };
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], PresentationPreviewPredicate.prototype, "name", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "cred_def_id" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.Matches)(utils_1.credDefIdRegex),
      __metadata("design:type", String)
    ], PresentationPreviewPredicate.prototype, "credentialDefinitionId", void 0);
    __decorate([
      (0, class_validator_1.IsEnum)(PredicateType_1.PredicateType),
      __metadata("design:type", String)
    ], PresentationPreviewPredicate.prototype, "predicate", void 0);
    __decorate([
      (0, class_validator_1.IsInt)(),
      __metadata("design:type", Number)
    ], PresentationPreviewPredicate.prototype, "threshold", void 0);
    exports.PresentationPreviewPredicate = PresentationPreviewPredicate;
    var PresentationPreview = class {
      constructor(options) {
        var _a, _b;
        this.type = PresentationPreview.type.messageTypeUri;
        if (options) {
          this.attributes = (_a = options.attributes) !== null && _a !== void 0 ? _a : [];
          this.predicates = (_b = options.predicates) !== null && _b !== void 0 ? _b : [];
        }
      }
      toJSON() {
        return JsonTransformer_1.JsonTransformer.toJSON(this);
      }
    };
    PresentationPreview.type = (0, messageType_1.parseMessageType)("https://didcomm.org/present-proof/1.0/presentation-preview");
    __decorate([
      (0, class_transformer_1.Expose)({ name: "@type" }),
      (0, messageType_1.IsValidMessageType)(PresentationPreview.type),
      (0, class_transformer_1.Transform)(({ value }) => (0, messageType_1.replaceLegacyDidSovPrefix)(value), {
        toClassOnly: true
      }),
      __metadata("design:type", Object)
    ], PresentationPreview.prototype, "type", void 0);
    __decorate([
      (0, class_transformer_1.Type)(() => PresentationPreviewAttribute),
      (0, class_validator_1.ValidateNested)({ each: true }),
      (0, class_validator_1.IsInstance)(PresentationPreviewAttribute, { each: true }),
      __metadata("design:type", Array)
    ], PresentationPreview.prototype, "attributes", void 0);
    __decorate([
      (0, class_transformer_1.Type)(() => PresentationPreviewPredicate),
      (0, class_validator_1.ValidateNested)({ each: true }),
      (0, class_validator_1.IsInstance)(PresentationPreviewPredicate, { each: true }),
      __metadata("design:type", Array)
    ], PresentationPreview.prototype, "predicates", void 0);
    exports.PresentationPreview = PresentationPreview;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/messages/V1ProposePresentationMessage.js
var require_V1ProposePresentationMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/messages/V1ProposePresentationMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1ProposePresentationMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var messageType_1 = require_messageType();
    var V1PresentationPreview_1 = require_V1PresentationPreview();
    var V1ProposePresentationMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a;
        super();
        this.type = V1ProposePresentationMessage.type.messageTypeUri;
        if (options) {
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.comment = options.comment;
          if (options.parentThreadId) {
            this.setThread({
              parentThreadId: options.parentThreadId
            });
          }
          this.presentationProposal = options.presentationProposal;
        }
      }
    };
    V1ProposePresentationMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/present-proof/1.0/propose-presentation");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V1ProposePresentationMessage.type),
      __metadata("design:type", Object)
    ], V1ProposePresentationMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], V1ProposePresentationMessage.prototype, "comment", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "presentation_proposal" }),
      (0, class_transformer_1.Type)(() => V1PresentationPreview_1.PresentationPreview),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsInstance)(V1PresentationPreview_1.PresentationPreview),
      __metadata("design:type", V1PresentationPreview_1.PresentationPreview)
    ], V1ProposePresentationMessage.prototype, "presentationProposal", void 0);
    exports.V1ProposePresentationMessage = V1ProposePresentationMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/models/ProofFormatSpec.js
var require_ProofFormatSpec = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/models/ProofFormatSpec.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofFormatSpec = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var uuid_1 = require_uuid();
    var ProofFormatSpec = class {
      constructor(options) {
        var _a;
        if (options) {
          this.attachmentId = (_a = options.attachmentId) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.format = options.format;
        }
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "attach_id" }),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], ProofFormatSpec.prototype, "attachmentId", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], ProofFormatSpec.prototype, "format", void 0);
    exports.ProofFormatSpec = ProofFormatSpec;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/messages/V1RequestPresentationMessage.js
var require_V1RequestPresentationMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/messages/V1RequestPresentationMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1RequestPresentationMessage = exports.INDY_PROOF_REQUEST_ATTACHMENT_ID = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var Attachment_1 = require_Attachment();
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var JsonTransformer_1 = require_JsonTransformer();
    var messageType_1 = require_messageType();
    var ProofFormatConstants_1 = require_ProofFormatConstants();
    var ProofRequest_1 = require_ProofRequest();
    var ProofFormatSpec_1 = require_ProofFormatSpec();
    exports.INDY_PROOF_REQUEST_ATTACHMENT_ID = "libindy-request-presentation-0";
    var V1RequestPresentationMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a;
        super();
        this.type = V1RequestPresentationMessage.type.messageTypeUri;
        if (options) {
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.comment = options.comment;
          this.requestPresentationAttachments = options.requestPresentationAttachments;
          if (options.parentThreadId) {
            this.setThread({
              parentThreadId: options.parentThreadId
            });
          }
        }
      }
      get indyProofRequest() {
        const proofRequestJson = this.indyProofRequestJson;
        const proofRequest = JsonTransformer_1.JsonTransformer.fromJSON(proofRequestJson, ProofRequest_1.ProofRequest);
        return proofRequest;
      }
      get indyProofRequestJson() {
        var _a;
        const attachment = this.requestPresentationAttachments.find((attachment2) => attachment2.id === exports.INDY_PROOF_REQUEST_ATTACHMENT_ID);
        return (_a = attachment === null || attachment === void 0 ? void 0 : attachment.getDataAsJson()) !== null && _a !== void 0 ? _a : null;
      }
      getAttachmentFormats() {
        const attachment = this.indyAttachment;
        if (!attachment) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`Could not find a request presentation attachment`);
        }
        return [
          {
            format: new ProofFormatSpec_1.ProofFormatSpec({ format: ProofFormatConstants_1.V2_INDY_PRESENTATION_REQUEST }),
            attachment
          }
        ];
      }
      get indyAttachment() {
        var _a;
        return (_a = this.requestPresentationAttachments.find((attachment) => attachment.id === exports.INDY_PROOF_REQUEST_ATTACHMENT_ID)) !== null && _a !== void 0 ? _a : null;
      }
    };
    V1RequestPresentationMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/present-proof/1.0/request-presentation");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V1RequestPresentationMessage.type),
      __metadata("design:type", Object)
    ], V1RequestPresentationMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], V1RequestPresentationMessage.prototype, "comment", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "request_presentations~attach" }),
      (0, class_transformer_1.Type)(() => Attachment_1.Attachment),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)({
        each: true
      }),
      (0, class_validator_1.IsInstance)(Attachment_1.Attachment, { each: true }),
      __metadata("design:type", Array)
    ], V1RequestPresentationMessage.prototype, "requestPresentationAttachments", void 0);
    exports.V1RequestPresentationMessage = V1RequestPresentationMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/messages/V1PresentationMessage.js
var require_V1PresentationMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/messages/V1PresentationMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1PresentationMessage = exports.INDY_PROOF_ATTACHMENT_ID = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var Attachment_1 = require_Attachment();
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var messageType_1 = require_messageType();
    var ProofFormatConstants_1 = require_ProofFormatConstants();
    var ProofFormatSpec_1 = require_ProofFormatSpec();
    exports.INDY_PROOF_ATTACHMENT_ID = "libindy-presentation-0";
    var V1PresentationMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a;
        super();
        this.type = V1PresentationMessage.type.messageTypeUri;
        if (options) {
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : this.generateId();
          this.comment = options.comment;
          this.presentationAttachments = options.presentationAttachments;
          this.appendedAttachments = options.attachments;
        }
      }
      getAttachmentFormats() {
        const attachment = this.indyAttachment;
        if (!attachment) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`Could not find a presentation attachment`);
        }
        return [
          {
            format: new ProofFormatSpec_1.ProofFormatSpec({ format: ProofFormatConstants_1.V2_INDY_PRESENTATION }),
            attachment
          }
        ];
      }
      get indyAttachment() {
        var _a;
        return (_a = this.presentationAttachments.find((attachment) => attachment.id === exports.INDY_PROOF_ATTACHMENT_ID)) !== null && _a !== void 0 ? _a : null;
      }
      get indyProof() {
        var _a;
        const attachment = this.indyAttachment;
        const proofJson = (_a = attachment === null || attachment === void 0 ? void 0 : attachment.getDataAsJson()) !== null && _a !== void 0 ? _a : null;
        return proofJson;
      }
    };
    V1PresentationMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/present-proof/1.0/presentation");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V1PresentationMessage.type),
      __metadata("design:type", Object)
    ], V1PresentationMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], V1PresentationMessage.prototype, "comment", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "presentations~attach" }),
      (0, class_transformer_1.Type)(() => Attachment_1.Attachment),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)({
        each: true
      }),
      (0, class_validator_1.IsInstance)(Attachment_1.Attachment, { each: true }),
      __metadata("design:type", Array)
    ], V1PresentationMessage.prototype, "presentationAttachments", void 0);
    exports.V1PresentationMessage = V1PresentationMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/messages/V1PresentationAckMessage.js
var require_V1PresentationAckMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/messages/V1PresentationAckMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1PresentationAckMessage = void 0;
    var messageType_1 = require_messageType();
    var common_1 = require_common();
    var V1PresentationAckMessage = class extends common_1.AckMessage {
      constructor(options) {
        super(options);
        this.type = V1PresentationAckMessage.type.messageTypeUri;
      }
    };
    V1PresentationAckMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/present-proof/1.0/ack");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V1PresentationAckMessage.type),
      __metadata("design:type", Object)
    ], V1PresentationAckMessage.prototype, "type", void 0);
    exports.V1PresentationAckMessage = V1PresentationAckMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/messages/index.js
var require_messages14 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/messages/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_V1ProposePresentationMessage(), exports);
    __exportStar(require_V1RequestPresentationMessage(), exports);
    __exportStar(require_V1PresentationProblemReportMessage(), exports);
    __exportStar(require_V1PresentationMessage(), exports);
    __exportStar(require_V1PresentationAckMessage(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/models/ProofIdentifier.js
var require_ProofIdentifier = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/models/ProofIdentifier.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofIdentifier = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var regex_1 = require_regex();
    var ProofIdentifier = class {
      constructor(options) {
        if (options) {
          this.schemaId = options.schemaId;
          this.credentialDefinitionId = options.credentialDefinitionId;
          this.revocationRegistryId = options.revocationRegistryId;
          this.timestamp = options.timestamp;
        }
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "schema_id" }),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], ProofIdentifier.prototype, "schemaId", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "cred_def_id" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.Matches)(regex_1.credDefIdRegex),
      __metadata("design:type", String)
    ], ProofIdentifier.prototype, "credentialDefinitionId", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "rev_reg_id" }),
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], ProofIdentifier.prototype, "revocationRegistryId", void 0);
    __decorate([
      (0, class_validator_1.IsOptional)(),
      (0, class_validator_1.IsNumber)(),
      __metadata("design:type", Number)
    ], ProofIdentifier.prototype, "timestamp", void 0);
    exports.ProofIdentifier = ProofIdentifier;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/models/ProofAttribute.js
var require_ProofAttribute = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/models/ProofAttribute.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofAttribute = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var ProofAttribute = class {
      constructor(options) {
        if (options) {
          this.subProofIndex = options.subProofIndex;
          this.raw = options.raw;
          this.encoded = options.encoded;
        }
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "sub_proof_index" }),
      (0, class_validator_1.IsInt)(),
      __metadata("design:type", Number)
    ], ProofAttribute.prototype, "subProofIndex", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], ProofAttribute.prototype, "raw", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      __metadata("design:type", String)
    ], ProofAttribute.prototype, "encoded", void 0);
    exports.ProofAttribute = ProofAttribute;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/models/RequestedProof.js
var require_RequestedProof = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/models/RequestedProof.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RequestedProof = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var ProofAttribute_1 = require_ProofAttribute();
    var RequestedProof = class {
      constructor(options) {
        this.selfAttestedAttributes = /* @__PURE__ */ new Map();
        if (options) {
          this.revealedAttributes = options.revealedAttributes;
          this.selfAttestedAttributes = options.selfAttestedAttributes;
        }
      }
    };
    __decorate([
      (0, class_transformer_1.Expose)({ name: "revealed_attrs" }),
      (0, class_validator_1.ValidateNested)({ each: true }),
      (0, class_transformer_1.Type)(() => ProofAttribute_1.ProofAttribute),
      (0, class_validator_1.IsInstance)(ProofAttribute_1.ProofAttribute, { each: true }),
      __metadata("design:type", Map)
    ], RequestedProof.prototype, "revealedAttributes", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "self_attested_attrs" }),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", Map)
    ], RequestedProof.prototype, "selfAttestedAttributes", void 0);
    exports.RequestedProof = RequestedProof;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/models/PartialProof.js
var require_PartialProof = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/models/PartialProof.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PartialProof = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var ProofIdentifier_1 = require_ProofIdentifier();
    var RequestedProof_1 = require_RequestedProof();
    var PartialProof = class {
      constructor(options) {
        if (options) {
          this.identifiers = options.identifiers;
        }
      }
    };
    __decorate([
      (0, class_transformer_1.Type)(() => ProofIdentifier_1.ProofIdentifier),
      (0, class_validator_1.ValidateNested)({ each: true }),
      (0, class_validator_1.IsInstance)(ProofIdentifier_1.ProofIdentifier, { each: true }),
      __metadata("design:type", Array)
    ], PartialProof.prototype, "identifiers", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "requested_proof" }),
      (0, class_transformer_1.Type)(() => RequestedProof_1.RequestedProof),
      (0, class_validator_1.ValidateNested)(),
      (0, class_validator_1.IsInstance)(RequestedProof_1.RequestedProof),
      __metadata("design:type", RequestedProof_1.RequestedProof)
    ], PartialProof.prototype, "requestedProof", void 0);
    exports.PartialProof = PartialProof;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/models/index.js
var require_models11 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/models/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_PartialProof(), exports);
    __exportStar(require_ProofAttribute(), exports);
    __exportStar(require_ProofIdentifier(), exports);
    __exportStar(require_RequestedProof(), exports);
    __exportStar(require_V1PresentationPreview(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/ProofEvents.js
var require_ProofEvents = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/ProofEvents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofEventTypes = void 0;
    var ProofEventTypes;
    (function(ProofEventTypes2) {
      ProofEventTypes2["ProofStateChanged"] = "ProofStateChanged";
    })(ProofEventTypes = exports.ProofEventTypes || (exports.ProofEventTypes = {}));
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/ProofService.js
var require_ProofService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/ProofService.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofService = void 0;
    var JsonTransformer_1 = require_JsonTransformer();
    var ProofEvents_1 = require_ProofEvents();
    var ProofService = class {
      constructor(agentConfig, proofRepository, connectionService, didCommMessageRepository, wallet, eventEmitter) {
        this.proofRepository = proofRepository;
        this.connectionService = connectionService;
        this.didCommMessageRepository = didCommMessageRepository;
        this.eventEmitter = eventEmitter;
        this.wallet = wallet;
        this.logger = agentConfig.logger;
      }
      emitStateChangedEvent(agentContext, proofRecord, previousState) {
        const clonedProof = JsonTransformer_1.JsonTransformer.clone(proofRecord);
        this.eventEmitter.emit(agentContext, {
          type: ProofEvents_1.ProofEventTypes.ProofStateChanged,
          payload: {
            proofRecord: clonedProof,
            previousState
          }
        });
      }
      /**
       * Update the record to a new state and emit an state changed event. Also updates the record
       * in storage.
       *
       * @param proofRecord The proof record to update the state for
       * @param newState The state to update to
       *
       */
      async updateState(agentContext, proofRecord, newState) {
        const previousState = proofRecord.state;
        proofRecord.state = newState;
        await this.proofRepository.update(agentContext, proofRecord);
        this.emitStateChangedEvent(agentContext, proofRecord, previousState);
      }
      update(agentContext, proofRecord) {
        return this.proofRepository.update(agentContext, proofRecord);
      }
      async saveOrUpdatePresentationMessage(agentContext, options) {
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          associatedRecordId: options.proofRecord.id,
          agentMessage: options.message,
          role: options.role
        });
      }
      async delete(agentContext, proofRecord, options) {
        var _a;
        await this.proofRepository.delete(agentContext, proofRecord);
        const deleteAssociatedDidCommMessages = (_a = options === null || options === void 0 ? void 0 : options.deleteAssociatedDidCommMessages) !== null && _a !== void 0 ? _a : true;
        if (deleteAssociatedDidCommMessages) {
          const didCommMessages = await this.didCommMessageRepository.findByQuery(agentContext, {
            associatedRecordId: proofRecord.id
          });
          for (const didCommMessage of didCommMessages) {
            await this.didCommMessageRepository.delete(agentContext, didCommMessage);
          }
        }
      }
    };
    exports.ProofService = ProofService;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/formats/indy/IndyProofFormatService.js
var require_IndyProofFormatService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/formats/indy/IndyProofFormatService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndyProofFormatService = void 0;
    var tsyringe_1 = (init_esm53(), __toCommonJS(esm5_exports3));
    var AgentConfig_1 = require_AgentConfig();
    var Attachment_1 = require_Attachment();
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var logger_1 = require_logger();
    var DidCommMessageRepository_1 = require_DidCommMessageRepository();
    var utils_1 = require_utils();
    var JsonEncoder_1 = require_JsonEncoder();
    var JsonTransformer_1 = require_JsonTransformer();
    var MessageValidator_1 = require_MessageValidator();
    var uuid_1 = require_uuid();
    var IndyWallet_1 = require_IndyWallet();
    var credentials_1 = require_credentials();
    var IndyCredentialUtils_1 = require_IndyCredentialUtils();
    var indy_1 = require_indy2();
    var ledger_1 = require_ledger();
    var ProofFormatSpec_1 = require_ProofFormatSpec();
    var models_1 = require_models11();
    var ProofFormatConstants_1 = require_ProofFormatConstants();
    var ProofFormatService_1 = require_ProofFormatService();
    var InvalidEncodedValueError_1 = require_InvalidEncodedValueError();
    var MissingIndyProofMessageError_1 = require_MissingIndyProofMessageError();
    var models_2 = require_models9();
    var ProofRequest_1 = require_ProofRequest();
    var RequestedCredentials_1 = require_RequestedCredentials();
    var RetrievedCredentials_1 = require_RetrievedCredentials();
    var IndyProofFormatService = class IndyProofFormatService extends ProofFormatService_1.ProofFormatService {
      constructor(agentConfig, indyHolderService, indyVerifierService, indyRevocationService, ledgerService, didCommMessageRepository, wallet) {
        super(didCommMessageRepository, agentConfig);
        this.formatKey = "indy";
        this.proofRecordType = "indy";
        this.indyHolderService = indyHolderService;
        this.indyVerifierService = indyVerifierService;
        this.indyRevocationService = indyRevocationService;
        this.ledgerService = ledgerService;
        this.wallet = wallet;
        this.logger = new logger_1.ConsoleLogger(logger_1.LogLevel.off);
      }
      createRequestAttachment(options) {
        const format2 = new ProofFormatSpec_1.ProofFormatSpec({
          attachmentId: options.id,
          format: ProofFormatConstants_1.V2_INDY_PRESENTATION_REQUEST
        });
        const request = new ProofRequest_1.ProofRequest(options.proofRequestOptions);
        (0, utils_1.checkProofRequestForDuplicates)(request);
        const attachment = new Attachment_1.Attachment({
          id: options.id,
          mimeType: "application/json",
          data: new Attachment_1.AttachmentData({
            base64: JsonEncoder_1.JsonEncoder.toBase64(request)
          })
        });
        return { format: format2, attachment };
      }
      async createProofAttachment(options) {
        const format2 = new ProofFormatSpec_1.ProofFormatSpec({
          attachmentId: options.id,
          format: ProofFormatConstants_1.V2_INDY_PRESENTATION_PROPOSAL
        });
        const request = new ProofRequest_1.ProofRequest(options.proofProposalOptions);
        MessageValidator_1.MessageValidator.validateSync(request);
        const attachment = new Attachment_1.Attachment({
          id: options.id,
          mimeType: "application/json",
          data: new Attachment_1.AttachmentData({
            base64: JsonEncoder_1.JsonEncoder.toBase64(JsonTransformer_1.JsonTransformer.toJSON(request))
          })
        });
        return { format: format2, attachment };
      }
      async createProposal(options) {
        var _a;
        if (!options.formats.indy) {
          throw Error("Missing indy format to create proposal attachment format");
        }
        const proofRequest = await this.createRequestFromPreview(options.formats.indy);
        return await this.createProofAttachment({
          id: (_a = options.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)(),
          proofProposalOptions: proofRequest
        });
      }
      async processProposal(options) {
        var _a;
        const proofProposalJson = options.proposal.attachment.getDataAsJson();
        if (!proofProposalJson) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`Missing required base64 or json encoded attachment data for presentation proposal with thread id ${(_a = options.record) === null || _a === void 0 ? void 0 : _a.threadId}`);
        }
        const proposalMessage = JsonTransformer_1.JsonTransformer.fromJSON(proofProposalJson, ProofRequest_1.ProofRequest);
        MessageValidator_1.MessageValidator.validateSync(proposalMessage);
      }
      async createRequestAsResponse(options) {
        var _a;
        if (!options.proofFormats.indy) {
          throw Error("Missing indy format to create proposal attachment format");
        }
        const id = (_a = options.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
        const format2 = new ProofFormatSpec_1.ProofFormatSpec({
          attachmentId: id,
          format: ProofFormatConstants_1.V2_INDY_PRESENTATION_REQUEST
        });
        const attachment = new Attachment_1.Attachment({
          id,
          mimeType: "application/json",
          data: new Attachment_1.AttachmentData({
            base64: JsonEncoder_1.JsonEncoder.toBase64(options.proofFormats.indy)
          })
        });
        return { format: format2, attachment };
      }
      async createRequest(options) {
        var _a, _b, _c, _d;
        if (!options.formats.indy) {
          throw new AriesFrameworkError_1.AriesFrameworkError("Missing indy format to create proof request attachment format.");
        }
        const indyFormat = options.formats.indy;
        return this.createRequestAttachment({
          id: (_a = options.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)(),
          proofRequestOptions: Object.assign(Object.assign({}, indyFormat), { name: (_b = indyFormat.name) !== null && _b !== void 0 ? _b : "proof-request", version: (_c = indyFormat.version) !== null && _c !== void 0 ? _c : "1.0", nonce: (_d = indyFormat.nonce) !== null && _d !== void 0 ? _d : await this.wallet.generateNonce() })
        });
      }
      async processRequest(options) {
        var _a;
        const proofRequestJson = options.requestAttachment.attachment.getDataAsJson();
        const proofRequest = JsonTransformer_1.JsonTransformer.fromJSON(proofRequestJson, ProofRequest_1.ProofRequest);
        if (!proofRequest) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`Missing required base64 or json encoded attachment data for presentation request with thread id ${(_a = options.record) === null || _a === void 0 ? void 0 : _a.threadId}`);
        }
        MessageValidator_1.MessageValidator.validateSync(proofRequest);
        (0, utils_1.checkProofRequestForDuplicates)(proofRequest);
      }
      async createPresentation(agentContext, options) {
        var _a, _b;
        const proofRequestJson = (_a = options.attachment.getDataAsJson()) !== null && _a !== void 0 ? _a : null;
        const proofRequest = JsonTransformer_1.JsonTransformer.fromJSON(proofRequestJson, ProofRequest_1.ProofRequest);
        if (!options.proofFormats.indy) {
          throw new AriesFrameworkError_1.AriesFrameworkError("Missing indy format to create proof presentation attachment format.");
        }
        const requestedCredentials = new RequestedCredentials_1.RequestedCredentials({
          requestedAttributes: options.proofFormats.indy.requestedAttributes,
          requestedPredicates: options.proofFormats.indy.requestedPredicates,
          selfAttestedAttributes: options.proofFormats.indy.selfAttestedAttributes
        });
        const proof = await this.createProof(agentContext, proofRequest, requestedCredentials);
        const attachmentId = (_b = options.id) !== null && _b !== void 0 ? _b : (0, uuid_1.uuid)();
        const format2 = new ProofFormatSpec_1.ProofFormatSpec({
          attachmentId,
          format: ProofFormatConstants_1.V2_INDY_PRESENTATION
        });
        const attachment = new Attachment_1.Attachment({
          id: attachmentId,
          mimeType: "application/json",
          data: new Attachment_1.AttachmentData({
            base64: JsonEncoder_1.JsonEncoder.toBase64(proof)
          })
        });
        return { format: format2, attachment };
      }
      async processPresentation(agentContext, options) {
        const requestFormat = options.formatAttachments.request.find((x) => x.format.format === ProofFormatConstants_1.V2_INDY_PRESENTATION_REQUEST);
        if (!requestFormat) {
          throw new MissingIndyProofMessageError_1.MissingIndyProofMessageError("Missing Indy Proof Request format while trying to process an Indy proof presentation.");
        }
        const proofFormat = options.formatAttachments.presentation.find((x) => x.format.format === ProofFormatConstants_1.V2_INDY_PRESENTATION);
        if (!proofFormat) {
          throw new MissingIndyProofMessageError_1.MissingIndyProofMessageError("Missing Indy Proof Presentation format while trying to process an Indy proof presentation.");
        }
        return await this.verifyProof(agentContext, { request: requestFormat.attachment, proof: proofFormat.attachment });
      }
      async verifyProof(agentContext, options) {
        var _a, _b;
        if (!options) {
          throw new AriesFrameworkError_1.AriesFrameworkError("No Indy proof was provided.");
        }
        const proofRequestJson = (_a = options.request.getDataAsJson()) !== null && _a !== void 0 ? _a : null;
        const proofRequest = JsonTransformer_1.JsonTransformer.fromJSON(proofRequestJson, ProofRequest_1.ProofRequest);
        const proofJson = (_b = options.proof.getDataAsJson()) !== null && _b !== void 0 ? _b : null;
        const proof = JsonTransformer_1.JsonTransformer.fromJSON(proofJson, models_1.PartialProof);
        for (const [referent, attribute] of proof.requestedProof.revealedAttributes.entries()) {
          if (!IndyCredentialUtils_1.IndyCredentialUtils.checkValidEncoding(attribute.raw, attribute.encoded)) {
            throw new InvalidEncodedValueError_1.InvalidEncodedValueError(`The encoded value for '${referent}' is invalid. Expected '${IndyCredentialUtils_1.IndyCredentialUtils.encode(attribute.raw)}'. Actual '${attribute.encoded}'`);
          }
        }
        const schemas = await this.getSchemas(agentContext, new Set(proof.identifiers.map((i) => i.schemaId)));
        const credentialDefinitions = await this.getCredentialDefinitions(agentContext, new Set(proof.identifiers.map((i) => i.credentialDefinitionId)));
        return await this.indyVerifierService.verifyProof(agentContext, {
          proofRequest: proofRequest.toJSON(),
          proof: proofJson,
          schemas,
          credentialDefinitions
        });
      }
      supportsFormat(formatIdentifier) {
        const supportedFormats = [ProofFormatConstants_1.V2_INDY_PRESENTATION_PROPOSAL, ProofFormatConstants_1.V2_INDY_PRESENTATION_REQUEST, ProofFormatConstants_1.V2_INDY_PRESENTATION];
        return supportedFormats.includes(formatIdentifier);
      }
      /**
       * Compare presentation attrs with request/proposal attrs (auto-accept)
       *
       * @param proposalAttachments attachment data from the proposal
       * @param requestAttachments  attachment data from the request
       * @returns boolean value
       */
      proposalAndRequestAreEqual(proposalAttachments, requestAttachments) {
        var _a, _b;
        const proposalAttachment = (_a = proposalAttachments.find((x) => x.format.format === ProofFormatConstants_1.V2_INDY_PRESENTATION_PROPOSAL)) === null || _a === void 0 ? void 0 : _a.attachment;
        const requestAttachment = (_b = requestAttachments.find((x) => x.format.format === ProofFormatConstants_1.V2_INDY_PRESENTATION_REQUEST)) === null || _b === void 0 ? void 0 : _b.attachment;
        if (!proposalAttachment) {
          throw new AriesFrameworkError_1.AriesFrameworkError("Proposal message has no attachment linked to it");
        }
        if (!requestAttachment) {
          throw new AriesFrameworkError_1.AriesFrameworkError("Request message has no attachment linked to it");
        }
        const proposalAttachmentJson = proposalAttachment.getDataAsJson();
        const proposalAttachmentData = JsonTransformer_1.JsonTransformer.fromJSON(proposalAttachmentJson, ProofRequest_1.ProofRequest);
        const requestAttachmentJson = requestAttachment.getDataAsJson();
        const requestAttachmentData = JsonTransformer_1.JsonTransformer.fromJSON(requestAttachmentJson, ProofRequest_1.ProofRequest);
        if ((0, utils_1.deepEquality)(proposalAttachmentData.requestedAttributes, requestAttachmentData.requestedAttributes) && (0, utils_1.deepEquality)(proposalAttachmentData.requestedPredicates, requestAttachmentData.requestedPredicates)) {
          return true;
        }
        return false;
      }
      /**
       * Build credential definitions object needed to create and verify proof objects.
       *
       * Creates object with `{ credentialDefinitionId: CredentialDefinition }` mapping
       *
       * @param credentialDefinitionIds List of credential definition ids
       * @returns Object containing credential definitions for specified credential definition ids
       *
       */
      async getCredentialDefinitions(agentContext, credentialDefinitionIds) {
        const credentialDefinitions = {};
        for (const credDefId of credentialDefinitionIds) {
          const credDef = await this.ledgerService.getCredentialDefinition(agentContext, credDefId);
          credentialDefinitions[credDefId] = credDef;
        }
        return credentialDefinitions;
      }
      async getRequestedCredentialsForProofRequest(agentContext, options) {
        var _a, _b, _c;
        const retrievedCredentials = new RetrievedCredentials_1.RetrievedCredentials({});
        const { attachment, presentationProposal } = options;
        const filterByNonRevocationRequirements = (_a = options.config) === null || _a === void 0 ? void 0 : _a.filterByNonRevocationRequirements;
        const proofRequestJson = (_b = attachment.getDataAsJson()) !== null && _b !== void 0 ? _b : null;
        const proofRequest = JsonTransformer_1.JsonTransformer.fromJSON(proofRequestJson, ProofRequest_1.ProofRequest);
        for (const [referent, requestedAttribute] of proofRequest.requestedAttributes.entries()) {
          let credentialMatch = [];
          const credentials = await this.getCredentialsForProofRequest(agentContext, proofRequest, referent);
          if (credentials.length === 1 || !presentationProposal) {
            credentialMatch = credentials;
          } else {
            const names = (_c = requestedAttribute.names) !== null && _c !== void 0 ? _c : [requestedAttribute.name];
            credentialMatch = credentials.filter((credential) => {
              const { attributes, credentialDefinitionId } = credential.credentialInfo;
              return names.every((name) => presentationProposal.attributes.find((a) => a.name === name && a.credentialDefinitionId === credentialDefinitionId && (!a.value || a.value === attributes[name])));
            });
          }
          retrievedCredentials.requestedAttributes[referent] = await Promise.all(credentialMatch.map(async (credential) => {
            const { revoked, deltaTimestamp } = await this.getRevocationStatusForRequestedItem(agentContext, {
              proofRequest,
              requestedItem: requestedAttribute,
              credential
            });
            return new models_2.RequestedAttribute({
              credentialId: credential.credentialInfo.referent,
              revealed: true,
              credentialInfo: credential.credentialInfo,
              timestamp: deltaTimestamp,
              revoked
            });
          }));
          if (filterByNonRevocationRequirements) {
            retrievedCredentials.requestedAttributes[referent] = retrievedCredentials.requestedAttributes[referent].filter((r) => !r.revoked);
          }
        }
        for (const [referent, requestedPredicate] of proofRequest.requestedPredicates.entries()) {
          const credentials = await this.getCredentialsForProofRequest(agentContext, proofRequest, referent);
          retrievedCredentials.requestedPredicates[referent] = await Promise.all(credentials.map(async (credential) => {
            const { revoked, deltaTimestamp } = await this.getRevocationStatusForRequestedItem(agentContext, {
              proofRequest,
              requestedItem: requestedPredicate,
              credential
            });
            return new models_2.RequestedPredicate({
              credentialId: credential.credentialInfo.referent,
              credentialInfo: credential.credentialInfo,
              timestamp: deltaTimestamp,
              revoked
            });
          }));
          if (filterByNonRevocationRequirements) {
            retrievedCredentials.requestedPredicates[referent] = retrievedCredentials.requestedPredicates[referent].filter((r) => !r.revoked);
          }
        }
        return {
          proofFormats: {
            indy: retrievedCredentials
          }
        };
      }
      async getCredentialsForProofRequest(agentContext, proofRequest, attributeReferent) {
        const credentialsJson = await this.indyHolderService.getCredentialsForProofRequest(agentContext, {
          proofRequest: proofRequest.toJSON(),
          attributeReferent
        });
        return JsonTransformer_1.JsonTransformer.fromJSON(credentialsJson, credentials_1.IndyCredential);
      }
      async autoSelectCredentialsForProofRequest(options) {
        const { proofFormats } = options;
        const indy = proofFormats.indy;
        if (!indy) {
          throw new AriesFrameworkError_1.AriesFrameworkError("No indy options provided");
        }
        const requestedCredentials = new RequestedCredentials_1.RequestedCredentials({});
        Object.keys(indy.requestedAttributes).forEach((attributeName) => {
          const attributeArray = indy.requestedAttributes[attributeName];
          if (attributeArray.length === 0) {
            throw new AriesFrameworkError_1.AriesFrameworkError("Unable to automatically select requested attributes.");
          } else {
            requestedCredentials.requestedAttributes[attributeName] = attributeArray[0];
          }
        });
        Object.keys(indy.requestedPredicates).forEach((attributeName) => {
          if (indy.requestedPredicates[attributeName].length === 0) {
            throw new AriesFrameworkError_1.AriesFrameworkError("Unable to automatically select requested predicates.");
          } else {
            requestedCredentials.requestedPredicates[attributeName] = indy.requestedPredicates[attributeName][0];
          }
        });
        return {
          proofFormats: {
            indy: requestedCredentials
          }
        };
      }
      /**
       * Build schemas object needed to create and verify proof objects.
       *
       * Creates object with `{ schemaId: Schema }` mapping
       *
       * @param schemaIds List of schema ids
       * @returns Object containing schemas for specified schema ids
       *
       */
      async getSchemas(agentContext, schemaIds) {
        const schemas = {};
        for (const schemaId of schemaIds) {
          const schema = await this.ledgerService.getSchema(agentContext, schemaId);
          schemas[schemaId] = schema;
        }
        return schemas;
      }
      /**
       * Create indy proof from a given proof request and requested credential object.
       *
       * @param proofRequest The proof request to create the proof for
       * @param requestedCredentials The requested credentials object specifying which credentials to use for the proof
       * @returns indy proof object
       */
      async createProof(agentContext, proofRequest, requestedCredentials) {
        const credentialObjects = await Promise.all([
          ...Object.values(requestedCredentials.requestedAttributes),
          ...Object.values(requestedCredentials.requestedPredicates)
        ].map(async (c) => {
          if (c.credentialInfo) {
            return c.credentialInfo;
          }
          const credentialInfo = await this.indyHolderService.getCredential(agentContext, c.credentialId);
          return JsonTransformer_1.JsonTransformer.fromJSON(credentialInfo, credentials_1.IndyCredentialInfo);
        }));
        const schemas = await this.getSchemas(agentContext, new Set(credentialObjects.map((c) => c.schemaId)));
        const credentialDefinitions = await this.getCredentialDefinitions(agentContext, new Set(credentialObjects.map((c) => c.credentialDefinitionId)));
        return await this.indyHolderService.createProof(agentContext, {
          proofRequest: proofRequest.toJSON(),
          requestedCredentials,
          schemas,
          credentialDefinitions
        });
      }
      async createProofRequestFromProposal(options) {
        const proofRequestJson = options.presentationAttachment.getDataAsJson();
        const proofRequest = JsonTransformer_1.JsonTransformer.fromJSON(proofRequestJson, ProofRequest_1.ProofRequest);
        if (!proofRequest) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`Missing required base64 or json encoded attachment data for presentation request.`);
        }
        MessageValidator_1.MessageValidator.validateSync(proofRequest);
        (0, utils_1.checkProofRequestForDuplicates)(proofRequest);
        return {
          indy: proofRequest
        };
      }
      async getRevocationStatusForRequestedItem(agentContext, { proofRequest, requestedItem, credential }) {
        var _a;
        const requestNonRevoked = (_a = requestedItem.nonRevoked) !== null && _a !== void 0 ? _a : proofRequest.nonRevoked;
        const credentialRevocationId = credential.credentialInfo.credentialRevocationId;
        const revocationRegistryId = credential.credentialInfo.revocationRegistryId;
        if (requestNonRevoked && credentialRevocationId && revocationRegistryId) {
          this.logger.trace(`Presentation is requesting proof of non revocation, getting revocation status for credential`, {
            requestNonRevoked,
            credentialRevocationId,
            revocationRegistryId
          });
          const status = await this.indyRevocationService.getRevocationStatus(agentContext, credentialRevocationId, revocationRegistryId, requestNonRevoked);
          return status;
        }
        return { revoked: void 0, deltaTimestamp: void 0 };
      }
      async createRequestFromPreview(indyFormat) {
        const preview = new models_1.PresentationPreview({
          attributes: indyFormat.attributes,
          predicates: indyFormat.predicates
        });
        const proofRequest = await this.createReferentForProofRequest(indyFormat, preview);
        return proofRequest;
      }
      async createReferentForProofRequest(indyFormat, preview) {
        var _a, _b, _c;
        const proofRequest = new ProofRequest_1.ProofRequest({
          name: (_a = indyFormat.name) !== null && _a !== void 0 ? _a : "proof-request",
          version: (_b = indyFormat.version) !== null && _b !== void 0 ? _b : "1.0",
          nonce: (_c = indyFormat.nonce) !== null && _c !== void 0 ? _c : await this.wallet.generateNonce()
        });
        const attributesByReferent = {};
        for (const proposedAttributes of preview.attributes) {
          if (!proposedAttributes.referent)
            proposedAttributes.referent = (0, uuid_1.uuid)();
          const referentAttributes = attributesByReferent[proposedAttributes.referent];
          if (referentAttributes) {
            referentAttributes.push(proposedAttributes);
          } else {
            attributesByReferent[proposedAttributes.referent] = [proposedAttributes];
          }
        }
        for (const [referent, proposedAttributes] of Object.entries(attributesByReferent)) {
          const attributeName = proposedAttributes.length == 1 ? proposedAttributes[0].name : void 0;
          const attributeNames = proposedAttributes.length > 1 ? proposedAttributes.map((a) => a.name) : void 0;
          const requestedAttribute = new models_2.ProofAttributeInfo({
            name: attributeName,
            names: attributeNames,
            restrictions: [
              new models_2.AttributeFilter({
                credentialDefinitionId: proposedAttributes[0].credentialDefinitionId
              })
            ]
          });
          proofRequest.requestedAttributes.set(referent, requestedAttribute);
        }
        for (const proposedPredicate of preview.predicates) {
          const requestedPredicate = new models_2.ProofPredicateInfo({
            name: proposedPredicate.name,
            predicateType: proposedPredicate.predicate,
            predicateValue: proposedPredicate.threshold,
            restrictions: [
              new models_2.AttributeFilter({
                credentialDefinitionId: proposedPredicate.credentialDefinitionId
              })
            ]
          });
          proofRequest.requestedPredicates.set((0, uuid_1.uuid)(), requestedPredicate);
        }
        return proofRequest;
      }
    };
    IndyProofFormatService = __decorate([
      (0, tsyringe_1.scoped)(tsyringe_1.Lifecycle.ContainerScoped),
      __metadata("design:paramtypes", [
        AgentConfig_1.AgentConfig,
        indy_1.IndyHolderService,
        indy_1.IndyVerifierService,
        indy_1.IndyRevocationService,
        ledger_1.IndyLedgerService,
        DidCommMessageRepository_1.DidCommMessageRepository,
        IndyWallet_1.IndyWallet
      ])
    ], IndyProofFormatService);
    exports.IndyProofFormatService = IndyProofFormatService;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/handlers/V1PresentationAckHandler.js
var require_V1PresentationAckHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/handlers/V1PresentationAckHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1PresentationAckHandler = void 0;
    var messages_1 = require_messages14();
    var V1PresentationAckHandler = class {
      constructor(proofService) {
        this.supportedMessages = [messages_1.V1PresentationAckMessage];
        this.proofService = proofService;
      }
      async handle(messageContext) {
        await this.proofService.processAck(messageContext);
      }
    };
    exports.V1PresentationAckHandler = V1PresentationAckHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/handlers/V1PresentationHandler.js
var require_V1PresentationHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/handlers/V1PresentationHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1PresentationHandler = void 0;
    var models_1 = require_models3();
    var messages_1 = require_messages14();
    var V1PresentationHandler = class {
      constructor(proofService, agentConfig, proofResponseCoordinator, didCommMessageRepository) {
        this.supportedMessages = [messages_1.V1PresentationMessage];
        this.proofService = proofService;
        this.agentConfig = agentConfig;
        this.proofResponseCoordinator = proofResponseCoordinator;
        this.didCommMessageRepository = didCommMessageRepository;
      }
      async handle(messageContext) {
        const proofRecord = await this.proofService.processPresentation(messageContext);
        const shouldAutoRespond = await this.proofResponseCoordinator.shouldAutoRespondToPresentation(messageContext.agentContext, proofRecord);
        if (shouldAutoRespond) {
          return await this.createAck(proofRecord, messageContext);
        }
      }
      async createAck(record, messageContext) {
        this.agentConfig.logger.info(`Automatically sending acknowledgement with autoAccept on ${this.agentConfig.autoAcceptProofs}`);
        const { message, proofRecord } = await this.proofService.createAck(messageContext.agentContext, {
          proofRecord: record
        });
        const requestMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: messages_1.V1RequestPresentationMessage
        });
        const presentationMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: messages_1.V1PresentationMessage
        });
        if (messageContext.connection) {
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            connection: messageContext.connection,
            associatedRecord: proofRecord
          });
        } else if ((requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.service) && (presentationMessage === null || presentationMessage === void 0 ? void 0 : presentationMessage.service)) {
          const recipientService = presentationMessage === null || presentationMessage === void 0 ? void 0 : presentationMessage.service;
          const ourService = requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.service;
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            serviceParams: {
              service: recipientService.resolvedDidCommService,
              senderKey: ourService.resolvedDidCommService.recipientKeys[0]
            }
          });
        }
        this.agentConfig.logger.error(`Could not automatically create presentation ack`);
      }
    };
    exports.V1PresentationHandler = V1PresentationHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/handlers/V1ProposePresentationHandler.js
var require_V1ProposePresentationHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/handlers/V1ProposePresentationHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1ProposePresentationHandler = void 0;
    var models_1 = require_models3();
    var error_1 = require_error();
    var messages_1 = require_messages14();
    var V1ProposePresentationHandler = class {
      constructor(proofService, agentConfig, proofResponseCoordinator, didCommMessageRepository) {
        this.supportedMessages = [messages_1.V1ProposePresentationMessage];
        this.proofService = proofService;
        this.agentConfig = agentConfig;
        this.proofResponseCoordinator = proofResponseCoordinator;
        this.didCommMessageRepository = didCommMessageRepository;
      }
      async handle(messageContext) {
        const proofRecord = await this.proofService.processProposal(messageContext);
        const shouldAutoRespond = await this.proofResponseCoordinator.shouldAutoRespondToProposal(messageContext.agentContext, proofRecord);
        if (shouldAutoRespond) {
          return await this.createRequest(proofRecord, messageContext);
        }
      }
      async createRequest(proofRecord, messageContext) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.agentConfig.logger.info(`Automatically sending request with autoAccept on ${this.agentConfig.autoAcceptProofs}`);
        if (!messageContext.connection) {
          this.agentConfig.logger.error("No connection on the messageContext");
          throw new error_1.AriesFrameworkError("No connection on the messageContext");
        }
        const proposalMessage = await this.didCommMessageRepository.getAgentMessage(messageContext.agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: messages_1.V1ProposePresentationMessage
        });
        if (!proposalMessage) {
          this.agentConfig.logger.error(`Proof record with id ${proofRecord.id} is missing required credential proposal`);
          throw new error_1.AriesFrameworkError(`Proof record with id ${proofRecord.id} is missing required credential proposal`);
        }
        const proofRequestFromProposalOptions = {
          name: "proof-request",
          version: "1.0",
          nonce: await messageContext.agentContext.wallet.generateNonce(),
          proofRecord
        };
        const proofRequest = await this.proofService.createProofRequestFromProposal(messageContext.agentContext, proofRequestFromProposalOptions);
        const indyProofRequest = proofRequest.proofFormats;
        if (!indyProofRequest || !indyProofRequest.indy) {
          this.agentConfig.logger.error(`No Indy proof request was found`);
          throw new error_1.AriesFrameworkError("No Indy proof request was found");
        }
        const { message } = await this.proofService.createRequestAsResponse(messageContext.agentContext, {
          proofFormats: {
            indy: {
              name: (_a = indyProofRequest.indy) === null || _a === void 0 ? void 0 : _a.name,
              version: (_b = indyProofRequest.indy) === null || _b === void 0 ? void 0 : _b.version,
              nonRevoked: (_c = indyProofRequest.indy) === null || _c === void 0 ? void 0 : _c.nonRevoked,
              requestedAttributes: (_d = indyProofRequest.indy) === null || _d === void 0 ? void 0 : _d.requestedAttributes,
              requestedPredicates: (_e = indyProofRequest.indy) === null || _e === void 0 ? void 0 : _e.requestedPredicates,
              ver: (_f = indyProofRequest.indy) === null || _f === void 0 ? void 0 : _f.ver,
              nonce: (_g = indyProofRequest.indy) === null || _g === void 0 ? void 0 : _g.nonce
            }
          },
          proofRecord,
          autoAcceptProof: proofRecord.autoAcceptProof,
          willConfirm: true
        });
        return new models_1.OutboundMessageContext(message, {
          agentContext: messageContext.agentContext,
          connection: messageContext.connection,
          associatedRecord: proofRecord
        });
      }
    };
    exports.V1ProposePresentationHandler = V1ProposePresentationHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/handlers/V1RequestPresentationHandler.js
var require_V1RequestPresentationHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/handlers/V1RequestPresentationHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1RequestPresentationHandler = void 0;
    var models_1 = require_models3();
    var ServiceDecorator_1 = require_ServiceDecorator();
    var error_1 = require_error();
    var storage_1 = require_storage();
    var messages_1 = require_messages14();
    var V1RequestPresentationHandler = class {
      constructor(proofService, agentConfig, proofResponseCoordinator, mediationRecipientService, didCommMessageRepository, routingService) {
        this.supportedMessages = [messages_1.V1RequestPresentationMessage];
        this.proofService = proofService;
        this.agentConfig = agentConfig;
        this.proofResponseCoordinator = proofResponseCoordinator;
        this.mediationRecipientService = mediationRecipientService;
        this.didCommMessageRepository = didCommMessageRepository;
        this.routingService = routingService;
      }
      async handle(messageContext) {
        const proofRecord = await this.proofService.processRequest(messageContext);
        const shouldAutoRespond = await this.proofResponseCoordinator.shouldAutoRespondToRequest(messageContext.agentContext, proofRecord);
        if (shouldAutoRespond) {
          return await this.createPresentation(proofRecord, messageContext);
        }
      }
      async createPresentation(record, messageContext) {
        const requestMessage = await this.didCommMessageRepository.getAgentMessage(messageContext.agentContext, {
          associatedRecordId: record.id,
          messageClass: messages_1.V1RequestPresentationMessage
        });
        const indyProofRequest = requestMessage.indyProofRequest;
        this.agentConfig.logger.info(`Automatically sending presentation with autoAccept on ${this.agentConfig.autoAcceptProofs}`);
        if (!indyProofRequest) {
          this.agentConfig.logger.error("Proof request is undefined.");
          throw new error_1.AriesFrameworkError("No proof request found.");
        }
        const retrievedCredentials = await this.proofService.getRequestedCredentialsForProofRequest(messageContext.agentContext, {
          proofRecord: record,
          config: {
            filterByPresentationPreview: true
          }
        });
        if (!retrievedCredentials.proofFormats.indy) {
          this.agentConfig.logger.error("No matching Indy credentials could be retrieved.");
          throw new error_1.AriesFrameworkError("No matching Indy credentials could be retrieved.");
        }
        const options = {
          proofFormats: retrievedCredentials.proofFormats
        };
        const requestedCredentials = await this.proofService.autoSelectCredentialsForProofRequest(options);
        const { message, proofRecord } = await this.proofService.createPresentation(messageContext.agentContext, {
          proofRecord: record,
          proofFormats: {
            indy: requestedCredentials.proofFormats.indy
          },
          willConfirm: true
        });
        if (messageContext.connection) {
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            connection: messageContext.connection,
            associatedRecord: proofRecord
          });
        } else if (requestMessage.service) {
          const routing = await this.routingService.getRouting(messageContext.agentContext);
          message.service = new ServiceDecorator_1.ServiceDecorator({
            serviceEndpoint: routing.endpoints[0],
            recipientKeys: [routing.recipientKey.publicKeyBase58],
            routingKeys: routing.routingKeys.map((key) => key.publicKeyBase58)
          });
          const recipientService = requestMessage.service;
          await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
            agentMessage: message,
            associatedRecordId: proofRecord.id,
            role: storage_1.DidCommMessageRole.Sender
          });
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            serviceParams: {
              service: recipientService.resolvedDidCommService,
              senderKey: message.service.resolvedDidCommService.recipientKeys[0]
            }
          });
        }
        this.agentConfig.logger.error(`Could not automatically create presentation`);
      }
    };
    exports.V1RequestPresentationHandler = V1RequestPresentationHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/handlers/V1PresentationProblemReportHandler.js
var require_V1PresentationProblemReportHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/handlers/V1PresentationProblemReportHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1PresentationProblemReportHandler = void 0;
    var V1PresentationProblemReportMessage_1 = require_V1PresentationProblemReportMessage();
    var V1PresentationProblemReportHandler = class {
      constructor(proofService) {
        this.supportedMessages = [V1PresentationProblemReportMessage_1.V1PresentationProblemReportMessage];
        this.proofService = proofService;
      }
      async handle(messageContext) {
        await this.proofService.processProblemReport(messageContext);
      }
    };
    exports.V1PresentationProblemReportHandler = V1PresentationProblemReportHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/handlers/index.js
var require_handlers12 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/handlers/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_V1PresentationAckHandler(), exports);
    __exportStar(require_V1PresentationHandler(), exports);
    __exportStar(require_V1ProposePresentationHandler(), exports);
    __exportStar(require_V1RequestPresentationHandler(), exports);
    __exportStar(require_V1PresentationProblemReportHandler(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/V1ProofService.js
var require_V1ProofService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/V1ProofService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1ProofService = void 0;
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var tsyringe_1 = (init_esm53(), __toCommonJS(esm5_exports3));
    var AgentConfig_1 = require_AgentConfig();
    var EventEmitter_1 = require_EventEmitter();
    var constants_1 = require_constants();
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var storage_1 = require_storage();
    var DidCommMessageRepository_1 = require_DidCommMessageRepository();
    var utils_1 = require_utils();
    var JsonTransformer_1 = require_JsonTransformer();
    var MessageValidator_1 = require_MessageValidator();
    var AckMessage_1 = require_AckMessage();
    var connections_1 = require_connections();
    var credentials_1 = require_credentials();
    var IndyCredentialInfo_1 = require_IndyCredentialInfo();
    var indy_1 = require_indy2();
    var IndyLedgerService_1 = require_IndyLedgerService();
    var ProofService_1 = require_ProofService();
    var PresentationProblemReportReason_1 = require_PresentationProblemReportReason();
    var IndyProofFormatService_1 = require_IndyProofFormatService();
    var ProofRequest_1 = require_ProofRequest();
    var RequestedCredentials_1 = require_RequestedCredentials();
    var ProofState_1 = require_ProofState();
    var ProofExchangeRecord_1 = require_ProofExchangeRecord();
    var ProofRepository_1 = require_ProofRepository();
    var errors_1 = require_errors6();
    var handlers_1 = require_handlers12();
    var messages_1 = require_messages14();
    var V1PresentationProblemReportMessage_1 = require_V1PresentationProblemReportMessage();
    var V1PresentationPreview_1 = require_V1PresentationPreview();
    var V1ProofService = class V1ProofService extends ProofService_1.ProofService {
      constructor(proofRepository, didCommMessageRepository, ledgerService, wallet, agentConfig, connectionService, eventEmitter, credentialRepository, formatService, indyHolderService, indyRevocationService) {
        super(agentConfig, proofRepository, connectionService, didCommMessageRepository, wallet, eventEmitter);
        this.version = "v1";
        this.credentialRepository = credentialRepository;
        this.ledgerService = ledgerService;
        this.wallet = wallet;
        this.indyProofFormatService = formatService;
        this.indyHolderService = indyHolderService;
        this.indyRevocationService = indyRevocationService;
      }
      async createProposal(agentContext, options) {
        var _a, _b, _c;
        const { connectionRecord, proofFormats } = options;
        connectionRecord.assertReady();
        if (!proofFormats.indy || Object.keys(proofFormats).length !== 1) {
          throw new AriesFrameworkError_1.AriesFrameworkError("Only indy proof format is supported for present proof protocol v1");
        }
        const presentationProposal = new V1PresentationPreview_1.PresentationPreview({
          attributes: (_a = proofFormats.indy) === null || _a === void 0 ? void 0 : _a.attributes,
          predicates: (_b = proofFormats.indy) === null || _b === void 0 ? void 0 : _b.predicates
        });
        const proposalMessage = new messages_1.V1ProposePresentationMessage({
          comment: options === null || options === void 0 ? void 0 : options.comment,
          presentationProposal,
          parentThreadId: options.parentThreadId
        });
        const proofRecord = new ProofExchangeRecord_1.ProofExchangeRecord({
          connectionId: connectionRecord.id,
          threadId: proposalMessage.threadId,
          parentThreadId: (_c = proposalMessage.thread) === null || _c === void 0 ? void 0 : _c.parentThreadId,
          state: ProofState_1.ProofState.ProposalSent,
          autoAcceptProof: options === null || options === void 0 ? void 0 : options.autoAcceptProof,
          protocolVersion: "v1"
        });
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: proposalMessage,
          associatedRecordId: proofRecord.id,
          role: storage_1.DidCommMessageRole.Sender
        });
        await this.proofRepository.save(agentContext, proofRecord);
        this.emitStateChangedEvent(agentContext, proofRecord, null);
        return { proofRecord, message: proposalMessage };
      }
      async createProposalAsResponse(agentContext, options) {
        var _a, _b;
        const { proofRecord, proofFormats, comment } = options;
        proofRecord.assertState(ProofState_1.ProofState.RequestReceived);
        if (!proofFormats.indy || Object.keys(proofFormats).length !== 1) {
          throw new AriesFrameworkError_1.AriesFrameworkError("Only indy proof format is supported for present proof protocol v1");
        }
        const presentationPreview = new V1PresentationPreview_1.PresentationPreview({
          attributes: (_a = proofFormats.indy) === null || _a === void 0 ? void 0 : _a.attributes,
          predicates: (_b = proofFormats.indy) === null || _b === void 0 ? void 0 : _b.predicates
        });
        const proposalMessage = new messages_1.V1ProposePresentationMessage({
          comment,
          presentationProposal: presentationPreview
        });
        proposalMessage.setThread({ threadId: proofRecord.threadId });
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: proposalMessage,
          associatedRecordId: proofRecord.id,
          role: storage_1.DidCommMessageRole.Sender
        });
        await this.updateState(agentContext, proofRecord, ProofState_1.ProofState.ProposalSent);
        return { proofRecord, message: proposalMessage };
      }
      async processProposal(messageContext) {
        var _a;
        let proofRecord;
        const { message: proposalMessage, connection } = messageContext;
        this.logger.debug(`Processing presentation proposal with id ${proposalMessage.id}`);
        try {
          proofRecord = await this.getByThreadAndConnectionId(messageContext.agentContext, proposalMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
          const requestMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: messages_1.V1RequestPresentationMessage
          });
          proofRecord.assertState(ProofState_1.ProofState.RequestSent);
          this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
            previousReceivedMessage: proposalMessage,
            previousSentMessage: requestMessage !== null && requestMessage !== void 0 ? requestMessage : void 0
          });
          await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
            agentMessage: proposalMessage,
            associatedRecordId: proofRecord.id,
            role: storage_1.DidCommMessageRole.Receiver
          });
          await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.ProposalReceived);
        } catch (_b) {
          proofRecord = new ProofExchangeRecord_1.ProofExchangeRecord({
            connectionId: connection === null || connection === void 0 ? void 0 : connection.id,
            threadId: proposalMessage.threadId,
            parentThreadId: (_a = proposalMessage.thread) === null || _a === void 0 ? void 0 : _a.parentThreadId,
            state: ProofState_1.ProofState.ProposalReceived,
            protocolVersion: "v1"
          });
          this.connectionService.assertConnectionOrServiceDecorator(messageContext);
          await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
            agentMessage: proposalMessage,
            associatedRecordId: proofRecord.id,
            role: storage_1.DidCommMessageRole.Sender
          });
          await this.proofRepository.save(messageContext.agentContext, proofRecord);
          this.emitStateChangedEvent(messageContext.agentContext, proofRecord, null);
        }
        return proofRecord;
      }
      async createRequestAsResponse(agentContext, options) {
        const { proofRecord, comment, proofFormats } = options;
        if (!proofFormats.indy) {
          throw new AriesFrameworkError_1.AriesFrameworkError("Only indy proof format is supported for present proof protocol v1");
        }
        proofRecord.assertState(ProofState_1.ProofState.ProposalReceived);
        const { attachment } = await this.indyProofFormatService.createRequest({
          id: messages_1.INDY_PROOF_REQUEST_ATTACHMENT_ID,
          formats: proofFormats
        });
        const requestPresentationMessage = new messages_1.V1RequestPresentationMessage({
          comment,
          requestPresentationAttachments: [attachment]
        });
        requestPresentationMessage.setThread({
          threadId: proofRecord.threadId
        });
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: requestPresentationMessage,
          associatedRecordId: proofRecord.id,
          role: storage_1.DidCommMessageRole.Sender
        });
        await this.updateState(agentContext, proofRecord, ProofState_1.ProofState.RequestSent);
        return { message: requestPresentationMessage, proofRecord };
      }
      async createRequest(agentContext, options) {
        var _a, _b;
        this.logger.debug(`Creating proof request`);
        if (options.connectionRecord) {
          options.connectionRecord.assertReady();
        }
        if (!options.proofFormats.indy || Object.keys(options.proofFormats).length !== 1) {
          throw new AriesFrameworkError_1.AriesFrameworkError("Only indy proof format is supported for present proof protocol v1");
        }
        const { attachment } = await this.indyProofFormatService.createRequest({
          id: messages_1.INDY_PROOF_REQUEST_ATTACHMENT_ID,
          formats: options.proofFormats
        });
        const requestPresentationMessage = new messages_1.V1RequestPresentationMessage({
          comment: options === null || options === void 0 ? void 0 : options.comment,
          requestPresentationAttachments: [attachment],
          parentThreadId: options.parentThreadId
        });
        const proofRecord = new ProofExchangeRecord_1.ProofExchangeRecord({
          connectionId: (_a = options.connectionRecord) === null || _a === void 0 ? void 0 : _a.id,
          threadId: requestPresentationMessage.threadId,
          parentThreadId: (_b = requestPresentationMessage.thread) === null || _b === void 0 ? void 0 : _b.parentThreadId,
          state: ProofState_1.ProofState.RequestSent,
          autoAcceptProof: options === null || options === void 0 ? void 0 : options.autoAcceptProof,
          protocolVersion: "v1"
        });
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: requestPresentationMessage,
          associatedRecordId: proofRecord.id,
          role: storage_1.DidCommMessageRole.Sender
        });
        await this.proofRepository.save(agentContext, proofRecord);
        this.emitStateChangedEvent(agentContext, proofRecord, null);
        return { message: requestPresentationMessage, proofRecord };
      }
      async processRequest(messageContext) {
        var _a;
        let proofRecord;
        const { message: proofRequestMessage, connection } = messageContext;
        this.logger.debug(`Processing presentation request with id ${proofRequestMessage.id}`);
        const requestAttachments = proofRequestMessage.getAttachmentFormats();
        for (const attachmentFormat of requestAttachments) {
          await this.indyProofFormatService.processRequest({
            requestAttachment: attachmentFormat
          });
        }
        const proofRequest = proofRequestMessage.indyProofRequest;
        if (!proofRequest) {
          throw new errors_1.V1PresentationProblemReportError(`Missing required base64 or json encoded attachment data for presentation request with thread id ${proofRequestMessage.threadId}`, { problemCode: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned });
        }
        await (0, class_validator_1.validateOrReject)(proofRequest);
        (0, utils_1.checkProofRequestForDuplicates)(proofRequest);
        this.logger.debug("received proof request", proofRequest);
        try {
          proofRecord = await this.getByThreadAndConnectionId(messageContext.agentContext, proofRequestMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
          const requestMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: messages_1.V1RequestPresentationMessage
          });
          const proposalMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: messages_1.V1ProposePresentationMessage
          });
          proofRecord.assertState(ProofState_1.ProofState.ProposalSent);
          this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
            previousReceivedMessage: requestMessage !== null && requestMessage !== void 0 ? requestMessage : void 0,
            previousSentMessage: proposalMessage !== null && proposalMessage !== void 0 ? proposalMessage : void 0
          });
          await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
            agentMessage: proofRequestMessage,
            associatedRecordId: proofRecord.id,
            role: storage_1.DidCommMessageRole.Receiver
          });
          await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.RequestReceived);
        } catch (_b) {
          proofRecord = new ProofExchangeRecord_1.ProofExchangeRecord({
            connectionId: connection === null || connection === void 0 ? void 0 : connection.id,
            threadId: proofRequestMessage.threadId,
            parentThreadId: (_a = proofRequestMessage.thread) === null || _a === void 0 ? void 0 : _a.parentThreadId,
            state: ProofState_1.ProofState.RequestReceived,
            protocolVersion: "v1"
          });
          await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
            agentMessage: proofRequestMessage,
            associatedRecordId: proofRecord.id,
            role: storage_1.DidCommMessageRole.Receiver
          });
          this.connectionService.assertConnectionOrServiceDecorator(messageContext);
          await this.proofRepository.save(messageContext.agentContext, proofRecord);
          this.emitStateChangedEvent(messageContext.agentContext, proofRecord, null);
        }
        return proofRecord;
      }
      async createPresentation(agentContext, options) {
        var _a, _b, _c, _d;
        const { proofRecord, proofFormats } = options;
        this.logger.debug(`Creating presentation for proof record with id ${proofRecord.id}`);
        if (!proofFormats.indy || Object.keys(proofFormats).length !== 1) {
          throw new AriesFrameworkError_1.AriesFrameworkError("Only indy proof format is supported for present proof protocol v1");
        }
        proofRecord.assertState(ProofState_1.ProofState.RequestReceived);
        const requestMessage = await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: messages_1.V1RequestPresentationMessage
        });
        const requestAttachment = requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.indyAttachment;
        if (!requestAttachment) {
          throw new errors_1.V1PresentationProblemReportError(`Missing required base64 or json encoded attachment data for presentation with thread id ${proofRecord.threadId}`, { problemCode: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned });
        }
        const presentationOptions = {
          id: messages_1.INDY_PROOF_ATTACHMENT_ID,
          attachment: requestAttachment,
          proofFormats
        };
        const proof = await this.indyProofFormatService.createPresentation(agentContext, presentationOptions);
        const proofRequestJson = (_a = requestAttachment.getDataAsJson()) !== null && _a !== void 0 ? _a : null;
        const proofRequest = JsonTransformer_1.JsonTransformer.fromJSON(proofRequestJson, ProofRequest_1.ProofRequest);
        const requestedCredentials = new RequestedCredentials_1.RequestedCredentials({
          requestedAttributes: (_b = proofFormats.indy) === null || _b === void 0 ? void 0 : _b.requestedAttributes,
          requestedPredicates: (_c = proofFormats.indy) === null || _c === void 0 ? void 0 : _c.requestedPredicates,
          selfAttestedAttributes: (_d = proofFormats.indy) === null || _d === void 0 ? void 0 : _d.selfAttestedAttributes
        });
        const linkedAttachments = await this.getRequestedAttachmentsForRequestedCredentials(agentContext, proofRequest, requestedCredentials);
        const presentationMessage = new messages_1.V1PresentationMessage({
          comment: options === null || options === void 0 ? void 0 : options.comment,
          presentationAttachments: [proof.attachment],
          attachments: linkedAttachments
        });
        presentationMessage.setThread({ threadId: proofRecord.threadId });
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: presentationMessage,
          associatedRecordId: proofRecord.id,
          role: storage_1.DidCommMessageRole.Sender
        });
        await this.updateState(agentContext, proofRecord, ProofState_1.ProofState.PresentationSent);
        return { message: presentationMessage, proofRecord };
      }
      async processPresentation(messageContext) {
        const { message: presentationMessage, connection } = messageContext;
        this.logger.debug(`Processing presentation with id ${presentationMessage.id}`);
        const proofRecord = await this.getByThreadAndConnectionId(messageContext.agentContext, presentationMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        const proposalMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: messages_1.V1ProposePresentationMessage
        });
        const requestMessage = await this.didCommMessageRepository.getAgentMessage(messageContext.agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: messages_1.V1RequestPresentationMessage
        });
        proofRecord.assertState(ProofState_1.ProofState.RequestSent);
        this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
          previousReceivedMessage: proposalMessage !== null && proposalMessage !== void 0 ? proposalMessage : void 0,
          previousSentMessage: requestMessage !== null && requestMessage !== void 0 ? requestMessage : void 0
        });
        try {
          const isValid = await this.indyProofFormatService.processPresentation(messageContext.agentContext, {
            record: proofRecord,
            formatAttachments: {
              presentation: presentationMessage.getAttachmentFormats(),
              request: requestMessage.getAttachmentFormats()
            }
          });
          await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
            agentMessage: presentationMessage,
            associatedRecordId: proofRecord.id,
            role: storage_1.DidCommMessageRole.Receiver
          });
          proofRecord.isVerified = isValid;
          await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.PresentationReceived);
        } catch (e) {
          if (e instanceof AriesFrameworkError_1.AriesFrameworkError) {
            throw new errors_1.V1PresentationProblemReportError(e.message, {
              problemCode: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned
            });
          }
          throw e;
        }
        return proofRecord;
      }
      async processAck(messageContext) {
        const { message: presentationAckMessage, connection } = messageContext;
        this.logger.debug(`Processing presentation ack with id ${presentationAckMessage.id}`);
        const proofRecord = await this.getByThreadAndConnectionId(messageContext.agentContext, presentationAckMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        const requestMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: messages_1.V1RequestPresentationMessage
        });
        const presentationMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: messages_1.V1PresentationMessage
        });
        proofRecord.assertState(ProofState_1.ProofState.PresentationSent);
        this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
          previousReceivedMessage: requestMessage !== null && requestMessage !== void 0 ? requestMessage : void 0,
          previousSentMessage: presentationMessage !== null && presentationMessage !== void 0 ? presentationMessage : void 0
        });
        await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.Done);
        return proofRecord;
      }
      async createProblemReport(agentContext, options) {
        const msg = new V1PresentationProblemReportMessage_1.V1PresentationProblemReportMessage({
          description: {
            code: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned,
            en: options.description
          }
        });
        msg.setThread({
          threadId: options.proofRecord.threadId,
          parentThreadId: options.proofRecord.parentThreadId
        });
        return {
          proofRecord: options.proofRecord,
          message: msg
        };
      }
      async processProblemReport(messageContext) {
        const { message: presentationProblemReportMessage } = messageContext;
        const connection = messageContext.assertReadyConnection();
        this.logger.debug(`Processing problem report with id ${presentationProblemReportMessage.id}`);
        const proofRecord = await this.getByThreadAndConnectionId(messageContext.agentContext, presentationProblemReportMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        proofRecord.errorMessage = `${presentationProblemReportMessage.description.code}: ${presentationProblemReportMessage.description.en}`;
        await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.Abandoned);
        return proofRecord;
      }
      async createProofRequestFromProposal(agentContext, options) {
        const proofRecordId = options.proofRecord.id;
        const proposalMessage = await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: proofRecordId,
          messageClass: messages_1.V1ProposePresentationMessage
        });
        if (!proposalMessage) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`Proof record with id ${proofRecordId} is missing required presentation proposal`);
        }
        const indyProposeProofFormat = {
          name: "Proof Request",
          version: "1.0",
          nonce: await this.wallet.generateNonce()
        };
        const proofRequest = await this.indyProofFormatService.createReferentForProofRequest(indyProposeProofFormat, proposalMessage.presentationProposal);
        return {
          proofRecord: options.proofRecord,
          proofFormats: {
            indy: proofRequest
          }
        };
      }
      /**
       * Retrieves the linked attachments for an {@link indyProofRequest}
       * @param indyProofRequest The proof request for which the linked attachments have to be found
       * @param requestedCredentials The requested credentials
       * @returns a list of attachments that are linked to the requested credentials
       */
      async getRequestedAttachmentsForRequestedCredentials(agentContext, indyProofRequest, requestedCredentials) {
        var _a, _b;
        const attachments = [];
        const credentialIds = /* @__PURE__ */ new Set();
        const requestedAttributesNames = [];
        for (const [referent, requestedAttribute] of Object.entries(requestedCredentials.requestedAttributes)) {
          const requestedAttributes = indyProofRequest.requestedAttributes.get(referent);
          requestedAttributesNames.push(...(_a = requestedAttributes.names) !== null && _a !== void 0 ? _a : [requestedAttributes.name]);
          if (!requestedAttribute.credentialInfo) {
            const indyCredentialInfo = await this.indyHolderService.getCredential(agentContext, requestedAttribute.credentialId);
            requestedAttribute.credentialInfo = JsonTransformer_1.JsonTransformer.fromJSON(indyCredentialInfo, IndyCredentialInfo_1.IndyCredentialInfo);
          }
          for (const attribute of Object.values(requestedAttribute.credentialInfo.attributes)) {
            if (attribute.toLowerCase().startsWith("hl:")) {
              credentialIds.add(requestedAttribute.credentialId);
            }
          }
        }
        for (const credentialId of credentialIds) {
          const credentialRecord = await this.credentialRepository.getSingleByQuery(agentContext, {
            credentialIds: [credentialId]
          });
          if (credentialRecord.linkedAttachments) {
            const requestedCredentials2 = (_b = credentialRecord.credentialAttributes) === null || _b === void 0 ? void 0 : _b.filter((credential) => credential.value.toLowerCase().startsWith("hl:") && requestedAttributesNames.includes(credential.name));
            const linkedAttachments = credentialRecord.linkedAttachments.filter((attachment) => requestedCredentials2 === null || requestedCredentials2 === void 0 ? void 0 : requestedCredentials2.map((credential) => credential.value.split(":")[1]).includes(attachment.id));
            if (linkedAttachments) {
              attachments.push(...linkedAttachments);
            }
          }
        }
        return attachments.length ? attachments : void 0;
      }
      async shouldAutoRespondToProposal(agentContext, proofRecord) {
        const proposal = await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: messages_1.V1ProposePresentationMessage
        });
        if (!proposal)
          return false;
        MessageValidator_1.MessageValidator.validateSync(proposal);
        const request = await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: messages_1.V1RequestPresentationMessage
        });
        if (!request)
          return false;
        const proofRequest = request.indyProofRequest;
        if (!proofRequest) {
          throw new errors_1.V1PresentationProblemReportError(`Missing required base64 or json encoded attachment data for presentation request with thread id ${request.threadId}`, { problemCode: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned });
        }
        await (0, class_validator_1.validateOrReject)(proofRequest);
        (0, utils_1.checkProofRequestForDuplicates)(proofRequest);
        const proposalAttributes = proposal.presentationProposal.attributes;
        const requestedAttributes = proofRequest.requestedAttributes;
        const proposedAttributeNames = proposalAttributes.map((x) => x.name);
        let requestedAttributeNames = [];
        const requestedAttributeList = Array.from(requestedAttributes.values());
        requestedAttributeList.forEach((x) => {
          if (x.name) {
            requestedAttributeNames.push(x.name);
          } else if (x.names) {
            requestedAttributeNames = requestedAttributeNames.concat(x.names);
          }
        });
        if (requestedAttributeNames.length > proposedAttributeNames.length) {
          return false;
        }
        requestedAttributeNames.forEach((x) => {
          if (!proposedAttributeNames.includes(x)) {
            this.logger.debug(`Attribute ${x} was requested but wasn't proposed.`);
            return false;
          }
        });
        const providedPredicateNames = proposal.presentationProposal.predicates.map((x) => x.name);
        proofRequest.requestedPredicates.forEach((x) => {
          if (!providedPredicateNames.includes(x.name)) {
            return false;
          }
        });
        return true;
      }
      async shouldAutoRespondToRequest(agentContext, proofRecord) {
        const proposal = await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: messages_1.V1ProposePresentationMessage
        });
        if (!proposal) {
          return false;
        }
        const request = await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: messages_1.V1RequestPresentationMessage
        });
        if (!request) {
          throw new AriesFrameworkError_1.AriesFrameworkError(`Expected to find a request message for ProofExchangeRecord with id ${proofRecord.id}`);
        }
        const proofRequest = request.indyProofRequest;
        if (!proofRequest) {
          throw new errors_1.V1PresentationProblemReportError(`Missing required base64 or json encoded attachment data for presentation request with thread id ${request.threadId}`, { problemCode: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned });
        }
        await (0, class_validator_1.validateOrReject)(proofRequest);
        (0, utils_1.checkProofRequestForDuplicates)(proofRequest);
        const proposalAttributes = proposal.presentationProposal.attributes;
        const requestedAttributes = proofRequest.requestedAttributes;
        const proposedAttributeNames = proposalAttributes.map((x) => x.name);
        let requestedAttributeNames = [];
        const requestedAttributeList = Array.from(requestedAttributes.values());
        requestedAttributeList.forEach((x) => {
          if (x.name) {
            requestedAttributeNames.push(x.name);
          } else if (x.names) {
            requestedAttributeNames = requestedAttributeNames.concat(x.names);
          }
        });
        if (requestedAttributeNames.length > proposedAttributeNames.length) {
          return false;
        }
        requestedAttributeNames.forEach((x) => {
          if (!proposedAttributeNames.includes(x)) {
            this.logger.debug(`Attribute ${x} was requested but wasn't proposed.`);
            return false;
          }
        });
        const providedPredicateNames = proposal.presentationProposal.predicates.map((x) => x.name);
        proofRequest.requestedPredicates.forEach((x) => {
          if (!providedPredicateNames.includes(x.name)) {
            return false;
          }
        });
        return true;
      }
      async shouldAutoRespondToPresentation(agentContext, proofRecord) {
        this.logger.debug(`Should auto respond to presentation for proof record id: ${proofRecord.id}`);
        return true;
      }
      async getRequestedCredentialsForProofRequest(agentContext, options) {
        var _a;
        const requestMessage = await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: options.proofRecord.id,
          messageClass: messages_1.V1RequestPresentationMessage
        });
        const proposalMessage = await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: options.proofRecord.id,
          messageClass: messages_1.V1ProposePresentationMessage
        });
        const indyProofRequest = requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.requestPresentationAttachments;
        if (!indyProofRequest) {
          throw new AriesFrameworkError_1.AriesFrameworkError("Could not find proof request");
        }
        const requestedCredentials = await this.indyProofFormatService.getRequestedCredentialsForProofRequest(agentContext, {
          attachment: indyProofRequest[0],
          presentationProposal: proposalMessage === null || proposalMessage === void 0 ? void 0 : proposalMessage.presentationProposal,
          config: (_a = options.config) !== null && _a !== void 0 ? _a : void 0
        });
        return requestedCredentials;
      }
      async autoSelectCredentialsForProofRequest(options) {
        return await this.indyProofFormatService.autoSelectCredentialsForProofRequest(options);
      }
      registerMessageHandlers(dispatcher, agentConfig, proofResponseCoordinator, mediationRecipientService, routingService) {
        dispatcher.registerMessageHandler(new handlers_1.V1ProposePresentationHandler(this, agentConfig, proofResponseCoordinator, this.didCommMessageRepository));
        dispatcher.registerMessageHandler(new handlers_1.V1RequestPresentationHandler(this, agentConfig, proofResponseCoordinator, mediationRecipientService, this.didCommMessageRepository, routingService));
        dispatcher.registerMessageHandler(new handlers_1.V1PresentationHandler(this, agentConfig, proofResponseCoordinator, this.didCommMessageRepository));
        dispatcher.registerMessageHandler(new handlers_1.V1PresentationAckHandler(this));
        dispatcher.registerMessageHandler(new handlers_1.V1PresentationProblemReportHandler(this));
      }
      async findRequestMessage(agentContext, proofRecordId) {
        return await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: proofRecordId,
          messageClass: messages_1.V1RequestPresentationMessage
        });
      }
      async findPresentationMessage(agentContext, proofRecordId) {
        return await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: proofRecordId,
          messageClass: messages_1.V1PresentationMessage
        });
      }
      async findProposalMessage(agentContext, proofRecordId) {
        return await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: proofRecordId,
          messageClass: messages_1.V1ProposePresentationMessage
        });
      }
      async getFormatData(agentContext, proofRecordId) {
        var _a, _b;
        const [proposalMessage, requestMessage, presentationMessage] = await Promise.all([
          this.findProposalMessage(agentContext, proofRecordId),
          this.findRequestMessage(agentContext, proofRecordId),
          this.findPresentationMessage(agentContext, proofRecordId)
        ]);
        const indyProposeProof = proposalMessage ? JsonTransformer_1.JsonTransformer.toJSON(await this.rfc0592ProposalFromV1ProposeMessage(proposalMessage)) : void 0;
        const indyRequestProof = (_a = requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.indyProofRequestJson) !== null && _a !== void 0 ? _a : void 0;
        const indyPresentProof = (_b = presentationMessage === null || presentationMessage === void 0 ? void 0 : presentationMessage.indyProof) !== null && _b !== void 0 ? _b : void 0;
        return {
          proposal: proposalMessage ? {
            indy: indyProposeProof
          } : void 0,
          request: requestMessage ? {
            indy: indyRequestProof
          } : void 0,
          presentation: presentationMessage ? {
            indy: indyPresentProof
          } : void 0
        };
      }
      async rfc0592ProposalFromV1ProposeMessage(proposalMessage) {
        const indyFormat = {
          name: "Proof Request",
          version: "1.0",
          nonce: await this.wallet.generateNonce(),
          attributes: proposalMessage.presentationProposal.attributes,
          predicates: proposalMessage.presentationProposal.predicates
        };
        if (!indyFormat) {
          throw new AriesFrameworkError_1.AriesFrameworkError("No Indy format found.");
        }
        const preview = new V1PresentationPreview_1.PresentationPreview({
          attributes: indyFormat.attributes,
          predicates: indyFormat.predicates
        });
        return this.indyProofFormatService.createReferentForProofRequest(indyFormat, preview);
      }
      /**
       * Retrieve all proof records
       *
       * @returns List containing all proof records
       */
      async getAll(agentContext) {
        return this.proofRepository.getAll(agentContext);
      }
      /**
       * Retrieve a proof record by connection id and thread id
       *
       * @param connectionId The connection id
       * @param threadId The thread id
       * @throws {RecordNotFoundError} If no record is found
       * @throws {RecordDuplicateError} If multiple records are found
       * @returns The proof record
       */
      async getByThreadAndConnectionId(agentContext, threadId, connectionId) {
        return this.proofRepository.getSingleByQuery(agentContext, { threadId, connectionId });
      }
      async createAck(gentContext, options) {
        const { proofRecord } = options;
        this.logger.debug(`Creating presentation ack for proof record with id ${proofRecord.id}`);
        proofRecord.assertState(ProofState_1.ProofState.PresentationReceived);
        const ackMessage = new messages_1.V1PresentationAckMessage({
          status: AckMessage_1.AckStatus.OK,
          threadId: proofRecord.threadId
        });
        await this.updateState(gentContext, proofRecord, ProofState_1.ProofState.Done);
        return { message: ackMessage, proofRecord };
      }
    };
    V1ProofService = __decorate([
      (0, tsyringe_1.scoped)(tsyringe_1.Lifecycle.ContainerScoped),
      __param(3, (0, tsyringe_1.inject)(constants_1.InjectionSymbols.Wallet)),
      __metadata("design:paramtypes", [
        ProofRepository_1.ProofRepository,
        DidCommMessageRepository_1.DidCommMessageRepository,
        IndyLedgerService_1.IndyLedgerService,
        Object,
        AgentConfig_1.AgentConfig,
        connections_1.ConnectionService,
        EventEmitter_1.EventEmitter,
        credentials_1.CredentialRepository,
        IndyProofFormatService_1.IndyProofFormatService,
        indy_1.IndyHolderService,
        indy_1.IndyRevocationService
      ])
    ], V1ProofService);
    exports.V1ProofService = V1ProofService;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/index.js
var require_v14 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v1/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_errors6(), exports);
    __exportStar(require_messages14(), exports);
    __exportStar(require_models11(), exports);
    __exportStar(require_V1ProofService(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/messages/V2PresentationAckMessage.js
var require_V2PresentationAckMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/messages/V2PresentationAckMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2PresentationAckMessage = void 0;
    var messageType_1 = require_messageType();
    var AckMessage_1 = require_AckMessage();
    var V2PresentationAckMessage = class extends AckMessage_1.AckMessage {
      constructor(options) {
        super(options);
        this.type = V2PresentationAckMessage.type.messageTypeUri;
      }
    };
    V2PresentationAckMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/present-proof/2.0/ack");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V2PresentationAckMessage.type),
      __metadata("design:type", Object)
    ], V2PresentationAckMessage.prototype, "type", void 0);
    exports.V2PresentationAckMessage = V2PresentationAckMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/messages/V2PresentationMessage.js
var require_V2PresentationMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/messages/V2PresentationMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2PresentationMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var Attachment_1 = require_Attachment();
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var messageType_1 = require_messageType();
    var uuid_1 = require_uuid();
    var ProofFormatSpec_1 = require_ProofFormatSpec();
    var V2PresentationMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a, _b;
        super();
        this.type = V2PresentationMessage.type.messageTypeUri;
        this.lastPresentation = true;
        if (options) {
          this.formats = [];
          this.presentationsAttach = [];
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.comment = options.comment;
          this.goalCode = options.goalCode;
          this.lastPresentation = (_b = options.lastPresentation) !== null && _b !== void 0 ? _b : true;
          for (const entry of options.attachmentInfo) {
            this.addPresentationsAttachment(entry);
          }
        }
      }
      addPresentationsAttachment(attachment) {
        this.formats.push(attachment.format);
        this.presentationsAttach.push(attachment.attachment);
      }
      /**
       * Every attachment has a corresponding entry in the formats array.
       * This method pairs those together in a {@link ProofAttachmentFormat} object.
       */
      getAttachmentFormats() {
        const attachmentFormats = [];
        this.formats.forEach((format2) => {
          const attachment = this.presentationsAttach.find((attachment2) => attachment2.id === format2.attachmentId);
          if (!attachment) {
            throw new AriesFrameworkError_1.AriesFrameworkError(`Could not find a matching attachment with attachmentId: ${format2.attachmentId}`);
          }
          attachmentFormats.push({ format: format2, attachment });
        });
        return attachmentFormats;
      }
    };
    V2PresentationMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/present-proof/2.0/presentation");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V2PresentationMessage.type),
      __metadata("design:type", Object)
    ], V2PresentationMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], V2PresentationMessage.prototype, "comment", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "goal_code" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], V2PresentationMessage.prototype, "goalCode", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "last_presentation" }),
      (0, class_validator_1.IsBoolean)(),
      __metadata("design:type", Object)
    ], V2PresentationMessage.prototype, "lastPresentation", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "formats" }),
      (0, class_transformer_1.Type)(() => ProofFormatSpec_1.ProofFormatSpec),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)({ each: true }),
      (0, class_validator_1.IsInstance)(ProofFormatSpec_1.ProofFormatSpec, { each: true }),
      __metadata("design:type", Array)
    ], V2PresentationMessage.prototype, "formats", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "presentations~attach" }),
      (0, class_transformer_1.Type)(() => Attachment_1.Attachment),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)({ each: true }),
      (0, class_validator_1.IsInstance)(Attachment_1.Attachment, { each: true }),
      __metadata("design:type", Array)
    ], V2PresentationMessage.prototype, "presentationsAttach", void 0);
    exports.V2PresentationMessage = V2PresentationMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/messages/V2PresentationProblemReportMessage.js
var require_V2PresentationProblemReportMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/messages/V2PresentationProblemReportMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2PresentationProblemReportMessage = void 0;
    var messageType_1 = require_messageType();
    var ProblemReportMessage_1 = require_ProblemReportMessage();
    var V2PresentationProblemReportMessage = class extends ProblemReportMessage_1.ProblemReportMessage {
      /**
       * Create new PresentationProblemReportMessage instance.
       * @param options
       */
      constructor(options) {
        super(options);
        this.type = V2PresentationProblemReportMessage.type.messageTypeUri;
      }
    };
    V2PresentationProblemReportMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/present-proof/2.0/problem-report");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V2PresentationProblemReportMessage.type),
      __metadata("design:type", Object)
    ], V2PresentationProblemReportMessage.prototype, "type", void 0);
    exports.V2PresentationProblemReportMessage = V2PresentationProblemReportMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/messages/V2ProposalPresentationMessage.js
var require_V2ProposalPresentationMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/messages/V2ProposalPresentationMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2ProposalPresentationMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var Attachment_1 = require_Attachment();
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var messageType_1 = require_messageType();
    var uuid_1 = require_uuid();
    var ProofFormatSpec_1 = require_ProofFormatSpec();
    var V2ProposalPresentationMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a, _b;
        super();
        this.type = V2ProposalPresentationMessage.type.messageTypeUri;
        this.willConfirm = false;
        if (options) {
          this.formats = [];
          this.proposalsAttach = [];
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.comment = options.comment;
          this.goalCode = options.goalCode;
          this.willConfirm = (_b = options.willConfirm) !== null && _b !== void 0 ? _b : false;
          if (options.parentThreadId) {
            this.setThread({
              parentThreadId: options.parentThreadId
            });
          }
          for (const entry of options.attachmentInfo) {
            this.addProposalsAttachment(entry);
          }
        }
      }
      addProposalsAttachment(attachment) {
        this.formats.push(attachment.format);
        this.proposalsAttach.push(attachment.attachment);
      }
      /**
       * Every attachment has a corresponding entry in the formats array.
       * This method pairs those together in a {@link ProofAttachmentFormat} object.
       */
      getAttachmentFormats() {
        const attachmentFormats = [];
        this.formats.forEach((format2) => {
          const attachment = this.proposalsAttach.find((attachment2) => attachment2.id === format2.attachmentId);
          if (!attachment) {
            throw new AriesFrameworkError_1.AriesFrameworkError(`Could not find a matching attachment with attachmentId: ${format2.attachmentId}`);
          }
          attachmentFormats.push({ format: format2, attachment });
        });
        return attachmentFormats;
      }
    };
    V2ProposalPresentationMessage.type = (0, messageType_1.parseMessageType)(`https://didcomm.org/present-proof/2.0/propose-presentation`);
    __decorate([
      (0, messageType_1.IsValidMessageType)(V2ProposalPresentationMessage.type),
      __metadata("design:type", Object)
    ], V2ProposalPresentationMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], V2ProposalPresentationMessage.prototype, "comment", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "goal_code" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], V2ProposalPresentationMessage.prototype, "goalCode", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "will_confirm" }),
      (0, class_validator_1.IsBoolean)(),
      __metadata("design:type", Object)
    ], V2ProposalPresentationMessage.prototype, "willConfirm", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "formats" }),
      (0, class_transformer_1.Type)(() => ProofFormatSpec_1.ProofFormatSpec),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)({ each: true }),
      (0, class_validator_1.IsInstance)(ProofFormatSpec_1.ProofFormatSpec, { each: true }),
      __metadata("design:type", Array)
    ], V2ProposalPresentationMessage.prototype, "formats", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "proposals~attach" }),
      (0, class_transformer_1.Type)(() => Attachment_1.Attachment),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)({ each: true }),
      (0, class_validator_1.IsInstance)(Attachment_1.Attachment, { each: true }),
      __metadata("design:type", Array)
    ], V2ProposalPresentationMessage.prototype, "proposalsAttach", void 0);
    exports.V2ProposalPresentationMessage = V2ProposalPresentationMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/messages/V2RequestPresentationMessage.js
var require_V2RequestPresentationMessage = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/messages/V2RequestPresentationMessage.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2RequestPresentationMessage = void 0;
    var class_transformer_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var class_validator_1 = (init_esm52(), __toCommonJS(esm5_exports2));
    var AgentMessage_1 = require_AgentMessage();
    var Attachment_1 = require_Attachment();
    var error_1 = require_error();
    var messageType_1 = require_messageType();
    var uuid_1 = require_uuid();
    var ProofFormatSpec_1 = require_ProofFormatSpec();
    var V2RequestPresentationMessage = class extends AgentMessage_1.AgentMessage {
      constructor(options) {
        var _a, _b, _c;
        super();
        this.type = V2RequestPresentationMessage.type.messageTypeUri;
        this.willConfirm = false;
        this.presentMultiple = false;
        if (options) {
          this.formats = [];
          this.requestPresentationsAttach = [];
          this.id = (_a = options.id) !== null && _a !== void 0 ? _a : (0, uuid_1.uuid)();
          this.comment = options.comment;
          this.goalCode = options.goalCode;
          this.willConfirm = (_b = options.willConfirm) !== null && _b !== void 0 ? _b : true;
          this.presentMultiple = (_c = options.presentMultiple) !== null && _c !== void 0 ? _c : false;
          if (options.parentThreadId) {
            this.setThread({
              parentThreadId: options.parentThreadId
            });
          }
          for (const entry of options.attachmentInfo) {
            this.addRequestPresentationsAttachment(entry);
          }
        }
      }
      addRequestPresentationsAttachment(attachment) {
        this.formats.push(attachment.format);
        this.requestPresentationsAttach.push(attachment.attachment);
      }
      getAttachmentByFormatIdentifier(formatIdentifier) {
        const format2 = this.formats.find((x) => x.format === formatIdentifier);
        if (!format2) {
          throw new error_1.AriesFrameworkError(`Expected to find a format entry of type: ${formatIdentifier}, but none could be found.`);
        }
        const attachment = this.requestPresentationsAttach.find((x) => x.id === format2.attachmentId);
        if (!attachment) {
          throw new error_1.AriesFrameworkError(`Expected to find an attachment entry with id: ${format2.attachmentId}, but none could be found.`);
        }
        return attachment;
      }
      /**
       * Every attachment has a corresponding entry in the formats array.
       * This method pairs those together in a {@link ProofAttachmentFormat} object.
       */
      getAttachmentFormats() {
        const attachmentFormats = [];
        this.formats.forEach((format2) => {
          const attachment = this.requestPresentationsAttach.find((attachment2) => attachment2.id === format2.attachmentId);
          if (!attachment) {
            throw new error_1.AriesFrameworkError(`Could not find a matching attachment with attachmentId: ${format2.attachmentId}`);
          }
          attachmentFormats.push({ format: format2, attachment });
        });
        return attachmentFormats;
      }
    };
    V2RequestPresentationMessage.type = (0, messageType_1.parseMessageType)("https://didcomm.org/present-proof/2.0/request-presentation");
    __decorate([
      (0, messageType_1.IsValidMessageType)(V2RequestPresentationMessage.type),
      __metadata("design:type", Object)
    ], V2RequestPresentationMessage.prototype, "type", void 0);
    __decorate([
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], V2RequestPresentationMessage.prototype, "comment", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "goal_code" }),
      (0, class_validator_1.IsString)(),
      (0, class_validator_1.IsOptional)(),
      __metadata("design:type", String)
    ], V2RequestPresentationMessage.prototype, "goalCode", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "will_confirm" }),
      (0, class_validator_1.IsBoolean)(),
      __metadata("design:type", Object)
    ], V2RequestPresentationMessage.prototype, "willConfirm", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "present_multiple" }),
      (0, class_validator_1.IsBoolean)(),
      __metadata("design:type", Object)
    ], V2RequestPresentationMessage.prototype, "presentMultiple", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "formats" }),
      (0, class_transformer_1.Type)(() => ProofFormatSpec_1.ProofFormatSpec),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)({ each: true }),
      (0, class_validator_1.IsInstance)(ProofFormatSpec_1.ProofFormatSpec, { each: true }),
      __metadata("design:type", Array)
    ], V2RequestPresentationMessage.prototype, "formats", void 0);
    __decorate([
      (0, class_transformer_1.Expose)({ name: "request_presentations~attach" }),
      (0, class_transformer_1.Type)(() => Attachment_1.Attachment),
      (0, class_validator_1.IsArray)(),
      (0, class_validator_1.ValidateNested)({ each: true }),
      (0, class_validator_1.IsInstance)(Attachment_1.Attachment, { each: true }),
      __metadata("design:type", Array)
    ], V2RequestPresentationMessage.prototype, "requestPresentationsAttach", void 0);
    exports.V2RequestPresentationMessage = V2RequestPresentationMessage;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/messages/index.js
var require_messages15 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/messages/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_V2PresentationAckMessage(), exports);
    __exportStar(require_V2PresentationMessage(), exports);
    __exportStar(require_V2PresentationProblemReportMessage(), exports);
    __exportStar(require_V2ProposalPresentationMessage(), exports);
    __exportStar(require_V2RequestPresentationMessage(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/errors/V2PresentationProblemReportError.js
var require_V2PresentationProblemReportError = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/errors/V2PresentationProblemReportError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2PresentationProblemReportError = void 0;
    var ProblemReportError_1 = require_ProblemReportError();
    var messages_1 = require_messages15();
    var V2PresentationProblemReportError = class extends ProblemReportError_1.ProblemReportError {
      constructor(message, { problemCode }) {
        super(message, { problemCode });
        this.message = message;
        this.problemReport = new messages_1.V2PresentationProblemReportMessage({
          description: {
            en: message,
            code: problemCode
          }
        });
      }
    };
    exports.V2PresentationProblemReportError = V2PresentationProblemReportError;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/errors/index.js
var require_errors7 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/errors/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_V2PresentationProblemReportError(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/repository/index.js
var require_repository8 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/repository/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ProofExchangeRecord(), exports);
    __exportStar(require_ProofRepository(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/handlers/V2PresentationAckHandler.js
var require_V2PresentationAckHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/handlers/V2PresentationAckHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2PresentationAckHandler = void 0;
    var messages_1 = require_messages15();
    var V2PresentationAckHandler = class {
      constructor(proofService) {
        this.supportedMessages = [messages_1.V2PresentationAckMessage];
        this.proofService = proofService;
      }
      async handle(messageContext) {
        await this.proofService.processAck(messageContext);
      }
    };
    exports.V2PresentationAckHandler = V2PresentationAckHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/handlers/V2PresentationHandler.js
var require_V2PresentationHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/handlers/V2PresentationHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2PresentationHandler = void 0;
    var models_1 = require_models3();
    var messages_1 = require_messages15();
    var V2PresentationHandler = class {
      constructor(proofService, agentConfig, proofResponseCoordinator, didCommMessageRepository) {
        this.supportedMessages = [messages_1.V2PresentationMessage];
        this.proofService = proofService;
        this.agentConfig = agentConfig;
        this.proofResponseCoordinator = proofResponseCoordinator;
        this.didCommMessageRepository = didCommMessageRepository;
      }
      async handle(messageContext) {
        const proofRecord = await this.proofService.processPresentation(messageContext);
        const shouldAutoRespond = await this.proofResponseCoordinator.shouldAutoRespondToPresentation(messageContext.agentContext, proofRecord);
        if (shouldAutoRespond) {
          return await this.createAck(proofRecord, messageContext);
        }
      }
      async createAck(record, messageContext) {
        this.agentConfig.logger.info(`Automatically sending acknowledgement with autoAccept on ${this.agentConfig.autoAcceptProofs}`);
        const { message, proofRecord } = await this.proofService.createAck(messageContext.agentContext, {
          proofRecord: record
        });
        const requestMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: messages_1.V2RequestPresentationMessage
        });
        const presentationMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: messages_1.V2PresentationMessage
        });
        if (messageContext.connection) {
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            connection: messageContext.connection,
            associatedRecord: proofRecord
          });
        } else if ((requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.service) && (presentationMessage === null || presentationMessage === void 0 ? void 0 : presentationMessage.service)) {
          const recipientService = presentationMessage === null || presentationMessage === void 0 ? void 0 : presentationMessage.service;
          const ourService = requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.service;
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            serviceParams: {
              service: recipientService.resolvedDidCommService,
              senderKey: ourService.resolvedDidCommService.recipientKeys[0]
            }
          });
        }
        this.agentConfig.logger.error(`Could not automatically create presentation ack`);
      }
    };
    exports.V2PresentationHandler = V2PresentationHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/handlers/V2PresentationProblemReportHandler.js
var require_V2PresentationProblemReportHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/handlers/V2PresentationProblemReportHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2PresentationProblemReportHandler = void 0;
    var messages_1 = require_messages15();
    var V2PresentationProblemReportHandler = class {
      constructor(proofService) {
        this.supportedMessages = [messages_1.V2PresentationProblemReportMessage];
        this.proofService = proofService;
      }
      async handle(messageContext) {
        await this.proofService.processProblemReport(messageContext);
      }
    };
    exports.V2PresentationProblemReportHandler = V2PresentationProblemReportHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/handlers/V2ProposePresentationHandler.js
var require_V2ProposePresentationHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/handlers/V2ProposePresentationHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2ProposePresentationHandler = void 0;
    var models_1 = require_models3();
    var AriesFrameworkError_1 = require_AriesFrameworkError();
    var V2ProposalPresentationMessage_1 = require_V2ProposalPresentationMessage();
    var V2ProposePresentationHandler = class {
      constructor(proofService, agentConfig, didCommMessageRepository, proofResponseCoordinator) {
        this.supportedMessages = [V2ProposalPresentationMessage_1.V2ProposalPresentationMessage];
        this.proofService = proofService;
        this.agentConfig = agentConfig;
        this.didCommMessageRepository = didCommMessageRepository;
        this.proofResponseCoordinator = proofResponseCoordinator;
      }
      async handle(messageContext) {
        const proofRecord = await this.proofService.processProposal(messageContext);
        const shouldAutoRespond = await this.proofResponseCoordinator.shouldAutoRespondToProposal(messageContext.agentContext, proofRecord);
        if (shouldAutoRespond) {
          return this.createRequest(proofRecord, messageContext);
        }
      }
      async createRequest(proofRecord, messageContext) {
        this.agentConfig.logger.info(`Automatically sending request with autoAccept on ${this.agentConfig.autoAcceptProofs}`);
        if (!messageContext.connection) {
          this.agentConfig.logger.error("No connection on the messageContext");
          throw new AriesFrameworkError_1.AriesFrameworkError("No connection on the messageContext");
        }
        const proposalMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: V2ProposalPresentationMessage_1.V2ProposalPresentationMessage
        });
        if (!proposalMessage) {
          this.agentConfig.logger.error(`Proof record with id ${proofRecord.id} is missing required credential proposal`);
          throw new AriesFrameworkError_1.AriesFrameworkError(`Proof record with id ${proofRecord.id} is missing required credential proposal`);
        }
        const proofRequestFromProposalOptions = {
          proofRecord
        };
        const proofRequest = await this.proofService.createProofRequestFromProposal(messageContext.agentContext, proofRequestFromProposalOptions);
        const indyProofRequest = proofRequest.proofFormats;
        if (!indyProofRequest) {
          this.agentConfig.logger.error("Failed to create proof request");
          throw new AriesFrameworkError_1.AriesFrameworkError("Failed to create proof request.");
        }
        const options = {
          proofRecord,
          autoAcceptProof: proofRecord.autoAcceptProof,
          proofFormats: indyProofRequest,
          willConfirm: true
        };
        const { message } = await this.proofService.createRequestAsResponse(messageContext.agentContext, options);
        return new models_1.OutboundMessageContext(message, {
          agentContext: messageContext.agentContext,
          connection: messageContext.connection,
          associatedRecord: proofRecord
        });
      }
    };
    exports.V2ProposePresentationHandler = V2ProposePresentationHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/handlers/V2RequestPresentationHandler.js
var require_V2RequestPresentationHandler = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/handlers/V2RequestPresentationHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2RequestPresentationHandler = void 0;
    var models_1 = require_models3();
    var ServiceDecorator_1 = require_ServiceDecorator();
    var storage_1 = require_storage();
    var V2RequestPresentationMessage_1 = require_V2RequestPresentationMessage();
    var V2RequestPresentationHandler = class {
      constructor(proofService, agentConfig, proofResponseCoordinator, mediationRecipientService, didCommMessageRepository, routingService) {
        this.supportedMessages = [V2RequestPresentationMessage_1.V2RequestPresentationMessage];
        this.proofService = proofService;
        this.agentConfig = agentConfig;
        this.proofResponseCoordinator = proofResponseCoordinator;
        this.mediationRecipientService = mediationRecipientService;
        this.didCommMessageRepository = didCommMessageRepository;
        this.routingService = routingService;
      }
      async handle(messageContext) {
        const proofRecord = await this.proofService.processRequest(messageContext);
        const shouldAutoRespond = await this.proofResponseCoordinator.shouldAutoRespondToRequest(messageContext.agentContext, proofRecord);
        if (shouldAutoRespond) {
          return await this.createPresentation(proofRecord, messageContext);
        }
      }
      async createPresentation(record, messageContext) {
        const requestMessage = await this.didCommMessageRepository.getAgentMessage(messageContext.agentContext, {
          associatedRecordId: record.id,
          messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage
        });
        this.agentConfig.logger.info(`Automatically sending presentation with autoAccept on ${this.agentConfig.autoAcceptProofs}`);
        const retrievedCredentials = await this.proofService.getRequestedCredentialsForProofRequest(messageContext.agentContext, {
          proofRecord: record,
          config: {
            filterByPresentationPreview: false
          }
        });
        const requestedCredentials = await this.proofService.autoSelectCredentialsForProofRequest(retrievedCredentials);
        const { message, proofRecord } = await this.proofService.createPresentation(messageContext.agentContext, {
          proofRecord: record,
          proofFormats: requestedCredentials.proofFormats
        });
        if (messageContext.connection) {
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            connection: messageContext.connection,
            associatedRecord: proofRecord
          });
        } else if (requestMessage.service) {
          const routing = await this.routingService.getRouting(messageContext.agentContext);
          message.service = new ServiceDecorator_1.ServiceDecorator({
            serviceEndpoint: routing.endpoints[0],
            recipientKeys: [routing.recipientKey.publicKeyBase58],
            routingKeys: routing.routingKeys.map((key) => key.publicKeyBase58)
          });
          const recipientService = requestMessage.service;
          await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
            agentMessage: message,
            associatedRecordId: proofRecord.id,
            role: storage_1.DidCommMessageRole.Sender
          });
          return new models_1.OutboundMessageContext(message, {
            agentContext: messageContext.agentContext,
            serviceParams: {
              service: recipientService.resolvedDidCommService,
              senderKey: message.service.resolvedDidCommService.recipientKeys[0]
            }
          });
        }
        this.agentConfig.logger.error(`Could not automatically create presentation`);
      }
    };
    exports.V2RequestPresentationHandler = V2RequestPresentationHandler;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/V2ProofService.js
var require_V2ProofService = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/V2ProofService.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2ProofService = void 0;
    var tsyringe_1 = (init_esm53(), __toCommonJS(esm5_exports3));
    var AgentConfig_1 = require_AgentConfig();
    var EventEmitter_1 = require_EventEmitter();
    var constants_1 = require_constants();
    var error_1 = require_error();
    var storage_1 = require_storage();
    var MessageValidator_1 = require_MessageValidator();
    var common_1 = require_common();
    var connections_1 = require_connections();
    var ProofService_1 = require_ProofService();
    var PresentationProblemReportReason_1 = require_PresentationProblemReportReason();
    var ProofFormatConstants_1 = require_ProofFormatConstants();
    var IndyProofFormatService_1 = require_IndyProofFormatService();
    var ProofState_1 = require_ProofState();
    var repository_1 = require_repository8();
    var errors_1 = require_errors7();
    var V2PresentationAckHandler_1 = require_V2PresentationAckHandler();
    var V2PresentationHandler_1 = require_V2PresentationHandler();
    var V2PresentationProblemReportHandler_1 = require_V2PresentationProblemReportHandler();
    var V2ProposePresentationHandler_1 = require_V2ProposePresentationHandler();
    var V2RequestPresentationHandler_1 = require_V2RequestPresentationHandler();
    var messages_1 = require_messages15();
    var V2PresentationMessage_1 = require_V2PresentationMessage();
    var V2PresentationProblemReportMessage_1 = require_V2PresentationProblemReportMessage();
    var V2ProposalPresentationMessage_1 = require_V2ProposalPresentationMessage();
    var V2RequestPresentationMessage_1 = require_V2RequestPresentationMessage();
    var V2ProofService = class V2ProofService extends ProofService_1.ProofService {
      constructor(agentConfig, connectionService, proofRepository, didCommMessageRepository, eventEmitter, indyProofFormatService, wallet) {
        super(agentConfig, proofRepository, connectionService, didCommMessageRepository, wallet, eventEmitter);
        this.version = "v2";
        this.wallet = wallet;
        this.formatServiceMap = [indyProofFormatService].reduce((formatServiceMap, formatService) => Object.assign(Object.assign({}, formatServiceMap), { [formatService.formatKey]: formatService }), {});
      }
      async createProposal(agentContext, options) {
        var _a;
        const formats = [];
        for (const key of Object.keys(options.proofFormats)) {
          const service = this.formatServiceMap[key];
          formats.push(await service.createProposal({ formats: options.proofFormats }));
        }
        const proposalMessage = new V2ProposalPresentationMessage_1.V2ProposalPresentationMessage({
          attachmentInfo: formats,
          comment: options.comment,
          willConfirm: options.willConfirm,
          goalCode: options.goalCode,
          parentThreadId: options.parentThreadId
        });
        const proofRecord = new repository_1.ProofExchangeRecord({
          connectionId: options.connectionRecord.id,
          threadId: proposalMessage.threadId,
          parentThreadId: (_a = proposalMessage.thread) === null || _a === void 0 ? void 0 : _a.parentThreadId,
          state: ProofState_1.ProofState.ProposalSent,
          protocolVersion: "v2"
        });
        await this.proofRepository.save(agentContext, proofRecord);
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: proposalMessage,
          role: storage_1.DidCommMessageRole.Sender,
          associatedRecordId: proofRecord.id
        });
        this.emitStateChangedEvent(agentContext, proofRecord, null);
        return {
          proofRecord,
          message: proposalMessage
        };
      }
      async createProposalAsResponse(agentContext, options) {
        options.proofRecord.assertState(ProofState_1.ProofState.RequestReceived);
        const formats = [];
        for (const key of Object.keys(options.proofFormats)) {
          const service = this.formatServiceMap[key];
          formats.push(await service.createProposal({
            formats: options.proofFormats
          }));
        }
        const proposalMessage = new V2ProposalPresentationMessage_1.V2ProposalPresentationMessage({
          attachmentInfo: formats,
          comment: options.comment,
          goalCode: options.goalCode,
          willConfirm: options.willConfirm
        });
        proposalMessage.setThread({ threadId: options.proofRecord.threadId });
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: proposalMessage,
          role: storage_1.DidCommMessageRole.Sender,
          associatedRecordId: options.proofRecord.id
        });
        await this.updateState(agentContext, options.proofRecord, ProofState_1.ProofState.ProposalSent);
        return { message: proposalMessage, proofRecord: options.proofRecord };
      }
      async processProposal(messageContext) {
        var _a;
        const { message: proposalMessage, connection: connectionRecord } = messageContext;
        let proofRecord;
        const proposalAttachments = proposalMessage.getAttachmentFormats();
        for (const attachmentFormat of proposalAttachments) {
          const service = this.getFormatServiceForFormat(attachmentFormat.format);
          await (service === null || service === void 0 ? void 0 : service.processProposal({
            proposal: attachmentFormat
          }));
        }
        try {
          proofRecord = await this.proofRepository.getSingleByQuery(messageContext.agentContext, {
            threadId: proposalMessage.threadId,
            connectionId: connectionRecord === null || connectionRecord === void 0 ? void 0 : connectionRecord.id
          });
          const requestMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage
          });
          proofRecord.assertState(ProofState_1.ProofState.RequestSent);
          this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
            previousReceivedMessage: proposalMessage,
            previousSentMessage: requestMessage !== null && requestMessage !== void 0 ? requestMessage : void 0
          });
          await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
            agentMessage: proposalMessage,
            associatedRecordId: proofRecord.id,
            role: storage_1.DidCommMessageRole.Receiver
          });
          await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.ProposalReceived);
        } catch (_b) {
          proofRecord = new repository_1.ProofExchangeRecord({
            connectionId: connectionRecord === null || connectionRecord === void 0 ? void 0 : connectionRecord.id,
            threadId: proposalMessage.threadId,
            parentThreadId: (_a = proposalMessage.thread) === null || _a === void 0 ? void 0 : _a.parentThreadId,
            state: ProofState_1.ProofState.ProposalReceived,
            protocolVersion: "v2"
          });
          this.connectionService.assertConnectionOrServiceDecorator(messageContext);
          await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
            agentMessage: proposalMessage,
            associatedRecordId: proofRecord.id,
            role: storage_1.DidCommMessageRole.Receiver
          });
          await this.proofRepository.save(messageContext.agentContext, proofRecord);
          this.emitStateChangedEvent(messageContext.agentContext, proofRecord, null);
        }
        return proofRecord;
      }
      async createRequest(agentContext, options) {
        var _a, _b;
        const formats = [];
        for (const key of Object.keys(options.proofFormats)) {
          const service = this.formatServiceMap[key];
          formats.push(await service.createRequest({
            formats: options.proofFormats
          }));
        }
        const requestMessage = new V2RequestPresentationMessage_1.V2RequestPresentationMessage({
          attachmentInfo: formats,
          comment: options.comment,
          willConfirm: options.willConfirm,
          goalCode: options.goalCode,
          parentThreadId: options.parentThreadId
        });
        const proofRecord = new repository_1.ProofExchangeRecord({
          connectionId: (_a = options.connectionRecord) === null || _a === void 0 ? void 0 : _a.id,
          threadId: requestMessage.threadId,
          parentThreadId: (_b = requestMessage.thread) === null || _b === void 0 ? void 0 : _b.parentThreadId,
          state: ProofState_1.ProofState.RequestSent,
          protocolVersion: "v2"
        });
        await this.proofRepository.save(agentContext, proofRecord);
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: requestMessage,
          role: storage_1.DidCommMessageRole.Sender,
          associatedRecordId: proofRecord.id
        });
        this.emitStateChangedEvent(agentContext, proofRecord, null);
        return {
          proofRecord,
          message: requestMessage
        };
      }
      async createRequestAsResponse(agentContext, options) {
        options.proofRecord.assertState(ProofState_1.ProofState.ProposalReceived);
        const proposal = await this.didCommMessageRepository.getAgentMessage(agentContext, {
          associatedRecordId: options.proofRecord.id,
          messageClass: V2ProposalPresentationMessage_1.V2ProposalPresentationMessage
        });
        if (!proposal) {
          throw new error_1.AriesFrameworkError(`Proof record with id ${options.proofRecord.id} is missing required presentation proposal`);
        }
        const formats = [];
        for (const key of Object.keys(options.proofFormats)) {
          const service = this.formatServiceMap[key];
          const requestOptions = {
            proofFormats: options.proofFormats,
            proofRecord: options.proofRecord
          };
          formats.push(await service.createRequestAsResponse(requestOptions));
        }
        const requestMessage = new V2RequestPresentationMessage_1.V2RequestPresentationMessage({
          attachmentInfo: formats,
          comment: options.comment,
          willConfirm: options.willConfirm,
          goalCode: options.goalCode
        });
        requestMessage.setThread({ threadId: options.proofRecord.threadId });
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: requestMessage,
          role: storage_1.DidCommMessageRole.Sender,
          associatedRecordId: options.proofRecord.id
        });
        await this.updateState(agentContext, options.proofRecord, ProofState_1.ProofState.RequestSent);
        return { message: requestMessage, proofRecord: options.proofRecord };
      }
      async processRequest(messageContext) {
        var _a;
        const { message: proofRequestMessage, connection: connectionRecord } = messageContext;
        const requestAttachments = proofRequestMessage.getAttachmentFormats();
        for (const attachmentFormat of requestAttachments) {
          const service = this.getFormatServiceForFormat(attachmentFormat.format);
          await (service === null || service === void 0 ? void 0 : service.processRequest({
            requestAttachment: attachmentFormat
          }));
        }
        if (proofRequestMessage.requestPresentationsAttach.length === 0) {
          throw new errors_1.V2PresentationProblemReportError(`Missing required base64 or json encoded attachment data for presentation request with thread id ${proofRequestMessage.threadId}`, { problemCode: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned });
        }
        this.logger.debug(`Received proof request`, proofRequestMessage);
        let proofRecord;
        try {
          proofRecord = await this.proofRepository.getSingleByQuery(messageContext.agentContext, {
            threadId: proofRequestMessage.threadId,
            connectionId: connectionRecord === null || connectionRecord === void 0 ? void 0 : connectionRecord.id
          });
          const requestMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage
          });
          const proposalMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
            associatedRecordId: proofRecord.id,
            messageClass: V2ProposalPresentationMessage_1.V2ProposalPresentationMessage
          });
          proofRecord.assertState(ProofState_1.ProofState.ProposalSent);
          this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
            previousReceivedMessage: requestMessage !== null && requestMessage !== void 0 ? requestMessage : void 0,
            previousSentMessage: proposalMessage !== null && proposalMessage !== void 0 ? proposalMessage : void 0
          });
          await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
            agentMessage: proofRequestMessage,
            associatedRecordId: proofRecord.id,
            role: storage_1.DidCommMessageRole.Receiver
          });
          await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.RequestReceived);
        } catch (_b) {
          proofRecord = new repository_1.ProofExchangeRecord({
            connectionId: connectionRecord === null || connectionRecord === void 0 ? void 0 : connectionRecord.id,
            threadId: proofRequestMessage.threadId,
            parentThreadId: (_a = proofRequestMessage.thread) === null || _a === void 0 ? void 0 : _a.parentThreadId,
            state: ProofState_1.ProofState.RequestReceived,
            protocolVersion: "v2"
          });
          await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
            agentMessage: proofRequestMessage,
            associatedRecordId: proofRecord.id,
            role: storage_1.DidCommMessageRole.Receiver
          });
          this.connectionService.assertConnectionOrServiceDecorator(messageContext);
          await this.proofRepository.save(messageContext.agentContext, proofRecord);
          this.emitStateChangedEvent(messageContext.agentContext, proofRecord, null);
        }
        return proofRecord;
      }
      async createPresentation(agentContext, options) {
        options.proofRecord.assertState(ProofState_1.ProofState.RequestReceived);
        const proofRequest = await this.didCommMessageRepository.getAgentMessage(agentContext, {
          associatedRecordId: options.proofRecord.id,
          messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage
        });
        const formats = [];
        for (const key of Object.keys(options.proofFormats)) {
          const service = this.formatServiceMap[key];
          formats.push(await service.createPresentation(agentContext, {
            attachment: proofRequest.getAttachmentByFormatIdentifier(ProofFormatConstants_1.V2_INDY_PRESENTATION_REQUEST),
            proofFormats: options.proofFormats
          }));
        }
        const presentationMessage = new V2PresentationMessage_1.V2PresentationMessage({
          comment: options.comment,
          attachmentInfo: formats,
          goalCode: options.goalCode,
          lastPresentation: options.lastPresentation
        });
        presentationMessage.setThread({ threadId: options.proofRecord.threadId });
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(agentContext, {
          agentMessage: presentationMessage,
          associatedRecordId: options.proofRecord.id,
          role: storage_1.DidCommMessageRole.Sender
        });
        await this.updateState(agentContext, options.proofRecord, ProofState_1.ProofState.PresentationSent);
        return { message: presentationMessage, proofRecord: options.proofRecord };
      }
      async processPresentation(messageContext) {
        const { message: presentationMessage, connection: connectionRecord } = messageContext;
        this.logger.debug(`Processing presentation with id ${presentationMessage.id}`);
        const proofRecord = await this.proofRepository.getSingleByQuery(messageContext.agentContext, {
          threadId: presentationMessage.threadId,
          connectionId: connectionRecord === null || connectionRecord === void 0 ? void 0 : connectionRecord.id
        });
        const proposalMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: V2ProposalPresentationMessage_1.V2ProposalPresentationMessage
        });
        const requestMessage = await this.didCommMessageRepository.getAgentMessage(messageContext.agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage
        });
        proofRecord.assertState(ProofState_1.ProofState.RequestSent);
        this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
          previousReceivedMessage: proposalMessage !== null && proposalMessage !== void 0 ? proposalMessage : void 0,
          previousSentMessage: requestMessage !== null && requestMessage !== void 0 ? requestMessage : void 0
        });
        const formatVerificationResults = [];
        for (const attachmentFormat of presentationMessage.getAttachmentFormats()) {
          const service = this.getFormatServiceForFormat(attachmentFormat.format);
          if (service) {
            try {
              formatVerificationResults.push(await service.processPresentation(messageContext.agentContext, {
                record: proofRecord,
                formatAttachments: {
                  request: requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.getAttachmentFormats(),
                  presentation: presentationMessage.getAttachmentFormats()
                }
              }));
            } catch (e) {
              if (e instanceof error_1.AriesFrameworkError) {
                throw new errors_1.V2PresentationProblemReportError(e.message, {
                  problemCode: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned
                });
              }
              throw e;
            }
          }
        }
        if (formatVerificationResults.length === 0) {
          throw new errors_1.V2PresentationProblemReportError("None of the received formats are supported.", {
            problemCode: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned
          });
        }
        const isValid = formatVerificationResults.every((x) => x === true);
        await this.didCommMessageRepository.saveOrUpdateAgentMessage(messageContext.agentContext, {
          agentMessage: presentationMessage,
          associatedRecordId: proofRecord.id,
          role: storage_1.DidCommMessageRole.Receiver
        });
        proofRecord.isVerified = isValid;
        await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.PresentationReceived);
        return proofRecord;
      }
      async createAck(agentContext, options) {
        const presentation = await this.didCommMessageRepository.getAgentMessage(agentContext, {
          associatedRecordId: options.proofRecord.id,
          messageClass: V2PresentationMessage_1.V2PresentationMessage
        });
        if (!presentation.lastPresentation) {
          throw new error_1.AriesFrameworkError(`Trying to send an ack message while presentation with id ${presentation.id} indicates this is not the last presentation (presentation.lastPresentation is set to false)`);
        }
        const message = new messages_1.V2PresentationAckMessage({
          threadId: options.proofRecord.threadId,
          status: common_1.AckStatus.OK
        });
        await this.updateState(agentContext, options.proofRecord, ProofState_1.ProofState.Done);
        return {
          message,
          proofRecord: options.proofRecord
        };
      }
      async processAck(messageContext) {
        const { message: ackMessage, connection: connectionRecord } = messageContext;
        const proofRecord = await this.proofRepository.getSingleByQuery(messageContext.agentContext, {
          threadId: ackMessage.threadId,
          connectionId: connectionRecord === null || connectionRecord === void 0 ? void 0 : connectionRecord.id
        });
        const requestMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage
        });
        const presentationMessage = await this.didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: V2PresentationMessage_1.V2PresentationMessage
        });
        proofRecord.assertState(ProofState_1.ProofState.PresentationSent);
        this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
          previousReceivedMessage: requestMessage !== null && requestMessage !== void 0 ? requestMessage : void 0,
          previousSentMessage: presentationMessage !== null && presentationMessage !== void 0 ? presentationMessage : void 0
        });
        await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.Done);
        return proofRecord;
      }
      async createProblemReport(agentContext, options) {
        const msg = new V2PresentationProblemReportMessage_1.V2PresentationProblemReportMessage({
          description: {
            code: PresentationProblemReportReason_1.PresentationProblemReportReason.Abandoned,
            en: options.description
          }
        });
        msg.setThread({
          threadId: options.proofRecord.threadId,
          parentThreadId: options.proofRecord.threadId
        });
        return {
          proofRecord: options.proofRecord,
          message: msg
        };
      }
      async processProblemReport(messageContext) {
        const { message: presentationProblemReportMessage } = messageContext;
        const connectionRecord = messageContext.assertReadyConnection();
        this.logger.debug(`Processing problem report with id ${presentationProblemReportMessage.id}`);
        const proofRecord = await this.proofRepository.getSingleByQuery(messageContext.agentContext, {
          threadId: presentationProblemReportMessage.threadId,
          connectionId: connectionRecord === null || connectionRecord === void 0 ? void 0 : connectionRecord.id
        });
        proofRecord.errorMessage = `${presentationProblemReportMessage.description.code}: ${presentationProblemReportMessage.description.en}`;
        await this.updateState(messageContext.agentContext, proofRecord, ProofState_1.ProofState.Abandoned);
        return proofRecord;
      }
      async createProofRequestFromProposal(agentContext, options) {
        const proofRecordId = options.proofRecord.id;
        const proposalMessage = await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: proofRecordId,
          messageClass: V2ProposalPresentationMessage_1.V2ProposalPresentationMessage
        });
        if (!proposalMessage) {
          throw new error_1.AriesFrameworkError(`Proof record with id ${proofRecordId} is missing required presentation proposal`);
        }
        const proposalAttachments = proposalMessage.getAttachmentFormats();
        let result2 = {};
        for (const attachmentFormat of proposalAttachments) {
          const service = this.getFormatServiceForFormat(attachmentFormat.format);
          if (!service) {
            throw new error_1.AriesFrameworkError("No format service found for getting requested.");
          }
          result2 = Object.assign(Object.assign({}, result2), await service.createProofRequestFromProposal({
            presentationAttachment: attachmentFormat.attachment
          }));
        }
        const retVal = {
          proofRecord: options.proofRecord,
          proofFormats: result2
        };
        return retVal;
      }
      async shouldAutoRespondToProposal(agentContext, proofRecord) {
        const proposal = await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: V2ProposalPresentationMessage_1.V2ProposalPresentationMessage
        });
        if (!proposal)
          return false;
        const request = await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage
        });
        if (!request)
          return false;
        MessageValidator_1.MessageValidator.validateSync(proposal);
        const proposalAttachments = proposal.getAttachmentFormats();
        const requestAttachments = request.getAttachmentFormats();
        const equalityResults = [];
        for (const attachmentFormat of proposalAttachments) {
          const service = this.getFormatServiceForFormat(attachmentFormat.format);
          equalityResults.push(service === null || service === void 0 ? void 0 : service.proposalAndRequestAreEqual(proposalAttachments, requestAttachments));
        }
        return true;
      }
      async shouldAutoRespondToRequest(agentContext, proofRecord) {
        const proposal = await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: V2ProposalPresentationMessage_1.V2ProposalPresentationMessage
        });
        if (!proposal) {
          return false;
        }
        const request = await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage
        });
        if (!request) {
          throw new error_1.AriesFrameworkError(`Expected to find a request message for ProofExchangeRecord with id ${proofRecord.id}`);
        }
        const proposalAttachments = proposal.getAttachmentFormats();
        const requestAttachments = request.getAttachmentFormats();
        const equalityResults = [];
        for (const attachmentFormat of proposalAttachments) {
          const service = this.getFormatServiceForFormat(attachmentFormat.format);
          equalityResults.push(service === null || service === void 0 ? void 0 : service.proposalAndRequestAreEqual(proposalAttachments, requestAttachments));
        }
        return equalityResults.every((x) => x === true);
      }
      async shouldAutoRespondToPresentation(agentContext, proofRecord) {
        const request = await this.didCommMessageRepository.getAgentMessage(agentContext, {
          associatedRecordId: proofRecord.id,
          messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage
        });
        return request.willConfirm;
      }
      async findRequestMessage(agentContext, proofRecordId) {
        return await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: proofRecordId,
          messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage
        });
      }
      async findPresentationMessage(agentContext, proofRecordId) {
        return await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: proofRecordId,
          messageClass: V2PresentationMessage_1.V2PresentationMessage
        });
      }
      async findProposalMessage(agentContext, proofRecordId) {
        return await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: proofRecordId,
          messageClass: V2ProposalPresentationMessage_1.V2ProposalPresentationMessage
        });
      }
      async getFormatData(agentContext, proofRecordId) {
        const [proposalMessage, requestMessage, presentationMessage] = await Promise.all([
          this.findProposalMessage(agentContext, proofRecordId),
          this.findRequestMessage(agentContext, proofRecordId),
          this.findPresentationMessage(agentContext, proofRecordId)
        ]);
        const messages = {
          proposal: [proposalMessage === null || proposalMessage === void 0 ? void 0 : proposalMessage.formats, proposalMessage === null || proposalMessage === void 0 ? void 0 : proposalMessage.proposalsAttach],
          request: [requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.formats, requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.requestPresentationsAttach],
          presentation: [presentationMessage === null || presentationMessage === void 0 ? void 0 : presentationMessage.formats, presentationMessage === null || presentationMessage === void 0 ? void 0 : presentationMessage.presentationsAttach]
        };
        const formatData = {};
        for (const [messageKey, [formats, attachments]] of Object.entries(messages)) {
          if (!formats || !attachments)
            continue;
          const formatServices = this.getFormatServicesFromMessage(formats);
          const messageFormatData = {};
          for (const formatService of formatServices) {
            const attachment = this.getAttachmentForService(formatService, formats, attachments);
            messageFormatData[formatService.formatKey] = attachment.getDataAsJson();
          }
          formatData[messageKey] = messageFormatData;
        }
        return formatData;
      }
      getFormatServicesFromMessage(messageFormats) {
        const formatServices = /* @__PURE__ */ new Set();
        for (const msg of messageFormats) {
          const service = this.getFormatServiceForFormat(msg);
          if (service)
            formatServices.add(service);
        }
        return Array.from(formatServices);
      }
      getAttachmentForService(proofFormatService, formats, attachments) {
        const attachmentId = this.getAttachmentIdForService(proofFormatService, formats);
        const attachment = attachments.find((attachment2) => attachment2.id === attachmentId);
        if (!attachment) {
          throw new error_1.AriesFrameworkError(`Attachment with id ${attachmentId} not found in attachments.`);
        }
        return attachment;
      }
      getAttachmentIdForService(proofFormatService, formats) {
        const format2 = formats.find((format3) => proofFormatService.supportsFormat(format3.format));
        if (!format2)
          throw new error_1.AriesFrameworkError(`No attachment found for service ${proofFormatService.formatKey}`);
        return format2.attachmentId;
      }
      async getRequestedCredentialsForProofRequest(agentContext, options) {
        const requestMessage = await this.didCommMessageRepository.findAgentMessage(agentContext, {
          associatedRecordId: options.proofRecord.id,
          messageClass: V2RequestPresentationMessage_1.V2RequestPresentationMessage
        });
        if (!requestMessage) {
          throw new error_1.AriesFrameworkError("No proof request found.");
        }
        const requestAttachments = requestMessage.getAttachmentFormats();
        let result2 = {
          proofFormats: {}
        };
        for (const attachmentFormat of requestAttachments) {
          const service = this.getFormatServiceForFormat(attachmentFormat.format);
          if (!service) {
            throw new error_1.AriesFrameworkError("No format service found for getting requested.");
          }
          result2 = Object.assign(Object.assign({}, result2), await service.getRequestedCredentialsForProofRequest(agentContext, {
            attachment: attachmentFormat.attachment,
            presentationProposal: void 0,
            config: options.config
          }));
        }
        return result2;
      }
      async autoSelectCredentialsForProofRequest(options) {
        let returnValue = {
          proofFormats: {}
        };
        for (const [id] of Object.entries(options.proofFormats)) {
          const service = this.formatServiceMap[id];
          const credentials = await service.autoSelectCredentialsForProofRequest(options);
          returnValue = Object.assign(Object.assign({}, returnValue), credentials);
        }
        return returnValue;
      }
      registerMessageHandlers(dispatcher, agentConfig, proofResponseCoordinator, mediationRecipientService, routingService) {
        dispatcher.registerMessageHandler(new V2ProposePresentationHandler_1.V2ProposePresentationHandler(this, agentConfig, this.didCommMessageRepository, proofResponseCoordinator));
        dispatcher.registerMessageHandler(new V2RequestPresentationHandler_1.V2RequestPresentationHandler(this, agentConfig, proofResponseCoordinator, mediationRecipientService, this.didCommMessageRepository, routingService));
        dispatcher.registerMessageHandler(new V2PresentationHandler_1.V2PresentationHandler(this, agentConfig, proofResponseCoordinator, this.didCommMessageRepository));
        dispatcher.registerMessageHandler(new V2PresentationAckHandler_1.V2PresentationAckHandler(this));
        dispatcher.registerMessageHandler(new V2PresentationProblemReportHandler_1.V2PresentationProblemReportHandler(this));
      }
      getFormatServiceForFormat(format2) {
        for (const service of Object.values(this.formatServiceMap)) {
          if (service.supportsFormat(format2.format)) {
            return service;
          }
        }
        return null;
      }
    };
    V2ProofService = __decorate([
      (0, tsyringe_1.scoped)(tsyringe_1.Lifecycle.ContainerScoped),
      __param(6, (0, tsyringe_1.inject)(constants_1.InjectionSymbols.Wallet)),
      __metadata("design:paramtypes", [
        AgentConfig_1.AgentConfig,
        connections_1.ConnectionService,
        repository_1.ProofRepository,
        storage_1.DidCommMessageRepository,
        EventEmitter_1.EventEmitter,
        IndyProofFormatService_1.IndyProofFormatService,
        Object
      ])
    ], V2ProofService);
    exports.V2ProofService = V2ProofService;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/index.js
var require_v24 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/v2/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_errors7(), exports);
    __exportStar(require_messages15(), exports);
    __exportStar(require_V2ProofService(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/protocol/index.js
var require_protocol4 = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/protocol/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_v14(), exports);
    __exportStar(require_v24(), exports);
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/ProofResponseCoordinator.js
var require_ProofResponseCoordinator = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/ProofResponseCoordinator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var ProofResponseCoordinator_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofResponseCoordinator = void 0;
    var plugins_1 = require_plugins();
    var ProofService_1 = require_ProofService();
    var ProofAutoAcceptType_1 = require_ProofAutoAcceptType();
    var ProofResponseCoordinator = ProofResponseCoordinator_1 = class ProofResponseCoordinator {
      constructor(proofService) {
        this.proofService = proofService;
      }
      /**
       * Returns the proof auto accept config based on priority:
       *	- The record config takes first priority
       *	- Otherwise the agent config
       *	- Otherwise {@link AutoAcceptProof.Never} is returned
       */
      static composeAutoAccept(recordConfig, agentConfig) {
        var _a;
        return (_a = recordConfig !== null && recordConfig !== void 0 ? recordConfig : agentConfig) !== null && _a !== void 0 ? _a : ProofAutoAcceptType_1.AutoAcceptProof.Never;
      }
      /**
       * Checks whether it should automatically respond to a proposal
       */
      async shouldAutoRespondToProposal(agentContext, proofRecord) {
        const autoAccept = ProofResponseCoordinator_1.composeAutoAccept(proofRecord.autoAcceptProof, agentContext.config.autoAcceptProofs);
        if (autoAccept === ProofAutoAcceptType_1.AutoAcceptProof.Always) {
          return true;
        }
        if (autoAccept === ProofAutoAcceptType_1.AutoAcceptProof.ContentApproved) {
          return this.proofService.shouldAutoRespondToProposal(agentContext, proofRecord);
        }
        return false;
      }
      /**
       * Checks whether it should automatically respond to a request
       */
      async shouldAutoRespondToRequest(agentContext, proofRecord) {
        const autoAccept = ProofResponseCoordinator_1.composeAutoAccept(proofRecord.autoAcceptProof, agentContext.config.autoAcceptProofs);
        if (autoAccept === ProofAutoAcceptType_1.AutoAcceptProof.Always) {
          return true;
        }
        if (autoAccept === ProofAutoAcceptType_1.AutoAcceptProof.ContentApproved) {
          return this.proofService.shouldAutoRespondToRequest(agentContext, proofRecord);
        }
        return false;
      }
      /**
       * Checks whether it should automatically respond to a presentation of proof
       */
      async shouldAutoRespondToPresentation(agentContext, proofRecord) {
        const autoAccept = ProofResponseCoordinator_1.composeAutoAccept(proofRecord.autoAcceptProof, agentContext.config.autoAcceptProofs);
        if (autoAccept === ProofAutoAcceptType_1.AutoAcceptProof.Always) {
          return true;
        }
        if (autoAccept === ProofAutoAcceptType_1.AutoAcceptProof.ContentApproved) {
          return this.proofService.shouldAutoRespondToPresentation(agentContext, proofRecord);
        }
        return false;
      }
    };
    ProofResponseCoordinator = ProofResponseCoordinator_1 = __decorate([
      (0, plugins_1.injectable)(),
      __metadata("design:paramtypes", [ProofService_1.ProofService])
    ], ProofResponseCoordinator);
    exports.ProofResponseCoordinator = ProofResponseCoordinator;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/ProofsApi.js
var require_ProofsApi = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/ProofsApi.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofsApi = void 0;
    var tsyringe_1 = (init_esm53(), __toCommonJS(esm5_exports3));
    var AgentConfig_1 = require_AgentConfig();
    var Dispatcher_1 = require_Dispatcher();
    var MessageSender_1 = require_MessageSender();
    var AgentContext_1 = require_AgentContext();
    var models_1 = require_models3();
    var constants_1 = require_constants();
    var ServiceDecorator_1 = require_ServiceDecorator();
    var error_1 = require_error();
    var DidCommMessageRole_1 = require_DidCommMessageRole();
    var ConnectionService_1 = require_ConnectionService();
    var MediationRecipientService_1 = require_MediationRecipientService();
    var RoutingService_1 = require_RoutingService();
    var ProofResponseCoordinator_1 = require_ProofResponseCoordinator();
    var ProofState_1 = require_ProofState();
    var V1ProofService_1 = require_V1ProofService();
    var V2ProofService_1 = require_V2ProofService();
    var ProofRepository_1 = require_ProofRepository();
    var ProofsApi = class ProofsApi {
      constructor(dispatcher, mediationRecipientService, messageSender, connectionService, agentContext, agentConfig, routingService, logger, proofRepository, v1Service, v2Service) {
        this.messageSender = messageSender;
        this.connectionService = connectionService;
        this.proofRepository = proofRepository;
        this.agentContext = agentContext;
        this.agentConfig = agentConfig;
        this.routingService = routingService;
        this.logger = logger;
        this.serviceMap = [v1Service, v2Service].reduce((serviceMap, service) => Object.assign(Object.assign({}, serviceMap), { [service.version]: service }), {});
        this.logger.debug(`Initializing Proofs Module for agent ${this.agentContext.config.label}`);
        this.registerMessageHandlers(dispatcher, mediationRecipientService);
      }
      getService(protocolVersion) {
        if (!this.serviceMap[protocolVersion]) {
          throw new error_1.AriesFrameworkError(`No proof service registered for protocol version ${protocolVersion}`);
        }
        return this.serviceMap[protocolVersion];
      }
      /**
       * Initiate a new presentation exchange as prover by sending a presentation proposal message
       * to the connection with the specified connection id.
       *
       * @param options multiple properties like protocol version, connection id, proof format (indy/ presentation exchange)
       * to include in the message
       * @returns Proof record associated with the sent proposal message
       */
      async proposeProof(options) {
        const service = this.getService(options.protocolVersion);
        const { connectionId } = options;
        const connection = await this.connectionService.getById(this.agentContext, connectionId);
        connection.assertReady();
        const proposalOptions = {
          connectionRecord: connection,
          proofFormats: options.proofFormats,
          autoAcceptProof: options.autoAcceptProof,
          goalCode: options.goalCode,
          comment: options.comment,
          parentThreadId: options.parentThreadId
        };
        const { message, proofRecord } = await service.createProposal(this.agentContext, proposalOptions);
        const outboundMessageContext = new models_1.OutboundMessageContext(message, {
          agentContext: this.agentContext,
          connection,
          associatedRecord: proofRecord
        });
        await this.messageSender.sendMessage(outboundMessageContext);
        return proofRecord;
      }
      /**
       * Accept a presentation proposal as verifier (by sending a presentation request message) to the connection
       * associated with the proof record.
       *
       * @param options multiple properties like proof record id, additional configuration for creating the request
       * @returns Proof record associated with the presentation request
       */
      async acceptProposal(options) {
        var _a;
        const { proofRecordId } = options;
        const proofRecord = await this.getById(proofRecordId);
        const service = this.getService(proofRecord.protocolVersion);
        if (!proofRecord.connectionId) {
          throw new error_1.AriesFrameworkError(`No connectionId found for proof record '${proofRecord.id}'. Connection-less issuance does not support presentation proposal or negotiation.`);
        }
        const connection = await this.connectionService.getById(this.agentContext, proofRecord.connectionId);
        connection.assertReady();
        const proofRequestFromProposalOptions = {
          proofRecord
        };
        const proofRequest = await service.createProofRequestFromProposal(this.agentContext, proofRequestFromProposalOptions);
        const requestOptions = {
          proofRecord,
          proofFormats: proofRequest.proofFormats,
          goalCode: options.goalCode,
          willConfirm: (_a = options.willConfirm) !== null && _a !== void 0 ? _a : true,
          comment: options.comment
        };
        const { message } = await service.createRequestAsResponse(this.agentContext, requestOptions);
        const outboundMessageContext = new models_1.OutboundMessageContext(message, {
          agentContext: this.agentContext,
          connection,
          associatedRecord: proofRecord
        });
        await this.messageSender.sendMessage(outboundMessageContext);
        return proofRecord;
      }
      /**
       * Answer with a new presentation request in response to received presentation proposal message
       * to the connection associated with the proof record.
       *
       * @param options multiple properties like proof record id, proof formats to accept requested credentials object
       * specifying which credentials to use for the proof
       * @returns Proof record associated with the sent request message
       */
      async negotiateProposal(options) {
        const { proofRecordId } = options;
        const proofRecord = await this.getById(proofRecordId);
        const service = this.getService(proofRecord.protocolVersion);
        if (!proofRecord.connectionId) {
          throw new error_1.AriesFrameworkError(`No connectionId found for proof record '${proofRecord.id}'. Connection-less issuance does not support negotiation.`);
        }
        const connection = await this.connectionService.getById(this.agentContext, proofRecord.connectionId);
        connection.assertReady();
        const requestOptions = {
          proofRecord,
          proofFormats: options.proofFormats,
          autoAcceptProof: options.autoAcceptProof,
          comment: options.comment
        };
        const { message } = await service.createRequestAsResponse(this.agentContext, requestOptions);
        const outboundMessageContext = new models_1.OutboundMessageContext(message, {
          agentContext: this.agentContext,
          connection,
          associatedRecord: proofRecord
        });
        await this.messageSender.sendMessage(outboundMessageContext);
        return proofRecord;
      }
      /**
       * Initiate a new presentation exchange as verifier by sending a presentation request message
       * to the connection with the specified connection id
       *
       * @param options multiple properties like connection id, protocol version, proof Formats to build the proof request
       * @returns Proof record associated with the sent request message
       */
      async requestProof(options) {
        const service = this.getService(options.protocolVersion);
        const connection = await this.connectionService.getById(this.agentContext, options.connectionId);
        connection.assertReady();
        const createProofRequest = {
          connectionRecord: connection,
          proofFormats: options.proofFormats,
          autoAcceptProof: options.autoAcceptProof,
          parentThreadId: options.parentThreadId,
          comment: options.comment
        };
        const { message, proofRecord } = await service.createRequest(this.agentContext, createProofRequest);
        const outboundMessageContext = new models_1.OutboundMessageContext(message, {
          agentContext: this.agentContext,
          connection,
          associatedRecord: proofRecord
        });
        await this.messageSender.sendMessage(outboundMessageContext);
        return proofRecord;
      }
      /**
       * Accept a presentation request as prover (by sending a presentation message) to the connection
       * associated with the proof record.
       *
       * @param options multiple properties like proof record id, proof formats to accept requested credentials object
       * specifying which credentials to use for the proof
       * @returns Proof record associated with the sent presentation message
       */
      async acceptRequest(options) {
        const { proofRecordId, proofFormats, comment } = options;
        const record = await this.getById(proofRecordId);
        const service = this.getService(record.protocolVersion);
        const presentationOptions = {
          proofFormats,
          proofRecord: record,
          comment
        };
        const { message, proofRecord } = await service.createPresentation(this.agentContext, presentationOptions);
        const requestMessage = await service.findRequestMessage(this.agentContext, proofRecord.id);
        if (proofRecord.connectionId) {
          const connection = await this.connectionService.getById(this.agentContext, proofRecord.connectionId);
          connection.assertReady();
          const outboundMessageContext = new models_1.OutboundMessageContext(message, {
            agentContext: this.agentContext,
            connection,
            associatedRecord: proofRecord
          });
          await this.messageSender.sendMessage(outboundMessageContext);
          return proofRecord;
        } else if (requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.service) {
          const routing = await this.routingService.getRouting(this.agentContext);
          message.service = new ServiceDecorator_1.ServiceDecorator({
            serviceEndpoint: routing.endpoints[0],
            recipientKeys: [routing.recipientKey.publicKeyBase58],
            routingKeys: routing.routingKeys.map((key) => key.publicKeyBase58)
          });
          const recipientService = requestMessage.service;
          await service.saveOrUpdatePresentationMessage(this.agentContext, {
            proofRecord,
            message,
            role: DidCommMessageRole_1.DidCommMessageRole.Sender
          });
          await this.messageSender.sendMessageToService(new models_1.OutboundMessageContext(message, {
            agentContext: this.agentContext,
            serviceParams: {
              service: recipientService.resolvedDidCommService,
              senderKey: message.service.resolvedDidCommService.recipientKeys[0],
              returnRoute: true
            }
          }));
          return proofRecord;
        } else {
          throw new error_1.AriesFrameworkError(`Cannot accept presentation request without connectionId or ~service decorator on presentation request.`);
        }
      }
      /**
       * Initiate a new presentation exchange as verifier by sending an out of band presentation
       * request message
       *
       * @param options multiple properties like protocol version, proof Formats to build the proof request
       * @returns the message itself and the proof record associated with the sent request message
       */
      async createRequest(options) {
        const service = this.getService(options.protocolVersion);
        const createProofRequest = {
          proofFormats: options.proofFormats,
          autoAcceptProof: options.autoAcceptProof,
          comment: options.comment,
          parentThreadId: options.parentThreadId
        };
        return await service.createRequest(this.agentContext, createProofRequest);
      }
      async declineRequest(proofRecordId) {
        const proofRecord = await this.getById(proofRecordId);
        const service = this.getService(proofRecord.protocolVersion);
        proofRecord.assertState(ProofState_1.ProofState.RequestReceived);
        await service.updateState(this.agentContext, proofRecord, ProofState_1.ProofState.Declined);
        return proofRecord;
      }
      /**
       * Answer with a new presentation proposal in response to received presentation request message
       * to the connection associated with the proof record.
       *
       * @param options multiple properties like proof record id, proof format (indy/ presentation exchange)
       * to include in the message
       * @returns Proof record associated with the sent proposal message
       */
      async negotiateRequest(options) {
        const { proofRecordId } = options;
        const proofRecord = await this.getById(proofRecordId);
        const service = this.getService(proofRecord.protocolVersion);
        if (!proofRecord.connectionId) {
          throw new error_1.AriesFrameworkError(`No connectionId found for proof record '${proofRecord.id}'. Connection-less issuance does not support presentation proposal or negotiation.`);
        }
        const connection = await this.connectionService.getById(this.agentContext, proofRecord.connectionId);
        connection.assertReady();
        const proposalOptions = {
          proofRecord,
          proofFormats: options.proofFormats,
          autoAcceptProof: options.autoAcceptProof,
          goalCode: options.goalCode,
          comment: options.comment
        };
        const { message } = await service.createProposalAsResponse(this.agentContext, proposalOptions);
        const outboundMessageContext = new models_1.OutboundMessageContext(message, {
          agentContext: this.agentContext,
          connection,
          associatedRecord: proofRecord
        });
        await this.messageSender.sendMessage(outboundMessageContext);
        return proofRecord;
      }
      /**
       * Accept a presentation as prover (by sending a presentation acknowledgement message) to the connection
       * associated with the proof record.
       *
       * @param proofRecordId The id of the proof exchange record for which to accept the presentation
       * @returns Proof record associated with the sent presentation acknowledgement message
       *
       */
      async acceptPresentation(proofRecordId) {
        const record = await this.getById(proofRecordId);
        const service = this.getService(record.protocolVersion);
        const { message, proofRecord } = await service.createAck(this.agentContext, {
          proofRecord: record
        });
        const requestMessage = await service.findRequestMessage(this.agentContext, record.id);
        const presentationMessage = await service.findPresentationMessage(this.agentContext, record.id);
        if (proofRecord.connectionId) {
          const connection = await this.connectionService.getById(this.agentContext, proofRecord.connectionId);
          connection.assertReady();
          const outboundMessageContext = new models_1.OutboundMessageContext(message, {
            agentContext: this.agentContext,
            connection,
            associatedRecord: proofRecord
          });
          await this.messageSender.sendMessage(outboundMessageContext);
        } else if ((requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.service) && (presentationMessage === null || presentationMessage === void 0 ? void 0 : presentationMessage.service)) {
          const recipientService = presentationMessage === null || presentationMessage === void 0 ? void 0 : presentationMessage.service;
          const ourService = requestMessage.service;
          await this.messageSender.sendMessageToService(new models_1.OutboundMessageContext(message, {
            agentContext: this.agentContext,
            serviceParams: {
              service: recipientService.resolvedDidCommService,
              senderKey: ourService.resolvedDidCommService.recipientKeys[0],
              returnRoute: true
            }
          }));
        } else {
          throw new error_1.AriesFrameworkError(`Cannot accept presentation without connectionId or ~service decorator on presentation message.`);
        }
        return record;
      }
      /**
       * Create a {@link RetrievedCredentials} object. Given input proof request and presentation proposal,
       * use credentials in the wallet to build indy requested credentials object for input to proof creation.
       * If restrictions allow, self attested attributes will be used.
       *
       * @param options multiple properties like proof record id and optional configuration
       * @returns RequestedCredentials
       */
      async autoSelectCredentialsForProofRequest(options) {
        const proofRecord = await this.getById(options.proofRecordId);
        const service = this.getService(proofRecord.protocolVersion);
        const retrievedCredentials = await service.getRequestedCredentialsForProofRequest(this.agentContext, {
          proofRecord,
          config: options.config
        });
        return await service.autoSelectCredentialsForProofRequest(retrievedCredentials);
      }
      /**
       * Create a {@link RetrievedCredentials} object. Given input proof request and presentation proposal,
       * use credentials in the wallet to build indy requested credentials object for input to proof creation.
       *
       * If restrictions allow, self attested attributes will be used.
       *
       * @param options multiple properties like proof record id and optional configuration
       * @returns RetrievedCredentials object
       */
      async getRequestedCredentialsForProofRequest(options) {
        const record = await this.getById(options.proofRecordId);
        const service = this.getService(record.protocolVersion);
        return await service.getRequestedCredentialsForProofRequest(this.agentContext, {
          proofRecord: record,
          config: options.config
        });
      }
      /**
       * Send problem report message for a proof record
       *
       * @param proofRecordId  The id of the proof record for which to send problem report
       * @param message message to send
       * @returns proof record associated with the proof problem report message
       */
      async sendProblemReport(proofRecordId, message) {
        const record = await this.getById(proofRecordId);
        const service = this.getService(record.protocolVersion);
        if (!record.connectionId) {
          throw new error_1.AriesFrameworkError(`No connectionId found for proof record '${record.id}'.`);
        }
        const connection = await this.connectionService.getById(this.agentContext, record.connectionId);
        connection.assertReady();
        const { message: problemReport } = await service.createProblemReport(this.agentContext, {
          proofRecord: record,
          description: message
        });
        const outboundMessageContext = new models_1.OutboundMessageContext(problemReport, {
          agentContext: this.agentContext,
          connection,
          associatedRecord: record
        });
        await this.messageSender.sendMessage(outboundMessageContext);
        return record;
      }
      async getFormatData(proofRecordId) {
        const proofRecord = await this.getById(proofRecordId);
        const service = this.getService(proofRecord.protocolVersion);
        return service.getFormatData(this.agentContext, proofRecordId);
      }
      /**
       * Retrieve all proof records
       *
       * @returns List containing all proof records
       */
      async getAll() {
        return this.proofRepository.getAll(this.agentContext);
      }
      /**
       * Retrieve all proof records by specified query params
       *
       * @returns List containing all proof records matching specified params
       */
      findAllByQuery(query) {
        return this.proofRepository.findByQuery(this.agentContext, query);
      }
      /**
       * Retrieve a proof record by id
       *
       * @param proofRecordId The proof record id
       * @throws {RecordNotFoundError} If no record is found
       * @return The proof record
       *
       */
      async getById(proofRecordId) {
        return await this.proofRepository.getById(this.agentContext, proofRecordId);
      }
      /**
       * Retrieve a proof record by id
       *
       * @param proofRecordId The proof record id
       * @return The proof record or null if not found
       *
       */
      async findById(proofRecordId) {
        return await this.proofRepository.findById(this.agentContext, proofRecordId);
      }
      /**
       * Delete a proof record by id
       *
       * @param proofId the proof record id
       */
      async deleteById(proofId, options) {
        const proofRecord = await this.getById(proofId);
        const service = this.getService(proofRecord.protocolVersion);
        return service.delete(this.agentContext, proofRecord, options);
      }
      /**
       * Retrieve a proof record by connection id and thread id
       *
       * @param connectionId The connection id
       * @param threadId The thread id
       * @throws {RecordNotFoundError} If no record is found
       * @throws {RecordDuplicateError} If multiple records are found
       * @returns The proof record
       */
      async getByThreadAndConnectionId(threadId, connectionId) {
        return this.proofRepository.getByThreadAndConnectionId(this.agentContext, threadId, connectionId);
      }
      /**
       * Retrieve proof records by connection id and parent thread id
       *
       * @param connectionId The connection id
       * @param parentThreadId The parent thread id
       * @returns List containing all proof records matching the given query
       */
      async getByParentThreadAndConnectionId(parentThreadId, connectionId) {
        return this.proofRepository.getByParentThreadAndConnectionId(this.agentContext, parentThreadId, connectionId);
      }
      /**
       * Update a proof record by
       *
       * @param proofRecord the proof record
       */
      async update(proofRecord) {
        await this.proofRepository.update(this.agentContext, proofRecord);
      }
      async findProposalMessage(proofRecordId) {
        const record = await this.getById(proofRecordId);
        const service = this.getService(record.protocolVersion);
        return service.findProposalMessage(this.agentContext, proofRecordId);
      }
      async findRequestMessage(proofRecordId) {
        const record = await this.getById(proofRecordId);
        const service = this.getService(record.protocolVersion);
        return service.findRequestMessage(this.agentContext, proofRecordId);
      }
      async findPresentationMessage(proofRecordId) {
        const record = await this.getById(proofRecordId);
        const service = this.getService(record.protocolVersion);
        return service.findPresentationMessage(this.agentContext, proofRecordId);
      }
      registerMessageHandlers(dispatcher, mediationRecipientService) {
        for (const service of Object.values(this.serviceMap)) {
          const proofService = service;
          proofService.registerMessageHandlers(dispatcher, this.agentConfig, new ProofResponseCoordinator_1.ProofResponseCoordinator(proofService), mediationRecipientService, this.routingService);
        }
      }
    };
    ProofsApi = __decorate([
      (0, tsyringe_1.injectable)(),
      __param(7, (0, tsyringe_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [
        Dispatcher_1.Dispatcher,
        MediationRecipientService_1.MediationRecipientService,
        MessageSender_1.MessageSender,
        ConnectionService_1.ConnectionService,
        AgentContext_1.AgentContext,
        AgentConfig_1.AgentConfig,
        RoutingService_1.RoutingService,
        Object,
        ProofRepository_1.ProofRepository,
        V1ProofService_1.V1ProofService,
        V2ProofService_1.V2ProofService
      ])
    ], ProofsApi);
    exports.ProofsApi = ProofsApi;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/ProofsApiOptions.js
var require_ProofsApiOptions = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/ProofsApiOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/ProofsModuleConfig.js
var require_ProofsModuleConfig = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/ProofsModuleConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofsModuleConfig = void 0;
    var ProofAutoAcceptType_1 = require_ProofAutoAcceptType();
    var ProofsModuleConfig = class {
      constructor(options) {
        this.options = options !== null && options !== void 0 ? options : {};
      }
      /** See {@link ProofsModuleConfigOptions.autoAcceptProofs} */
      get autoAcceptProofs() {
        var _a;
        return (_a = this.options.autoAcceptProofs) !== null && _a !== void 0 ? _a : ProofAutoAcceptType_1.AutoAcceptProof.Never;
      }
    };
    exports.ProofsModuleConfig = ProofsModuleConfig;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/ProofsModule.js
var require_ProofsModule = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/ProofsModule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofsModule = void 0;
    var models_1 = require_models3();
    var ProofsApi_1 = require_ProofsApi();
    var ProofsModuleConfig_1 = require_ProofsModuleConfig();
    var IndyProofFormatService_1 = require_IndyProofFormatService();
    var v1_1 = require_v14();
    var v2_1 = require_v24();
    var repository_1 = require_repository8();
    var ProofsModule = class {
      constructor(config) {
        this.api = ProofsApi_1.ProofsApi;
        this.config = new ProofsModuleConfig_1.ProofsModuleConfig(config);
      }
      /**
       * Registers the dependencies of the proofs module on the dependency manager.
       */
      register(dependencyManager, featureRegistry) {
        dependencyManager.registerContextScoped(ProofsApi_1.ProofsApi);
        dependencyManager.registerInstance(ProofsModuleConfig_1.ProofsModuleConfig, this.config);
        dependencyManager.registerSingleton(v1_1.V1ProofService);
        dependencyManager.registerSingleton(v2_1.V2ProofService);
        dependencyManager.registerSingleton(repository_1.ProofRepository);
        dependencyManager.registerSingleton(IndyProofFormatService_1.IndyProofFormatService);
        featureRegistry.register(new models_1.Protocol({
          id: "https://didcomm.org/present-proof/1.0",
          roles: ["verifier", "prover"]
        }));
      }
    };
    exports.ProofsModule = ProofsModule;
  }
});

// node_modules/@aries-framework/core/build/modules/proofs/index.js
var require_proofs = __commonJS({
  "node_modules/@aries-framework/core/build/modules/proofs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_errors4(), exports);
    __exportStar(require_formats2(), exports);
    __exportStar(require_messages13(), exports);
    __exportStar(require_models5(), exports);
    __exportStar(require_protocol4(), exports);
    __exportStar(require_repository8(), exports);
    __exportStar(require_ProofEvents(), exports);
    __exportStar(require_ProofResponseCoordinator(), exports);
    __exportStar(require_ProofsApi(), exports);
    __exportStar(require_ProofsApiOptions(), exports);
    __exportStar(require_ProofService(), exports);
    __exportStar(require_ProofsModule(), exports);
    __exportStar(require_ProofsModuleConfig(), exports);
  }
});

// node_modules/@aries-framework/core/build/wallet/Wallet.js
var require_Wallet = __commonJS({
  "node_modules/@aries-framework/core/build/wallet/Wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aries-framework/core/build/wallet/WalletApi.js
var require_WalletApi = __commonJS({
  "node_modules/@aries-framework/core/build/wallet/WalletApi.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletApi = void 0;
    var agent_1 = require_agent();
    var constants_1 = require_constants();
    var plugins_1 = require_plugins();
    var storage_1 = require_storage();
    var updates_1 = require_updates();
    var WalletError_1 = require_WalletError();
    var WalletNotFoundError_1 = require_WalletNotFoundError();
    var WalletApi = class WalletApi {
      constructor(storageUpdateService, agentContext, logger) {
        this.storageUpdateService = storageUpdateService;
        this.logger = logger;
        this.wallet = agentContext.wallet;
        this.agentContext = agentContext;
      }
      get isInitialized() {
        return this.wallet.isInitialized;
      }
      get isProvisioned() {
        return this.wallet.isProvisioned;
      }
      get walletConfig() {
        return this._walletConfig;
      }
      async initialize(walletConfig) {
        var _a;
        this.logger.info(`Initializing wallet '${walletConfig.id}'`, Object.assign(Object.assign({}, walletConfig), { key: (walletConfig === null || walletConfig === void 0 ? void 0 : walletConfig.key) ? "[*****]" : void 0, storage: Object.assign(Object.assign({}, walletConfig === null || walletConfig === void 0 ? void 0 : walletConfig.storage), { credentials: ((_a = walletConfig === null || walletConfig === void 0 ? void 0 : walletConfig.storage) === null || _a === void 0 ? void 0 : _a.credentials) ? "[*****]" : void 0 }) }));
        if (this.isInitialized) {
          throw new WalletError_1.WalletError("Wallet instance already initialized. Close the currently opened wallet before re-initializing the wallet");
        }
        try {
          await this.open(walletConfig);
        } catch (error) {
          if (error instanceof WalletNotFoundError_1.WalletNotFoundError) {
            await this.createAndOpen(walletConfig);
          } else {
            throw error;
          }
        }
      }
      async createAndOpen(walletConfig) {
        await this.wallet.createAndOpen(walletConfig);
        this._walletConfig = walletConfig;
        await this.storageUpdateService.setCurrentStorageVersion(this.agentContext, updates_1.CURRENT_FRAMEWORK_STORAGE_VERSION);
      }
      async create(walletConfig) {
        await this.createAndOpen(walletConfig);
        await this.close();
      }
      async open(walletConfig) {
        await this.wallet.open(walletConfig);
        this._walletConfig = walletConfig;
      }
      async close() {
        await this.wallet.close();
      }
      async rotateKey(walletConfig) {
        await this.wallet.rotateKey(walletConfig);
      }
      async generateNonce() {
        return await this.wallet.generateNonce();
      }
      async delete() {
        await this.wallet.delete();
      }
      async export(exportConfig) {
        await this.wallet.export(exportConfig);
      }
      async import(walletConfig, importConfig) {
        await this.wallet.import(walletConfig, importConfig);
      }
    };
    WalletApi = __decorate([
      (0, plugins_1.injectable)(),
      __param(2, (0, plugins_1.inject)(constants_1.InjectionSymbols.Logger)),
      __metadata("design:paramtypes", [
        storage_1.StorageUpdateService,
        agent_1.AgentContext,
        Object
      ])
    ], WalletApi);
    exports.WalletApi = WalletApi;
  }
});

// node_modules/@aries-framework/core/build/wallet/WalletModule.js
var require_WalletModule = __commonJS({
  "node_modules/@aries-framework/core/build/wallet/WalletModule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletModule = void 0;
    var WalletApi_1 = require_WalletApi();
    var WalletModule = class {
      constructor() {
        this.api = WalletApi_1.WalletApi;
      }
      /**
       * Registers the dependencies of the wallet module on the injection dependencyManager.
       */
      register(dependencyManager) {
        dependencyManager.registerContextScoped(WalletApi_1.WalletApi);
      }
    };
    exports.WalletModule = WalletModule;
  }
});

// node_modules/@aries-framework/core/build/wallet/index.js
var require_wallet = __commonJS({
  "node_modules/@aries-framework/core/build/wallet/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_Wallet(), exports);
    __exportStar(require_IndyWallet(), exports);
    __exportStar(require_WalletApi(), exports);
    __exportStar(require_WalletModule(), exports);
  }
});

// node_modules/@aries-framework/core/build/agent/AgentModules.js
var require_AgentModules = __commonJS({
  "node_modules/@aries-framework/core/build/agent/AgentModules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAgentApi = exports.extendModulesWithDefaultModules = void 0;
    var basic_messages_1 = require_basic_messages();
    var connections_1 = require_connections();
    var credentials_1 = require_credentials();
    var dids_1 = require_dids();
    var discover_features_1 = require_discover_features();
    var generic_records_1 = require_generic_records();
    var indy_1 = require_indy2();
    var ledger_1 = require_ledger();
    var oob_1 = require_oob();
    var proofs_1 = require_proofs();
    var routing_1 = require_routing();
    var vc_1 = require_vc3();
    var wallet_1 = require_wallet();
    function getDefaultAgentModules(agentConfig) {
      return {
        connections: () => new connections_1.ConnectionsModule({
          autoAcceptConnections: agentConfig.autoAcceptConnections
        }),
        credentials: () => new credentials_1.CredentialsModule({
          autoAcceptCredentials: agentConfig.autoAcceptCredentials
        }),
        proofs: () => new proofs_1.ProofsModule({
          autoAcceptProofs: agentConfig.autoAcceptProofs
        }),
        mediator: () => new routing_1.MediatorModule({
          autoAcceptMediationRequests: agentConfig.autoAcceptMediationRequests
        }),
        mediationRecipient: () => new routing_1.RecipientModule({
          maximumMessagePickup: agentConfig.maximumMessagePickup,
          mediatorInvitationUrl: agentConfig.mediatorConnectionsInvite,
          mediatorPickupStrategy: agentConfig.mediatorPickupStrategy,
          baseMediatorReconnectionIntervalMs: agentConfig.baseMediatorReconnectionIntervalMs,
          maximumMediatorReconnectionIntervalMs: agentConfig.maximumMediatorReconnectionIntervalMs,
          mediatorPollingInterval: agentConfig.mediatorPollingInterval
        }),
        basicMessages: () => new basic_messages_1.BasicMessagesModule(),
        genericRecords: () => new generic_records_1.GenericRecordsModule(),
        ledger: () => new ledger_1.LedgerModule({
          connectToIndyLedgersOnStartup: agentConfig.connectToIndyLedgersOnStartup,
          indyLedgers: agentConfig.indyLedgers
        }),
        discovery: () => new discover_features_1.DiscoverFeaturesModule(),
        dids: () => new dids_1.DidsModule(),
        wallet: () => new wallet_1.WalletModule(),
        oob: () => new oob_1.OutOfBandModule(),
        indy: () => new indy_1.IndyModule(),
        w3cVc: () => new vc_1.W3cVcModule()
      };
    }
    function extendModulesWithDefaultModules(agentConfig, modules) {
      const extendedModules = Object.assign({}, modules);
      const defaultAgentModules = getDefaultAgentModules(agentConfig);
      for (const [moduleKey, getConfiguredModule] of Object.entries(defaultAgentModules)) {
        if (modules && modules[moduleKey])
          continue;
        extendedModules[moduleKey] = getConfiguredModule();
      }
      return extendedModules;
    }
    exports.extendModulesWithDefaultModules = extendModulesWithDefaultModules;
    function getAgentApi(dependencyManager, excludedApis = []) {
      const api = Object.entries(dependencyManager.registeredModules).reduce((api2, [moduleKey, module2]) => {
        if (!module2.api)
          return api2;
        const apiInstance = dependencyManager.resolve(module2.api);
        if (excludedApis.includes(apiInstance))
          return api2;
        return Object.assign(Object.assign({}, api2), { [moduleKey]: apiInstance });
      }, {});
      return api;
    }
    exports.getAgentApi = getAgentApi;
  }
});

// node_modules/@aries-framework/core/build/agent/BaseAgent.js
var require_BaseAgent = __commonJS({
  "node_modules/@aries-framework/core/build/agent/BaseAgent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseAgent = void 0;
    var error_1 = require_error();
    var basic_messages_1 = require_basic_messages();
    var connections_1 = require_connections();
    var credentials_1 = require_credentials();
    var dids_1 = require_dids();
    var discover_features_1 = require_discover_features();
    var generic_records_1 = require_generic_records();
    var ledger_1 = require_ledger();
    var oob_1 = require_oob();
    var ProofsApi_1 = require_ProofsApi();
    var routing_1 = require_routing();
    var storage_1 = require_storage();
    var UpdateAssistant_1 = require_UpdateAssistant();
    var updates_1 = require_updates();
    var wallet_1 = require_wallet();
    var error_2 = require_error3();
    var AgentModules_1 = require_AgentModules();
    var EventEmitter_1 = require_EventEmitter();
    var FeatureRegistry_1 = require_FeatureRegistry();
    var MessageReceiver_1 = require_MessageReceiver();
    var MessageSender_1 = require_MessageSender();
    var TransportService_1 = require_TransportService();
    var context_12 = require_context();
    var BaseAgent = class {
      constructor(agentConfig, dependencyManager) {
        this._isInitialized = false;
        this.dependencyManager = dependencyManager;
        this.agentConfig = agentConfig;
        this.logger = this.agentConfig.logger;
        this.logger.info("Creating agent with config", {
          agentConfig: agentConfig.toJSON()
        });
        if (!this.agentConfig.walletConfig) {
          this.logger.warn("Wallet config has not been set on the agent config. Make sure to initialize the wallet yourself before initializing the agent, or provide the required wallet configuration in the agent constructor");
        }
        this.eventEmitter = this.dependencyManager.resolve(EventEmitter_1.EventEmitter);
        this.featureRegistry = this.dependencyManager.resolve(FeatureRegistry_1.FeatureRegistry);
        this.messageSender = this.dependencyManager.resolve(MessageSender_1.MessageSender);
        this.messageReceiver = this.dependencyManager.resolve(MessageReceiver_1.MessageReceiver);
        this.transportService = this.dependencyManager.resolve(TransportService_1.TransportService);
        this.agentContext = this.dependencyManager.resolve(context_12.AgentContext);
        this.connections = this.dependencyManager.resolve(connections_1.ConnectionsApi);
        this.credentials = this.dependencyManager.resolve(credentials_1.CredentialsApi);
        this.proofs = this.dependencyManager.resolve(ProofsApi_1.ProofsApi);
        this.mediator = this.dependencyManager.resolve(routing_1.MediatorApi);
        this.mediationRecipient = this.dependencyManager.resolve(routing_1.RecipientApi);
        this.basicMessages = this.dependencyManager.resolve(basic_messages_1.BasicMessagesApi);
        this.genericRecords = this.dependencyManager.resolve(generic_records_1.GenericRecordsApi);
        this.ledger = this.dependencyManager.resolve(ledger_1.LedgerApi);
        this.discovery = this.dependencyManager.resolve(discover_features_1.DiscoverFeaturesApi);
        this.dids = this.dependencyManager.resolve(dids_1.DidsApi);
        this.wallet = this.dependencyManager.resolve(wallet_1.WalletApi);
        this.oob = this.dependencyManager.resolve(oob_1.OutOfBandApi);
        const defaultApis = [
          this.connections,
          this.credentials,
          this.proofs,
          this.mediator,
          this.mediationRecipient,
          this.basicMessages,
          this.genericRecords,
          this.ledger,
          this.discovery,
          this.dids,
          this.wallet,
          this.oob
        ];
        this.modules = (0, AgentModules_1.getAgentApi)(this.dependencyManager, defaultApis);
      }
      get isInitialized() {
        return this._isInitialized && this.wallet.isInitialized;
      }
      async initialize() {
        const { publicDidSeed, walletConfig } = this.agentConfig;
        if (this._isInitialized) {
          throw new error_1.AriesFrameworkError("Agent already initialized. Currently it is not supported to re-initialize an already initialized agent.");
        }
        if (!this.wallet.isInitialized && walletConfig) {
          await this.wallet.initialize(walletConfig);
        } else if (!this.wallet.isInitialized) {
          throw new error_2.WalletError("Wallet config has not been set on the agent config. Make sure to initialize the wallet yourself before initializing the agent, or provide the required wallet configuration in the agent constructor");
        }
        const storageUpdateService = this.dependencyManager.resolve(storage_1.StorageUpdateService);
        const isStorageUpToDate = await storageUpdateService.isUpToDate(this.agentContext);
        this.logger.info(`Agent storage is ${isStorageUpToDate ? "" : "not "}up to date.`);
        if (!isStorageUpToDate && this.agentConfig.autoUpdateStorageOnStartup) {
          const updateAssistant = new UpdateAssistant_1.UpdateAssistant(this, updates_1.DEFAULT_UPDATE_CONFIG);
          await updateAssistant.initialize();
          await updateAssistant.update();
        } else if (!isStorageUpToDate) {
          const currentVersion = await storageUpdateService.getCurrentStorageVersion(this.agentContext);
          await this.wallet.close();
          throw new error_1.AriesFrameworkError(
            // TODO: add link to where documentation on how to update can be found.
            `Current agent storage is not up to date. To prevent the framework state from getting corrupted the agent initialization is aborted. Make sure to update the agent storage (currently at ${currentVersion}) to the latest version (${UpdateAssistant_1.UpdateAssistant.frameworkStorageVersion}). You can also downgrade your version of Aries Framework JavaScript.`
          );
        }
        if (publicDidSeed) {
          await this.agentContext.wallet.initPublicDid({ seed: publicDidSeed });
        }
      }
      /**
       * @deprecated The publicDid property has been deprecated in favour of the DidsModule, which can be used to
       * create and resolve dids. Currently the global agent `publicDid` property is still used by the `LedgerModule`, but
       * will be removed once the LedgerApi has been refactored. Do not use this property for new functionality, but rather
       * use the `DidsModule`.
       */
      get publicDid() {
        return this.agentContext.wallet.publicDid;
      }
      /**
       * Receive a message. This should mainly be used for receiving connection-less messages.
       *
       * If you want to receive messages that originated from e.g. a transport make sure to use the {@link MessageReceiver}
       * for this. The `receiveMessage` method on the `Agent` class will associate the current context to the message, which
       * may not be what should happen (e.g. in case of multi tenancy).
       */
      async receiveMessage(inboundMessage, session) {
        return await this.messageReceiver.receiveMessage(inboundMessage, {
          session,
          contextCorrelationId: this.agentContext.contextCorrelationId
        });
      }
      get injectionContainer() {
        return this.dependencyManager.container;
      }
      get config() {
        return this.agentConfig;
      }
      get context() {
        return this.agentContext;
      }
    };
    exports.BaseAgent = BaseAgent;
  }
});

// node_modules/@aries-framework/core/build/agent/Agent.js
var require_Agent = __commonJS({
  "node_modules/@aries-framework/core/build/agent/Agent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Agent = void 0;
    var rxjs_1 = require_cjs();
    var operators_1 = require_operators();
    var cache_1 = require_cache();
    var constants_1 = require_constants();
    var crypto_1 = require_crypto();
    var JwsService_1 = require_JwsService();
    var error_1 = require_error();
    var plugins_1 = require_plugins();
    var storage_1 = require_storage();
    var InMemoryMessageRepository_1 = require_InMemoryMessageRepository();
    var IndyStorageService_1 = require_IndyStorageService();
    var IndyWallet_1 = require_IndyWallet();
    var AgentConfig_1 = require_AgentConfig();
    var AgentModules_1 = require_AgentModules();
    var BaseAgent_1 = require_BaseAgent();
    var Dispatcher_1 = require_Dispatcher();
    var EnvelopeService_1 = require_EnvelopeService();
    var EventEmitter_1 = require_EventEmitter();
    var Events_1 = require_Events();
    var FeatureRegistry_1 = require_FeatureRegistry();
    var MessageHandlerRegistry_1 = require_MessageHandlerRegistry();
    var MessageReceiver_1 = require_MessageReceiver();
    var MessageSender_1 = require_MessageSender();
    var TransportService_1 = require_TransportService();
    var context_12 = require_context();
    var Agent = class extends BaseAgent_1.BaseAgent {
      constructor(options, dependencyManager = new plugins_1.DependencyManager()) {
        const agentConfig = new AgentConfig_1.AgentConfig(options.config, options.dependencies);
        const modulesWithDefaultModules = (0, AgentModules_1.extendModulesWithDefaultModules)(agentConfig, options.modules);
        dependencyManager.registerSingleton(MessageHandlerRegistry_1.MessageHandlerRegistry);
        dependencyManager.registerSingleton(EventEmitter_1.EventEmitter);
        dependencyManager.registerSingleton(MessageSender_1.MessageSender);
        dependencyManager.registerSingleton(MessageReceiver_1.MessageReceiver);
        dependencyManager.registerSingleton(TransportService_1.TransportService);
        dependencyManager.registerSingleton(Dispatcher_1.Dispatcher);
        dependencyManager.registerSingleton(EnvelopeService_1.EnvelopeService);
        dependencyManager.registerSingleton(FeatureRegistry_1.FeatureRegistry);
        dependencyManager.registerSingleton(JwsService_1.JwsService);
        dependencyManager.registerSingleton(cache_1.CacheRepository);
        dependencyManager.registerSingleton(storage_1.DidCommMessageRepository);
        dependencyManager.registerSingleton(storage_1.StorageVersionRepository);
        dependencyManager.registerSingleton(storage_1.StorageUpdateService);
        dependencyManager.registerInstance(crypto_1.SigningProviderToken, "default");
        dependencyManager.registerInstance(AgentConfig_1.AgentConfig, agentConfig);
        dependencyManager.registerInstance(constants_1.InjectionSymbols.AgentDependencies, agentConfig.agentDependencies);
        dependencyManager.registerInstance(constants_1.InjectionSymbols.Stop$, new rxjs_1.Subject());
        dependencyManager.registerInstance(constants_1.InjectionSymbols.FileSystem, new agentConfig.agentDependencies.FileSystem());
        if (!dependencyManager.isRegistered(constants_1.InjectionSymbols.Wallet)) {
          dependencyManager.registerContextScoped(constants_1.InjectionSymbols.Wallet, IndyWallet_1.IndyWallet);
        }
        if (!dependencyManager.isRegistered(constants_1.InjectionSymbols.Logger)) {
          dependencyManager.registerInstance(constants_1.InjectionSymbols.Logger, agentConfig.logger);
        }
        if (!dependencyManager.isRegistered(constants_1.InjectionSymbols.StorageService)) {
          dependencyManager.registerSingleton(constants_1.InjectionSymbols.StorageService, IndyStorageService_1.IndyStorageService);
        }
        if (!dependencyManager.isRegistered(constants_1.InjectionSymbols.MessageRepository)) {
          dependencyManager.registerSingleton(constants_1.InjectionSymbols.MessageRepository, InMemoryMessageRepository_1.InMemoryMessageRepository);
        }
        dependencyManager.registerModules(modulesWithDefaultModules);
        dependencyManager.registerInstance(context_12.AgentContext, new context_12.AgentContext({
          dependencyManager,
          contextCorrelationId: "default"
        }));
        if (!dependencyManager.isRegistered(constants_1.InjectionSymbols.AgentContextProvider)) {
          dependencyManager.registerSingleton(constants_1.InjectionSymbols.AgentContextProvider, context_12.DefaultAgentContextProvider);
        }
        super(agentConfig, dependencyManager);
        const stop$ = this.dependencyManager.resolve(constants_1.InjectionSymbols.Stop$);
        this.messageSubscription = this.eventEmitter.observable(Events_1.AgentEventTypes.AgentMessageReceived).pipe((0, operators_1.takeUntil)(stop$), (0, operators_1.concatMap)((e) => this.messageReceiver.receiveMessage(e.payload.message, {
          connection: e.payload.connection,
          contextCorrelationId: e.payload.contextCorrelationId
        }).catch((error) => {
          this.logger.error("Failed to process message", { error });
        }))).subscribe();
      }
      registerInboundTransport(inboundTransport) {
        this.messageReceiver.registerInboundTransport(inboundTransport);
      }
      get inboundTransports() {
        return this.messageReceiver.inboundTransports;
      }
      registerOutboundTransport(outboundTransport) {
        this.messageSender.registerOutboundTransport(outboundTransport);
      }
      get outboundTransports() {
        return this.messageSender.outboundTransports;
      }
      get events() {
        return this.eventEmitter;
      }
      /**
       * Agent's feature registry
       */
      get features() {
        return this.featureRegistry;
      }
      async initialize() {
        await super.initialize();
        this.ledger.setPools(this.ledger.config.indyLedgers);
        if (this.ledger.config.connectToIndyLedgersOnStartup) {
          this.ledger.connectToPools().catch((error) => {
            this.logger.warn("Error connecting to ledger, will try to reconnect when needed.", { error });
          });
        }
        for (const transport of this.inboundTransports) {
          await transport.start(this);
        }
        for (const transport of this.outboundTransports) {
          await transport.start(this);
        }
        if (this.mediationRecipient.config.mediatorInvitationUrl) {
          this.logger.debug("Provision mediation with invitation", {
            mediatorInvitationUrl: this.mediationRecipient.config.mediatorInvitationUrl
          });
          const mediationConnection = await this.getMediationConnection(this.mediationRecipient.config.mediatorInvitationUrl);
          await this.mediationRecipient.provision(mediationConnection);
        }
        await this.mediator.initialize();
        await this.mediationRecipient.initialize();
        this._isInitialized = true;
      }
      async shutdown() {
        const stop$ = this.dependencyManager.resolve(constants_1.InjectionSymbols.Stop$);
        stop$.next(true);
        const allTransports = [...this.inboundTransports, ...this.outboundTransports];
        const transportPromises = allTransports.map((transport) => transport.stop());
        await Promise.all(transportPromises);
        if (this.wallet.isInitialized) {
          await this.wallet.close();
        }
        this._isInitialized = false;
      }
      async getMediationConnection(mediatorInvitationUrl) {
        const outOfBandInvitation = await this.oob.parseInvitation(mediatorInvitationUrl);
        const outOfBandRecord = await this.oob.findByReceivedInvitationId(outOfBandInvitation.id);
        const [connection] = outOfBandRecord ? await this.connections.findAllByOutOfBandId(outOfBandRecord.id) : [];
        if (!connection) {
          this.logger.debug("Mediation connection does not exist, creating connection");
          const routing = await this.mediationRecipient.getRouting({ useDefaultMediator: false });
          this.logger.debug("Routing created", routing);
          const { connectionRecord: newConnection } = await this.oob.receiveInvitation(outOfBandInvitation, {
            routing
          });
          this.logger.debug(`Mediation invitation processed`, { outOfBandInvitation });
          if (!newConnection) {
            throw new error_1.AriesFrameworkError("No connection record to provision mediation.");
          }
          return this.connections.returnWhenIsConnected(newConnection.id);
        }
        if (!connection.isReady) {
          return this.connections.returnWhenIsConnected(connection.id);
        }
        return connection;
      }
    };
    exports.Agent = Agent;
  }
});

// node_modules/@aries-framework/core/build/index.js
var require_build = __commonJS({
  "node_modules/@aries-framework/core/build/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utils = exports.CacheRepository = exports.PersistedLruCache = exports.IsValidMessageType = exports.parseMessageType = exports.Buffer = exports.TypedArrayEncoder = exports.isValidJweStructure = exports.isJsonObject = exports.JsonTransformer = exports.JsonEncoder = exports.ReturnRouteTypes = exports.AttachmentData = exports.Attachment = exports.TransportService = exports.InjectionSymbols = exports.getDirFromFilePath = exports.Repository = exports.InMemoryMessageRepository = exports.KeyDerivationMethod = exports.DidCommMimeType = exports.MessageSender = exports.Dispatcher = exports.AgentMessage = exports.AgentConfig = exports.MessageHandlerRegistry = exports.FeatureRegistry = exports.EventEmitter = exports.BaseAgent = exports.Agent = exports.MessageReceiver = void 0;
    require_Reflect();
    var MessageReceiver_1 = require_MessageReceiver();
    Object.defineProperty(exports, "MessageReceiver", { enumerable: true, get: function() {
      return MessageReceiver_1.MessageReceiver;
    } });
    var Agent_1 = require_Agent();
    Object.defineProperty(exports, "Agent", { enumerable: true, get: function() {
      return Agent_1.Agent;
    } });
    var BaseAgent_1 = require_BaseAgent();
    Object.defineProperty(exports, "BaseAgent", { enumerable: true, get: function() {
      return BaseAgent_1.BaseAgent;
    } });
    __exportStar(require_agent(), exports);
    var EventEmitter_1 = require_EventEmitter();
    Object.defineProperty(exports, "EventEmitter", { enumerable: true, get: function() {
      return EventEmitter_1.EventEmitter;
    } });
    var FeatureRegistry_1 = require_FeatureRegistry();
    Object.defineProperty(exports, "FeatureRegistry", { enumerable: true, get: function() {
      return FeatureRegistry_1.FeatureRegistry;
    } });
    var MessageHandlerRegistry_1 = require_MessageHandlerRegistry();
    Object.defineProperty(exports, "MessageHandlerRegistry", { enumerable: true, get: function() {
      return MessageHandlerRegistry_1.MessageHandlerRegistry;
    } });
    __exportStar(require_models3(), exports);
    var AgentConfig_1 = require_AgentConfig();
    Object.defineProperty(exports, "AgentConfig", { enumerable: true, get: function() {
      return AgentConfig_1.AgentConfig;
    } });
    var AgentMessage_1 = require_AgentMessage();
    Object.defineProperty(exports, "AgentMessage", { enumerable: true, get: function() {
      return AgentMessage_1.AgentMessage;
    } });
    var Dispatcher_1 = require_Dispatcher();
    Object.defineProperty(exports, "Dispatcher", { enumerable: true, get: function() {
      return Dispatcher_1.Dispatcher;
    } });
    var MessageSender_1 = require_MessageSender();
    Object.defineProperty(exports, "MessageSender", { enumerable: true, get: function() {
      return MessageSender_1.MessageSender;
    } });
    var types_1 = require_types3();
    Object.defineProperty(exports, "DidCommMimeType", { enumerable: true, get: function() {
      return types_1.DidCommMimeType;
    } });
    Object.defineProperty(exports, "KeyDerivationMethod", { enumerable: true, get: function() {
      return types_1.KeyDerivationMethod;
    } });
    __exportStar(require_BaseRecord(), exports);
    var InMemoryMessageRepository_1 = require_InMemoryMessageRepository();
    Object.defineProperty(exports, "InMemoryMessageRepository", { enumerable: true, get: function() {
      return InMemoryMessageRepository_1.InMemoryMessageRepository;
    } });
    var Repository_1 = require_Repository();
    Object.defineProperty(exports, "Repository", { enumerable: true, get: function() {
      return Repository_1.Repository;
    } });
    __exportStar(require_RepositoryEvents(), exports);
    __exportStar(require_migration(), exports);
    var path_1 = require_path();
    Object.defineProperty(exports, "getDirFromFilePath", { enumerable: true, get: function() {
      return path_1.getDirFromFilePath;
    } });
    var constants_1 = require_constants();
    Object.defineProperty(exports, "InjectionSymbols", { enumerable: true, get: function() {
      return constants_1.InjectionSymbols;
    } });
    __exportStar(require_wallet(), exports);
    var TransportService_1 = require_TransportService();
    Object.defineProperty(exports, "TransportService", { enumerable: true, get: function() {
      return TransportService_1.TransportService;
    } });
    var Attachment_1 = require_Attachment();
    Object.defineProperty(exports, "Attachment", { enumerable: true, get: function() {
      return Attachment_1.Attachment;
    } });
    Object.defineProperty(exports, "AttachmentData", { enumerable: true, get: function() {
      return Attachment_1.AttachmentData;
    } });
    var TransportDecorator_1 = require_TransportDecorator();
    Object.defineProperty(exports, "ReturnRouteTypes", { enumerable: true, get: function() {
      return TransportDecorator_1.ReturnRouteTypes;
    } });
    __exportStar(require_plugins(), exports);
    __exportStar(require_transport(), exports);
    __exportStar(require_basic_messages(), exports);
    __exportStar(require_common(), exports);
    __exportStar(require_credentials(), exports);
    __exportStar(require_discover_features(), exports);
    __exportStar(require_problem_reports(), exports);
    __exportStar(require_proofs(), exports);
    __exportStar(require_connections(), exports);
    __exportStar(require_ledger(), exports);
    __exportStar(require_routing(), exports);
    __exportStar(require_oob(), exports);
    __exportStar(require_dids(), exports);
    __exportStar(require_vc3(), exports);
    var utils_1 = require_utils();
    Object.defineProperty(exports, "JsonEncoder", { enumerable: true, get: function() {
      return utils_1.JsonEncoder;
    } });
    Object.defineProperty(exports, "JsonTransformer", { enumerable: true, get: function() {
      return utils_1.JsonTransformer;
    } });
    Object.defineProperty(exports, "isJsonObject", { enumerable: true, get: function() {
      return utils_1.isJsonObject;
    } });
    Object.defineProperty(exports, "isValidJweStructure", { enumerable: true, get: function() {
      return utils_1.isValidJweStructure;
    } });
    Object.defineProperty(exports, "TypedArrayEncoder", { enumerable: true, get: function() {
      return utils_1.TypedArrayEncoder;
    } });
    Object.defineProperty(exports, "Buffer", { enumerable: true, get: function() {
      return utils_1.Buffer;
    } });
    __exportStar(require_logger(), exports);
    __exportStar(require_error(), exports);
    __exportStar(require_error3(), exports);
    var messageType_1 = require_messageType();
    Object.defineProperty(exports, "parseMessageType", { enumerable: true, get: function() {
      return messageType_1.parseMessageType;
    } });
    Object.defineProperty(exports, "IsValidMessageType", { enumerable: true, get: function() {
      return messageType_1.IsValidMessageType;
    } });
    __exportStar(require_Events(), exports);
    __exportStar(require_crypto(), exports);
    var cache_1 = require_cache();
    Object.defineProperty(exports, "PersistedLruCache", { enumerable: true, get: function() {
      return cache_1.PersistedLruCache;
    } });
    Object.defineProperty(exports, "CacheRepository", { enumerable: true, get: function() {
      return cache_1.CacheRepository;
    } });
    var parseInvitation_1 = require_parseInvitation();
    var uuid_1 = require_uuid();
    var utils = {
      uuid: uuid_1.uuid,
      parseInvitationUrl: parseInvitation_1.parseInvitationUrl
    };
    exports.utils = utils;
  }
});

export {
  require_build
};
/*! Bundled license information:

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@digitalbazaar/security-context/dist/context.js:
  (*!
   * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalcredentials/jsonld-signatures/lib/constants.js:
  (*!
   * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalcredentials/jsonld/lib/context.js:
  (* disallow aliasing @context and @preserve *)

@digitalcredentials/jsonld/lib/frame.js:
  (* remove @preserve from results *)
  (**
   * Removes the @preserve keywords from expanded result of framing.
   *
   * @param input the framed, framed output.
   * @param options the framing options used.
   *
   * @return the resulting output.
   *)
  (* remove @preserve *)

@digitalcredentials/jsonld/lib/jsonld.js:
  (**
   * A JavaScript implementation of the JSON-LD API.
   *
   * @author Dave Longley
   *
   * @license BSD 3-Clause License
   * Copyright (c) 2011-2019 Digital Bazaar, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * Redistributions in binary form must reproduce the above copyright
   * notice, this list of conditions and the following disclaimer in the
   * documentation and/or other materials provided with the distribution.
   *
   * Neither the name of the Digital Bazaar, Inc. nor the names of its
   * contributors may be used to endorse or promote products derived from
   * this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
   * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
   * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
   * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *)

@digitalcredentials/jsonld-signatures/lib/documentLoader.js:
  (*!
   * Copyright (c) 2018-2021 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalcredentials/jsonld-signatures/lib/expansionMap.js:
  (*!
   * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalcredentials/jsonld-signatures/lib/ProofSet.js:
  (*!
   * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalcredentials/jsonld-signatures/lib/VerificationError.js:
  (*!
   * Copyright (c) 2020 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalcredentials/jsonld-signatures/lib/suites/LinkedDataProof.js:
  (*!
   * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalcredentials/jsonld-signatures/lib/suites/LinkedDataSignature.js:
  (*!
   * Copyright (c) 2017-2021 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalcredentials/jsonld-signatures/lib/suites.js:
  (*!
   * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalcredentials/jsonld-signatures/lib/purposes/ProofPurpose.js:
  (*!
   * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalcredentials/jsonld-signatures/lib/purposes/ControllerProofPurpose.js:
  (*!
   * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalcredentials/jsonld-signatures/lib/purposes/AssertionProofPurpose.js:
  (*!
   * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalcredentials/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js:
  (*!
   * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalcredentials/jsonld-signatures/lib/purposes.js:
  (*!
   * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalcredentials/jsonld-signatures/lib/jsonld-signatures.js:
  (*!
   * Copyright (c) 2010-2018 Digital Bazaar, Inc. All rights reserved.
   *)

ky/index.js:
  (*! MIT License © Sindre Sorhus *)

@digitalcredentials/http-client/dist/index.js:
  (*!
   * Copyright (c) 2020 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalcredentials/vc/lib/CredentialIssuancePurpose.js:
  (*!
   * Copyright (c) 2019-2021 Digital Bazaar, Inc. All rights reserved.
   *)

credentials-context/dist/context.esm.js:
  (*! For license information please see context.js.LICENSE.txt *)

@digitalcredentials/vc/lib/contexts/vc-examples-v1.js:
  (*!
   * Copyright (c) 2019-2021 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalcredentials/vc/lib/contexts/odrl.js:
  (*!
   * Copyright (c) 2019-2021 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalcredentials/vc/lib/contexts/index.js:
  (*!
   * Copyright (c) 2019-2021 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalcredentials/vc/lib/documentLoader.js:
  (*!
   * Copyright (c) 2019-2021 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalcredentials/vc/lib/vc.js:
  (**
   * A JavaScript implementation of Verifiable Credentials.
   *
   * @author Dave Longley
   * @author David I. Lehn
   *
   * @license BSD 3-Clause License
   * Copyright (c) 2017-2021 Digital Bazaar, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * Redistributions in binary form must reproduce the above copyright
   * notice, this list of conditions and the following disclaimer in the
   * documentation and/or other materials provided with the distribution.
   *
   * Neither the name of the Digital Bazaar, Inc. nor the names of its
   * contributors may be used to endorse or promote products derived from
   * this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
   * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
   * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
   * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *)
*/
//# sourceMappingURL=chunk-UUNO4XUA.js.map
